data,labels
"#include <stdio.h>
 #include <stdbool.h>
 
 bool array_mirror_inverse(int[], int);
 int main()
 {
 	int n;
 	bool f;
 	printf(""Enter the size of the array:"");
 	scanf(""%d"", &n);
 	int arr[n];
 	printf(""Enter the elements:"");
 	for (int i = 0; i < n; ++i)
 	{
 		scanf(""%d"", &arr[i]);
 	}
 
 	f = array_mirror_inverse(arr, n);
 	if (f)
 		printf(""The given array is mirror-inverse"");
 	else
 		printf(""The given array is not the mirror-inverse"");
 }
 
 // Boolean Function which return if the array is mirror-inverse or not
 bool array_mirror_inverse(int arr[], int n)
 {
 	bool f = true;
 	for (int i = 0; i < n; ++i)
 	{
 		if (arr[arr[i]] != i)
 		{
 			f = false;
 		}
 	}
 
 	return f;
 }
 
 /*
 Time Complexity: O(N)
 
 Sample Output
 Enter the size of the array:5
 Enter the elements:1 0 2 4 3
 The given array is mirror-inverse
 */
 
",C
"// Checking Palindrome number with Recursion
 
 import java.util.Scanner;
 class PalindromeRecursion
 {
     static long revNum=0; //stored reversed number
     public static long palindrome(long i)
     { if(i>0) //base class
         { revNum=(revNum*10)+(i%10);
             palindrome(i/10);
         }
         else
         return revNum;
         return revNum;
     }
     public static void main(String args[])
     {
         Scanner sc=new Scanner(System.in);
         System.out.print(""N = "");
         long n=sc.nextLong();
         if(n==palindrome(n))
         System.out.println(n+"" is a Palindrome number"");
         else
         System.out.println(n+"" is not a Palindrome number"");
     }
 }
 
 /*
 Sample Input and Output :
  N = 153
 153 is not a Palindrome number
 Space Complexity: O(1)
 Time Complexity : O(i) i=Number of digits in n
 */
",Java
"/*
 A program to find Greatest Common Divisor(GCD) of two Numbers.
 GCD of two integers is the largest positive integer that divides each of the integers.
 */
 
 //In-Built readline module
 const readline = require(""readline"");
 const rl = readline.createInterface({
   input: process.stdin,
   output: process.stdout,
 });
 
 const getLine = (function () {
   const getLineGen = (async function* () {
     for await (const line of rl) {
       yield line;
     }
   })();
   return async () => (await getLineGen.next()).value;
 })();
 
 function gcd(number1, number2) {
   //Smaller of the two number
   var smaller_number = Math.min(number1, number2);
 
   //Iterating from smaller number till 1
   for (var i = smaller_number; i >= 1; i--) {
     if (number1 % i == 0 && number2 % i == 0) {
       console.log(""HCF: "" + i);
       break;
     }
   }
 }
 
 const main = async () => {
   //Taking Input of First Number
   console.log(""Enter the First Number"");
   var number1 = Number(await getLine());
 
   //Taking Input of Second Number
   console.log(""Enter the Second Number"");
   var number2 = Number(await getLine());
 
   //Calling gcd function
   gcd(number1, number2);
 
   //To close the program
   process.exit(0);
 };
 
 main();
 
 /*
 
 Time Complexity:O(smaller(n1,n2))
 Space Complexity:O(1)
 
 Input:
 5 10
 
 Output:
 5
 
 Input:
 4 7
 
 Output:
 1
 
 */
",JavaScript
"/* This algorithm will print the next greater element for all the indices in an array using stacks.
 The procedure is to store the index of the next greater element in an answer array. Incase, there is no next greater element,
 -1 will be stored.*/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //Function to print the next greater element
 void next_greater(int arr[],int n)
 {
    int ans[n]; //declaring an answer array
    for(int i=0;i<n;i++)
    ans[i]=-1;  //marking all the indices with -1 initially
 
    stack<int> s;
    s.push(0);  //pushing the zeroth index of arr
    
    //iterating through the rest of indices of arr
    for(int i=1;i<n;i++)
    {
        /*If the stack is not empty and the value at cuurent index (arr[i]) is greater than value at s.top(),
         then next greater element for arr[s.top()] will be arr[i]. Once the next greater element for a particular
         index is found, then tha particular index can be popped out*/
      while(s.empty()==false && arr[i]>arr[s.top()]) 
      {                                              
         ans[s.top()]=i;
         s.pop();
      }
     s.push(i); //pushing the current index so that it can be compared with the values to its right in further iterations
    }
    
    //printing the final answer
    for(int i=0;i<n;i++)
    {
      if(ans[i]==-1) //if the value of ans[i] remains -1, it means there is no next greater element for it
      cout<<""-1 "";
      else
      cout<<arr[ans[i]]<<"" "";
    }
    return;
 }
 
 //Driver Code
 int main()
 {
  int n;
  cin>>n;
  int arr[n];
  for(int i=0;i<n;i++)
  cin>>arr[i];
  next_greater(arr,n);
  return 0;
 }
 
 /* Time Complexity : o(n)
    Space Complexity: O(n)
    Sample Input    : 4
                       4 5 2 25
    Sample Output   : 5 25 25 -1 */
",C-Plus-Plus
"'''
 Aim: To perform level-order traversal on a BST.
 
 '''
 
 # initializing the tree
 class Node:
     def __init__(self,data):
         self.right=self.left=None
         self.data = data
         
 class Solution:
     # inserting node
     def insert(self,root,data):
         if root==None:
             return Node(data)
         else:
             if data<=root.data:
                 cur=self.insert(root.left,data)
                 root.left=cur
             else:
                 cur=self.insert(root.right,data)
                 root.right=cur
         return root
     # performing level order traversal
     # the values will be printed according to the level they are in
     def levelOrder(self,root):
         if root is None:
             return 
         q = []
         q.append(root)
         while len(q) !=0:
             p = q.pop(0)
             print(p.data, end=' ')
             if p.left is not None:
                 q.append(p.left)
             if p.right is not None:
                 q.append(p.right)
         return q
     
 # getting the input    
 T=int(input())
 myTree=Solution()
 root=None
 for i in range(T):
     data=int(input())
     root=myTree.insert(root,data)
 # printing the result
 myTree.levelOrder(root)
 
 '''
 
 COMPLEXITY:
 	
 	 Time Complexity -> O(N)
 	 Space Complexity -> O(N)
      
 Sample Input:
 6
 3
 5
 4
 7
 2
 1
 Sample Output:
 3 2 5 1 4 7
 
 Explaination:
 The BST looks something like this:
     
                 3                    Level 0
             2       5                Level 1
         1        4      7            Level 2
  
 So, starting from level 0 and going to level 2, traversal will look like: 3, 2 5, 1 4 7.
 
 '''",Python
"/*
  This project converts infix expression to postfix expression in JavaScript.
 
  Infix expression:-  The expression of the form a op b. 
  When an operator is in-between every pair of operands.
 
  Postfix expression:-  An expression is called the postfix expression
   if the operator appears in the expression after the operands. 
   Simply of the form (operand1 operand2 operator). 
 
 */
 
 var stackarr=[];
 var topp=-1;
 
 // function for push  in stack
 function push(e)
 {
    topp++;
    stackarr[topp]=e;
 }
 
 // function for pop from stack
 function pop()
 {
     if(topp==-1)
     return 0;
     else
     {
         var popped_ele=stackarr[topp];
         topp--;
         return popped_ele;
     }
 }
 
 // function operator for checking isoperator
 function operator(op)
 {
     return ((op=='+' || op=='-' || op=='^' || op=='*' || op=='/' || op=='(' || op==')')? true:false);
 }
 
 // function for precedency
 function precedency(pre)
 {
     if(pre=='@' || pre=='(' || pre==')')
     {
         return 1;
     }
     else if(pre=='+' || pre=='-')
     {
         return 2;
     }
     else if (pre=='/' || pre=='*')
     {
         return 3;
     }
     else if(pre=='^')
     {
         return 4;
     }
     else
     return 0;
 }
 
 // function that convert infix to postfix
 function InfixtoPostfix(infixval)
 {
     var postfix=[];
     var temp=0;
     push('@'); 
     
     for(var i=0;i<infixval.length;i++)
     {
         var el=infixval[i];
         if(operator(el))
         {
             if (el ==')') {
                 while (stackarr[topp] != ""("") {
                   postfix[temp++] = pop();
                 }
                 pop();
             }
             else if(el=='(')
             {
                 push(el);
             }
             else if(precedency(el)>precedency(stackarr[topp]))
             {
                 push(el);
             }
             else
             {
                 while(precedency(el)<=precedency(stackarr[topp])&&",JavaScript
"/*
 Let's say we want to search for the number, what we'll do is we'll start at the root, and then we will compare 
 the value to be searched with the value of the root if it's equal we are done with the search if it's lesser 
 we know that we need to go to the left subtree because in a binary search tree all the elements in the left 
 subtree are lesser and all the elements in the right subtree are greater. Searching an element in the 
 binary search tree is basically this traversal in which at each step we will go either towards left or right 
 and hence in at each step we discard one of the sub-trees. If the tree is balanced, we call a tree balanced if 
 for all nodes the difference between the heights of left and right subtrees is not greater than one, 
 we will start with a search space of n nodes and when we will discard one of the sub-trees 
 we will discard n/2 nodes so our search space will be reduced to n/2 and then in the next step 
 we will reduce the search space to n/4 and we will go on reducing like this till we find the element or 
 till our search space is reduced to only one node.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 class node{
 public:
 	int data;
 	node* left;
 	node* right;
 
 	// constructor
 	node(int x){				
 		data = x;
 		left = nullptr;
 		right = nullptr;
 	}
 
 };
 
 node* Insert_into_bst(node* root, int data){
 
 	// make new node
 	if(root == nullptr){				
 		root = new node(data);
 		return root;
 	}
 
 	else if(data < root->data){
 		root->left = Insert_into_bst(root->left,data);
 	}
 	else{
 		root->right = Insert_into_bst(root->right,data);
 	}
 
 	return root;
 }
 
 node* Create_BST(){
 
 	// root node
 	int data;
 	cout<<""Enter the data for the node: ""<<endl;
 	cin >> data;
 
 	node* root = nullptr;
 
 	while(data!= -1){ 
 		root = Insert_into_bst(root, data);
 		cin >> data;
 	}
 
 	return root;
 }
 
 bool search(node* root, int key){
 
 	if(root == nullptr)
 		return false;
 
 	if(root->data == key)
 		retur",C-Plus-Plus
"/*
 C# program for Fibonacci Search 
 Fibonacci search -
 the Fibonacci search technique is a method of searching a sorted array 
 using a divide and conquer algorithm that narrows down possible locations
 with the aid of Fibonacci numbers.
 */
 using System;
 
 class Fibonacci 
 {
     public static int min(int x, int y)
     {
         return (x <= y) ? x : y;
     }
 
     /* Returns index of x if present, else returns -1 */
     public static int FibMonaccianSearch(int[] arr, int x, int n)
     {
         /* Initialize fibonacci numbers */
         int fibMMm2 = 0;
         int fibMMm1 = 1; 
         int fibM = fibMMm2 + fibMMm1; 
 
         while (fibM < n)
         {
             fibMMm2 = fibMMm1;
             fibMMm1 = fibM;
             fibM = fibMMm2 + fibMMm1;
         }
 
         int offset = -1;
 
         while (fibM > 1)
         {
             int i = min(offset + fibMMm2, n - 1);
 
             if (arr[i] < x)
             {
                 fibM = fibMMm1;
                 fibMMm1 = fibMMm2;
                 fibMMm2 = fibM - fibMMm1;
                 offset = i;
             }
 
             else if (arr[i] > x)
             {
                 fibM = fibMMm2;
                 fibMMm1 = fibMMm1 - fibMMm2;
                 fibMMm2 = fibM - fibMMm1;
             }
             
             else
                 return i;
         }
 
         if (fibMMm1 == 1 && arr[n - 1] == x)
             return n - 1;
 
         return -1;
     }
 
     public static void Main()
     {
         Console.WriteLine(""Enter size of array that you like to create"");
         int n = int.Parse(Console.ReadLine());
         int[] arr = new int[n];
         Console.WriteLine(""Enter values in array"");
         for(int i = 0; i < n; i++)
         {
             arr[i] = int.Parse(Console.ReadLine());
         }
 
         Console.WriteLine(""Enter value that you like to find in array"");
         int x = int.Parse(Console.ReadLine());
 
         int ind = FibMonaccianSearch(a",C-Sharp
"""""""
 Problem Statement : To find out if two given string is anagram strings or not.
 
 What is anagram?  The string is anagram if it is formed by changing the positions of the characters.
          
 Problem Link:- https://en.wikipedia.org/wiki/Anagram
 
 Intution: Sort the characters in both given strings.
           After sorting, if two strings are similar, they are an anagram of each other.
 
 Return  : A string which tells if the given two strings are Anagram or not.
 
 """"""
 
 def checkAnagram(str1, str2):
 
     #Checking if lenght of the strings are same
     if len(str1) == len(str2):
 
         #Sorting both the strings
         sorted_str1 = sorted(str1)
         sorted_str2 = sorted(str2)
 
         #Checking if both sorted strings are same or not
         if sorted_str1 == sorted_str2:
             return ""The two given strings are Anagram.""
         
         else:
             return ""The two given strings are not Anagram.""
             
 def main():
 
     #User input for both the strings
     str1 = input(""Enter 1st string: "")
     str2 = input(""Enter 2nd srring: "")
     
     #function call for checking if strings are anagram
     print(checkAnagram(str1, str2))
 
 main()
 
 """"""
 Sample Input / Output:
 
 Enter 1st string: lofty
 Enter 2nd srring: folty
 The two given strings are Anagram.
 
 Enter 1st string: bhuj
 Enter 2nd srring: ghuj
 The two given strings are not Anagram.
 
 """"""
",Python
"/*
 Harry, a blind man has N distinct binary strings all of equal lengths. A binary string only contains '0's and '1's. 
 The strings are numbered from 1 to N and all are distinct strings. Harry can only differentiate between these strings 
 by touching them. In one touch Harry can identify one character at a position of any particular string from the set. 
 Find the minimum number of touches Harry has to make so that he finds that all strings are different.
 */
 
 #include<bits/stdc++.h>
 #include <vector>
 using namespace std;
 int count_touches(int mask, vector<string>& arr, int n, int N, vector<vector<int>>& dp, int pos = 0)
 {
 	// When mask contains only 1 bit it means every string is recongnised.
 	if (mask && (mask & (mask - 1)) == 0)
 	{
 		return 0;
 	}
 
 	// Returning infinite value.
 	if (pos == n || mask == 0)
 	{
 		return 100000000;
 	}
 
 	// Adding memoization condition .
 	if (dp[mask][pos] != -1)
 	{
 		return dp[mask][pos];
 	}
 
 	int mask1 = 0;
 	int mask2 = 0;
 	int cnt = 0;
 
 	// Spliting the strings based on character at pos-th position.
 	for (int i = 0; i < N; i++)
 	{
 		if (((1 << i)&mask))
 		{
 			cnt++;
 
 			if (arr[i][pos] == '1')
 			{
 				mask2 |= (1 << i);
 			}
 			else
 			{
 				mask1 |= (1 << i);
 			}
 		}
 	}
 
 	int a = cnt + count_touches(mask1, arr, n, N, dp, pos + 1) + count_touches(mask2, arr, n, N, dp, pos + 1);
 	int b = count_touches(mask, arr, n, N, dp, pos + 1);
 
 	return dp[mask][pos] = min(a, b);
 
 }
 int minimumTouchesRequired(int N, vector<string> arr) {
 
 	int n = arr[0].size();
 
 	vector<vector<int>>dp((1 << N), vector<int>(n, -1));
 
 	return count_touches((1 << N) - 1, arr, n, N, dp);
 }
 
 
 int main(){
     int N;
     cout<<""Enter the number of strings: "";
     cin>>N;
     vector <string> arr;
     cout<<""Enter the strings: ""<<endl;
     for(int i = 0; i < N; i++){
         string inp;
         cin>>inp;
         arr.push_back(inp);
     }
     cout<<""The minimum number of touches required are: ",C-Plus-Plus
"/*
     This is a simple program in golang to cipher the given plain text
     using Affine Substitution Method. The Affine cipher is a type of
     monoalphabetic substitution cipher, wherein each letter in an alphabet 
     is mapped to its numeric equivalent, encrypted using a simple mathematical 
     function, and converted back to a letter. 
 
     Formula : y = ( a*x +b ) % 26
     
     Here a = 17
          b = 20 
 
     Note : Here a should be chosen to be relatively prime to m  
 */
 
 package main
 
 import (
 
   ""fmt""
   ""unicode""
   ""bufio""
   ""os""
   ""strings""
 
 )
 
 //Global Variables
 var plaintext string
 var ciphertext string
 
 /* We use this list of alphabets to check what letter we have
    in plaintext*/
 var list string = ""abcdefghijklmnopqrstuvwxyz""
 var a int = 17
 var b int = 20
 var cipherer string
 var output string
 
 // Using this function we build the cipherer
 func buildcipherer() {
      var res int
      for i:=0;i<26;i++ {
          res = (a*i + b)%26
          cipherer += string(list[res])
      }
 }
 
 /*
  This function formats the given ciphertext according to
  the orginal plaintext recieved from the user as input.
  In the monoalphabeticcipher function below, we converet
  the given plaintext into lowercase for our cinvinence of 
  checking. So, the ciphertext we get is also in all 
  lowercase. Here, we format the ciphertext so that wherever
  there is capital letter in the plaintext, same follows 
  in the ciphertext.*/
 func format(temp string) {
 
     /* Checking if the given letter in plaintext is capital 
        or not and changint it to capttal if it was*/
     for i:=0; i < len(temp); i++ {
        if (unicode.IsUpper (rune(temp[i]) ) ) {
            output += strings.ToUpper(string(ciphertext[i]))
        }else {
           output += string(ciphertext[i])
        }
     }
 }
 
 /* This is the function where we cipher the plaintext using 
    the cipherer into small letters */
 func monoaplhabeticcipher() {
 
  ",Go
"/* In a good number, every digit is greater than the sum of all digits on its right.
    Approach: The last digit of the number is extracted and stored in sum.
    That digit is removed and the last digit of the number so obtained is compared with sum.
    If it is less than sum iteration goes on till we are left with only one digit in the modified number else the iteration is stopped
 */
 
 import java.util.Scanner;
  public class good_number 
  {
     static void return_good(int first,int last)
     {
        for(int count=first;count<last;count++)
 	 {
 	     int current=count,sum=0;
 
              while(current!=0)
              {
                  sum=sum+current%10;
                  current/=10;
                  if((current!=0) && (current%10<=sum))
                   break;
              }
 
             if(current==0)
                 System.out.print(count+""  "");
          }
     }
     
      public static void main(String [] args)
      {
          Scanner scan=new Scanner(System.in);
          int start,end;
 
          System.out.println(""Enter the Range"");
          start=scan.nextInt();
          end=scan.nextInt();
          
          return_good(start,end);
      }
  }
 
 /*
                      OUTPUT:
 Test Case 1:
 Input: 345 678
 Output: 410  420  421  430  510  520  521  530  531  540  610  620  621  630  631  632  640  641  650
 
 Space Complexity: O(1)
 Time Complexity: O(n2)
 */
 
",Java
"/*
 Ugly numbers are numbers whose only prime factors are 2, 3 or 5. 
 For example consider 12
 Factorisation of 12 is 12 = 2 x 2 x 3 
 As 2 and 3 are its only prime factors it is a ugly number.
 */
 
 import 'dart:io';
 
 // Check if number is ugly number or no
 int checkUglyNumber(int number) {
   // Base case for true
   if (number == 1) {
     return 1;
   }
   // Base cases for false
   if (number <= 0) {
     return 0;
   }
 
   // Recursive cases to check divisibility
   if (number % 2 == 0) {
     return (checkUglyNumber(number ~/ 2));
   }
   if (number % 3 == 0) {
     return (checkUglyNumber(number ~/ 3));
   }
   if (number % 5 == 0) {
     return (checkUglyNumber(number ~/ 5));
   }
 
   // No case matched then return 0
   return 0;
 }
 
 // Main Function, with driver code
 void main() {
   print(""Enter a number:"");
   int input = int.parse(stdin.readLineSync()!);
 
   // Call checkUglyNumber function on input
   if (checkUglyNumber(input) == 1) {
     print(""$input is a ugly number"");
   } else {
     print(""$input is not a ugly number"");
   }
 }
 /**
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 Sample input/output:
 Enter a number:
 15
 15 is a ugly number
 
 Enter a number:
 11
 11 is not a ugly number
 */
 
",Dart
"'''
 In Columnar Cipher, we are given a plaintext and a key. The plaintext
 is written out in rows and the ciphertext is formed by reading out
 columns one by one according to the order of the key given. Key is
 converted to its corresponding numerical(Ex A-0, B-1, C-2, ...... , Z-25).
 Cipher text is formed by reading the columns corresponding to the lowest
 numerical value in the key to highest numerical value.
 '''
 
 
 def key_to_pad(keyword):
 ''' This function takes key as argument. It then sorts
     the key according to alphabetical order and return 
     the relative position of each keyword.'''
     
     sorted_keyword = sorted(keyword)
     pad = []
     for i in keyword:
         pad.append(sorted_keyword.index(i))
     return pad
 
 
 
 def matrix_plaintext(plaintext, keyword):
 ''' This funcion takes plaintext and keyword as input.
     It forms a matrix where plaintext characters are
     stored in row wise fashion.'''
 
     ''' To form a completely filled matrix, we check if plaintext
         is a multiple of keyword or not. If it is not, the we add
         underscores at the end of the plaintext.'''
     if len(plaintext) % len(keyword) != 0:
         empty = len(keyword) - (len(plaintext) % len(keyword))
         for i in range(empty):
             plaintext += ""_""
 
     # If plaintext has spaces, replace it with underscores
     for i in range(len(plaintext)):
         if(plaintext[i] == "" ""):
             plaintext = plaintext[:i] + ""_"" + plaintext[i + 1:]
 
     # The rows and columns of the matrix
     rows = len(plaintext) // len(keyword)
     columns = len(keyword)
     
     matrix = []
 
     count = 0
 
     # Adding plaintext to the matrix in row wise fashion
     for i in range(rows):
         column_matrix = []
         for j in range(columns):
             column_matrix.append(plaintext[count])
             count = count + 1
         matrix.append(column_matrix)
 
     # This function returns the matrix and the final plaintext
   ",Python
"""""""
 Purpose: Given a binary matrix of N*M order where 0 is the wall and 1 is the way.
         Find the shortest distance from a source cell to a destination cell,
         traversing through limited cells only. Also, you can move only
         up, down, left and right. If found then print the distance and
         path in separate lines, else return -1.
 
 """"""
 # Main DFS function using recursion
 
 def DFS(maze, src, des, way=1):
 
     # Dimention of the maze
     n = len(maze)
     m = len(maze[0])
 
     # To keep a track of visited nodes, also mark source as visited
     visited = [[False] * m for i in range(n)]
     visited[src[0]][src[1]] = True
 
     # All possible moves from a cell
     moves = {(1, 0): 'D', (-1, 0): 'U', (0, 1): 'R', (0, -1): 'L'}
 
     # Initilize the stack data structure and parent dictionary
     stack = [(src[0], src[1], 0)]
     parent = {}
 
     # Until the stack is empty, run the loop
     while stack:
         x, y, cost = stack.pop()
 
         # If the node is destination, calculate the path and return
         if (x, y) == des:
             path = ''
             dis = cost
             cur = (x, y)
 
             # Calculate the path by backtracking with the parent dict
             while cur != src:
                 prev_move = parent[cur]
                 m = (cur[0] - prev_move[0], cur[1] - prev_move[1])
                 path += moves[m]
                 cur = prev_move
 
             # Return the distance and path
             return dis, path[::-1]
 
         # For a given node check each possible move
         for i in moves.keys():
             r = x + i[0]
             c = y + i[1]
 
             # If the next node inside the maze , has a way and not yet visited
             # then mark it visited and push it in the stack
             if 0 <= r < n and 0 <= c < m and maze[r][c] == way and not visited[r][c]:
                 visited[r][c] = True
                 parent[(r, c)] = (x, y)
                 stack.append(",Python
"/*
 Transforms given BST into greater sum tree (GST) where each node contains sum of all nodes greater than that node.
 */
 
 #include<iostream>
 using namespace std;
 
 struct BST
 {
 	int a,count = 0; 
 	BST *left = NULL;
 	BST *right = NULL;
 };
 
 //points to the root node
 BST *start = NULL; 
 
 //function to convert array into Binary Search Tree with shortest height
 BST *arr_to_BST(int arr[20], int beg, int end) 
 {
 	BST *ptr;
 	
 	if(beg <= end)
 	{
 		ptr = new BST;
 		ptr->left = NULL;
 		ptr->right = NULL;
 		ptr->a = arr[(beg+end)/2];
 		int mid = beg + ((end - beg) / 2);
 		ptr->left = arr_to_BST(arr,beg,mid-1);
 		ptr->right = arr_to_BST(arr,mid+1,end);	
 		return ptr;
 	}
 	else
 		return NULL;
 }
 
 //function to print Binary Search Tree
 void Display_BST(BST *ptr) 
 {
 	if(ptr == NULL)
 		return;
 			
 	if(ptr->left != NULL)
 		Display_BST(ptr->left);
 	
 	cout<<""\t""<<ptr->a;
 
 	if(ptr->right != NULL)
 		Display_BST(ptr->right);
 }
 
 //function to convert BST to Greater Sum Tree
 int BST_to_GST(BST *ptr=start, int sum = 0)
 {
 	int temp = 0;
 	if(ptr != NULL)
 	{
 		sum = BST_to_GST(ptr->right,sum);
 		temp = ptr->a;
 		ptr->a = sum;
 		sum = BST_to_GST(ptr->left,sum+temp);
 	}
 	else
 		return sum;	
 }
 
 int main()
 {
 	int n, arr[20];
 	cout<<""\nEnter number of elements:""; 
 	cin>>n;
 	cout<<""\nEnter sorted array:"";
 	for(int i = 0 ; i < n ; i++)
 	{
 		cin>>arr[i];
 	}
 	start = arr_to_BST(arr, 0, n-1);	
 	cout<<""\nBinary Search Tree before conversion"";
 	Display_BST(start);
 
 	BST_to_GST(start);
 
 	cout<<""\nBinary Search Tree after conversion"";
 	Display_BST(start);
 
   	return 0;
 }
 
 /*
 Time Complexity:
 T(n)  = O(k) + 2 T(n/2) 
 Space Complexity:
 O(n)
 Sample I/O:
 Enter number of elements:6
 
 Enter sorted array:1 2 3 4 5 6
 
 Binary Search Tree before conversion    1       2       3       4       5       6
 Binary Search Tree after conversion     20      18      15      11      6       0
 */
",C-Plus-Plus
"/*
 Merge K sorted arrays
 =====================
 Given K sorted arrays, merge all of them into a single sorted array
 
 M-> Total number of elements
 Time Complexity: O(MlogM)
 Space Complexity: O(M)
 */
 #include <iostream>
 #include<queue>
 using namespace std;
 
 // Node class
 class Node {
 public:
 	int value; // Stores value of the node
 	int i; // Stores row number of the node
 	int j; // Stores column number of the node
 
 	// Constructor
 	Node(int value, int i, int j) {
 		this->value = value;
 		this->i = i;
 		this->j = j;
 	}
 };
 
 // Comparator class for priority_queue
 class NodeCompare {
 public:
 	bool operator()(Node a, Node b) {
 		return a.value > b.value;
 	}
 };
 
 // Merges k sorted arrays
 void merge(vector<vector<int>> a, int k) {
 
 	// minHeap declared
 	priority_queue<Node, vector<Node>, NodeCompare> pq;
 
 	// pq must be initialised with the first elements of all the k arrays
 	for (int i = 0; i < k; i++) {
 		Node node(a[i][0], i, 0); // node is located at the ith row and 0th column
 		pq.push(node);
 	}
 
 	// Stores final array
 	vector<int> ans;
 
 	// While pq is not empty
 	while (pq.size()) {
 		// Consider the topmost element of pq
 		Node f = pq.top();
 		pq.pop();
 		// Topmost element must be stored in ans
 		ans.push_back(f.value);
 
 		// Push next element of same row into the pq
 		int row = f.i;
 		int col = f.j;
 
 		if (col + 1 < a[row].size()) {
 			Node new_node(a[row][col + 1], row, col + 1);
 			pq.push(new_node);
 		}
 	}
 
 	// Print ans
 	for (auto x : ans) {
 		cout << x << "" "";
 	}
 }
 
 // driver code
 int main() {
 
 	int k; cin >> k;
 
 	vector<vector<int>> a(k);
 
 	for (int i = 0; i < k; i++) {
 		int n; cin >> n;
 		for (int j = 0; j < n; j++) {
 			int x; cin >> x;
 			a[i].push_back(x);
 		}
 	}
 
 	merge(a, k);
 }
 
 /*
 Input:
 3
 4
 2 6 12 15
 4
 1 3 14 15
 4
 3 5 8 10
 
 Output:
 1 2 3 3 5 6 8 10 12 14 15 15
 */",C-Plus-Plus
"/*  Find a Common element in rows of a given row-wise sorted matrix. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function to find common element in the matrix */
 int solve()
 {
     /* Input row = size of row.
        Input col = size of column. */
     int row,col;
     cin >> row >> col;
 
     /* Input elements in matrix. */
     int a[row][col];
     for (int i = 0; i < row; ++i)
     {
         for (int j = 0; j < col; ++j)
         {
             cin >> a[i][j];
         }
     }
     
     /* Create a hash map to store 
      count of element */
     unordered_map<int, int> count;
   
     for (int i = 0; i < row; i++) {
         
         for (int j = 1; j < col; j++) {
 
             /* Insert elements of the first row and
                initialize them with a value of 1 */
             if (i == 0) {
                 count[a[0][i]] = 1;
             }
             
             /* Check if the current element exists
                in the map and first in the current row */
             if (a[i][j] != a[i][j - 1])
                 count[a[i][j]]++;
         }
     }
       
     /* Return the element having a count 1 */
     for (auto element : count) {
         if (element.second == row)
             return element.first;
     }
 
     /* Return the element having a count not equal to 1 */
     return -1;
 }
 
 int main()
 {
     int common = solve();
 
     if (common == -1)
         cout << ""No Common element""<< endl;
     else
         cout << ""Common element is : "" << common << endl;
     return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
 
         4 5
         1 2 3 4 5
         2 4 5 8 10
         3 5 7 9 11
         1 3 5 7 9
 
     Output 1 :
 
         Common element is : 5
 
     Input 2 :
 
         4 5
         2 4 3 8 7
         1 3 5 6 8
         1 2 3 1 3
         4 5 0 2 3
     
     Output 2 :
     
         No Common element
     
     Time complexity: O(r*c)
     Space Complexity: O(1)
 */
",C-Plus-Plus
"/*
    This is a simple program in go language to calculate the
    catalan number if give a number as input.
 
    formula used : Co = 1 ; Cn+1 = summation from i = 0 to n (CiCn-1)
 
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 /* This function calculates and returns catalan number in a 
    recursive manner */
 func catalannumber(n int) int {
 
    var catalan int
    catalan = 0
 
    if (n == 0 || n ==1 ) {
 
        return 1
 
    }else {
 
       for i:=0;i<n;i++ {
 
          catalan += catalannumber(i) * catalannumber(n-i-1);
 
       }
 
    }
 
    return catalan
 
 }
 
 // driver function
 func main() {
 
    var number int
 
    // Taking the input from user here
    fmt.Print(""Enter the number here :"")
    fmt.Scan(&number)
 
    var catalan int
    catalan = 0 
    // calling the catalannumber function 
    catalan = catalannumber(number)
 
    // Printing the catalan number
    fmt.Print(""The catalan number is : "",catalan)
 
 }
 
 /*
    Sample I/O :
 
    Enter the number here :5
    The catalan number is : 42 
 
 */
 
",Go
"/**
 Program to search a given element using Fibonacci Search. We use Fibonacci
 numbers and compare them to the indexes of array elements to divde the array
 into smaller parts.
  */
 import 'dart:io';
 import 'dart:math';
 
 // fibonacci search function
 int fiboSearch(List arr, int item, int size) {
   // initialising fibonacci numbers
   int num1 = 0, num2 = 1, fibNum = num1 + num2;
 
   // fibNum stores the first fibonacci number greater than or equal to
   // the size of the array
   while (fibNum < size) {
     num1 = num2;
     num2 = fibNum;
     fibNum = num2 + num1;
   }
 
   // marks the eliminated range from the beginning
   int pos = 0;
 
   // we compare arr[num1] with x. if fibNum = 1 then num1 = 0
   while (fibNum > 1) {
     int i = min(pos + num1, size - 1);
 
     if (arr[i] > item) {
       // move two down
       fibNum = num1;
       num2 -= num1;
       num1 = fibNum - num2;
     } else if (item > arr[i]) {
       // move one down and reset offset
       fibNum = num2;
       num2 = num1;
       num1 = fibNum - num2;
       pos = i;
     } else {
       // item found
       return i;
     }
   }
 
   // element not found
   return -1;
 }
 
 // main function, entry point of program
 void main() {
   print(""Enter the size of list:"");
   int size = int.parse(stdin.readLineSync()!);
   List arr = [];
   print(""Enter the sorted list:"");
   for (int i = 0; i < size; i++) {
     arr.add(int.parse(stdin.readLineSync()!));
   }
   print(""Enter the number to be searched:"");
   int num = int.parse(stdin.readLineSync()!);
   // sorting
   int result = fiboSearch(arr, num, size);
   if (result != -1) {
     print(""$num found at position: ${result + 1}"");
   } else {
     print(""$num not found in the list."");
   }
 }
 
 /**
 Enter the size of list:
 6
 Enter the sorted list:
 12
 25
 32
 47
 56
 68
 Enter the number to be searched:
 47
 47 found at position: 4
 
 Time complexity: O(log n)
 Best case Time complexity: O(1)
 Space complexity: O(1)
  */
",Dart
"import java.util.*;
 import java.lang.*;
 
 /*
 Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers; that is, it is an integer sorting algorithm. It operates by counting the number of objects that have each distinct key value, and using arithmetic on those counts to determine the positions of each key value in the output sequence. 
 Worst complexity: O(n+k)
 Average complexity: O(n+k)
 Space complexity: O(n+k)
 where n is the number of elements in input array and k is the range of input.
 */
 
 class CountingSort
 {
     static void sortIntegerArray(int arr[])
     {
         int i=0;
         int n = arr.length;
         int minElement=Integer.MAX_VALUE;
         int maxElement=Integer.MIN_VALUE;
 
         //Maximum and Minimum element from input array
         for(i=0;i<n;i++)
         {
             if (arr[i] > maxElement) {
                 maxElement=arr[i];
             }
             if (arr[i] < minElement){
                 minElement=arr[i];
             }
         }
         
         int range = maxElement-minElement+1;
         int[] arrElementCount = new int[range];
         int[] sortedArray = new int[n];
         
         //count occurance of an element
         for(i=0;i<n;i++)
         {
             arrElementCount[arr[i]-minElement]++;
         }
         //Accumulative sum of elements
         for(i=0;i<range-1;i++){
             arrElementCount[i+1]+=arrElementCount[i];
         }
         //Shift array by one index
         int temp=arrElementCount[0];
         for(i=1;i<range;i++){
             int nextTemp=arrElementCount[i];
             arrElementCount[i]=temp;
             temp=nextTemp;
         }
         arrElementCount[0]=0;
         //store element at right index
         for(i=0;i<n;i++){
             sortedArray[arrElementCount[arr[i]-minElement]]=arr[i];
             arrElementCount[arr[i]-minElement]++;
         }
         //copy sorted array to input array
         for(i",Java
"import java.util.*;
  class SelectionSort
 {
 	public static void main(String[] args) {
 		int indexI,arrayLength,indexJ,temp=0,minElementIndex=0;
 		Scanner sc=new Scanner(System.in);
 		System.out.println(""Enter size of array"");
 		arrayLength=sc.nextInt();
 		int array[]=new int[arrayLength];
 		System.out.println(""Enter Elements of array"");
 		for(indexI=0;indexI<arrayLength;indexI++)
 		array[indexI]=sc.nextInt();
 		for(indexI=0;indexI<arrayLength;indexI++)
 		{   
 		    minElementIndex=indexI;
 		    for(indexJ=indexI+1;indexJ<=arrayLength-1;indexJ++)
 		    {
 		        if(array[minElementIndex]>array[indexJ])
 		        minElementIndex=indexJ;
 		      }
 		        
 		        temp=array[indexI];
 		        array[indexI]=array[minElementIndex];
 		        array[minElementIndex]=temp;
 		      }
 		  
 		  for(indexI=0;indexI<arrayLength;indexI++)
 		    System.out.println(array[indexI]);
 		}
 		}
",Java
"#include <stdio.h>
 
 void TowerOfHanoi(int n,int a,int b,int c){
     if(n){
         TowerOfHanoi(n-1,a,c,b);
         printf(""%d -> %d\n"", a,b);
         TowerOfHanoi(n-1,c,b,a);
     }
 }
 
 int main(){
     int number_of_discs;
     printf(""Enter the value of n: "");
     scanf(""%d"",&number_of_discs);
     printf(""\nThe value of n is: %d\n"", number_of_discs);
     TowerOfHanoi(number_of_discs,1,2,3);
     //each rod is numbered as 1,2,3
     return 0;
 }
 
 /*
 Tower of Hanoi is a mathematical puzzle where we have three rods and n disks. The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:
 1) Only one disk can be moved at a time.
 2) Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack i.e. a disk can only be moved if it is the uppermost disk on a stack.
 3) No disk may be placed on top of a smaller disk.
 
 In this code, we use the recursive definition of Tower of Hanoi.
 
 Time Complexity: O(2^N)
 Space Complexity: O(N)
 
 OUTPUT
 Enter the value of n: 4
 The value of n is: 4
 1 -> 3
 1 -> 2
 3 -> 2
 1 -> 3
 2 -> 1
 2 -> 3
 1 -> 3
 1 -> 2
 3 -> 2
 3 -> 1
 2 -> 1
 3 -> 2
 1 -> 3
 1 -> 2
 3 -> 2
 */
",C
"# Z ALgorithm Function
 def Z__Algo(text, pattern):
     List = []
     substring = """"
 
     """""" Iterating upto the index where the substring can occur """"""
     for text_index in range(0, len(text) - len(pattern)+1):
 
         """""" Extracting the --substring of the same length as pattern-- from the text """"""
         substring = text[text_index:text_index + len(pattern)]
 
         """""" Loop for comparing the substring and pattern """"""
         count = 0
         for substring_index in range(0, len(pattern)):
 
             """""" If the charecters of substring and pattern matches , increment count by 1 """"""
             if substring[substring_index] == pattern[substring_index]:
                 count += 1
 
         """""" If all the charecters of substring and pattern matches , add position to list """"""
         if count == len(pattern):
             List.append(text_index)
 
     """""" Return the list that contains all the positions the substring is present at """"""
     return List
 
 
 # Searching Process Driver Code
 
 if __name__ == '__main__':
     text = input(""Enter Text : "")
     pattern = input(""Enter pattern : "")
     
     """"""Calling Z__Algo to seacrh the substring positions""""""
     positions = Z__Algo(text, pattern)
 
     """"""If returned list from Z__Algo is not empty , print positions , else prompt -- pattern not found""""""
     if len(positions) != 0:
         for position in positions:
             print(""The pattern is present at : "" + str(position))
 
     else:
         print(""Pattern Not Found !!!"")
 
         
         
         
         
         
 """"""
     Input description: 
     Line 1 -- Text
     Line 2 -- Pattern
     
     Output Description :
     The pattern is present at : position_index
     ...
     ...
     
     
     Input 1:        
         aaaabbabbababaabbabaaaa
         aa
     Ouput 1:
         The pattern is present at : 0
         The pattern is present at : 1
         The pattern is present at : 2
         The pattern is present at :",Python
"/*BigInteger class is used for mathematical operation which involves very big integer calculations that are outside the limit of all available primitive data types. For example factorial of 100 contains 158 digits in it so we can't store it in any primitive data type available*/
 import java.math.*;
 import java.util.*;
 class Big_Integer_Factorial {
     public static void main(String args[]) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the number to find the factorial of"");
         int n = sc.nextInt();
         System.out.println("" The factorial of "" + n + "" is : "" + factorial(n));
     }
     public static BigInteger factorial(int n) {
         BigInteger fact = new BigInteger(Integer.toString(n));
         for (int i = 1; i < n; i++)
             fact = fact.multiply(BigInteger.valueOf(i));
         return fact;
 
     }
 
 }
 /* Sample Input and Output : 
  * Enter the number to find the factorial of
 32
  The factorial of 32 is : 263130836933693530167218012160000000
 Time Complexity : O(n)
 Space Complexity : O(1)
  */",Java
"class Spiral_Matrix {
 public:
     vector<int> spiralOrder(vector<vector<int>>& matrix) {
         vector<int> arrLL;
         
         //EDGE CASE
         if (matrix.size()  == 0) return arrLL;
         
         int rows = matrix.size() ;
         int columns = matrix[0].size() ;
         
         if (rows == 1 && columns == 1) {
             arrLL.push_back(matrix[0][0]);
             return arrLL;
         }
         
         if (rows == 1) {
             for (int j = 0; j < columns; j++){
                 arrLL.push_back(matrix[0][j]);  
             }
             return arrLL;
         }
         
         if (columns == 1){
             for (int i = 0; i < rows; i++){
                 arrLL.push_back(matrix[i][0]);  
             }
             return arrLL;
         }
         
         int i, j, k1, k2, itr = 0;
         while (j < columns || i < rows || j > k1 || i > k2){
            
             bool cond1 = false;
             while (j < columns ){
                 if (i != itr || i >= rows) break;
                 arrLL.push_back(matrix[i][j]);
                 j++;
                 cond1 = true;
             }
         
             i++; j--; n--;
             bool cond2 = false;
             while (i < rows && cond1 == true){
                 arrLL.push_back(matrix[i][j]);
                 cond2 = true;
                 i++;
             }
             
             j--; i--; m--;
             bool cond3 = false;
             while ( j>= k1  && cond2 == true){
                 arrLL.push_back(matrix[i][j]);
                 j--;
                 cond3 = true;
             }
             
             j++; i--; k1++;
             while ( i > k2 && cond3 == true) {
                 arrLL.push_back(matrix[i][j]);
                 i--;
             }
             
             j++; i++; k2++;
             itr ++;
         }
         return arrLL;
     }
 };
 
 /*
 TEST CASE
 
 TIME COMPLEXITY : 0(N*M) 
 SPACE COMPLEXITY: 0(N+M)
 
 where N is number",C-Plus-Plus
"
 // Given a list of words and two words word1 and word2, find the shortest distance between those two words from the list.
 
 import java.util.*;
 class Shortest_Dist {
     static List < String > arr;
     public static void main(String args[]) {
         int t = 0;
 
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the list of words "" + ""\n"" + ""Words = "");
         arr = new ArrayList <> ();
 
         arr.add(sc.nextLine());
         while (sc.hasNext()) {
             arr.add(sc.nextLine());
             if (sc.hasNextInt()) {
                 t = sc.nextInt();
                 break;
             }
 
         }
 
         List < String > wd = new ArrayList(arr);
         while (t > 0) {
             System.out.println(""Enter the words between which the shortest distance is to be calculated"");
             String wd1 = sc.next();
             String wd2 = sc.next();
             System.out.println("" The shortest Distance between "" + wd1 + "" and "" + wd2 + "" is : "" + shortest_dist(wd, wd1, wd2));
             //List<> wd is being allocation with elements of Collection arr
             wd = new ArrayList(arr);
 
             t--;
         }
 
     }
     public static int shortest_dist(List < String > wd, String wd1, String wd2) {
         int dist = -1;
         List < String > wdcopy = new ArrayList(wd);
         //list <> ind1. List <> ind2, for storing indexes of wd1, wd2 in List <> wd
         List < Integer > ind1 = new ArrayList <> ();
         List < Integer > ind2 = new ArrayList <> ();
 
         while (wd.contains(wd1)) {
             ind1.add(wd.indexOf(wd1));
             //
             wd.add(wd.indexOf(wd1), ""0"");
             wd.remove(wd.indexOf(wd1));
 
         }
 
         while (wdcopy.contains(wd2)) {
             ind2.add(wdcopy.indexOf(wd2));
 
             wdcopy.add(wdcopy.indexOf(wd2), ""0"");
             wdcopy.remove(wdcopy.indexOf(wd2));
         }
 
         for (int i = 0; i < ind1.size(); i++) {
    ",Java
"/*Tree sort is a sorting algorithm that is based on Binary Search Tree data structure.
  It first creates a binary search tree from the elements of the input list
  or array and then performs an in-order traversal on the created binary search
  tree to get the elements in sorted order.
  */
 
 import java.util.*;
 import java.lang.*;
 
 class Node{
 
     int data;
     Node left, right;
 
     public Node(int data){
         this.data = data;
         left = right = null; //Initially assigning left and right node as null
     }
 }
 
 //Tree_Sort Algorithm
 class Tree_Sort {
     Node root;
 
     //Constructor
     Tree_Sort(int value){
         root = new Node(value);
     }
 
     //Inserting values in a tree
     public Node insert(int value, Node root){
 
         /*Initially assigning first value
           from the array as root
          */
         if(root == null){
             return new Node(value);
         }
 
         if(root.data > value){
             //checking if preceding node to left of root is empty
             if(root.left == null){
                 root.left = new Node(value);
             }
             insert(value, root.left);
             //Recursive Call for inserting values in left subtree
         }
 
         if(root.data < value){
             //checking if preceding node to right of root is empty
             if(root.right == null){
                 root.right = new Node(value);
             }
             insert(value, root.right);
             //Recursive Call for inserting values in right subtree
         }
 
         return root;
     }
 
     //Inorder Traversal of Tree
     public void inOrder(Node root){
         if(root != null){
             inOrder(root.left);
             System.out.print(root.data + "" "");
             inOrder(root.right);
         }
     }
 }
 
 public class TreeSort {
     public static void main(String[] args) {
         
      int n;
         Scanner sc=new Scanner(System.in);
         System.out.pri",Java
"/*
 
 Introduction 
 Given a Binary Tree , print maximum leaf to leaf path sum
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 Function to find and return maximum leaf to leaf path sum
 
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h> 
 using namespace std;
 //Define a global variable and keep updating it whenever u get a maximum value
 long MaxSum;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Function to calculate leaf to leaf sum and update it recursively
 //If root->key is negative it may happen that leaf to leaf path sum",C-Plus-Plus
"/*
 
 Introduction 
 Given a Binary Tree , Print the value of maximum node key 
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 A function which returns the maximum element 
 If the root is NULL it prints -1
 
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Function to return maximum value of root key of the given tree
 int FindMax(struct Node* root)
 {
 
     // If root is NULL , return -1
     if (root == NULL)
         return -1;
     //Initialise a maxim",C-Plus-Plus
"/*
 About Preemptive Priority Scheduling:-
 It is a method of scheduling processes that is based on priority. 
 In this algorithm, the scheduler selects the tasks to work as per the priority.
 If two processes have the same priority, then the job with the shortest burst time is executed first.
 
 Time related to each process-
 Arrival Time(AT)-The time at which process enters into the ready queue.
 Burst Time(BT)-The total time required by the CPU to execute the whole process.
 Completion Time(CT)-The time at which the process enters into completion state.
 Turn Around Time(TAT)-The total amount of time spent by the process from its completion.
                       It is calculated as - TAT=CT-AT
 Waiting Time(WT)-The total time for which the process waits for the CPU to be assigned.
                  It is calculated as - WT=TAT-BT
 Response Time(RT)-The difference between arrival time and the time at which the process first gets the CPU.
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 #define MAX 50
 const int N;
 
 //structure of priority queue
 struct queue
 {
 	int burst_time;
 	int process;
 	int priority;
 	struct queue * next;
 };
 struct queue *q = NULL;
 
 //push function for queue
 void push(int n, int p, int b)
 {
 	struct queue *new = (struct queue *) malloc(sizeof(struct queue));
 	new->process = n;
 	new->priority = p;
 	new->burst_time = b;
 	new->next = NULL;
 	if (q == NULL)
 	{
 		q = new;
 	}
 	else
 	{
 		struct queue *t1, *t2;
 		t1 = q;
 		while (t1 != NULL && t1->priority <= p)
 		{
 			if (t1->priority < p)
 			{
 				t2 = t1;
 				t1 = t1->next;
 			}
 			else
 			{
 				if (t1->burst_time > b)
 				{
 					break;
 				}
 				else
 				{
 					t2 = t1;
 					t1 = t1->next;
 				}
 			}
 		}
 
 		if (t1 == q)
 		{
 			new->next = t1;
 			q = new;
 		}
 		else if (t1 == NULL)
 		{
 			t2->next = new;
 		}
 		else
 		{
 			new->next = t1;
 			t2->next = new;
 		}
 	}
 }
 
 //pop function for queue
 int pop()
 {
 	struct queue *t = q;
 	int x",C
"/*Russian Reasant Algorithm
 
 In this algorithm, two numbers are multiplied without using multiplication operator.
 We double the first number and halve the second number repeatedly till the second number doesnt become 1. 
 In the process, whenever the second number becomes odd, we add the first number to result.
 
 In the 1800s, Peasants in a remote area of Russia were discovered multiplying numbers using this remarkably unusual process.
 */
 
 #include <iostream>
 using namespace std;
 int main()
 {
     int a, b, result = 0;
 
     cout << ""Enter two numbers to multiply: \n"";
     cin >> a >> b;
     while (b > 0)
     {
         if (b % 2 != 0)
         {
             result += a;
         }
         a = a << 1;
         b = b >> 1;
     }
     cout << ""Product: "" << result;
     return 0;
 }
 
 /*Input:
 Enter two numbers to multiply: 
 4 20
 
 Output:
 Product: 80
 
 Time complexity: O(1)
 */",C-Plus-Plus
"/*    This C++ Program is the implementation of the Klee's Algorithm.
 
     Description: Given a Point with x and y coordinates,this algorithm finds the union of the
                  lengths covered by all these line segments.
     This algorithm was proposed by Klee in 1977 and is asymptotically the fastest.     */
 
 
 #include<bits/stdc++.h>
 #define x first
 #define y second
 
 using namespace std;
 
 //Structure to store the point coordinates.
 typedef struct points {
 	int x, y;
 }points;
 
 //vector to indicate the points in the plane.
 vector<points>plane;
 
 //function to find the union of the lengths.
 int find_union(vector<points>line) {
 
 	int size = line.size();
 
 	//This vector first stores the coordinate and then the bool value.
 	//Here,the starting coordinate is marked false and the ending coordinate as true in pair.
 	vector<pair<int, bool>> points(size * 2);
 
 	for (int i = 0; i < size; i++)
 	{
 
 		points[i * 2] = make_pair(line[i].x, false);
 		points[i * 2 + 1] = make_pair(line[i].y, true);
 
 	}
 
 	//This is to sort all the ending points.
 	sort(points.begin(), points.end());
 
 	//Initializing variable answer which will store the final length and counter which will keep track of the opening and closing segment.
 	int answer = 0, counter = 0;
 
 	//traversing through all the ending points
 	for (int i = 0; i < size * 2; i++)
 	{
 		//for adding the difference of current and previous points to answer.
 		if (counter)
 			answer += (points[i].x - points[i - 1].x);
 
 		//for the endpoint of the segment, decrements the counter or else increment the counter.
 		if (points[i].y)
 			counter--;
 		else
 			counter++;
 	}
 
 	return answer;
 }
 
 int main()
 {
 
 	//declaration of the number of points.
 	int n;
 
 	cout << ""Enter the desired number of points:\n"";
 	cin >> n;
 	cout << ""Enter the x and y coordinates for the points with a space:\n"";
 
 	plane.resize(n);
 
 	//For input of x and y coordinates of the desired points
 	for (int i = ",C-Plus-Plus
""""""" Fortunately, we dont need to implement AES from scratch
     to do so We have to first install ""pycryptodome"" library
     -- pip install pycryptodome """"""
 
 
 from Crypto.Cipher import AES
 from Crypto.Hash import SHA256
 
 from Crypto import Random
 import base64
 
 """""" taking key from user and hashing it (can generate random key also )
     hash key can be 16 bytes or 24 bytes or 32 bytes long """"""
 
 key = input(""Enter your secret key: "")
 hash_key = SHA256.new(key.encode()).digest()
 print(""Hashedn key for your secret key:"")
 print(hash_key)
 len_hash_key = len(hash_key)
 
 """"""taking block size to be implemented in AES""""""
 block_size = input(""Enter the block-size in bytes: "")
 block_size = int(block_size)
 print(block_size)
 
 
 """""" Writing padding and unpadding functions
 padding: as AES algorithm works in blocks of ciphers,our message gets divides into
 blocks of ciphers which can be 128 or 192 or 256 bits long, we want our message in
 multiples of this numbers. thats why we padd our msg.
 unpadding can be used in time of decryption and padding in time of encryption
 example: lets take string ""I love cats"" len-11 after padding ""I love cats ----"" len-16
 padding character used here '-'.  """"""
 
 
 def padding(msg, blocks_size):
     '''
     The chr() method returns a character from an integer (unicode)
     we are generating padding char using padding_bytes_len
     we can also use any padding char as explained in above example such as -,= etc
     '''
     padding_bytes_len = blocks_size - len(msg) % blocks_size
     padded_char = chr(padding_bytes_len)
     padding_string = padding_bytes_len*padded_char
     padded_res = msg+padding_string
     return padded_res
 
 
 def unpadding(msg):
     '''
     The ord() function returns the number representing the unicode code of a character.
     as we added unicode code of character to make it padded we are removing same.
     '''
     last_char = msg[len(msg) - 1:]
     unpadded_bytes_len = ord(last_char)
   ",Python
"'''
 PROBLEM STATEMENT:
 Given a binary tree, the task is to print its left view. Left view of
 a binary tree is defined as the nodes which will be visible if the tree
 is viewed from the left side. The input for the binary tree is in the
 form of preorder and entering '-1' denotes a null node.
 For example:
 Input: 3 4 -1 6 -1 -1 5 1 -1 -1 -1
 The above input will have the following structure:
     3
    / \
   4   5
   \   /
    6  1
 Output: 3 4 6, as as these are the nodes that will be visible from left.
 '''
 
 
 # A class to create a node
 class Node:
     # Constructor to initialize node
     def __init__(self, data):
         self.data = data
         self.left = None
         self.right = None
 
 
 # A function to build the tree in preorder form
 def BuildTree():
     d = int(input())
     if d == -1:
         return None
     root = Node(d)
     root.left = BuildTree()
     root.right = BuildTree()
     return root
 
 
 # A function to print the left view of the binary tree
 def LeftView(root, level, maxlevel):
     # base case
     if root is None:
         return
     if level > maxlevel[0]:
         print(root.data, end="" "")
         maxlevel[0] = level
     # Recursive case
     LeftView(root.left, level + 1, maxlevel)
     LeftView(root.right, level + 1, maxlevel)
 
 
 print(""Enter values in a binary tree:"")
 # A function call to build the tree and return root node
 root = BuildTree()
 # maxlevel is defined as a list because it is mutable and we want the changes
 # made to it gets reflected outside the function
 maxlevel = [-1]
 print(""Left view of the binary tree is:"")
 LeftView(root, 0, maxlevel)
 
 
 '''
 TEST CASE:
 1.
 Input:
 Enter values in a binary tree:
 2
 4
 7
 8
 -1
 -1
 -1
 5
 -1
 -1
 3
 9
 -1
 6
 -1
 1
 -1
 -1
 -1
 Output:
 Left view of the binary tree is:
 2 4 7 8 1
 Explanation:
 The structure of the tree is:
             2
           /   \
          4     3
         / \   /
        7   5 9
       /       \
      8         6
          ",Python
"/*
 Shell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm.
 This algorithm avoids large shifts as in case of insertion sort, if the smaller value is to the far right 
 and has to be moved to the far left.This algorithm uses insertion sort on a widely spread elements, first to sort 
 them and then sorts the less widely spaced elements. This spacing is termed as interval.
 Worst case time complexity = O(n2)
 Best case complexity = O(nlog(n)).
 Space complexity = O(1).
 */
 
 
 #include<iostream>
 using namespace std;
 /*Method to sort the list/array*/
 void shellSort(int sort[],int size){
     for(int gap=size/2;gap>0;gap/=2){
         for(int i=gap;i<size;i++){
             int temp=sort[i];
             int j;
             for(j=i;j>=gap&&sort[j-gap]>temp;j-=gap){
                 sort[j]=sort[j-gap];
             }
             sort[j]=temp;
         }
     }
 }
 //main program
 int main(){
     int size;
     cout<<""Enter the size of the array: "";
     cin>>size;
     int sort[size];
     cout<<""Enter the Elements to be sorted:"";
     for(int i=0;i<size;i++){
         cin>>sort[i];
     }
     shellSort(sort,size);
     cout<<""Array after sorting is: "";
     for(int i=0;i<size;i++){
         cout<<sort[i]<<"" "";
     }
     cout<<endl;
     return 0;
 }
 /*       Output
 Enter the size of the array: 5                                                                                                                
 9 5 8 1 4                                                                                                                                            5                                                                                                                                             
 Array after sorting is: 1 4 5 8 9                                                                                                                                           Array after sorting is: 1 4 5 8 9 
 */
",C-Plus-Plus
"// C Program to find the Number of Digits of a given number
 #include <stdio.h>
 
 int sum_of_digits(int num)
 {
     int cnt = 0;
     while (num != 0)
     {
         cnt++;
         // Removing the least significant digit
         num = num / 10;
     }
     return cnt;
 }
 
 int main()
 {
     int num, cnt;
     printf(""\nEnter the number: "");
     scanf(""%d"", &num);
 
     // If the number is negative, convert it into positive
     if (num < 0)
     {
         num = num * -1;
     }
 
     // Call the function
     cnt = sum_of_digits(num);
     // Print the obtained count
     printf(""The number of digits in the given number is: %d"", cnt);
     return 0;
 }
 
 /*
 Time Complexity- O(log(num)), where 'num' is the given num
 Space Complexity- O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number: 1231
 The number of digits in the given number is: 4
 */
",C
"import java.util.*;
 class Min_Element_Rotated_array {
     public static void main(String args[]) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the elements"");
         int min = sc.nextInt();
         while (sc.hasNextInt()) {
             int num = sc.nextInt();
             if (num < min)
                 min = num;
         }
         System.out.println("" Minimum element in the list : "" + min);
     }
 }
 /* Sample Input and Output :
  * Minimum element in the list : 2
 Enter the elements
 3
 4
 5
 1
 2
 
  Minimum element in the list : 1
 Time Complexity : O(n)
 Space Complexity : O(1)
  */
",Java
"// The BoyerMoore majority vote algorithm in C++
 // This algorithm finds a majority element, if there is one: i.e, an element that occurs repeatedly for more than half of the elements of the input.
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // To find majority element
 int majority(int arr[], int arrsize) {
 	int index = 0, count = 1;
 	// finding num to check majority
 	for (int i = 1; i < arrsize; i++) {
 		if (arr[index] == arr[i])
 			count++;
 		else
 			count--;
 		if (count == 0) {
 			index = i;
 			count = 1;
 		}
 	}
 	int num = arr[index];
 	for (int i = 0; i < arrsize; i++)
 		if (arr[i] == num)
 			count++;
 	// checking for majority
 	if (count > arrsize / 2)
 		return num;
 	else
 		return -1;
 }
 
 int main() {
 	int n;
 	cout << ""Enter no of elements:"";
 	cin >> n;
 	cout << ""\nEnter elements: "";
 	int arr[n];
 	for (int i = 0; i < n; i++)
 		cin >> arr[i];
 	int result = majority(arr, n);
 	if (result != -1)
 		cout << ""Majority of a sequence is "" << result << endl;
 	else
 		cout << ""There is no majority \n"";
 	return 0;
 }
 
 /*input/output:
  Enter no of elements:5
  Enter elements: 1 1 1 1 2
  Majority of arr sequence is 1
 
  Enter no of elements:5
  Enter elements: 1 2 3 2 4
  There is no Majority.
 
  Time complexity : O(n)
  Space complexity: O(1)
  */
",C-Plus-Plus
"/*
 
   Euler's Totient Function in Dart
 
   The result of the Euler's Totient Function for a number n (F(n)) 
   denotes the number of coprimes of n from 1 to n
 */
 
 import 'dart:io';
 
 int totientFunction(int n) {
   var arr = new List(n + 1);
 
   int i, j;
 
   arr[0] = 0;
   arr[1] = 1; // as 1 is coprime with itself
 
   for (i = 2; i <= n; i++) {
     arr[i] = i;
   }
 
   /*
     in each iteration, we find the number of coprimes of 
     that particular ""i"". So in the end we get return the 
     last element of the array which has the number of coprimes result.
 
     For example 
     if n = 8
     before this loop arr[] = [0, 1, 2, 3, 4, 5, 6, 7, 8]
     after this loop  arr[] = [0, 1, 1, 2, 2, 4, 2, 6, 4]
     Observe how every number represents its own number of coprimes
   */
   for (i = 2; i <= n; i++) {
     if (arr[i] == i) {
       for (j = i; j <= n; j += i) {
         arr[j] = arr[j] - (arr[j] / i).floor();
       }
     }
   }
   return arr[n];
 }
 
 int main() {
   stdout.write(""Enter a integer: "");
 
   int n = int.parse(stdin.readLineSync()); // taking input as integer n
 
   stdout.write(""no. of coprime of $n from 1 to $n: "");
   stdout.write(totientFunction(n)); // printing Euler's Totient Function for int n
   print("" "");
   return 0;
 }
 
 /*
 
   SAMPLE TESTS
 
   SAMPLE TEST 1
   Enter a integer: 5
   no. of coprimes of 5 from 1 to 5: 4
   
   Explanation
   As 5 is a prime no. so it is coprime with all 1, 2, 3 & 4.
   Therefore, its Euler's Totient Function value is 4;
 
 
   SAMPLE TEST 2
   Enter a integer: 4
   no. of coprimes of 4 from 1 to 4: 2
 
   Explanation
   4 is coprime with 1 and 2 only.
   Therefore its Euler's Totient function value is 2
 
   
   Time Complexity O(n)
   Space complexity O(n)
 */
",Dart
"'''
 You are given an array prices where prices[i] is the price of a given stock on the ith day.
 You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to 
 sell that stock.Return the maximum profit you can achieve from this transaction. 
 If you cannot achieve any profit, return 0.
 
 Example 1:
 
 Input: prices = [7,1,5,3,6,4]
 Output: 5
 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
 Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
 
 Example 2:
 
 Input: prices = [7,6,4,3,1]
 Output: 0
 Explanation: In this case, no transactions are done and the max profit = 0.
 
 Note: You may not engage in multiple transactions at the same time(i.e., you must sell the stock before you buy again).
 '''
 def best_transaction(arr):
     #if the arr is smaller than 2 max profit is 0 
     if len(arr) < 2:
         return 0
 
     size = len(arr)
 
     hold = [0] * size   
     unhold = [0] * size
 
     hold[0] = 0 - arr[0]
     unhold[0] = 0
     hold[1] = max(-arr[0], -arr[1])  #find when is maximum profit 
     unhold[1] = max(arr[1] - arr[0], 0)  #find when is the minimum  profit  
 
     for i in range(2, size):
         #checking the which time buy and sell in every element(price) in array  
         hold[i] = max(hold[i - 1], unhold[i - 2] - arr[i])
         unhold[i] = max(hold[i - 1] + arr[i], unhold[i - 1])
     #result
     return unhold[-1]
 
 
 if __name__ == ""__main__"":
     arr = list(map(int,input(""Enter the prices: "").split()))
     print(""Maximum Profit is "",best_transaction(arr))
 
 '''
 Time complexcity : O(n)
 Space Complexcity : O(n)
 
 Input:
 Enter the prices: 7 1 5 3 6 4
 
 Output:
 Maximum Profit is  5
 
 '''
",Python
"// C program to Rotate a number by a specific bits
 #include <stdio.h>
 
 // Left Rotate 'cnt' number of bits of the given number 'n'
 int left_rotate_bits(int n, int cnt)
 {
     int msb;
 
     // 32 is the total number of bits used to store an INT variable in C++
     for (cnt = cnt % 31; cnt > 0; cnt--)
     {
         //Store the current MSB in a temporary variable
         msb = (n >> 31) & 1;
         //Left rotate the given number by one bit
         n = (n << 1);
         //Set the dropped MSB as the new LSB
         n = n | msb;
     }
     return n;
 }
 
 // Right Rotate 'cnt' number of bits of the given number 'n'
 int right_rotate_bits(int n, int cnt)
 {
     int lsb;
 
     // 32 is the total number of bits used to store an INT variable in C++
     for (cnt = cnt % 31; cnt > 0; cnt--)
     {
         //Store the current LSB in a temporary variable
         lsb = n & 1;
         //Right rotate the given number by one bit and drop its LSB
         n = (n >> 1) & (~(1 << 31));
         //Set the dropped LSB as the new MSB
         n = n | (lsb << 31);
     }
     return n;
 }
 
 int main()
 {
     int n, cnt, left, right;
     printf(""\nEnter the number? "");
     scanf(""%d"", &n);
 
     printf(""How many bits do you want to rotate? "");
     scanf(""%d"", &cnt);
 
     //Call the sort function
     left = left_rotate_bits(n, cnt);
     right = right_rotate_bits(n, cnt);
 
     printf(""The Left-rotated number is: %d\n"", left);
     printf(""The Right-rotated number is: %d\n"", right);
 
     return 0;
 }
 
 /*
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 39
 How many bits do you want to rotate? 17
 The Left-rotated number is: 5111808 
 The Right-rotated number is: 1277952
 
 */
",C
"/**
  * Ackermann Function is a function with 2 aguments ( A(m,n) ). Each argument can be assigned any non negative integer
  * in A(m,n),
     * If m=0, then A(m,n) = n+1
     * If m != 0 but n=0, A(m,n)=A(m-1,1)
     * If m and n both are not zero then... A(m,n) = A( m-1, A(m,n-1) )
  *  */
 
 import 'dart:io';
 
 int Ackermann_Function(int m, int n) {
   if (m == 0)
     return n + 1;
   else if (m > 0 && n == 0)
     return Ackermann_Function(m - 1, 1);
   else if (m > 0 && n > 0) return Ackermann_Function(m - 1, Ackermann_Function(m, n - 1));
 
   return 0;
 }
 
 void main() {
   print(""Input first Number"");
   int m = int.parse(stdin.readLineSync()!);
   print(""Input second Number"");
   int n = int.parse(stdin.readLineSync()!);
   int result = Ackermann_Function(m, n);
   print(""Result: $result"");
 }
 
 /*
  * Time complexity:-O(2^(2^n)) to compute A(m, n). 
     Ackermann's function is like the upper bound for primitive recursive functions. Also, O(2^(2^n)) time complexity is much worse than n^n. 
  
  * Space complexity:- O(m) to compute A(m, n)
 
 Examples:-
 
 Input first Number
 1
 Input second Number
 2
 Result: 4
 
 Input first Number
 3
 Input second Number
 3
 Result: 61
 */
",Dart
"import java.util.*;
 
 /*
 A program to find the gcd of two numbers
 GCD= Greatest common divisor
 */
 
 public class FindGCDOfTwoNo{
 
     private static Scanner sc = new Scanner(System.in);
 
     public static void main(String[] args) {
 
         //taking the two numbers as input from the user
         System.out.println(""Kindly enter the two numbers: "");
         int a = sc.nextInt();
         int b = sc.nextInt();
 
         int gcd = findgcd(a,b);
 
         System.out.println(""The GCD of ""+a+"" and ""+b+"" = ""+gcd);
     }
 
     //method to find the gcd of two numbers
     private static int findgcd(int a, int b) 
     {
         //the loop executes until the two numbers are equal to each other
         while(a!=b)   
         {  
             if(a>b)  
                 a=a-b;  
             else  
                 b=b-a;  
         }  
         return b;
     }
 }
 
 /*
 Output:
 
 Kindly enter the two numbers:
 14
 16
 The GCD of 14 and 16 = 2
 
 Kindly enter the two numbers:
 18
 1034
 The GCD of 18 and 1034 = 2
 
 Kindly enter the two numbers:
 48
 120
 The GCD of 48 and 120 = 24
 
 */
 
",Java
"// Tower of Hanoi problem a mathematical problem
 // The Time complexity of this problem is O(2^n) and Space complexity is O(n).
 
 using System; 
   
 class towerOfHanoi
 { 
 	// recursive function to move complete disks from starting rod to final rod
 	
     static void moveDisks(int n, int start_rod, int final_rod, int aux_rod) 
     { 
         if (n>0) 
         { 
         moveDisks(n-1, start_rod, aux_rod, final_rod); 
         Console.WriteLine(""Move disk "" + n + "" from rod "" + start_rod + "" to rod "" + final_rod); 
         moveDisks(n-1, aux_rod, final_rod, start_rod); 
         }
     } 
       
     public static void Main() 
     { 
         Console.WriteLine(""Enter the number of disks: "");
         int num = Convert.ToInt32(Console.ReadLine());
           
         moveDisks(num, 1, 3, 2);  
     } 
 }
 
 /* Sample input/output
 Enter the number of disks: 
 4
 Move disk 1 from rod 1 to rod 2
 Move disk 2 from rod 1 to rod 3
 Move disk 1 from rod 2 to rod 3
 Move disk 3 from rod 1 to rod 2
 Move disk 1 from rod 3 to rod 1
 Move disk 2 from rod 3 to rod 2
 Move disk 1 from rod 1 to rod 2
 Move disk 4 from rod 1 to rod 3
 Move disk 1 from rod 2 to rod 3
 Move disk 2 from rod 2 to rod 1
 Move disk 1 from rod 3 to rod 1
 Move disk 3 from rod 2 to rod 3
 Move disk 1 from rod 1 to rod 2
 Move disk 2 from rod 1 to rod 3
 Move disk 1 from rod 2 to rod 3
 */
",C-Sharp
"/*Problem link: https://binarysearch.com/problems/A-Flight-of-Stairs-Sequel
 
 Problem Statement:
 You are given positive integers n and k and you are currently at stair 0 and want to climb to stair n. 
 You can either climb 1, 2, or 3 stairs at a time, but you can only climb 3 stairs at most k times.
 Return the number of ways to climb to the nth stair.
 */
 
 import java.util.Scanner;
 
 public class FlightOfStairs{
 
     public static int ans(int[][] memo, int n, int k) {
 
         /*base conditions*/
         if (n == 0)
             return 1;
         else if (n < 0)
             return 0;
         else if (memo[n][k] != 0)
             return memo[n][k];
 
         /*recursive calls for 1 step and 2 steps respectively*/
         memo[n][k] = ans(memo, n - 1, k) + ans(memo, n - 2, k);
 
         /*recursive call for 3 steps only if k satisfies*/
         if (k > 0)
             memo[n][k] += ans(memo, n - 3, k - 1);
 
        /*returning memoized answer*/
         return memo[n][k];
 
     }
     public static void main(String args[]) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the value of n"");
         int n = sc.nextInt();
         System.out.println(""Enter the value of k"");
         int k = sc.nextInt();
 
         /*array to initiate memoization*/
         int[][] memo = new int[n+1][k+1];
 
         /*passing arguments to the function and displaying answer*/
         System.out.println(""The answer is: ""+ans(memo, n, k));
         sc.close();
     }
 }
 
 /*
 Sample Input :
 Enter the value of n
 4
 Enter the value of k
 1
 Output :
 The answer is: 7
 */
 
 /*
 Time complexity: O(n*k) 
 Space complexity: O(n*k)
  */
",Java
"public class BubbleSort
 {
     public static void Sort(int[] array)
     {
         for (int i = 0; i < array.Length - 1; i++)
         {
             bool noSwap = true;
 
             for (int j = 0; j < array.Length - i - 1; j++)
             {
                 if (array[j] > array[j + 1])
                 {
                     (array[j], array[j + 1]) = (array[j + 1], array[j]);
                     noSwap = false;
                 }
             }
 
             // if there is no swap done we stop the algo
             if (noSwap)
             {
                 break;
             }
         }
     }
 }
 
",C-Sharp
"/*
 Given a function int f(unsigned int x) which takes a non-negative integer x 
 as input and returns an integer as output. The function is monotonically increasing 
 with respect to value of x, i.e., the value of f(x+1) is greater than f(x) for every 
 input x. Find the value n where f() becomes positive for the first time.
 Since f() is monotonically increasing, values of f(n+1), f(n+2), must be positive and 
 values of f(n-2), f(n-3), .. must be negative.
 */
 #include<bits/stdc++.h> 
 using namespace std; 
 
 int binarySearch(int low, int high); 
 
 // Let's take an example function 
 // f(x) = x^2 - 10*x - 20 
 int function(int x) 
 { 
 	return (x*x - 10*x - 20);
 } 
 
 int findFirstPositive() 
 { 
 	if (function(0) > 0) 
 		return 0; 
 
 	int i = 1; 
 	while (function(i) <= 0) 
 		i = i*2; 
 
 	return binarySearch(i/2, i); 
 } 
 
 int binarySearch(int low, int high) 
 { 
 	if (high >= low) 
 	{ 
 		int mid = low + (high - low)/2;
 
 		if (function(mid) > 0 && (mid == low || function(mid-1) <= 0)) 
 			return mid; 
 
 		if (function(mid) <= 0) 
 			return binarySearch((mid + 1), high); 
 		else 
 			return binarySearch(low, (mid -1)); 
 	} 
 	return -1; 
 } 
 /* Driver code */
 int main() 
 { 
 	cout<<""The value n where function() becomes positive first is ""<< findFirstPositive(); 
 	return 0; 
 } 
 /*
 SAMPLE OUTPUT:
 
 Input : x^2 - 10*x - 20
 Output : The value n where function() becomes positive first is 12
 
 Time Conplexity:O(log n)
 Space Complexity:O(1)
 */
 
",C-Plus-Plus
"/*
 You are given two lists of closed 
 intervals,firstList and secondList,
 where firstList[i] = [starti, endi]
 and secondList[j] = [startj, endj].
 Each list of intervals is pairwise
 disjoint and in sorted order.Return
 the intersection of these two inte-
 -rval lists.The intersection of two
 closed intervals is a set of real
 numbers that are either empty or 
 represented as a closed interval.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 vector<int> IntervalList(int I1, int J1, int I2, int J2)
 {
     vector<int> U;
     if (J2 == I1) {
         U.push_back(J2);
         U.push_back(J2);
         return U;
     }
     if ((I2 < I1) && (J2 > I1) && (J2 < J1)) {
         U.push_back(I1);
         U.push_back(J2);
         return U;
     }
     if ((I2 >= I1) && (J2 <= J1)) {
         U.push_back(I2);
         U.push_back(J2);
         return U;
     }
     if ((I2 > I1) && (J2 >= J1) && (I2 < J1)) {
         U.push_back(I2);
         U.push_back(J1);
         return U;
     }
     if ((I1 >= I2) && (J1 <= J2)) {
         U.push_back(I1);
         U.push_back(J1);
         return U;
     }
     if (J1 == I2) {
         U.push_back(J1);
         U.push_back(J1);
         return U;
     }
     return U;
 }
 vector<vector<int> > intervalIntersection(
     vector<vector<int> >& firstList,
     vector<vector<int> >& secondList)
 {
     int X, Y, i, j, I1, J1, I2, J2;
     X = firstList.size();
     Y = secondList.size();
     vector<vector<int> > Ans;
     if ((X == 0) || (Y == 0))
         return Ans;
     I1 = firstList[0][0];
     J1 = firstList[0][1];
     I2 = secondList[0][0];
     J2 = secondList[0][1];
     i = 0;
     j = 0;
     while ((i < X) && (j < Y)) {
         vector<int> U = IntervalList(I1, J1, I2, J2);
         if (U.size() != 0) {
             Ans.push_back(U);
         }
         if (J1 < J2) {
             ++i;
             if (i < X) {
                 I1 = firstList[i][0];
                 J1 = firstList[i][1];
             }
         ",C-Plus-Plus
"/*
 INVERSE OF AN ARRAY   
 If the array elements are swapped with their corresponding indices,
 the array finally results is inverse of an array. 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void inverse(int a[], int n, int b[])
 {
     for (int i = 0; i < n; i++)
     {
         int temp = a[i];
         b[temp] = i;
     }
     for (int i = 0; i < n; i++)
         cout << b[i] << "" "";
 }
 
 int main()
 {
     // Driver code begins
     int t, n;
     cin >> t;
     while (t--)
     {
         cin >> n;
         int ori[n];
         int inv[n];
 
         for (int i = 0; i < n; i++)
             cin >> ori[i];
 
         inverse(ori, n, inv);
     }
     return 0;
 }
 
 /*
 time complexity -: O(n) 
 Sample input:
 2
 5
 4 0 2 3 1
 3
 0 1 2
 Sample Output
 1 4 2 3 0
 0 1 2
 */
 
",C-Plus-Plus
"//Stack implemetation Its readme file in wiki
 import java.util.*;
 import java.lang.*;
 class mystack<E>
 {
     static class Node<E> {
         E data;
         Node<E> next;
         Node(E data) {
             this.data = data;
             next = null;
         }
     }
     Node<E> head;
     Node<E> top;
     int c=0;
     boolean isempty(){ return head==null;}
     void push(E a){
         Node<E> temp=new Node<E>(a);
         Node<E> temp1=head;
         if(isempty()){
             head=temp;
             top=head;
             c++;
             return;
         }
         else{
             while(temp1.next!=null){
                 temp1=temp1.next;
             }
             temp1.next=temp;
             c++;
             top=temp;
         }
     }
     E peek(){
         if(isempty())
             return null;
         return top.data;
     }
     E pop() throws Exception{
         if(isempty()){
             throw  new Exception(""eeempty"");
         }
         else if(head==top){
             Node<E> temp1=head;
             head=top=null;
             return temp1.data;
         }
         else{
             Node<E> temp1=head;
             Node<E> temp;
             while(temp1.next.next!=null){
                 temp1=temp1.next;
             }
             temp=temp1.next;
             temp1.next=null;
             top=temp1;
             c--;
             return temp.data;
         }
     }
 }
 
 public class Stackll {
     public static void main(String[] args) throws Exception {
         mystack<Integer> s = new mystack<Integer>();
         s.push(1);
         s.push(2);
         s.push(3);
         System.out.println(s.peek());
         System.out.println(s.pop());
         System.out.println(s.pop());
         System.out.println(s.pop());
         System.out.println(s.peek());
         System.out.println(s.pop());
     }
 }
 /*
 output:
 3
 3
 2
 1
 null
 Exception in thread ""main"" java.lang.Exception: eeempty
 	at mystack.pop(Stackll.java:43)",Java
"#include <stdio.h>
 #include <stdlib.h>
 
 int main(){
     int n;
     printf(""Enter the value of n: "");
     scanf(""%d\n"",&n);
     printf(""Enter the array:\n"");
     int *arr = (int*)malloc(n * sizeof(int));
     for (int i = 1; i <= n; ++i)
     {
         scanf(""%d"", &arr[i]);
     }
     if (arr == NULL) { 
         printf(""Memory not allocated.\n""); 
         return 0;
     } 
     else {
         for (int i = 1; i <= n; i++) {
             if (arr[i] <= 0 || arr[i] > n) 
                 continue; 
 
             int x = arr[i]; 
             while (arr[x] != x) { 
                 int next_ele = arr[x]; 
                 arr[x] = x; 
                 x = next_ele;
                 if (x <= 0 || x > n) 
                     break; 
             } 
         }
         int ans = n + 1;
         for (int i = 1; i <= n; i++) { 
             if (arr[i] != i) { 
                 ans = i;
                 break;
             } 
         }
         printf(""%d"", ans);
     } 
     
     return 0;
 }
 
 /*
 Time Complexity: O(N)
 Space Complexity: O(1)
 OUTPUT
 Enter the value of n: 4
 Enter the array:
 3 4 -1 1
 2
 */
",C
"/*Problem Statement:
 You are given a graph with N vertices and M edges.
 Master parent is the vertex which has no parent but may have 0 or more children. 
 In any connected component of the graph, 
 vertex with the lowest value in that component serves as the master parent.
 Count the total no of vertices which have more children than its parent. 
 The graph has no cycles or self loops. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class graph
 {
     public:
         int V;
     list<int> *adjList;
     list<int> *realList;
 
     graph(int V)
     {
         this->V = V;
         adjList = new list < int>[V];
         realList = new list < int>[V];
     }
 
     void addEdge(int u, int v)
     {
         adjList[u].push_back(v);
     }
 
     void Make_edges()
     {
         set<int> s;
         for (int i = 0; i < V; i++)
         {
             s.insert(i);
         }
 
         while (s.empty() == false)
         {
             bool visited[V];
             for (int i = 0; i < V; i++)
             {
                 visited[i] = false;
             }
 
             set<int>::iterator it = s.begin();
 
             queue<int> q;
             q.push(*it);
             while (q.empty() == false)
             {
                 int x = q.front();
                 q.pop();
                 visited[x] = true;
                 s.erase(x);
                 int size = adjList[x].size();
                 for (int i = 0; i < size; i++)
                 {
                     int k = adjList[x].front();
                     adjList[x].pop_front();
                     if (visited[k] == false)
                     {
                         q.push(k);
                         realList[x].push_back(k);
                     }
                 }
             }
         }
     }
 
     int total_vertices()
     {
         int child[V];
         for (int i = 0; i < V; i++)
         {
             child[i] = 0;
         }
 
         int cnt = 0;
         for (int i = ",C-Plus-Plus
"'''
 Problem: Check if two BSTs are identical or not.
 BST or Binary Search Tree is a tree data structure that has following properties:
 1. left node is smaller than its root node
 2. right node is greater than its root node
 3. both left and right subtrees are also BSTs.
 
 To check whether two BSTs are identical or not, we follow a recursive approach
 where we check whether the value of current node is equal or not.
 If it is, we then check whether the left and right substrees
 are identical or not using recursion.
 If all the three conditions are true, BSTs are identical
 Otherwise they are not
 '''
 
 
 # Class that defines a node of BST
 class BSTNode:
     def __init__(self, data):
         self.val = data
         self.left = None
         self.right = None
 
 
 def check_identical(bst1, bst2):
     # if bst2 is None & bst1 is not, they are not identical
     if bst1 and not bst2:
         return False
 
     # if bst1 is None & bst2 is not, they are not identical
     if bst2 and not bst1:
         return False
 
     # if both bst1 & bst2 are None
     if not bst1 and not bst2:
         return True
 
     # if both bst1 & bst2 are not empty/None, check if they are identical
     while bst1 and bst2:
         # check if current node values are same
         # check if left and right subtrees are also identical
         if bst1.val == bst2.val and check_identical(bst1.left, bst2.left) and check_identical(bst1.right, bst2.right):
             return True
         else:
             return False
 
 
 def insert_node(root, value):
     # If root is empty, create a new node
     if root is None:
         return BSTNode(value)
 
     # if the value already exists, return the root
     if root.val == value:
         return root
 
     # insert the value in left subtree if it is less than the root value
     if value < root.val:
         root.left = insert_node(root.left, value)
 
     # insert the value in right subtree if it is greater than the root value
     el",Python
"//C code to implement maximum sum rectangle in a 2D matrix 
 
 #include <stdio.h>
 #include<stdbool.h>
 #include<string.h>
 #include <limits.h>
 
 int main() {
     
   // R & C are the number of rows and columns 
   int R, C; 
   printf(""Input-->\n"");
   printf(""Enter the row-sze: \n"");
   scanf(""%d"", & R);
   printf(""Enter the column-sze: \n"");
   scanf(""%d"", & C);
   int matrix[R][C], temp[R], top, bottom;
   printf(""Enter the elements of 2-D matrix :\n"");
   for (int ol = 0; ol < R; ol++) {
     for (int inloop= 0; inloop < C; inloop++) {
       scanf(""%d"", & matrix[ol][inloop]);
     }
   }
   int maxSum = INT_MIN, finalTop, finalBottom, finalRight, finalLeft;
 
   for (int Left= 0; Left < C; Left++) {
     // Initialize the all elements of temp as 0
     memset(temp, 0, sizeof(temp));
     for (int Right = Left; Right < C; Right++) {
       for (int i = 0; i < R; i++) temp[i] += matrix[i][Right];
       int max = INT_MIN, S = 0, localTop = 0, sum;
       bool flag = false;
       for (int index = 0; index < R; index++) {
         if (temp[index] >= 0) flag = true;
         S = S + temp[index];
         if (S < 0) {
           S = 0;
           localTop = index+ 1;
         } else if (S > max) {
           max = S;
           top = localTop;
           bottom = index;
         }
       }
       if (flag) {
         sum = max;
       } else {
         max = INT_MIN;
         //To find the maximum element in array  
         for (int index = 0; index < R; index++) {
           if (max < temp[index]) {
             max = temp[index];
             top = bottom = index;
           }
         }
         sum = max;;
       }
       // Comparison of  sum with maximum sum 
       if (sum > maxSum) {
         maxSum = sum;
         finalTop = top;
         finalBottom = bottom;
         finalLeft = Left;
         finalRight = Right;
       }
     }
   }
   printf(""\nOutput-->\n"");
   printf(""Maximum sumRectangle is : %d\n"", maxSum);
 
   return 0;
 }
 
 /*
  Input-->
  E",C
"""""""
 A number is said to be a Harshad Number if it is divisible by the sum of its digits.
 For example: The number 84 is divisible by the sum (12) of its digits (8, 4).
 
 """"""
 
 
 def isHarshad(number) :
     copy = number
 
     # Calculating the sum of digits of the number
     sum_of_digits = 0
     while number != 0 :
         digit = number % 10
         sum_of_digits += digit
         number = number // 10
 
     # Checking if Number is divisible by sum of digits
     if copy % sum_of_digits == 0 :
         return True
     return False
 
 
 user_input = int(input(""Enter a number:""))
 
 if isHarshad(user_input):
     print(user_input, ""is a Harshad number"")
 else:
     print(user_input, ""is not a Harshad number"")
 
 """"""
 Space Complexity O(1)
 Time Complexity  O(log(n))
 
 Sample input/output:
 Enter a number:84
 84 is a Harshad number
 
 Enter a number:123
 123 is not a Harshad number
 
 """"""
",Python
"/*
 Given total number of nodes in an undirected graph
 numbered from 1 to n [ number of nodes] and total number of edges in the graph.
 Find  minimum distance of each node using SSSP (Single Source Shortest Path) on trees
 by DFS.
 */
 
 #include <stdio.h>
 
 int adj[10009][1009];
 int visited[10009];
 int distance_array[10009];
 
 // this function will print the minimum distance
 void print_minimum_distance_of_each_nodes(int nodes)
 {
     for(int i = 1; i <= nodes; i++)
     {
         printf(""%d "", distance_array[i]);
     }
     printf(""\n"");
 }
 
 // this get_number_of_divisors will count the number of divisors of the number
 void dfs(int node, int dist, int nodes)
 {
     /* for each node we will put  visited[node] = 1
     means that node is visited
     and put distance_array[node] = dist means current distance.
     and then recursively will visit the
     adjacency matrix
      */
     visited[node] = 1;
     distance_array[node] = dist;
     for(int i = 1; i <= nodes; i++)
     {
         if(adj[node][i] != 0 && visited[i] == 0)
         {
             dfs(i , distance_array[node] + 1, nodes);
         }
     }
 
 }
 
 int main()
 {
     printf( ""Enter the nodes of the graph :\n"");
     int nodes;
     scanf(""%d"",&nodes);
     printf( ""Enter the adjacency matrix :\n"");
     for(int i = 1; i <= nodes; i++)
     {
         for(int j = 1; j <= nodes; j++)
         {
             scanf(""%d"", &adj[i][j]);
         }
     }
 
     /* here dfs call(1, 0)
     from 1th node distance is 0
     */
     dfs(1, 0, nodes);
     printf( ""Minimum Distance of Each Nodes: \n"");
     print_minimum_distance_of_each_nodes(nodes);
 
 }
 
 /*
 Standard Input and Output
 
 Enter the nodes of the graph :
 8
 Enter the adjacency matrix :
 0 1 1 0 1 0 1 1
 0 1 1 0 1 0 1 1
 1 1 1 0 0 1 0 1
 0 0 0 1 1 0 1 1
 0 1 1 0 0 1 1 1
 1 1 0 0 1 1 1 1
 1 0 1 0 0 1 1 0
 1 0 1 0 1 0 1 0
 
 Minimum Distance of Each Nodes:
 0 1 2 0 4 3 5 5
 
 Time Complexity :  O(N*N) N = nodes
 
 Space Complexit",C
"def longest_substring_length(string):
     """"""Returns length of the longest substring without repetition of characters """"""
     dct = {}
     result = 0
     start = 0
     counter = 0
     for index, val in enumerate(string):
         if val not in dct:
             dct[val] = index
             counter += 1
         else:
             if dct[val] >= start:
                 start = dct[val] + 1
                 counter = index - dct[val] -1
             counter += 1
             dct[val] = index
         result = max(result, counter)
     return result
 
 test_case = int(input('No. of test cases:'))
 while test_case:
     print(longest_substring_length(input()))
     test_case -= 1
     
 """"""
 Input format:
 3                       #No. of Test cases
 abccddabc
 bb
 pwwkew
 
 Approach:
 di -> dictionary is used to keep track of duplicates.
 counter-> to keep count of distinct chars since last occurence of duplicate character.
 start-> start pointer from where counter starts.
 If the character has its duplicate in the dictionary, we check its last occurence,
 if its greater than start, then the counter becomes currentIndex - lastOccurence. Start becomes lastOccurence + 1
         
 Complexity: Time: O(n) n-> length of string
             Space: O(n)
 contributed by @pradeep98
 """"""
",Python
"/*
  * Definition of a  singly-linked list.
  * struct ListNode {
  *     int val;
  *     struct ListNode *next;
  * };
  */
 
 // Below is the function to delete node
 
 #include <stdio.h>
 #include <stdlib.h>
 
 struct node
 {
     int data;
     struct node *next;
 };
 
 struct node *newNode(int data)
 {
     struct node *n = (struct node *)malloc(sizeof(struct node *));
     n->data = data;
     n->next = NULL;
     return n;
 }
 
 void deleteNode(struct node *ref)
 {
     while (ref->next != NULL)
     {
         ref->data = ref->next->data; //NODE TO BE DELETE POINTER GIVEN
         ref = ref->next;
     }
     free(ref);
 }
 
 void main()
 {
     struct node *n = newNode(1);
     n->next = newNode(2);
     n->next->next = newNode(3);
     n->next->next->next = newNode(4);
     n->next->next->next->next = newNode(5);
     n->next->next->next->next->next = newNode(6);
 
     deleteNode(n->next->next->next); // deletion node is  4
 
     while (n->next != NULL)
     {
         printf(""%d\n"", n->data);
         n = n->next;
     }
 }
 
 /* OUTPUT
 1 2 3 4 5 NULL
 1 2 3 5 NULL
 Time Complexity: O(1)
 Space complexity: O(n)
 */
",C
"''' How to determine if a number is a Magic number.
     We calculate the sum of digits of the number till
     we get a single digit, recursively. If the single
     digit comes out to be 1, then we say that the number
     is a magic number. '''
 
 # This function checks if a number is a magic number.
 def is_Magic_number(number):
     
     sum_digits = 0
     ''' We loop till the number is greater than 0 or we
     get a single digit sum of the digits of the number.'''
     while(number > 0 or sum_digits > 9):
 
         # This is the iterating step.
         if(number == 0):
             ''' We replace the number by the sum of its
             digits. And set the sum to zero.'''
             number = sum_digits
             sum_digits = 0
 
         else:
             # We find the sum of the digits of number
             sum_digits += number % 10
             number = number // 10
 
     ''' After we get a single digit sum, we check if
     it 1, then it is a magic number and we return True.'''
     if(sum_digits == 1):
         return True
 
     # Else we return False
     else:
         return False
 
 ''' Below two function print the steps if the number
     indeed is a magic number.'''
 def sum_return(number):
     sum_number = 0
     # The output is stored in a string
     s = """"
     while(number):
         s += str(number % 10) + "" + ""
         sum_number += number % 10
         number = number // 10
 
     ''' After every iteration, we print the number
         and return the sum of the digits.'''
     print((s[:len(s) - 3])[::-1], ""="", sum_number)
     return sum_number
 
 def print_steps(number):
     sum_digits = 0
     while(number != 1):
         # Call the above function till number becomes 1
         number = sum_return(number)
 
 # Drivers function
 if __name__=='__main__':
 
     # Take input from the user
     number = int(input(""Enter a number to check if it's a magic number: ""))
 
     # Call the magic number function
     if(is_Magic_numb",Python
"import java.util.Scanner;
 
 public class MaximumSquareMatrix {
 
     public static void main(String[] args) {
 
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter number of rows and columns:"");
         int r = scanner.nextInt();
         int c = scanner.nextInt();
         int[][] matrix = new int[r][c];
         System.out.println(""Enter elements of the matrix:"");
         for (int i = 0; i < r; i++) {
             for (int j = 0; j < c; j++) {
                 matrix[i][j] = scanner.nextInt();
             }
         }
 
         printMaxSquare(matrix);
     }
 
     private static void printMaxSquare(int[][] matrix) {
 
         int rows = matrix.length, cols = matrix[0].length, i, j, maxSquare, max_i, max_j;
         int[][] squareSizes = new int[rows][cols];
 
         // Set first column of squareSizes[][]
         for(i = 0; i < rows; i++) {
             squareSizes[i][0] = matrix[i][0];
         }
 
         // Set first row of squareSizes[][]
         for(j = 0; j < cols; j++) {
             squareSizes[0][j] = matrix[0][j];
         }
 
         // getting other entries for squareSizes
         for (i = 1; i < rows; i++) {
             for (j = 1; j < cols; j++) {
                 if(matrix[i][j] == 1) {
                     squareSizes[i][j] = Math.min(squareSizes[i][j - 1],
                             Math.min(squareSizes[i - 1][j], squareSizes[i - 1][j - 1])) + 1;
                 } else {
                     squareSizes[i][j] = 0;
                 }
             }
         }
 
         // find max entry of squareSizes
         maxSquare = squareSizes[0][0]; max_i = 0; max_j = 0;
         for(i = 0; i < rows; i++)
         {
             for(j = 0; j < cols; j++)
             {
                 if(maxSquare < squareSizes[i][j])
                 {
                     maxSquare = squareSizes[i][j];
                     max_i = i;
                     max_j = j;
                 }
             }
         }
 
       ",Java
"/* 
 Given a binary array i.e consisting of only 0's and 1's and an integer k.
 We need to return the maximum number of consecutive 1's in the array if we can flip at most k 0's.
 
 Approach : Need to handle 3 cases for every element in the array
 
 Case 1: value is 1, increment count
 Case 2: value is 0 and K is non zero, decrement K and increment count
 Case 3: value is 0 and K is also zero, need to acquire this zero and 
         release the first zero from left to right, achieved using min heap
 
 Maintain a max_count at each step.
 */
 
 #include <iostream>
 #include <vector>
 #include <queue>
 using namespace std;
 
 int MaxConsecutiveOnes(int arr[], int n, int k)
 {
     int curr_count = 0;
     int max_count = 0;
     int originalK = k;
     priority_queue<int, vector<int>, greater<int>> pq;
     for (int i = 0; i < n; i++)
     {
         if (arr[i] == 1)
         { //case 1
             curr_count++;
         }
         /* Handles the test case when we are not allowed to flip 0, 
             set current count=0 as this point act as the breaking point of consecutive sequence  */
         else if (arr[i] == 0 && originalK == 0)
         {
             curr_count = 0;
         }
         else if (arr[i] == 0 && originalK > 0)
         {
             /* Till we are allowed to flip 0's add them in current count and decrease k .
                 A min heap is maintained containing indices of all k zeroes so that we can pop
                 the zero with minimum index whenever k reduces to 0. (case 2) */
             if (k != 0)
             {
                 k--;
                 curr_count++;
                 pq.push(i);
             }
             /* This is case 3 , need to acquire this zero to continue the sequence. Pop the index of zero 
                 that appeared first in the array from left to right and push the current index in the 
                 priority queue. */
             else
             {
                 int v = pq.top();
             ",C-Plus-Plus
"/* Find the maximum product subarray of a given array */
 
 #include<stdio.h>
 /* Function for finding minimum of two numbers */
 int min(int p, int q)
 {
     if (p < q)
         return p;
     else
         return q;
 }
 
 /* Function for finding maximum of two numbers */
 int max(int p, int q)
 {
     if (p > q)
         return p;
     else
         return q;
 }
 
 /* Function for finding maximum product subarray */
 int solve()
 {
     /* Input size of an array */
     int n;
     scanf(""%d"", &n);
 
     /* Declear an array*/
     int a[n];
 
     /* Input values in an array */
     for (int i = 0; i < n; i++)
     {
         scanf(""%d"" , &a[i]);
     }
 
     int maxend = 0, minend = 0;
     int maxupto = 0;
 
     /* traverse the given array */
     for (int i = 0; i < n; i++)
     {
         int temp = maxend;
         /* Update the maximum product */
         maxend = max(a[i], max(a[i] * maxend, a[i] * minend));
 
         /* Update the minimum product */
         minend = min(a[i], min(a[i] * temp, a[i] * minend));
         maxupto = max(maxupto, maxend);
     }
 
     /* Return the maximum product */
     return maxupto;
 }
 
 int main()
 {
     int k = solve();
 
     printf(""The maximum product of a subarray is %d"", k);
     return 0;
 }
 
 /*
 Test cases :
 
     Input 1 :
 
         8
         -4 9 -7 0 -15 6 2 -3
 
     Output 1 :
 
         The maximum product of a subarray is 540
 
     Input 2 :
 
         5
         6 -3 -10 0 2
 
     Output 2 :
 
         The maximum product of a subarray is 180
 
     Time complexity: O(n)
     Space Complexity: O(1)
 */
",C
"/**
 Given an array of integers,
 find the largest continuous subarray 
 with sum zero
 **/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 vector<int> lszero(vector<int> &A) {
     int start = -1, end = -1, m = 0, l = 0;
     unordered_map<int, int> umap;
     int sum = 0, n = A.size();
     for(int i=0; i<n; i++) {
         sum += A[i];
         if(sum == 0) {
             start = 0;
             end = i;
             m = i+1;
         } else {
             if(umap.find(sum) != umap.end()) {
                 l = i-umap[sum];
                 if(l > m) {
                     m = l;
                     start = umap[sum]+1;
                     end = i;
                 } 
             } else 
                 umap[sum] = i;
         }
     }
     
     if(start == -1)
         return vector<int> (0);
     
     vector<int> res(m);
     for(int i=start; i<=end; i++)
         res[i-start] = A[i];
     return res;
 }
 
 int main() {
     int n;
     cin >> n;
     vector<int> arr(n);
     for(int i = 0; i < n; i++)
         cin >> arr[i];
     vector<int> ans = lszero(arr);
     cout << ""The longest subarray with sum zer is : \n"";
     for(int i = 0; i < ans.size(); i++)
         cout << ans[i] << ' ';
     cout << '\n';
     return 0;
 }
 
 /**
 
 Input :
 5
 1 2 -2 4 -4
 Output:
 The longest subarray with sum zer is : 
 2 -2 4 -4 
 
 Time Complexity : O(n)
 Space Complexity : O(n)
 
 **/",C-Plus-Plus
"/*
 Inplace rotation of matrix by 90 degrees.
 
 For a given matrix your task is to rotate it by 90 degrees
 in anti clockwise direction and return the matrix thus formed.
 It is given that the rotation should be performed 
 without using any extra space.
 */
 
 #include <bits/stdc++.h> 
 
 using namespace std;
 
 //for solving this problem we rotate the array in form of outer
 //squares making a boundary i.e first row, last column
 //last row and first column as 1 square and remaing inside elements considered similarly 
 
 //function to find the rotated matrix inplace
 void rotateBy90Deg(int matrix[][order])
 {
     //we consider the squares one by one
     for(int squarCount = 0; squarCount < order / 2; squarCount++)
     {
         //we consider the elements in a sets of 4 elements one by one
         for(int i = squarCount; i < order - squarCount - 1; i++)
         {
             //swapping for rotation
             int tempmat = matrix[squarCount][i];
             //rotating
             matrix[squarCount][i] = matrix[i][order - squarCount - 1];
             matrix[i][order - squarCount - 1] = matrix[order - squarCount - 1][order - i - 1];
             matrix[order - squarCount - 1][order - i - 1] = matrix[order - i - 1][squarCount];
             matrix[order - i - 1][squarCount] = tempmat;
         }
     }
 }
 
 ///function for printing the matrix 
 void printMatrix(int matrix[][order])
 {
     for(int pass1 = 0; pass1 < order; pass1++)
     {
         for(int pass2 = 0; pass2 < order; pass2++)
         {
             //printing
             cout << matrix[pass1][pass2] << "" "";
         }
         cout << endl;
     }
 }
 
 //driver code
 int main()
 {
     //taking input
     int order;
     cout << ""Enter the order of matrix: "";
     cin >> order;
     int matrix[order][order];
     cout << ""Enter the elements of matrix: "";
     for( int i = 0; i < order; i++)
     {
         for( int j = 0; j < order; j++)
         {
             cin >> matrix[i][j];
     ",C-Plus-Plus
"/*
 Given a binary string s and an
 integer k.
 Print True if every binary code
 of length k is a substring of s.
 Otherwise, Print False.
 
 Constraints:
 1 <= s.length <= 5 * 10^5
 s consists of 0's and 1's only.
 1 <= k <= 20
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /*
 This Function will check all string 
 of length k present in given string 
 s or not.
 */
 
 bool hasAllCodes(string s, int k) 
 {
     int length,totalBinaryString,Z,i;
     length=s.length();
     totalBinaryString=pow(2,k);
     int A[2022600]={0};
     Z=0;
     for(i=0;i<k;i++)
     {
         if(i!=0  &&  Z!=0)
             Z=(Z<<1);
         if(s[i]=='1')
             Z++;
     }
     A[Z]=1;
     for(i=k;i<length;i++)
     {
         if(Z>=(pow(2,k-1)))
             Z-=(pow(2,k-1));
         if(Z!=0)
             Z=(Z<<1);
         if(s[i]=='1')
             Z++;
         A[Z]=1;
     }
     for(i=0;i<totalBinaryString;i++)
     {
         if(A[i]==0)
             return false;
     }
     return true;
 }
 
 int main()
 {
     string S;
     int K;
     cout<<""Enter an String""<<endl;
     cin>>S;
     cout<<""Enter the integer""<<endl;
     cin>>K;
     bool Ans=hasAllCodes(S,K);
     if(Ans==true)
         cout<<""Yes""<<endl;
     else
         cout<<""No""<<endl;
     return 0;
 }
 
 /*
 Time Complexity=O(N)
 Space Complexity=O(2^K)
 where N is the length of the given 
 string and K is the given integer.
 
 Sample Input Output
 Input:
 Enter an String
 00110
 Enter the integer
 2
 Output:
 Yes
 */
 
",C-Plus-Plus
"/** 
 -> Radix sort is based on counting sort
 -> The following program sorts negative as well as 
 positive integers.
 -> Assuming the range is fixed, as ll capacity
 is limited in any language, this sort takes
 -> MAX_INT contains 10 decimal values
 -> If range is not fixed, this sort takes O(kn) time
 where k is #decimal places in the number
 This works because of the nature of counting sort
 -> Counting sort is a stable sort
 **/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 #define ll long long
 #define K 10
 #define M 10
 #define DIF 2147483648
 
 /* The idea behind sorting negative numbers too is below
 -> A signed 32 bit integer goes from -2,147,483,648 to 2,147,483,647
 and an unsigned integer from 0 to 4,294,967,295.
 -> So you could just add 2,147,483,648 to the signed number to 
 convert it to an unsigned one for sorting
 then subtract to get back to signed numbers when you have finished sorting*/
 
 void counting_sort(ll arr[], ll  n, ll p) {
     ll element = pow(10, p);
     ll divs = element / 10;
     ll count[M];
     for(ll i = 0; i < M; i++)
         count[i] = 0;
     for(ll i = 0; i < n; i++)
         count[(arr[i] % element) / divs] ++;
     for(ll i = 1; i < M; i++)
         count[i] += count[i-1];
     ll op[n];
     for(ll i = n-1; i >= 0; i--) {
         op[count[(arr[i] % element) / divs] - 1] = arr[i];
         count[(arr[i] % element) / divs] --;
     }
     // copying the array back
     for(ll i = 0; i < n; i++)
         arr[i] = op[i];
 }
 
 void radix_sort(ll arr[], ll n) {
     // apply counting sort for all decimal places
     for(ll i = 1; i <= K; i++)
         counting_sort(arr, n, i);
 }
 
 int main() {    
     ll n;
     cin >> n;
     ll arr[n];
     // Taking input
     for(ll i = 0; i < n; i++) {
         cin >> arr[i];
         // Adding DIF to make negative numbers positive
         arr[i]+=DIF;
     }
     // perform the sort
     radix_sort(arr, n);
 
     // Outputting the sorted array
     for(ll i = 0; i < n;",C-Plus-Plus
"/*
 -First Come First Serve (FCFS) is an operating system scheduling algorithm that automatically 
 executes queued requests and processes in order of their arrival. 
 -It is the easiest and simplest CPU scheduling algorithm. 
 -In this type of algorithm, processes which requests the CPU first get the CPU allocation first.
 -This is managed with a FIFO queue.
 */
 
 import java.util.Scanner;
 
 class fcfs          
 {
     int arrival_time;
     int finish_time=0;
     int burst_time;
     int turnaround_time;
     int id;
     int waiting_time;
   
     public fcfs(int at,int bt,int Id)			
     {
         arrival_time=at;
         finish_time=0;
         burst_time=bt;
         id=Id;
     }
 }
 
 class first_come_first_serve
 {
     fcfs f[]=new fcfs[20];				//Array of objects
   
     Scanner sc=new Scanner(System.in);
     int arrival_time,burst_time,num;
     int id;
  
     public void accept()				//Accepting the details of processes
     {
     
         System.out.println(""Enter the number of processes: "");
         num=sc.nextInt();
             for(int i=0;i<num;i++)
             {
                  System.out.println(""Enter process id(Integer): "");
                 id=sc.nextInt();
               
                 System.out.println(""Enter arrival time: "");
                 arrival_time=sc.nextInt();
               
                 System.out.println(""Enter burst time: "");
                 burst_time=sc.nextInt();
               
                 f[i]=new fcfs(arrival_time,burst_time,id);
             }
         }
     
         public void calc() 		
         {
             f[0].finish_time=f[0].burst_time;
           
             System.out.println(f[0].finish_time);
           
             for(int i=1;i<num;i++)           //Finish time calculation
             {
                 f[i].finish_time=f[i].burst_time+f[i-1].finish_time;
             }
 
         for(int i=0;i<num;i++)				//Turnaround time calculation
         {
             f[i].turnaround",Java
"/*
   Segmented sieve is used to print prime number in a given range(l,r).
 */
 
 import java.util.ArrayList;
 import java.util.Scanner;
 
 public class Segmented_Sieve {
 
 	public static int MAX=1000000;
 	public static boolean prime[]=new boolean[MAX+1];
 	
 //	Basic sieve returning a list of primes number less than or equal to MAX
 	public static ArrayList<Integer> sieve() {
 		
 //		Marking all number as true initailly
 		for(int i=0;i<=MAX;i++) {
 			prime[i]=true;
 		}
 		
 //	0 and 1 are not prime , so marking them as false		
 		prime[0]=prime[1]=false;
 		
 		for(int i=2;i*i<=MAX;i++) {
 //			If the given number is prime
 			if(prime[i]==true) {
 //				Marking all its multiple as false
 				for(int j=i*i;j<=MAX;j+=i) {
 					prime[j]=false;
 				}
 			}
 		}
 		
 		ArrayList<Integer> primeList=new ArrayList<Integer>();
 		
 		for(int i=0;i<=MAX;i++){
 			if(prime[i]==true) {
 				primeList.add(i);
 			}
 		}
 		
 		return primeList;
 	}
 	
 //	Printing prime number in the given range l to r
 	public static void printPrimeInRange(long l,long r,ArrayList<Integer> primeList) {
 		
 		boolean array[]=new boolean[(int)(r-l+1)];
 		
 		for(int i=0;i<=(r-l);i++) {
 			array[i]=true;
 		}
 		
 		for(int i=0;i<primeList.size()&&(long)primeList.get(i)*primeList.get(i)<=r;i++) {
 			
 			int currentPrime=primeList.get(i);
 			
 //			Finding nearest number greater than or equal to l  which is divisible by currentPrimeNumber
 			int baseValue=(int)(l/currentPrime)*currentPrime;
 			
 			if(baseValue<l) {
 				baseValue+=currentPrime;
 			}
 			
 			for(int j=baseValue;j<=r;j+=currentPrime) {
 				array[(int)(j-l)]=false;
 			}
 			if(baseValue==currentPrime) {
 				array[(int)(baseValue-l)]=true;
 			}
 		}
 		
 		for(int i=0;i<=(r-l);i++) {
 			if(array[i]==true) {
 				System.out.print((i+l)+"" "");
 			}
 		}
 	}
 	
 	public static void main(String[] args) {
 		
 		Scanner sc=new Scanner(System.in);
 		
 		System.out.println(""Enter lower limit : "");
 		long l=sc.nextLo",Java
"//Given a collection of intervals, merge all overlapping intervals.
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Scanner;
 
 public class MergeOverlappingArray {
 
 	public static int[][] merge(int[][] intervals) {
 		List<int[]> list = new ArrayList<>();
 
 		if (intervals.length == 0 || intervals == null)
 			list.toArray(new int[0][]);
 
 		Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
 		int begin = intervals[0][0];
 		int end = intervals[0][1];
 		for (int [] j : intervals) {
 			if (j[0] <= end) {
 				end = Math.max(end, j[1]);
 			} else {
 				list.add(new int[] {begin, end});
 				begin = j[0];
 				end = j[1];
 			}
 		}
 		list.add(new int[] {begin, end});
 		intervals = list.toArray(new int[0][]);
 		return intervals;
 
 	}
 
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 		System.out.println(""Enter the number of intervals: "");
 		int n = sc.nextInt();
 		System.out.println(""Enter intervals: "");
 		int[][] arr = new int[n][2];
 		for (int k = 0; k < arr.length; k++) {
 			for (int l = 0; l < arr[k].length; l++) {
 				arr[k][l] = sc.nextInt();
 			}
 		}
 		int[][] t = merge(arr);
 		for (int[] row : t) {
 			System.out.println(Arrays.toString(row));
 		}
 		sc.close();
 	}
 }
 
 /*
 
 Input and Output of Program
 
 Enter the number of intervals:
 2
 Enter intervals:
 1 8
 2 7
 [1, 8]
 
 Enter the number of intervals:
 4
 Enter intervals:
 1 3
 2 6
 8 10
 15 18
 [1, 6]
 [8, 10]
 [15, 18]
 
 Time Complexity: O(nlogn) + O(n)
 Space Complexity: O(n)
 
 */
",Java
"/*
 Given a string s, determine the minimum number of cuts required to make all substrings into palindrome.
 */
 #include <bits/stdc++.h> 
 using namespace std; 
 
 bool dp[1001][1001];
 
 int minCutToPalindrome_Opt(string s) {
         int n = s.length();
         // Computing dp (2D matrix) where [a,b] stores whether the sub-string 'a' to 'b' is a palindrome.
         bool dp[s.length()][s.length()];
         for (int mid = 0; mid < s.length(); mid++) {
             int si = 0, ei = mid;
             while (ei < s.length()) {
                 //If no letter is present in the gap then it is a palindrome
                 if (mid == 0) {
                     dp[si][ei] = true;
                 } 
                 //If one letter is present in middle then it is a palindrome if both the extreme letters are same
                 else if (mid == 1) {
                     dp[si][ei] = s[si] == s[ei];
                 } 
                 //If more than more letter in the middle then both the extreme letters must be same, and compare the middle string represented by dp[si + 1][ei - 1];
                 else {
                     if (s[si] == s[ei]) {
                         dp[si][ei] = dp[si + 1][ei - 1];
                     } else {
                         dp[si][ei] = false;
                     }
                 }
                 si++;
                 ei++;
             }
         }
 // Array to store minCuts for every suffix
         int cuts[n];
         for (int i = 0; i < n; i++) {
             if (dp[0][i] == true) {
                 cuts[i] = 0;
             } else {
                 cuts[i] = INT_MAX;
                 for (int j = 0; j < i; j++) {
                     if(dp[j + 1][i] == true && 1 + cuts[j] < cuts[i]){
                         cuts[i] = 1 + cuts[j];
                     }
                 }
             }
         }
         return cuts[n - 1];
     }
 
 int main() 
 { 
     memset(dp,-1,sizeof(dp));
     string s;
     cin>>s;
     cout<<m",C-Plus-Plus
"/**
  * Double Ended Queue is a linear data structure which follows both -
  * LIFO(Last In First Out) and FIFO(First In First Out).
  * 
  * Push Front  ---> O - O - O - O - O - O <---  Push Rear
  *                  |   |   |   |   |   |
  *   Pop Front <--- O - O - O - O - O - O ---> Pop Rear
  *              ^                   ^
  *            First                Last
  *           (Front)              (Rear)
  *            
  * The code has six methods:
  * void pushfront(int) - to insert a value at the front end of the queue
  * void pushrear(int) - to insert a value at the rear end of the queue
  * int popfront() - to delete a value from the front end of the queue
  * int poprear() - to delete a value from the rear end of the queue
  * void display() - to display the queue
  * void main() - driver code to execute all the methods
  * 
  * In addition to the methods, the code also has a default constructor DEQueue(int)
  * to initialize the global parameters:
  * integer array dequeue[] - to store the elements
  * integer variable elements - to keep a count of the number of elements in the queue
  * integer variable front - to point at the front end of the dequeue
  * integer variable rear - to point at the rear end of the dequeue
  * 
  * To take input from the user, Scanner class has been instantiated.
  * 
  */
 
 import java.util.*;
 
 public class DEQueue
 {
     Scanner scanner = new Scanner(System.in);
 
     int dequeue[], elements, front, rear;
 
     DEQueue(int size)
     {
         dequeue = new int[size];
         elements=0;
         front=-1;
         rear=-1;
     }
 
     void pushfront(int value)
     {
         if(elements==dequeue.length)
         { 
             System.out.println(""Overflow"");
         }
         else
         {
             if(front==0)
             {
                 System.out.println(""Front full"");
             }
             else
             {
                 elements++;
                 front--;
                 d",Java
"/*Queue is a data structure which works on FIFO principle i.e First In First Out. Element inserted first will also get deleted first.Insertion will always take place at front and Deletion from Rear. You can understand Queue with the example of a Queue at Ticket counter. The people keep on adding in Queue from End and Exist from Beginning. */
 #include<bits/stdc++.h>//Header file for all standard library
 using namespace std;
 struct Node //Structure of node of linked list
 {
  public:
     int info; 
     Node *next;
 } * ptr, *save, *rear, *front, *NEW;
 Node *CN(int y) // For creating node
 {
     ptr = new Node;
     ptr->info = y;
     ptr->next = NULL;
     return ptr;
 }
 void insert(Node *NEWPTR)// For inserting node
 {
     if (front == NULL)
     {
       front = rear = NEWPTR;                
   
     }
     else
     {
         rear->next = NEWPTR;  
         rear = NEWPTR;
     }
 }
 void Delete() //for deleting a node
 {
 
     if (front == NULL)
         cout << ""\nUnderflow!!"";
 
     else
     {
         ptr = front;
         front = front->next;
         delete ptr;
         cout << ""\nValue got deleted"";
     }
 }
 /*Time complexity:- O(n)
    Space Complexity:- O(n)*/
 void Display(Node *D) //for displaying the queue
 {
     if (D != NULL)
     {
         while (D != NULL)
         {
             cout << D->info << ""-->"";
             D = D->next;
         }
     }
     else
         cout << ""Empty!:("";
 }
 
 int main()
 {
     int a, x;
     char ch = 'y';
     do 
     {
         cout << ""\nWhat do u want to do with Queue\n1. Insert a node \n2. Delete a node \n3. Display\n Enter your choice:"";
         cin >> a;
         switch (a)
         {
 
         case 1:
         {
             cout << ""\nEnter the data of new node :"";
             cin >> x;
             NEW = CN(x);
             insert(NEW);
             cout << ""\nNew node with value "" << x << "" is inserted in Queue."";
         }
         break;
         case 2:
         {
             ",C-Plus-Plus
"/*
 Find the maximum product by multiplying any two elements of the 
 input Array. The array may contain negative numbers also.This program uses the most optimised approach to solve the problem.
 */
 
 #include<bits/stdc++.h>
 
 using namespace std;
 
 int main()
 {
     //Declaring variable that stores number of elements in the Array
     int n;
     //Taking the number of elements of Array as input
     cout<<""Enter the number of elements of Array""<<endl;
     cin>>n;
     if (n < 2)
     {
         cout << ""There are no pairs\n"";
         return 0;
     }
     //Declaring 1-D Array
     int A[1000];
     //Declaring iteration variables
     int i,j;
     //Taking elements of Array as input
     cout<<""Enter the elements of Array""<<endl;
     for(i=0;i<n;i++)
     {
         cin>>A[i];
     }
     if (n == 2)
     {
         cout << ""Max product pair is {"" << A[0] << "", ""<< A[1]<< ""}""<<"" and product is ""<<A[0]*A[1];
         return 0;      
     }
     // Iniitialize maximum and second maximum positive numbers to default min value
     int p_max1 = INT_MIN, p_max2 = INT_MIN; 
     // Iniitialize minimum and second minimum negative numbers to default min value
     int n_max1 = INT_MIN, n_max2 = INT_MIN;
     // Traverse given Array
     for (int i = 0; i < n; i++)
     {
         // Update maximum and second maximum if needed
         if (A[i] > p_max1)
         {
             p_max2 = p_max1;
             p_max1 = A[i];
         }
         else if (A[i] > p_max2)
             p_max2 = A[i]; 
         // Update minimum and second minimum if needed
         if (A[i] < 0 && abs(A[i]) > abs(n_max1))
         {
             n_max2 = n_max1;
             n_max1 = A[i];
         }
         else if(A[i] < 0 && abs(A[i]) > abs(n_max2))
             n_max2 = A[i];
     } 
     // Check whether negative numbers product is greater or positive numbers product
     if (n_max1*n_max2 > p_max1*p_max2)
         cout << ""Max product pair is {"" << n_max1 << "", ""<< n_max2 << ""}""<<"" ",C-Plus-Plus
"//Egg Dropping problem
 /*
 The Egg Dropping Problem: There is a building with k floors. You are given n eggs.
 
 An egg dropping from any floor is termed a trial. After a dropping, an egg can either survive or
 break. A broken egg cannot be used whereas a survived egg can be used for another trial. All eggs are
 identical, i.e. effect must be same for all eggs.
 
 A floor is called the critical floor if an egg breaks from that floor and above but does not break from
 any floor below that one. We assume that if an egg survives a fall, it survives a shorter fall. And if an
 egg breaks from some floor, then it would break from higher floor also.
 
 Given n and k, you have to find the minimum number of trials in the worst case.
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 int egg,flr;
 int **table= NULL;
 int min_probes=0;
 
 void input()
 {
 	cin>>egg;
 	cin>>flr;
 	table=new int*[flr+1];		//Initializing memory for DP Table
 	for(int i = 0; i <= egg; ++i)
       table[i] = new int[flr+1];
   
 }
 int find_min_probes(int e,int f)
 {   
 
 	if(e==1)
 		return f;
 
     if(f==0||f==1)
 		return  f;
     
     int probes=INT_MAX;
     for(int k=1;k<=f;k++)
     {
 		int temp=1+max(find_min_probes(e-1,k-1),find_min_probes(e,f-k));
         probes=min(probes,temp);
     }
    	return probes;
 }
 
 void display()
 {
 	cout<<""*************** Egg Droping Problem *****************""<<endl;
 	cout<<endl<<""Number of eggs are: ""<<egg;
 	cout<<endl<<""Number of floors are: ""<<flr<<endl;
 	cout<<""\nMinimum number of trials in worst case with ""<<egg<<"" eggs and ""<<flr<<"" flrs are: ""<<min_probes<<endl<<endl;
 }
 
 int main() 
 { 
     input(); 
     min_probes = find_min_probes(egg,flr);
 	display();
 	return 0;
 } 
 
 /*
 Input:
 2
 10
 
 Output:
 *************** Egg Droping Problem *****************
 
 Number of eggs are: 2
 Number of floors are: 10
 
 Minimum number of trials in worst case with 2 eggs and 10 flrs are: 4
 */",C-Plus-Plus
"/*
 All Basics Features of singly Linked List
 
 @author: Rishikeshrajrxl
 @created: 16/08/2020
 
       Here Indexing starts from 1   
       All Insertion and Deletion are based on Index 1.
 */
 
 #include <iostream>
 using namespace std;
 
 struct node
 {                                //declaration of node
 int data;
 struct node*next;
 }*ptr,*head,*tail,*temp;         //pointer to node
 
 void Insert_At_Front();
 void Insert_At_End();
 void Insert_At_Pos();            //function declaration
 void Delete_At_Front();
 void Delete_At_End();
 void Delete_At_Pos();
 void Display();
 void Length();
 int ele;			//ele is the input data from the user
 
 
 int main()              //Main Function Begins Here
 {
 int ch;
 cout<< ""\n\n\t All Basic Features of Singly Linked List""<<endl;         //Displaying the Features in a tabular manner         
 cout<<""\t **************************************************""<<endl;
 
 do
 {
 cout<<""\t 1) Insert at Front\t \t 2) Insert at End ""<<endl; 
 cout<<""\t 3) Insert at position\t \t 4) Delete at Front""<<endl;
 cout<<""\t 5) Delete at End\t \t 6) Delete at Position""<<endl;
 cout<<""\t 7) Length\t \t\t 8) Display""<<endl;
 cout<<""\t 9) Exit""<<endl;
 cout<<""\t ***************************************************\n ENTER YOUR CHOICE: ""<<endl;
 cin >>ch;
   switch(ch)
   {
     case 1:
     Insert_At_Front();
     break;
 
     case 2:
     Insert_At_End();
     break;
 
     case 3:
     Insert_At_Pos();
     break;
 
     case 4:
     Delete_At_Front();
     break;
 
     case 5:
     Delete_At_End();
     break;
 
     case 6:
     Delete_At_Pos();
     break;
 
     case 7:
     Length();
     break;
 
     case 8:
     Display();
     break;
     
     case 9:
     exit(0);
     break;
     
     default:
     cout<<""Invalid Input. Please enter the Number between 1 to 9 ""<<endl;
     
   }
 }while(ch!=0);
     return 0;
 }
 //-------------------------------------------------------------
 void Insert_At_End()
 {
     ptr=(struct node*)mal",C-Plus-Plus
"// C program to implement Three Way Merge Sort
 #include <stdio.h>
 
 // Time Complexity: O(n*logn)
 // Space Complexity: O(n)
 
 
 // Merge the three sections in ascending order
 void merge(int arr[], int beg, int midA, int midB, int end, int temp[])  
 {  
     int i, j, k, l;
     i = beg;
     j = midA; 
     k = midB; 
     l = beg;  
   
     // Find the smallest element among the three sections 
     while ((i < midA) && (j < midB) && (k < end))  
     {  
         if(arr[i] < arr[j]) 
         { 
             if(arr[i] < arr[k]) 
             { 
                 temp[l++] = arr[i++]; 
             } 
             else
             { 
                 temp[l++] = arr[k++]; 
             } 
         } 
         else
         { 
             if(arr[j] < arr[k]) 
             { 
                 temp[l++] = arr[j++]; 
             } 
             else
             { 
                 temp[l++] = arr[k++]; 
             } 
         } 
     }  
   
     /*
     Now any two arrays would have remaining values that are yet to be merged,
     We have to identify those two arrays and merge the elements.  
     */
  
     while ((i < midA) && (j < midB))  
     {  
         if(arr[i] < arr[j]) 
         { 
             temp[l++] = arr[i++]; 
         } 
         else
         { 
             temp[l++] = arr[j++]; 
         } 
     }  
   
    
     while ((j < midB) && (k < end))  
     {  
         if(arr[j] < arr[k]) 
         { 
             temp[l++] = arr[j++]; 
         } 
         else
         { 
             temp[l++] = arr[k++]; 
         }  
     }  
   
     while ((i < midA) && (k < end))  
     {  
         if(arr[i] < arr[k]) 
         { 
             temp[l++] = arr[i++]; 
         } 
         else
         { 
             temp[l++] = arr[k++]; 
         }  
     }  
   
   /*
     Now a single array would have remaining values that are yet to be merged,
     We have identify that array and copy its remaining elements.  
   */
     
     while (i < midA)",C
"//                      Best Fit , First Fit , Worst Fit
 
 //      Simulate first-fit, best-fit and worst-fit memory allocations
 
 /*
 
     FIRST FIT (FF) 
 *A resource allocation scheme (usually for memory). 
 *First Fit fits data into memory by scanning from the beginning of available memory to the end, 
 until the first free space which is at least big enough to accept the data is found.
 *This space is then allocated to the data.
 *Any left over becomes a smaller, separate free space. 
 *If the data to be allocated is bigger than the biggest free space, 
 the request cannot be met, and an error will be generated
 
 
     BEST FIT (BF) 
 *The best fit deals with allocating the smallest free partition which meets the requirement of the requesting process. 
 *This algorithm first searches the entire list of free partitions and considers the smallest hole that is adequate.
 *It then tries to find a hole which is close to actual process size needed.
 
 
     WORST FIT (WF) 
 *The algorithm searches for free-space in memory in which it can store the desired information. 
 *The algorithm selects the largest possible free space that the information can be stored on 
 (i.e. that is bigger than the information needing to be stored) and stores it there.
 *This is directly opposed to the best fit algorithm which searches the memory in much the same way as before.
 
 
 
 */
 
 import java.util.*;
 
 public class MemoryAllocations {
 
     // Array for storing the size of differnt memory blocks
     static int block[] = new int[10];
 
     // Array for storing the size of memory
     // required by each process
     static int process[] = new int[10];
 
     static int i;
     static int j;
     static int b;
     static int p;
 
     public static void initialize() {
 
         // Creating Scanner Object to read input from user
         Scanner t = new Scanner(System.in);
 
         // Fill the number of blocks
         System.out.println(""Enter the number of memory block",Java
"/* This program prints lucky numbers till a given number n. Lucky
 number - It is a set of numbers which is formed by eliminating
 numbers based on their position based on the remaining set.*/
 
 import java.util.*;
 import java.lang.*;
 
 public class LuckyNumber {
 
 	// Function to print lucky numbers
 	static void luckynumbers(int number) {
 
 		// This array stores the lucky numbers
 		int array[] = new int[number];
 
 		// This array is used for eliminating
 		int count[] = new int[number];
 
 		// This array is used for terminating
 		int check[] = new int[number];
 		check[0] = 0;
 
 		// Fill the array with numbers from 1 to n
 		for(int i = 0; i < number; i++) {
 			array[i] = i + 1;
 			count[i] = i + 1;
 		}
 
 		// First case where every second number is eliminated
 		int counter = 1;
 		for(int i = counter; i < number; i += 2) {
 			array[i] = -1;
 			count[i] = -1;
 		}
 
 		// Updating the count array for further eliminations
 		int cnt = 0;
 		for(int i = 0; i < number; i++) {
 			if(count[i] != -1) {
 				count[i] = cnt + 1;
 				cnt++;
 			}
 		}
 
 		counter = 3;
 		int same = 0;
 		int value = 1;
 
 		// For further forming the series of lucky numbers
 		while(true) {
 			same = 0;
 			/* Updating the value of array of lucky number
 			according to the count array.*/
 
 			for(int i = 0; i < number; i++) {
 				if(count[i] % counter == 0) {
 					array[i] = -1;
 				}
 			}
 
 			// Setting the count array to initial state
 			for(int i = 0; i < number; i++) {
 				count[i] = -1;
 			}
 
 			// Forming the count array for next set of eliminations
 			cnt = 0;
 
 			for(int i = 0; i < number; i++) {
 				if(array[i] != -1) {
 					count[i] = cnt + 1;
 					cnt++;
 				}
 				else {
 					// Keeping a track of number of -1's in array
 					same += 1;
 				}
 			}
 
 			// Filling number of -1's at each iteration
 			check[value] = same;
 
 			// Finding the next index to eliminate from
 			for(int i = counter; i < number; i++) {
 				if(array[i] !",Java
"/*
  Introduction:
  Given an array of integers nums. A pair (i,j) is called good if nums[i] == nums[j] and i < j.
  Return the number of good pairs.
  Approach:
  Use a Hash Table to calculate the frequency of each element in the given array.
  count the number of pairs using the formula y(y-1)/2; where y is the frequency for the element.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 int numGoodPairs(vector<int> &nums) 
 {
     int n = nums.size();
     unordered_map<int ,int> u_map;
     for(int i = 0;i<n;i++)
     {
         u_map[nums[i]]++;
     }
     int ans = 0;
     for(auto i: u_map)
     {
         int y = i.second;
         ans = ans + (y*(y-1))/2;
     }
     return ans;
 }
     
 int main() 
 {
     int n;
     cout<<""Enter the size of the array : "";
     cin >> n;
     vector<int> nums(n);
     cout<<""Enter the elements of the array : "";
     for(int i = 0; i < n; i++)
     {   
         cin >> nums[i];
     }
     int number_of_good_pairs = numGoodPairs(nums);
     cout<<""Number of Good Pairs in the array : ""<<number_of_good_pairs<<""\n"";
     return 0;
 }
 /*
 Standard Input and Output
 Enter the size of the array : 6
 Enter the elements of the array : 1 2 3 1 1 3
 Number of Good Pairs in the array : 4
 
 Time Complexity:O(n)
 Space Complexity:O(n)
 */
",C-Plus-Plus
"#include<bits/stdc++.h>
 using namespace std;
 //This functions returns the least significant bit
 int check_bit(int n){
     return n&1;
 }
 //This functions sets the given bit from the right
 //example n=11001 pos=2 , makes -> 11011 i.e second bit from right
 int set_bit(int n,int pos){
     int mask =1;
     mask<<=pos-1;
     return n|mask;
 }
 //Returns the complement of a number
 int complement(int n, int bits){
     return ((1<<bits)-1) ^ n;
 }
 //Clears the bit at given position from the right
 int clear_bit(int n,int pos){
     int mask = 1;
     mask<<=pos-1;
     int bits = floor(log2(n)) + 1;
     mask = complement(mask,bits);
     return n&mask;
 }
 int main(){
     int n,pos; cin>>n>>pos;
     cout<<check_bit(n)<<endl;
     cout<<set_bit(n,pos)<<endl;
     cout<<clear_bit(n,pos)<<endl;
     return 0;
 }
 /*
 Input:
 25 1
 Output
 1
 25
 24
 
 Time complexity: O(1) for all
 Space complexity: O(1) for all
 */
",C-Plus-Plus
"/*
 Bidirectional search is an algorithm in which we find the Smallest Path from the source to the
 target vertex of a graph.
 In this algorithm, we perform the search operation from two sides, i,e. from the source
 vertex(Forward Search) and the target vertex(Backward Search) simultaneously.
 It divides the graph into two smaller sub-graphs, one starting at the source
 vertex and other at the target vertex.
 As the searching operation proceeds, the two graphs grow and the search terminates when two graphs
 intersect.
 To perform the searching operation, we implement Breadth-first search on both source vertex and
 target vertex.
 
 Bidirectional search is faster in many cases as compared to normal one-directional search as it
 dramatically reduces the amount of required exploration.
 */
 
 typedef long long int ll;
 #include <iostream>
 #include <vector>
 #include <queue>
 #include <algorithm>
 using namespace std;
 #define mod 1000000007
 
 void bfs(queue<int>& q, vector<bool>& visited, vector<int>& parent, vector<int> graph[])
 {
     int current = q.front();
     q.pop();
 
     for (auto i : graph[current])
     {
 
         // If adjacent vertex is not visited earlier
         // mark it visited by assigning true value
         if (!visited[i])
         {
             // set current as parent of this vertex
             parent[i] = current;
             
             // Mark this vertex visited
             visited[i] = true;
             
             // Push to the end of queue
             q.push(i);
         }
     }
 }
 
 // Print the path from source to target
 void printShortestPath(vector<int>& parentF, vector<int>& parentB, int sv, int tv, int inode)
 {
     vector<int> path;
     path.push_back(inode);
     int i = inode;
     while (i != sv)
     {
         path.push_back(parentF[i]);
         i = parentF[i];
     }
     reverse(path.begin(), path.end());
     i = inode;
     while (i != tv)
     {
         path.push_back(parentB[i]);
         i = pa",C-Plus-Plus
"  /*
   An array element is a peak
   if it is NOT smaller than its neighbours.
   For corner elements, we need to consider only one neighbour.
   */
   import java.util.Scanner;
   public class peak_element 
   {
       // Function to find the peak element
       peak_element(int arr[], int length) 
       {
           for(int i=0;i<=length;i++) 
           {
               if(arr[i]==arr[0]) 
               {
                   if(arr[i]>arr[i+1]) 
                   {
                       System.out.println(""Peak value : ""+arr[i]);
                   }
               }    
               if(arr[i]==arr[length-1]) 
               {
                   if(arr[i]>arr[length-2]) 
                   {
                       System.out.println(""Peak value : ""+arr[i]);
                   }
               }
               if(arr[i]>arr[i+1] && arr[i]>arr[i-1]) 
               {
                   System.out.println(""Peak value : ""+arr[i]);
               }
           }
       }
   public static void main(String[] args) 
   {
       Scanner sc = new Scanner(System.in);
       System.out.println(""Enter length of an array.."");
       int length=sc.nextInt();
       System.out.println(""your array please.."");
       int arr[]=new int[length];
       for(int i=0;i<length;i++) 
       {
           arr[i]=sc.nextInt();
       }
       peak_element obj=new peak_element(arr, length);
   }
   }
 
   /*
   Input--
   Enter length of an array..
   5 
   your array please..
   2 5 8 9 5
 
   Output--
   Peak value : 9
 
   Time Complexity : O(n)
   Space Complexity : O(n)
   */
",Java
"// This program is for evaluating postfix expression.
 // In this we evaluate the given postfix expression using stack
 
 // creating stackarr 
 var stackarr=[];
 
 // Initialize topp variable with -1
 var topp=-1;
 
 // creating evalstack
 var evalstack=[];
 
 // function for evaluating postfix expression
 function postfixevaluator(evalst)
 {
     eval=evalst.split("" "");
    for(var i=0;i<eval.length;i++)
    {
        if(!operator(eval[i]))
        {
            push(eval[i]);
        }
        else
        {
            var op1=parseInt(pop());
            var op2=parseInt(pop());
            
            if(eval[i]==""+"")
            {
                push(op2+op1);
            }
            else if(eval[i]==""-"")
            {
                push(op2-op1);
            }
            else if(eval[i]==""*"")
            {
                push(op2*op1);
            }
            else
            {
                push(op2/op1);
            }
        }
    }
    console.log(pop());
 }
 
 // function for push 
 function push(e)
 {
    topp++;
    stackarr[topp]=e;
 }
 
 // function for pop out
 function pop()
 {
     if(topp==-1)
     return 0;
     else
     {
         var popped_ele=stackarr[topp];
         topp--;
         return popped_ele;
     }
 }
 
 // function for checking whether operator or not 
 function operator(op)
 {
     if(op=='+' || op=='-' || op=='^' || op=='*' || op=='/' || op=='(' || op==')')
     {
         return true;
     }
     else
     return false;
 }
 
 // function for checking precedency
 function precedency(pre)
 {
     if(pre=='@' || pre=='(' || pre==')')
     {
         return 1;
     }
     else if(pre=='+' || pre=='-')
     {
         return 2;
     }
     else if (pre=='/' || pre=='*')
     {
         return 3;
     }
     else if(pre=='^')
     {
         return 4;
     }
     else
     return 0;
 }
 
  //In-Built readline module
 const readline = require(""readline"");
 const rl = readline.createInterface({
   input: process.stdin,
 ",JavaScript
"import java.util.HashMap;
 import java.util.List;
 import java.util.ArrayList;
 import java.util.Random;
 import java.util.Scanner;
 
 /**
  * <h1>Homophonic Cipher</h1>
  * <p>
  * To Implement Homophonic Cipher
  * </p>
  * 
  * <b>Description</b>
  * <p>
  * Homophonic Cipher is a substitution cipher, it replaces each letter with a varity of substitues, it is very similar
  * to Monoalphabetic cipher, the key difference between Homophonic cipher and Monoalphabetic cipher is that, in
  * Monoalphabetic cipher there is a constant replacement of character to another character whereas in Homophonic cipher
  * we have a set of characters which we can substitute.
  * </p>
  */
 public class HomophonicCipher
 {
     // Character Mapping table for Homophonic Cipher
     private static HashMap<Character, List<Character>> homophonicSequence;
     
     /**
      * <p>
      * This is a public method which is used to initialize homophonicSequence with character mapping.
      * </p>
      */
     public void initializeHomophonicSequence()
     {
         // Initializing homophonicSequence
         homophonicSequence = new HashMap<Character, List<Character>>();
         
         // Character Mapping for letter 'A'
         List<Character> aCharacterList = new ArrayList<Character>();
         aCharacterList.add('D');
         aCharacterList.add('9');
         HomophonicCipher.homophonicSequence.put('A', aCharacterList);
         
         // Character Mapping for letter 'B'
         List<Character> bCharacterList = new ArrayList<Character>();
         bCharacterList.add('X');
         HomophonicCipher.homophonicSequence.put('B', bCharacterList);
         
         // Character Mapping for letter 'C'
         List<Character> cCharacterList = new ArrayList<Character>();
         cCharacterList.add('S');
         HomophonicCipher.homophonicSequence.put('C', cCharacterList);
         
         // Character Mapping for letter 'D'
         List<Character> dCharacterList = new Arra",Java
"/*
 MERGE SORT IN DART
 Merge sort is a divide-and-conquer algorithm. 
 It keeps on dividing the array in 2 halves until we reach a stage 
 where it can no longer be divided, 
 and then merges the two sorted halves.
 */
 
 import 'dart:io';
 
 void merge(var arr, int l, int m, int h) {
   int len1 = m - l + 1;
   int len2 = h - m;
 
   List Left = new List.filled(len1, null, growable: false);
   List Right = new List.filled(len2, null, growable: false);
 
   for (int i = 0; i < len1; i++) {
     Left[i] = arr[l + i];
   }
   for (int j = 0; j < len2; j++) {
     Right[j] = arr[m + 1 + j];
   }
 
   // Setting the initial index of the subarrays and actual array
   int i = 0, j = 0, k = l;
 
   // Sorting and placing the elements of subarray in the main array
   while (i < len1 && j < len2) {
     if (Left[i] <= Right[j]) {
       arr[k] = Left[i];
       i++;
     } else {
       arr[k] = Right[j];
       j++;
     }
     k++;
   }
 
   // Placing all the remaining elements in the array
   while (i < len1) {
     arr[k] = Left[i];
     i++;
     k++;
   }
 
   while (j < len2) {
     arr[k] = Right[j];
     j++;
     k++;
   }
 }
 
 void mergeSort(var arr, int low, int high) {
   if (low < high) {
     // finding mid element
     int mid = low + (high - low) ~/ 2;
 
     // recursively calling merge sort for each division
     mergeSort(arr, low, mid);
     mergeSort(arr, mid + 1, high);
 
     // merging the subarrays
     merge(arr, low, mid, high);
   }
 }
 
 void main() {
   var arr = [];
 
   // taking input from user for elements in array
   var n, each;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     each = stdin.readLineSync();
     each = int.parse(each);
     arr.add(each);
   }
 
   // applying merge sort to array
   mergeSort(arr, 0, n - 1);
 
   print(arr);
 }
 
 /*
 Time Complexity : O(n*log n)
 Space Complexity : O(n)
 
 Sample Input",Dart
"import java.util.*;
 
 public class AggressiveCow {
 
     private static boolean checkDist(int dist, int cows, int arr[]) {
         int cowInStall = 1;
         int lastPos = arr[0];
 
         // here we check if the distance we have can be minimum distance or not
         // if yes, we return true
         for (int i = 1; i < arr.length; i++) {
             if (arr[i] - lastPos < dist) {
                 continue;
             }
             if(++cowInStall == cows) {
                 return true;
             }
             lastPos = arr[i];
         }
 
         return false;
     }
 
     private static int binSearch(int cows, int arr[]) {
         int left = 0;
         int right = arr[arr.length - 1] - arr[0];
 
         // using binary search technique to find distances
         while (left <= right) {
             int mid = left + ((right - left) / 2);
 
             if (checkDist(mid, cows, arr)) {
                 left = mid + 1;
             } else {
                 right = mid - 1;
             }
         }
 
         return right;
     }
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter number of stalls and cows:"");
         int stalls = sc.nextInt();
         int cows = sc.nextInt();
         int arr[] = new int[stalls];
         System.out.println(""Enter stall indexes:"");
         for (int i = 0; i < stalls; i++) {
             arr[i] = sc.nextInt();
         }
         sc.close();
 
         // sorting array so that we can use it in Binary search
         Arrays.sort(arr);
 
         int result = binSearch(cows, arr);
 
         System.out.println(""Largest minimum distance:"" + result);
     }
 }
 /**
  * Sample input/output:
  * 
  * Enter number of stalls and cows:
  * 5 3
  * Enter stall indexes:
  * 1 2 4 8 9
  * Largest minimum distance:3
  * 
  * Enter number of stalls and cows:
  * 6 4
  * Enter stall indexes:
  * 0 3 4 7 9 10
  * Largest minimum distance:3
  * 
",Java
"
 ''' Minimum no of coins required'''
 
 '''Problem Statement : Given coins of different denominations with infinite supply and a total amount of money amount. 
                       Compute the fewest number of coins required to make up that amount.
 '''
 
 #importing sys module to initalize the maxsize 
 import sys
 
 # assigning max value a variable can take
 INT_MAX = sys.maxsize - 1
 
 # taking input of list of coins
 print(""Enter coins denominations :"")
 coins = list(map(int,input().split()))
 print(""Given coins denominations are: "",coins)
 
 # taking input of value of coin to be changed
 print(""Enter the total amount:"")
 value = int(input())
 print(""Given total amount is: "", value)
 
 # size of coins list
 n = len(coins)
 
 # constructing a matrix of size n * value
 k = [[0 for i in range(value + 1)] for j in range(n + 1)] 
 
 # Bottom Up Dp Apporach
 
 # coinchange function
 def coinChange(coins,value,n):
 
   # Initialize first row with sys.maxsize
   for i in range(1,value+1):
     k[0][i] =INT_MAX
 
   # Initialize first column with 0
   for j in range(n+1):
     k[j][0] = 0
 
 
   for i in range(1,n+1):
     for j in range(1,value+1):
 
       # checking if coins[i-1] is less than index j
       if coins[i-1] <= j:
 
         # assigning the min value 
         k[i][j] = min(k[i][j-coins[i-1]] + 1, k[i-1][j])
       else:
         # assigning the previous value from matrix
         k[i][j] = k[i-1][j]
 
   # returns value in n * value block
   return k[n][value]
 
 
 min_coins = coinChange(coins,value,n)
 
 # printing the min required coins
 print(""Minimum coins required are {}"".format(min_coins))
 
 ''' 
 Sample input:
     coins = [1,2,5,8,10]
     value = 24
 
 Sample Output:
     Minimum coins required are 3
 '''
",Python
"""""""
 Python program to get sum of divisors.
 The Sum of divisors refers to the sum of numbers in the range [1 to n] which perfectly divides n.
 """"""
 
 import math
 # Function to get the sum of divisors
 
 def sum_of_divisors(num):
     # Initializing i as 1 and sum as 0
 
     i = 1
     sum = 0
     while True:
         if i > math.sqrt(num):
             break
         # Adding i to sum if it is a factor
 
         if num % i == 0 and i == math.sqrt(num):
             sum += i
         # Adding i and n/i to sum if i is a factor
         
         elif num % i == 0:
             sum += i
             sum += num // i
         i += 1
     return sum
 
 if __name__ == '__main__':
     # Taking Input
 
     n = int(input(""Enter the number :""))
     # Printing Output
 
     print(""The sum of the divisors is: {} "".format(sum_of_divisors(n)))
 
 """"""
 Time Complexity - O(sqrt(n)), where 'n' is the number
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 SAMPLE I
 
 INPUT
 Enter the number: 36
 
 OUTPUT
 The sum of the divisors is: 91
 
 """"""
 
",Python
"/* To print the occurrence of the given number in the list/array using Binary Search Technique */
 
 #include <stdio.h>
 int Binary_search_algo_for__finding_occurrence(int* , int , int , int);
 int Partition(int* , int , int);
 int Quick_sort(int* , int , int);
 
 int Binary_search_algo_for__finding_occurrence(int array[], int sizeOf_array, int number, int found)
 {
     int start = 0, end = sizeOf_array - 1;
 
 // initializing value
     int value = -1;
 
     while (start <= end)
     {
         int middle = (start + end) / 2;
 
         /*** CASE : number equals middle element ***/
         if (number == array[middle]) // if both are equal then we update the 'value'
         {
             value = middle;
             if (found) { // searching in left side
                 end = middle - 1;
             }
             else { // searching in right side
                 start = middle + 1;
             }
         }
 
         /*** CASE : number less than middle element ***/
         else if (number < array[middle])
         {
             end = middle - 1;
         }
 
         /*** CASE : number greater than middle element (last case) ***/
         else
         {
             start = middle + 1;
         }
     }
     return value;
 }
 
 int Partition(int array[], int lower_bound, int upper_bound)
 {
     int pivot , start , end , t;
     pivot = array[lower_bound];
     start = lower_bound ;
     end = upper_bound ;
 
     while (start < end)
     {
         while (array[start] <= pivot)
         {
             start++;
         }
         while (array[end] > pivot)
         {
             end--;
         }
         if (start < end)
         {   //swap
             t = array[start];
             array[start] = array[end];
             array[end] = t;
         }
     }
     //if the condition is not followed then we replace the 'end' with 'pivot' element and return end
     //swap
     t =  array[lower_bound];
     array[lower_bound] = array[end];
     array[end]",C
"// This program prints all the possible codes for a given string.
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void printallcodes(string number, string ans) {
 	if (number.size() == 0) { //Base case
 		cout << ans << endl;
 		return;
 	}
 
 	int ch = number[0] - '0';
 
 	if (ch != 0) {
 		char code = char(ch - 1 + 'a'); //Extracting alphabet from its value
 		string rstr = number.substr(1);
 		printallcodes(rstr, ans + code);
 	}
 
 	if (number.size() >= 2) {
 		int num = stoi(number.substr(0, 2));
 
 		if (num >= 1 && num <= 26) {
 			char code = char(num - 1 + 'a');
 			string rstr = number.substr(2);
 			printallcodes(rstr, ans + code);
 		}
 	}
 }
 
 int main() {
 	string number;
 	cout << ""Enter the number"";
 	cin >> number;
 	printallcodes(number, """");
 	return 0;
 }
 
 /*
 Example:
 Input: s = ""1123""
 Output:
 aabc
 aaw
 alc
 kbc
 kw
 */
",C-Plus-Plus
"/*
 Given an array of N elements , find it's prefix sum array. In Competitive Programming, many times we need to calculate prefix sum array to solve our problem.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 int ar[100009];
 
 void prefix_sum_array(int ar[] ,int N)
 {
     int pref_ar[N+1] = {0};
     pref_ar[0] = ar[0];
     // we will add the current element of ar[] array and previous element of pref_ar [] array
     for(int i = 1; i < N; i++)
     {
         pref_ar[i] = ar[i] + pref_ar[i - 1];
     }
     cout << ""The New Prefix sum array is \n"";
     for(int i = 0; i < N; i++)
     {
         cout << pref_ar[i] << ' ';
     }
     cout << endl;
     return;
 }
 
 int main()
 {
     cout << ""Input array size\n"";
     int N;
     cin >> N;
     for(int i = 0; i < N; i++)
     {
         cin >> ar[i];
     }
     prefix_sum_array(ar , N);
 }
 /*
 Standard Input and Output
 
 Input array size
 7
 10 4 16 34 23 5 90
 The New Prefix sum array is
 10 14 30 64 87 92 182
 
 Time Complexity : O(N)
 Space Complexity : O(N)
 */
",C-Plus-Plus
"// C program to find the Length of Longest Increasing Subsequence
 /*
 In this problem, given an array we have to find the length of the longest increasing subsequence that array can make.
 The problem can be solved using Dynamic Programming
 */
 #include <stdio.h>
 #include <string.h>
 
 int length_longest_increasing_subsequence(int arr[], int n)
 {
     int dp[n], max_len = 0;
 
     /* Initialize the dp array with the 1 as value, as the maximum length
        at each point is atleast 1, by including that value in the sequence  */
     for (int i = 0; i < n; ++i)
         dp[i] = 1;
 
     /* Now Lets Fill the dp array in Bottom-Up manner
        Compare Each i'th element to its previous elements from 0 to i-1, 
        If arr[i] > arr[j](where j = 0 to i-1), then it qualifies for increasing subsequence and
        If dp[i] < dp[j] + 1, then that subsequence  qualifies for being the longest one */
     for (int i = 1; i < n; i++)
     {
         for (int j = 0; j < i; j++)
         {
             if (arr[i] > arr[j] && dp[i] < dp[j] + 1)
                 dp[i] = dp[j] + 1;
         }
     }
 
     //Now Find the maximum element in the 'dp' array
     for (int i = 0; i < n; i++)
     {
         if (dp[i] > max_len)
             max_len = dp[i];
     }
 
     return max_len;
 }
 
 int main()
 {
     int n, max_len;
     printf(""\nWhat is the length of the array? "");
     scanf(""%d"", &n);
     int arr[n];
     printf(""Enter the numbers: "");
     for (int i = 0; i < n; i++)
     {
         scanf(""%d"", &arr[i]);
     }
     max_len = length_longest_increasing_subsequence(arr, n);
 
     printf(""The length of the longest increasing subsequence of the given array is %d"", max_len);
     return 0;
 }
 
 /*
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 What is the length of the array? 5
 Enter the numbers: 1 2 3 4 3
 The length of the longest increasing subsequence of the given arra",C
"/* 
 Given an integer array nums, return the maximum result of nums[i] XOR nums[j], 
 where 0  i  j < n.
 */
 
 #include<iostream>
 #include<vector>
 using namespace std;
 
 // Constructing a trie
 struct trie {
         trie *zero,*one;
 };
 
 //Building the trie
 void insert(int num,trie *root) {
    trie *ptr=root;
       for(int i=31;i>=0;i--) {
          int h = (num>>i & 1);
            if(h==0) {
                 if(ptr->zero==NULL) {
                     ptr->zero=new trie();
                 }
                 ptr=ptr->zero;
             }
             else {
                 if(ptr->one==NULL) {
                     ptr->one=new trie();
                 }
                 ptr=ptr->one;
             }
         }
 }
 
 //Finding the maximum XOR for each element   
 int comp(int num,trie *root) {
         trie *ptr = root;
         int sum=0;
         for(int i=31;i>=0;i--) {
             sum=sum<<1;
            int h = (num>>i & 1);
             if(h==0) {
                 if(ptr->one) {
                    sum++;
                     ptr=ptr->one;
                 }
                 else ptr=ptr->zero;
                 
             }
             else {
                   if(ptr->zero) {
                    sum++;
                     ptr=ptr->zero;
                 }
                 else ptr=ptr->one;
             }
         }
         return sum;
 }
    
 int findMaximumXOR(vector<int>& nums) {
         trie *root = new trie(); 
         for(int i=0;i<nums.size();i++) {
             insert(nums[i],root);
         }
         int maxm=0;
         for(int i=0;i<nums.size();i++) {
             maxm=max(comp(nums[i],root),maxm);
         }
         return maxm;
 }
 
 //Main Function
 int main() {
 
    vector<int>nums;
    int sz; 
    
    cout<<""Enter the vector size\n"";
    cin>>sz; // size of the vector
  
    cout<<""Enter the elements in the vector\n"";
    for(int i=0;i<sz;i++) {
    	 int x; 
 	 cin>>x;
 	 nums.push_back(x);
    }
   
    int ans",C-Plus-Plus
"/* 
     Progam to find the Least Common Ancestor in a Binary Search Tree
     1. We are given a partially written BST class.
     2. We are required to complete the body of lca function. ""lca"" function is expected to find the lowest commong ancestor of d1 and d2.
 */
 import java.io.*;
 import java.util.*;
 import java.util.Scanner;
 
 //This class can be used as a reference to create a new Node in a Binary Tree
 class Node {
     Node left;
     Node right;
     int data;
 
     Node(int data) {
         this.data = data;
         left = null;
         right = null;
     }
 }
 
 // this class contains functions that will help find out the Least Common Ancestor in a Binary Search Tree
 class LCAofaBST {
     // function to find out the Least Common Ancestor in a Binary Search Tree
     public static Node lca(Node root, int d1, int d2) {
         // Write your code here.
         if (d1 > root.data && d2 > root.data) {
             return lca(root.right, d1, d2);
         } else if (d1 < root.data && d2 < root.data) {
             return lca(root.left, d1, d2);
         } else {
             return root;
         }
     }
     // function to insert nodes in a binary search tree , does navigation also along the way
     public static Node insertNode(Node root, int data) {
         if (root == null) {
             return new Node(data);
         } else {
             Node curr;
             if (data <= root.data) {
                 curr = insertNode(root.left, data);
                 root.left = curr;
             } else {
                 curr = insertNode(root.right, data);
                 root.right = curr;
             }
             return root;
         }
     }
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         int t = sc.nextInt();
         Node root = null;
         while (t-- > 0) {
             int data = sc.nextInt();
             root = insertNode(root, data);
         }
         int target1 = sc.nextIn",Java
"/*
 Perfect number is a positive integer which is equal to the sum of its proper positive divisors.
 For example: 6 is the first perfect number
 Proper divisors of 6 are 1, 2, 3
 Sum of its proper divisors = 1 + 2 + 3 = 6.
 Hence 6 is a perfect number.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int perfectnumber(int n)
 {
     int sum=0;
     for (int i = 1; i < n; i++)
     {
         if (n % i == 0)
             sum += i;
     }
     return sum;
 }
 
 int main()
 {
     int n;
     cout<<""Enter a number to check whether it is a perfect number or not: "";
     cin >> n;
     if (perfectnumber(n) == n)
         cout << n << "" is a perfect number."" << endl;
     else
         cout << n << "" is not a perfect number."" << endl;
     return 0;
 }
 
 /*
 
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 sample 1:
 Input: Enter a number to check whether it is a perfect number or not: 6
 Output: 6 is a perfect number.
 
 sample 2:
 Input: Enter a number to check whether it is a perfect number or not: 7
 output: 7 is not a perfect number.
 
 */ 
",C-Plus-Plus
"/*
 Ugly numbers are numbers whose only prime factors are 2, 3 or 5.
 The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15 ..
 shows the first 11 ugly numbers.
 Your Task is to find nth Ugly number
 Time Complexity:O(n)
 Space Complexity: O(n)
 Example 1:
 Sample Input:
 10
 Sample Output:
 12
 Example 2:
 Sample Input:
 4
 Sample Output:
 4
 Language: C
 */
 
 #include <stdio.h>
 
 //return the minimum among x and y
 #define MIN(X, Y)(((X) < (Y)) ? (X) : (Y))
 
 //this function return nth ugly number
 int get_ugly_no(int n)
 {
 	int ugly[n], i2 = 0, i3 = 0, i5 = 0;
 	int nxt_mul_2 = 2, nxt_mul_3 = 3;
 	int nxt_mul_5 = 5, nxt_ugly = 1;
 	ugly[0] = 1;
 	for (int i = 1; i < n; i++)
 	{
 		nxt_ugly = MIN(nxt_mul_2, MIN(nxt_mul_3, nxt_mul_5));
 		ugly[i] = nxt_ugly;
 		if (nxt_ugly == nxt_mul_2)
 		{
 			i2++;
 			nxt_mul_2 = ugly[i2] * 2;
 		}
 
 		if (nxt_ugly == nxt_mul_3)
 		{
 			i3++;
 			nxt_mul_3 = ugly[i3] * 3;
 		}
 
 		if (nxt_ugly == nxt_mul_5)
 		{
 			i5++;
 			nxt_mul_5 = ugly[i5] * 5;
 		}
 	}
 
 	return nxt_ugly;
 }
 
 int main()
 {
 	//find the nth ugly number
 	int n;
 	scanf(""%d"", &n);
 	//calls the get_ugly_no function
 	printf(""%d"", get_ugly_no(n));
 	return 0;
 }
",C
"/*
 The traversal operation is a frequently used operation on a binary tree. This operation is used to visit each node in the tree exactly once
 A full traversal on a binary tree gives a linear ordering of data in the tree .  This is the iterative inorder tree traversal algorithms
 */
 
 class Stack {
     constructor() {
         this.items = [];
     }
     push(element) {
         this.items.push(element)
     }
     pop() {
         if (this.items.length == 0) {
             return ""Underflow"";
         }
         return this.items.pop();
     }
     peek() {
         return this.items[this.items.length - 1]
     }
     isEmpty() {
         return this.items.length == 0;
     }
 }
 
 
 
 
 class Node {
     constructor(data) {
         this.data = data;
         this.left = null;
         this.right = null;
     }
 }
 
 class BinarySearchTree {
     constructor() {
         this.root = null;
     }
     //insert function inserts a new node into the binary search tree
     insert(value) {
         var New = new Node(value);
         if (this.root === null) {
             this.root = New;
             return this;
         }
         let curr = this.root;
         let prev = null;
         while (curr) {
             if (value < curr.data) {
                 prev = curr;
                 curr = curr.left;
             }
             else if (value > curr.data) {
                 prev = curr;
                 curr = curr.right;
             }
         }
         if (prev.data > value) {
             prev.left = New;
             return this;
         }
         else {
             prev.right = New;
             return this;
         }
 
     }
 
     iterative_inorder(node) {
         let ptr = node;
         let stack = new Stack();
         let s = """"
         while (!stack.isEmpty() || ptr != null) {
             if (ptr != null) {
                 stack.push(ptr);
                 ptr = ptr.left;
             }
             else {
                 ptr = stack.p",JavaScript
"/*
 Transpose of a matrix is a matrix obtained by changing rows to columns and columns
 to rows.In other words, transpose of Arr[][] is obtained by changing Arr[i][j] to Arr[j][i].
 The below program finds transpose of matrix[][] and stores the result in result[][]
 */
 const readline = require('readline');
 
 const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
 
 const getLine = (function () {
     const getLineGen = (async function* () {
         for await (const line of rl) {
             yield line;
         }
     })();
     return async () => ((await getLineGen.next()).value);
 })();
 
 const main = async () => {
     console.log(""Enter the number of rows in the matrix"");
     let n = Number(await getLine());
     console.log(""Enter the number of columns in the matrix"");
     let m = Number(await getLine());
     console.log(""Enter the elements of the matrix"");
     //initializing array
     let a_1 = new Array(n);
     for (let i = 0; i < n; i++) {
         a_1[i] = new Array(m);
     }
     for (let i = 0; i < n; i++) {
         for (let j = 0; j < m; j++) {
             console.log(""Enter the element at position "" + i + "" , "" + j);
             a_1[i][j] = Number(await getLine());
         }
     }
     //initializing array
     let res = new Array(n);
     for (let i = 0; i < n; i++) {
         res[i] = new Array(m);
     }
     for (let i = 0; i < n; i++) {
         for (let j = 0; j < m; j++) {
             res[i][j] = a_1[j][i];
         }
     }
     let s = '';
     for (let i = 0; i < n; i++) {
         for (let j = 0; j < m; j++) {
             s += res[i][j] + "" "";
         }
         s += '\n';
     }
     console.log(""Transpose of matrix is"");
     console.log(s);
     process.exit(0);
 };
 
 main();
 
 
 /*
 Sample I/O:
 
 Enter the number of rows in the matrix
 3
 Enter the number of columns in the matrix
 3
 Enter the elements of the matrix
 Enter the element at position 0 , 0
 1
 Enter the element at positio",JavaScript
"import java.util.*;
 
 public class Binary_search {
 	//binary search algorithm explanation in its readme file in wiki section
 	//this can performed recursively also
 	//The average and worst case time complexity is O(log n)
 	//The space complexity is O(1).
 	static int binSearch(int[] a, int l, int h, int key) {
 		while (l<= h) {
 			int mid = (l + h) / 2;
 			if (key == a[mid])
 				return mid + 1; //index starts from zero so position has to be incremented by one.
 			else if (key < a[mid])
 				h = mid - 1;
 			else
 				l = mid + 1;
 		}
 		return -1;
 	}
 	public static void main(String[] args) {
 		//to perform binary search the array must be in sorted order
 		Scanner sc = new Scanner(System.in);
 		System.out.print(""Enter the length of the array: "");
 		int length = sc.nextInt();
 		int arr[] = new int[length];
 		System.out.print(""Enter array values: "");
 		for (int i = 0; i < length; i++) {
 			arr[i] = sc.nextInt();
 		}
 		// to sort the array if not sorted
 		Arrays.sort(arr);
 		System.out.print(""Enter the value whose index needs to be searched: "");
 		int value = sc.nextInt();
 
 		int index = binSearch(arr, 0, length - 1, value);
 		if (index == -1)
 			System.out.println(""Element Not found"");
 		else
 			System.out.println(""Index of "" + value + "" is: "" + index);
 	}
 }
 /*
 Input:
 Enter the length of the array: 5
 Enter array values: 2 3 4 5 6
 Enter the value whose index needs to be searched: 4
 Output:
 Index of 4 is: 3
 */
",Java
"/*
 Given a sorted and rotated array.
 The array is rotated between 1 and n times[ n = array size]
 find the minimum element of the input array.
 array may contain duplicate elements.
 */
 
 import java.util.Scanner;
 import java.lang.*;
 
 public class Mineleinarray
 {
     // this function  will give us the minimum element
     static int get_minimum_element(int ar[], int N)
     {
          int first = 0, last = N - 1;
          int minelement = -1;
         while(first < last)
         {
              //if ar[first] > ar[last] then we will increment first and last remains same
              if(ar[first] > ar[last])
              {
                 first++;
                 minelement = ar[last];
              }
              //if ar[first] <=  ar[last] then we will decrement last and first remains same
              if(ar[first] <= ar[last])
              {
                  last--;
                  minelement = ar[first];
              }
         }
         return minelement;
     }
     
 
     public static void main(String args[])  
     {
        Scanner scan = new Scanner(System.in);
        System.out.print(""Enter the size of array \n"");
        int number = scan.nextInt();
        int[] ar = new int[number];
        System.out.println(""Enter array elements \n""); 
        for(int i = 0; i < number; i++)
        {
 	  ar[i] = scan.nextInt();
        }
        int minimum_element = get_minimum_element(ar, number);
        System.out.println(""Minimum Element of the array is: \n"");
        System.out.println(minimum_element);
        scan.close();
     }
 }
 /*
 Standard Input and Output
 
 Enter the size of the array :
 12
 Enter array elements :
 465 7878 3535 68 3435 89897 466 878 44 7879 3 67868
 
 Minimum Element of the array is:
 3
 
 Time Complexity : O( N )
 Space Complexity : O(1)
 
 */
",Java
"// check whether a number is Prime or not with recursion
 
 import java.util.Scanner;
 class PrimeRecursion
 {
     public static int prime(int n,int div)
     {
         if(div<n)
         { if(n%div!=0)
             prime(n,div+1);
             else
             return 0;
         }
         return 1;
     }
     public static void main(String args[])
     {
         Scanner sc=new Scanner(System.in);
         System.out.print(""Enter a number : "");
         int n=(int)Math.abs(sc.nextInt());
         int c=prime(n,2);
         System.out.println(n+((c!=0)?"" is a Prime Number."" :"" is not a Prime Number.""));
     }
 }
 
 // Contributed By ErzaTitani-2001
 
 /*
 Sample Input and Output :
 Input :
 Enter a number : 13
 Output :
 13 is a Prime Number.
 Space Complexity : O(n)
 Time Complexity : O(n)
 */
",Java
"// unique BSTs using DP
 // Given n, how many structurally unique BST's that store values 1 ... n?
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int uniqueBST(int n) {
 	vector<int> count(n + 1);
 	// for each 'i' number of nodes
 	for (int i = 1; i <= n ; ++i) {
 		for (int j = 0 ; j < i ; ++j) {
 			// No. of trees if j is a root
 			count[i] += max(count[j], 1) * max(count[i - j - 1], 1);
 		}
 	}
 	return count[n];
 }
 
 int main() {
 	int n;
 	cout << ""Enter value:"";
 	cin >> n;
 	cout << ""Number of Unique BSTs "" << uniqueBST(n) << endl;
 
 	return 0;
 }
 
 /*
 output:
 Enter value:3
 Number of Unique BSTs 5
 Time complexity : O(n)
 */
",C-Plus-Plus
"public class InsertionSort
 {
     public static void Sort(int[] array)
     {
         for (int i = 0; i < array.Length - 1; i++)
         {
             int minIndex = i;
 
             for (int j = i + 1; j < array.Length; j++)
             {
                 if (array[j] < array[minIndex])
                 {
                     minIndex = j;
                 }
             }
 
             if (minIndex != i)
             {
                 (array[i], array[minIndex]) = (array[minIndex], array[i]);
             }
         }
     }
 }
",C-Sharp
"#include<bits/stdc++.h>
 
 using namespace std;
 void generate_subsets(int arr[], int n) {
     /*
     Number of possible subsets are 2^n
     If n=2, then:
     00 01 10 11 , four sets
     00 Indicates that both 0 and 1 index are not set hence empty
     01 Indicating that first index is unset and zeroth index is set
     */
     for (int i = 0; i < pow(2, n); i++) {
         //For checking set bits in the binary pattern and then printing the corresponding element
         for (int j = 0; j < n; j++) {
             if (i & (1 << j)) {
                 cout << arr[j] << "" "";
             }
         }
         cout << endl;
     }
 }
 int main() {
     int n;
     cin >> n;
     int arr[n];
     for (int i = 0; i < n; i++) {
         cin >> arr[i];
     }
     generate_subsets(arr, n);
 }
 /*
 Input:
 3
 1 2 3 
 
 Output:
 1 
 2 
 1 2 
 3 
 1 3 
 2 3 
 1 2 3
 
 Time complexity: O(2^n)
 Space complexity: O(1)
 */
",C-Plus-Plus
"#include<bits/stdc++.h>
 using namespace std;
 
 /* Encrypts the plain text message into a cipher text 
 by simply replacing each letter of a given text by 
 some places down the alphabet. */
 string encode(string plain, int shift) {
 	
 	string encrypt = """";
 	int length = plain.length();
 	for(int i = 0;i < length; ++i) {
 		if(plain[i] <= 91) {
 			//uppercase letter
 			encrypt += char((plain[i] - 65 + shift)%26 + 65);
 		} else if(plain[i] > 97) {
 			//lowercase letter
 			encrypt += char((plain[i] - 97 + shift)%26 + 97);
 		}
 	}
 
 	return encrypt;
 }
 
 int main() {
 	
 	string plain,encrypt;
 	int shift;
 	cout<<""Enter the plain text: "";
 	cin>>plain;
 	
 	cout<<""Enter the integer key to shift: "";
 	cin>>shift;
 	
 	encrypt = encode(plain,shift);
 	cout<<""Cipher Text: ""<<encrypt<<endl;
 	
 }
 
 /*
 Example:
 Text : TESSERACTCODING
 Shift: 4
 Cipher: XIWWIVEGXGSHMRK
 
 Text : NEOALGO
 Shift: 2
 Cipher: PGQCNIQ
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */",C-Plus-Plus
"/**
 The program will find out the sum of Nth row
 in the Pascal's Triangle using the concept of Bitmasking.
 	1         -> 1st -> 1
 	1 1       -> 2nd -> 2
 	1 2 1     -> 3rd -> 4
 	1 3 3 1   -> 4th -> 8
 	1 4 6 4 1 -> 5th -> 16
 	...       -> nst -> 2^(n-1)		
 total sum = 2^0 + 2^1 + 2^2 + 2^3 + 2^4 + .. + upto nth row i.e 2^(n-1) = 2^n - 1;
 */
 
 import java.util.Scanner;
 
 public class PascalNthRowSum {
 
 	public static void main(String[] args) {
 
 		Scanner sc=new Scanner(System.in);
 		
               System.out.print (""Enter value of N - "");
 		int n=sc.nextInt();
 		
 		int row= 1<<(n-1);
 		System.out.println(""Nth row sum - ""+row);
 		
 		int sum=1<<n;
 		sum=sum-1;
 		System.out.println(""Sum of entire Pascal Triangle upto Nth row - ""+sum);
 	}
 }
 
 /**
 Time Complexity : O(1)
 Space Complexity : O(1)
 
 Input :
 
 Enter value of N - 5
 
 Output :
 
 Nth row sum - 16
 Sum of entire Pascal Triangle upto Nth row - 31
 
 */
 
",Java
"/* C++ Program for Conversion of Binary Number to Decimal Number
 In this Program only input line contains an integer input 'number'. Its length does not exceed 10.
 Here, a function named 'binary_to_decimal' will convert the given binary input into decimal number.
 And output contain Decimal Conversion of input in a single line.
 */  
 #include<bits/stdc++.h>
 using namespace std;
 int binary_to_decimal(int number){
     int i, remainder, store, output;    
     remainder=1;
     store=1;
     output=0;  
     for(i=0;number>0;i++){
         //dividing number by 10 to get digits according to place value     
         remainder=number%10;
         //multiplying remainder with power of 2 according to its place value
         store=remainder*(pow(2,i));
         //storing this in 'output' in each iteration
         output=output+store;
         number=number/10;
     }
     return output;
 }
 int main(){
     int numberInput,l,k;
     cin>>numberInput;
     cout<<binary_to_decimal(numberInput)<<endl;
     return 0;
 }
 
 /* SAMPLE
 Testcase 1
 INPUT   100
 OUTPUT  4   
 Time Complexity is O(T)    where T is number of digit in 'number'
 Space Complexity is O(1)   */
",C-Plus-Plus
"//Check if the kth bit is set or not
 
 #include<bits/stdc++.h>
 using namespace std;
 int main()
 {
 	int n,k;
 	cout<<""Enter number \n"";
 	cin>>n;
 	cout<<""Enter bit no \n"";
 	cin>>k;
 	//Using left shift operator
 	 cout<<""Using Left Shift operator "";
 	if((n & (1<<(k-1))) != 0)
 	 cout<<""Yes""<<""\n"";
 	 else
 	  cout<<""No""<<""\n"";
 	  // using right shift operator
 	  cout<<""Using Right Shift operator "";
 	  if((n>>(k-1)) & 1)
 	   cout<<""Yes""<<""\n"";
 	 else
 	  cout<<""No""<<""\n"";
 	  
 }
 
 /*
 Time Complexity: O(1) 
 Space Complexity: O(1)
 */
 
 /*
 Test cases:
 
 Example 1:- 
 Enter number
 8
 Enter bit no
 4
 
 Example 2:-
 Enter number
 50
 Enter bit no
 4
 
 Sample Output:
 Example 1:- 
 Using Left Shift operator Yes
 Using Right Shift operator Yes
 
 Example 2:- 
 Using Left Shift operator No
 Using Right Shift operator No
 */
 
",C-Plus-Plus
"#include <iostream>
 using namespace std;
 
 /* A Binary Search Tree (BST) is a tree in which all the nodes follow the below-mentioned properties
 
 The value of the key of the left sub-tree is less than the value of its parent (root) node's key.
 
 The value of the key of the right sub-tree is greater than or equal to the value of its parent (root) node's key.*/
 
 // This program implements insetion,Deletion and Searching in Binary Search Tree(BST)
 
 struct Node{               //Structure is declared which holds Node data and address of left and right child
     struct Node *lchild;
     int data;
     struct Node *rchild;
 }*root=NULL;      // root object is declared globally for struct Node
 
 void insert(int element)    //Insertion happens here
 {
     struct Node *p=root;   // using 2 pointers for keeping track of Nodes
     struct Node *q,*tmp;
     tmp= new Node;
     tmp->data=element;
     tmp->lchild=tmp->rchild=NULL;
     if(root==NULL)
     {
         root=tmp;
     }
     else
     {
         while(p!=NULL)
         {
             q=p;
             if(p->data==element)
             {
                 return;
             }
             else if(element < p->data)  //if Inserted data is less than current Node data, move to left child
             {
                 p=p->lchild;
             }
             else{
                 p=p->rchild;    //if Inserted data is greater than or equal to current Node data, move to right child
             }
         }
         if(element > q->data) 
         {
             q->rchild=tmp;
         }
         else
             q->lchild=tmp;
     }
 }
 
 void Search(Node *p,int key)  //Seraching operation takes key as input and search for key in BST
 {
     if(p==NULL)
     {
         cout << "" BST is empty"" << endl;
     }
     else{
         while(p!=NULL)
         {
             if(p->data==key)
             {
                 cout << ""Element is found"" << endl;
                 return;
             }
             el",C-Plus-Plus
"/*Problem Statement: 
 Theodore implements a new strategy game Defense of a Kingdom. 
 On each level a player defends the Kingdom that is represented by a rectangular grid of cells. 
 The player builds crossbow towers in some cells of the grid. 
 The tower defends all the cells in the same row and the same column. 
 No two towers share a row or a column.
 The penalty of the position is the number of cells in the largest undefended rectangle. 
 For example, the position shown on the picture has penalty 12.
 Help Theodore write a program that calculates the penalty of the given position */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int position(int x_points[], int y_points[],int n,int w,int h)
 {
     int dx=x_points[0];
     int dy=y_points[0];
     for(int i=1;i<n;i++)
     {
         dx=max(dx,x_points[i]-x_points[i-1]);
         dy=max(dy,y_points[i]-y_points[i-1]);
     }
     dx=max(dx,w+1-x_points[n-1]);
     dy=max(dy,h+1-y_points[n-1]);
     int ans=(dx-1)*(dy-1);
     return ans;
 }
 
 int main()
 {
     int w,h,n,x,y;
     int x_points[100],y_points[100];
     cout<<""Enter width, height and number of towers respectively: ""<<endl;
     cin>>w>>h>>n;
     cout<<""Enter coordinates: ""<<endl;
     for(int i=0;i<n;i++)
     {
         cin>>x_points[i];
         cin>>y_points[i];
     }
     sort(x_points,x_points+n);
     sort(y_points,y_points+n);
     cout<<""No of cells that can not be defended: ""<<position(x_points,y_points,n,w,h)<<endl;
     return 0;
 }
 /*
 Example:-
 
 Input:-
 Enter width, height and number of towers respectively:
 15 8 3
 Enter coordinates:
 3 8
 11 2
 8 6
 
 Output:-
 No of cells that can not be defended: 12
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
"/* This program prints pre-order traversal of a tree. In pre-order,
 the traversal is done as : (root, left, right). */
 
 package main
 
 import (
 	""fmt""
 )
 
 // Structure of a node in the tree
 type Node struct {
 	/* Every node has a data, pointer to its
 	left child and also right child.*/
 	data int
 	left *Node
 	right *Node
 }
 
 /* This function prints thre pre order traversal of
 the tree recursively.*/
 func pre_order(root *Node) {
 
 	// If we reach the end, return
 	if(root == nil) {
 		return
 	}
 
 	// Print the data
 	fmt.Print(root.data, "" "")
 
 	// Call the function for left half
 	pre_order(root.left)
 	// Then, call for the right half
 	pre_order(root.right)
 }
 
 // This function creates a new node
 func new_node(value int) *Node {
 	// It takes data to be stored as parameter
 	return &Node{value, nil, nil}
 }
 
 func form_tree(array []int) *Node {
 
 	/* The user input is considered as level
 	order traversal of the tree. This function
 	returns pointer to the root of the tree.*/
 
 	// This array contains all nodes in the tree
 	a := make([]*Node , len(array))
 	for i := 0; i < len(array); i++ {
 		a[i] = new_node(array[i])
 	}
 
 	// Below are some base cases for 1, 2, 3, 4 nodes
 
 	// If there is only one node return the node
 	if(len(array) == 1) {
 		return a[0]
 	}
 
 	// If there are two nodes
 	a[0].left = a[1]
 	if(len(array) == 2) {
 		// Point the second node to first and return
 		return a[0]
 	}
 
 	// If there are three nodes
 	a[0].right = a[2]
 	if(len(array) == 3) {
 		// Make a binary tree and return root node
 		return a[0]
 	}
 
 	// If there are four nodes
 	if(len(array) == 4) {
 		a[1].left = a[3]
 		return a[0]
 	}
 
 	// If there are more than four nodes
 	for i := 1; i < len(array); i++ {
 
 		// Point  each node to its left and right child
 		a[i].left = a[2*i + 1]
 		a[i].right = a[2*i + 2]
 
 		// If we reach the end, return root node
 		if(2*i + 2 == len(array) - 1) {
 			return a[0]
 		}
 	}
 	// Return root nod",Go
"/**
  * Given a number and you need to check if a number is Automorphic or not. 
  * A number is called Automorphic if the square of the number ends
  * with the number itself.
  * Input:
  * First line of input contains a number of integer data type.
  * Output:
  * A single line telling whether a number is Automorphic or not.
  *
 */
 
 import 'dart:io';
 import 'dart:math';
 
 int Check_Automorphic(int n) {
   int square, temp, remainder, no_digits = 0;
   temp = n;
   square = n * n;
   int flag = 10;
 
   while (n != 0) {
     n = (n / 10).floor();
     no_digits++;
   }
 
   flag = pow(10, no_digits) as int;
   remainder = square % flag;
 
   if (remainder == temp)
     return 1;
   else
     return 0;
 }
 
 void main() {
   int num;
   print(""Enter the number: "");
   num = int.parse(stdin.readLineSync()!);
 
   int result = Check_Automorphic(num);
 
   if (result == 1)
     print(""$num is a Automorphic number"");
   else
     print(""$num is not a Automorphic number"");
 }
 
 /*
  * Example:
  * Input:
  * 3
  * Output:
  * 3 is not a Automorphic number.
  * 
  * Input:
  * 25
  * Output:
  * 25 is a Automorphic number.
 */
 /*
 *Time complexity : O(n) 
 *Space complexity : O(1)
 */
",Dart
"/* This code is an implementation of Hill Cipher. It
    is a polygraphic substitution cipher. It forms a 
    nxn matrix of key and nx1 matrix(s) of the plaintext
    and then multiplies the two matrices to obtains the
    matrix of ciphertext.*/
 
 #include <stdio.h>
 #include <string.h>
 #include <math.h>
 #include <stdlib.h>
 
 // Define max-length for message, ciphertext and key
 #define MAXLENGTH 100
 
 // Define the size of the n.
 #define size 3
 
 /* This function forms the nxn matrix of keyword.
    The value of n can be changed from above macro*/
 void get_key_matrix(char* key, int matrix_key[][size]) {
 
 	int count = 0;
 	for(int i = 0; i < size; i++) {
 		for(int j = 0; j < size; j++) {
 			// Converting ascii to decimal
 			matrix_key[i][j] = key[count] - 0;
 			/* Here, a = 97, b = 98 and so on.
 			   We want a = 0, b = 1 and so on.
 			   So, we subtract 97.*/
 			matrix_key[i][j] -= 97;
 			count++;
 		}
 	}
 }
 
 /* This function forms the nx1 matrix of the plaintext.
    Value of n can be changed from the macro defined.*/
 void get_plaintext_matrix(char* message, int message_matrix[][1]) {
 
 	int count = 0;
 	for(int i = 0; i < size; i++) {
 		for(int j = 0; j < 1; j++) {
 			// Converting ascii to decimal
 			message_matrix[i][j] = message[count] - 0;
 			/* As we did above, similarly, we subtract
 			   97 from the decimal value to start
 			   indexing from 0.*/
 			message_matrix[i][j] -= 97;
 			count++;
 		}
 	}
 }
 
 /* This function forms the nx1 ciphertext matrix.
    The matrix of decimal is then converted to ascii
    value and combined and then returned.*/
 char* get_ciphertext_matrix(char* message, char* keyword, int matrix_cipher[][1]) {
 
 	// Forming the keyword matrix 
 	int matrix_key[size][size];
 	// Calling the keyord matrix function
 	get_key_matrix(keyword, matrix_key);
 
 	// Forming the plaintext matrix
 	int message_matrix[size][1];
 	// Callin the plaintext matrix function
 	get_plaintext_matrix(message, message_matri",C
"#MODULES
 
 # Importing sys module to initalize the maxsize
 import sys
 # Importing collections model to access deque
 from collections import deque
 # Importing collections model to access defaultdict
 from collections import defaultdict
 
 ''' Bridge-Edge-in-Graph '''
 '''
 Problem Statement :Given an undirected graph and an edge, the
                    task is to find if the given edge is a
                    bridge in graph, i.e., removing the edge
                    disconnects the graph.
 
 Input :The first line of the input contains an integer 'T'
        denoting the number of test cases. Then 'T' test cases
        follow. Each test case consists of two lines.
        Description of  test cases is as follows:
                    The First line of each test case contains
                    two integers 'N' and 'M'  which denotes
                    the no of vertices and no of edges
                    respectively.
                    
                    The Second line of each test case contains
                    M space-separated pairs u and v denoting that
                    there is a bidirectional edge from u to v.
 
                    The third line contains two space-separated
                    integers denoting the edge to be removed.
 
 Output :Output True if the edge is a Bridge and
         output False otherwise
 '''
 
 # Assigning max value a variable can take
 INT_MAX = sys.maxsize - 1
 # Initialize Infinity
 INF = 9999999
 
 # FUNCTIONS
 # Create The graph
 
 
 def creategraph(no_of_edges, array, graph):
     i = 0
     # Since the given Graph is a Biparted Graph
     while (i < 2 * no_of_edges):
         graph[array[i]].append(array[i + 1])
         graph[array[i+1]].append(array[i]) 
         i += 2
 
 # For Breath First Search
 
 
 def BFS(graph, u, lists, visited):
     # Create the queue to check the next reachable cell
     queue = []
     queue.append(u)
     # List to check if the cell is visited or not
     visited[u] = 1",Python
"import java.util.Queue;
 import java.util.LinkedList;
 import java.util.Scanner;
 
 /**
  * <h1>Rail Fence</h1>
  * <p>
  * RailFence class acts as a custom Data Structure which consits of a Queue of Characters, Queue is used due to its
  * FIFO(First In First Out) property.
  * </p>
  */
 class RailFence
 {
     public Queue<Character> railFenceQueue;
 }
 
 /**
  * <h1>Rail Fence Cipher</h1>
  * <p>
  * To Implement Rail Fence Cipher
  * </p>
  * <b>Description</b>
  * <p>
  * class RailFenceCipher is used to encrypt plainText to cipherText using Rail Fence Cipher and decrypt cipherText to
  * plainText using the respective algorithm, Rail Fence Cipher is also called as Zig-Zag Cipher, it is a form of
  * Transposition cipher, it has derived its name from the technique it uses to encode the plain text, which forms a
  * zig-zag pattern which looks like a rail fence, it jumbles up the characters in the plain text to form the cipher
  * text.
  * </p>
  * <b>Requirements</b>
  * <p>
  * A string plain text and an integer key are required for encryption and for decryption the cipher text which is
  * calculated from the given key and the key itself.
  * </p>
  */
 public class RailFenceCipher
 {
     /**
      * <p>
      * This is a public method used to encrypt plainText using integer key using the Rail Fence Cipher algorithm.
      * </p>
      * 
      * <b>Process</b>
      * <ul>
      * <li>Place the characters in rail fence sequence
      * <p>
      * Here plain text= HelloHiHowAreYou? and key =3
      * </p>
      * <p>
      *    0 H               O                   O                       E                   ?
      *    1    E       L       H          H           W           R           Y        U
      *    2        L               I                       A                       O
      * </p>
      * </li>
      * 
      * <li>Fetch all the characters in index 0 then iterate it over other indexes until the last character of the index is
      * fetched",Java
"/*
 ___Implement Open Hashing___
 Hashing is an important data structure that is used to map a given value with a particular index
 for faster access of elements. But sometimes more than one value gets mapped with a particular index.
 This can be resolved using open hashing.
 In open hashing, keys are stored in linked lists attached to cells of a hash table.
 */
 
 #include<stdio.h>
 #include<stdlib.h>
 #define SIZE 10
 struct node
 {
     int data;
     struct node *next;
 };
 //array of pointers
 struct node *head[SIZE]={NULL},*c;
 void openDisplay();
 void openInsert();
 void openSearch();
 void main()
 {
     //prints the hash function used in the program
     printf(""\nHash function : h(k)=k (mod 10)+1"");
     int size,i,temp,ch=0;
     while(ch!=4)
     {
         printf(""\n"");
         printf(""1.Insert\n2.Search\n3.Display\n4.Exit\n"");
         printf(""Enter your choice : "");
         scanf(""%d"",&ch);
         switch(ch)
         {
         case 1:
            openInsert();
            break;
         case 2:
            openSearch();
            break;
         case 3:
            openDisplay();
            break;
         case 4:
            break;
         default:
             printf(""Invalid choice\n"");
         }
     }
 }
 
 /*
 This function inserts elements into the hash table.
 Duplication is not allowed in hash table.
 We use an array of linked list to store the elements.
 */
 void openInsert()
 {
     int i,j,key;
     printf(""Enter the element  :  "");
     scanf(""%d"",&key);
     i=key%SIZE+1;
     for(c=head[i];c!=NULL;c=c->next)
         {
             if(c->data==key)  //checks for duplication
             {
                 printf(""Duplication\n"");
                 return;
             }
         }
     //dynamically allocates memory for the node
     struct node *newnode=(struct node*)malloc(sizeof(struct node));
     newnode->data=key;
     newnode->next=NULL;
     //if head is empty then element made as head
     if(head[i]==NULL)
         ",C
"/*Problem Description
 A vertex is said to be an articulation point in a graph if removal of the vertex and associated edges disconnects the graph.
 You are given the nodes and edges . Find the articulation point.
 */
 
 import java.util.*;
 import java.lang.*;
 import java.io.*;
 
 public class Articulation_Point {
         // Initialize all the required variables with their type. 
 	private static int[] low =  new int[10001];
 	private static int[] visited = new int[10001]; 
 	private static int[] disc = new int[10001] ;
 	private static int timer = 1;
 	private static Set<Integer> hashset ;
         static ArrayList<Integer> adj[];
         //  This class will help us to create a graph and know the articulation point.
 	static class Graph
 	 {
 		 static int v ;		
        		 // Creating graph 
 		 Graph(int v)
 		 {
 			 Graph.v = v;
 			 adj = new ArrayList[v+1];			 
 			 for(int i = 0 ; i < v+1 ; i++)
 			 {
 				 adj[i] = new ArrayList<Integer>();
 			 }
 		 }		 
      	         // adding nodes with each other 
 		 static void addEdge(int u , int v)
 		 {
 			 adj[u].add(v);
 			 adj[v].add(u);
 		 }
 		// The method will help us to know the articulation point
 		/*
 		    Code flow : 
 		    step 1 :  We need to calculate the lowest discovery number. 
 		    step 2 : The algorithm then searches for its adjacent vertices.
 		    step 3 : the algorithms take a pair of vertices and checks whether its an articulation point or not.
 		    step 4 : Theres one special case when the root is an articulation point
 		*/    
 		 static void dfs(int node , int par)
 			{
 				visited[node] = 1 ;
 				low[node] = disc[node] = timer++;
 				int children = 0 ;
 				for(int child : adj[node] )
 				{
 					if(child == par) continue;
 					if(visited[child] == 0 )
 					{
 						children++;
 						dfs(child , node );
 						if(disc[node] <= low[child] && par != -1)
 						{
 							hashset.add(node );
 						}
 						low[node] = Math.min(low[node] , low[child] );
 					}
 ",Java
"/*
 An expression is called prefix , if the operator appears in the expression before the operands. (operator operand operand)
 An expression is called postfix , if the operator appears in the expression after the operands . (operand operand operator)
 The program below accepts an expression in prefix and outputs the corresponding postfix expression .
 */
 #include <stdio.h>
 #include <string.h>
 // Struct for stack
 typedef struct
 {
     char arr[20][20];
     int top;
 } stack;
 
 stack s = {.top = -1};
 // push function pushes an element to the top of the stack
 void push(char arr[])
 {
     if (s.top == 20)
     {
         return;
     }
     s.top++;
     strcpy(s.arr[s.top], arr);
 }
 // pop function pops an item from the top of the stack
 char *pop()
 {
     if (s.top == -1)
     {
         return ""0"";
     }
     else
     {
         return s.arr[s.top--];
     }
 }
 // if operand function checks if the element is an operand
 int ifoperand(char c)
 {
     if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
     {
         return 1;
     }
     return 0;
 }
 // prefixtopostfix function converts a prefix expression to postfix
 void prefixtopostfix(char expression[])
 {
     int len = strlen(expression);
     for (int i = len - 1; i >= 0; i--)
     {
         if (ifoperand(expression[i]))
         {
             char exp[2];
             exp[0] = expression[i];
             exp[1] = '\0';
             push(exp);
         }
 
         else
         {
             char exp[2];
             exp[0] = expression[i];
             exp[1] = '\0';
             char op1[20];
             strcpy(op1, pop());
             char op2[20];
             strcpy(op2, pop());
             char temp[20];
             strcpy(temp, strcat(op1, op2));
             strcat(temp, exp);
             push(temp);
         }
     }
     printf(""the postfix expresssion is : %s"", pop());
 }
 // Driver code
 int main()
 {
     char exp[100];
     printf(""Enter the prefix expression \n"");
   ",C
"#include <bits/stdc++.h> 
 using namespace std; 
 
 //Recursive Approach: Time Complexity Is O(log3(N))
 int ternarySearchRecursion(int l, int r, int key, int ar[]) 
 { 
 	if (r >= l) { 
 		// Find the mid1 and mid2 
 		int mid1 = l + (r - l) / 3; 
 		int mid2 = r - (r - l) / 3;
 		
 		// Check if key is present at any mid
 		if (ar[mid1] == key) { 
 			return mid1; 
 		} 
 		if (ar[mid2] == key) { 
 			return mid2; 
 		} 
 		// Since key is not present at mid, 
         	// check in which region it is present 
 	        // then repeat the Search operation 
 	        // in that region 
 		if (key < ar[mid1]) { 
 			 // The key lies in between l and mid1 
 			return ternarySearchRecursion(l, mid1 - 1, key, ar); 
 		} 
 		else if (key > ar[mid2]) { 
 			// The key lies in between mid2 and r 
 			return ternarySearchRecursion(mid2 + 1, r, key, ar); 
 		} 
 		else {
        	                // The key lies in between mid1 and mid2 
 			return ternarySearchRecursion(mid1 + 1, mid2 - 1, key, ar); 
 		} 
 	} 
 	// Key not found 
 	return -1; 
 } 
 
 //Iterative Approach: Time Complexity Is O(log3(N))
 int ternarySearchIterative(int l, int r, int key, int ar[])   
 { 
     while (r >= l) { 
 	// Find the mid1 and mid2 
         int mid1 = l + (r - l) / 3; 
         int mid2 = r - (r - l) / 3; 
 	 // Check if key is present at any mid
         if (ar[mid1] == key) { 
             return mid1; 
         } 
         if (ar[mid2] == key) { 
             return mid2; 
         } 
 	// Since key is not present at mid, 
         // check in which region it is present 
         // then repeat the Search operation 
         // in that region 
         if (key < ar[mid1]) { 
 	    // The key lies in between l and mid1 
             r = mid1 - 1; 
         } 
         else if (key > ar[mid2]) { 
 	    // The key lies in between mid2 and r 
             l = mid2 + 1; 
         } 
         else { 
 	    // The key lies in between mid1 and mid2 
             l = mid1 + 1; 
             r",C-Plus-Plus
"#include <stdio.h>
 #include <stdlib.h>
 typedef struct Queue
 {
     struct Queue *head;
     struct Queue *next;
     int value;
     int size;
 }Queue;
 /*
  * create empty queue
 */
 Queue *create_queue()
 {
     Queue *ret = (Queue*) malloc(sizeof(Queue));
     ret->head = ret->next = NULL;
     ret->size = 0;
     return ret;
 }
 void enqueue(Queue *q, int value)
 {
     Queue *cur = q;
     // queue is empty, initialize head
     if( !q->head )
     {
         Queue *head = (Queue*) malloc(sizeof(Queue));
 
         if( !head )
         {
             perror(""create queue"");
             exit(-1);
         }
         head->value = value;
         head->next = NULL;
         cur->head = head;
         cur->size++;
     }
     else
     {
         // go until end of queue
         cur = cur->head;
         while( cur->next )
         {
             cur = cur->next;
         }
         // reached end of queue
         Queue *temp = (Queue*) malloc(sizeof(Queue));
         temp->value = value;
         temp->next = NULL;
         // make last node to point to temp - add the link
         cur->next = temp;
         q->size++;      // increase size
     }
     return;
 }
 int dequeue(Queue *q)
 {
     Queue *cur = q->head;
     int ret = cur->value;
     q->size--;
     // advance the head of the queue
     q->head = q->head->next;
     // free memory
     free(cur);
     cur = NULL;
     return ret;
 }
 void print_queue(Queue *q)
 {
     Queue *cur = q->head;
     printf(""["");
     while( cur )
     {
         printf("" %d "", cur->value);
         cur = cur->next;
     }
     printf(""]\n"");
     return;
 }
 int main()
 {
     Queue *q1 = create_queue();
     enqueue(q1, 5);
     enqueue(q1, 9);
     print_queue(q1);
     int d = dequeue(q1);
     printf(""d is %d\n"", d);
     print_queue(q1);
     enqueue(q1, 45);
     print_queue(q1);
     return 0;
 }
",C
"/*************************************************************
  Program to multiply two numbers using Russian peasant method
  Given two integers, write a function to multiply them without using multiplication operator.
  We double the first number and halve the second number repeatedly till the second number doesnt become 1.
 In the process, whenever the second number becomes odd, we add the first number to result.
 
  *************************************************************/
 
 #include <stdio.h>
 #include <iostream>
 #include <bits/stdc++.h>
 using namespace std;
 
 //implementation of logic
 int fractionalknapsack(int m, int n)
 {
     int result;
        while(n > 0)
     {
         if(n % 2 != 0)
         {
             result += m;
             m << 2;
             n >> 2;
         }
     }
     return result;
 }
 
 int main()
 {
     int num1, num2, result = 0, m, n;
     cout<<""Enter two numbers: "";
     cin>>num1>>num2;
     result= fractionalknapsack(m, n);
     cout<<num1<<"" * ""<<num2<<"" = ""<<result;
     return 0;
 }
 
 /*
 Sample Input Output
 Enter two numbers: 12 13
 12 * 13 = 156
 */
 
",C-Plus-Plus
"""""""Julia program to implement Merge sort
 Merge Sort is a Divide and Conquer algorithm. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.
 First divide the list into the smallest unit (1 element), then compare each element with the adjacent list to sort and merge the two adjacent lists. 
 Finally all the elements are sorted and merged.
 """"""
 function merge_sort(arr)
     if length(arr) <= 1
         return arr
     end
     middle = trunc(Int, length(arr) / 2) # Finding the mid of the array
     L = arr[1:middle]
     R = arr[middle+1:end]
     
     merge_sort(L) # Sorting the first half
     merge_sort(R) # Sorting the second half
     
     # Copy data to temp arrays L[] and R[]
     i = j = k = 1
     while i <= length(L) && j <= length(R)
         if L[i] < R[j]
             arr[k] = L[i]
             i+=1
         else
             arr[k] = R[j]
             j+=1
          end
          k+=1
      end
     # Checking if any element was left
      while i <= length(L)
           arr[k] = L[i]
           i+=1
           k+=1
       end
       while j <= length(R)
           arr[k] = R[j]
           j+=1
           k+=1
       end
       arr
 end
 
 print(""How many numbers do you want to sort? "")
 n = readline()
 n = parse(Int64, n)
 if (n <= 0)
     println(""No numbers to sort!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 merge_sort(arr)
 print(""The numbers in sorted order is "")
 print(arr)
 
 
 """"""
 Time Complexity - O(n*Log n), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 How many numbers do you want to sort? 4
 Enter the numbers: 8 2 7 6 
 The numbers in sorted order is [2, 6, 7, 8]
 """"""
 
 
",Julia
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# WHITE WINE QUALITY PREDICTION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [White Wine Quality](https://www.kaggle.com/piyushagni5/white-wine-quality)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import numpy as np\n"",
     ""from sklearn import preprocessing  \n"",
     ""from sklearn import metrics\n"",
     ""import seaborn as sns\n"",
     ""from scipy import stats\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""\n"",
     ""# making predictions using different classifiers\n"",
     ""from sklearn.neighbors import KNeighborsClassifier  \n"",
     ""from sklearn.svm import SVC\n"",
     ""from sklearn.tree import DecisionTreeClassifier\n"",
     ""from sklearn.ensemble import RandomForestClassifier\n"",
     ""from sklearn.naive_bayes import GaussianNB\n"",
     ""\n"",
     ""from statsmodels.stats.outliers_influence import variance_inflation_factor\n"",
     ""import matplotlib.pyplot as plt\n"",
     ""from sklearn.metrics import confusion_matrix\n"",
     ""from sklearn.metrics import classification_report""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting our Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe the",Python
"'''
 Articulation Point:- In an undirected graph, any vertex whose removal
         from the graph separates/divides the graph into 2 or more graph
         which are not connected by any edge is called a cut-vertex
         or Articulation Point.
 
 Purpose:- To return a list of all Articulation point in the given
             graph if such a point exists.
 Problem Link:- https://www.geeksforgeeks.org/articulation-points-or-cut-vertices-in-a-graph
 
 Method - Depth First Search
 Intuition:- The idea behind the solution is to use DFS because it forms a DFS tree.
         In DFS tree, a vertex u is articulation point if one of the following two conditions is true.
         1) u is the root of DFS tree and it has at least two children.
         2) u is not the root of DFS tree and it has a child v such that
             no vertex in the subtree rooted with v has a back edge to one
             of the ancestors (in DFS tree) of u.
 
 Time Complexity:-  O(N+M)
 Space Complexity:  O(N)
 
 Argument: Dictionary ( Graph vertex numbered 1 to N)
 Return  : List       ( Articulation Point)
 
 '''
 from collections import defaultdict
 
 # Global Variable to keep a track of finishing times
 Time = 0
 
 
 def dfs(graph, node, parent, low, f_time, visited, AP):
     global Time
 
     # Mark the node visited and Initialize the finishing time
     visited[node] = True
     low[node] = Time
     f_time[node] = Time
     Time += 1
 
     # To count the children from the current Node
     child = 0
 
     # Check for each adjoining Vertex/Node
     for i in graph[node]:
 
         if visited[i]:
             low[node] = min(low[node], f_time[i])
 
         if not visited[i]:
             parent[i] = node
             child += 1
             dfs(graph, i, parent, low, f_time, visited, AP)
             low[node] = min(low[node], low[i])
 
             # (1) u is the root of the DFS tree and has two or more children.
             if parent[node] == -1 and child > 1:
                 AP[n",Python
"/*
 CPP program to find the n'th number in the tribonacci series
 Tribonacci series is a generalization of the Fibonacci sequence, in which the current term
 is the sum of the previous three terms
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 long int find_tribonacci(int n)
 {
     long int dp[n];
     memset(dp, 0, sizeof(dp));
     dp[2] = 1;
 
     for(int i = 3;i < n; i++)
     {
         dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
     }
     return dp[n-1];
 }
 
 
 int main()
 {
     int n, ans;
     cout<<""Enter the value of n?, where you need the n'th number in the tribonacci sequence. "";
     cin >> n;
     ans = find_tribonacci(n);
     cout<<""The ""<<n<<""'th term in the tribonacci series is ""<<ans;
 }
 
 
 /*
 Time Complexity - O(n)
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the value of n?, where you need the n'th number in the tribonacci sequence. 12
 The 12'th term in the tribonacci series is 149.
 
 SAMPLE II
 
 Enter the value of n?, where you need the n'th number in the tribonacci sequence. 23
 The 23'th term in the tribonacci series is 121415
 */
",C-Plus-Plus
"'''
     IMPLEMENTATION OF BINARY SEARCH TREE (BST)
     Binary Search Tree is a special type of binary tree where:
     1. The value of all the nodes in the left sub-tree is less than or equal to the value of the root.
     2. The value of all the nodes in the right sub-tree is greater than value of the root.
     3. This rule will be recursively applied to all the left and right sub-trees of the root.
 
     This program contains the menu-based implementation of the basic operations on a BST:
     1. Insert Node into BST
     2. Search Node in BST
     3. Delete Node in BST
     4. Print BST (inorder way)
 '''
 
 
 class BSTNode:
     # A Node of the Binary Search Tree
     def __init__(self, val=None, left=None, right=None):
         self.val = val
         self.left = left
         self.right = right
 
 
 def insertNode(root, val):
     # Function to insert a node to a BST
 
     # if the given BST is empty
     if root is None:
         return BSTNode(val)
 
     # if the value to insert already exists in the tree
     if root.val == val:
         return root
 
     # if the value to insert should be inserted to the left subtree
     if val < root.val:
         root.left = insertNode(root.left, val)
 
     # if the value to insert should be inserted to the right subtree
     else:
         root.right = insertNode(root.right, val)
 
     return root
 
 
 def searchNode(root, val):
     # Function to search a node in a BST
 
     # if the BST is empty or if the node doesn't exist
     if root is None:
         return False
 
     # if the value exists in the BST
     if root.val == val:
         return True
 
     # if the value might exist in the right subtree
     if val > root.val:
         return searchNode(root.right, val)
 
     # if the value might exist in the left subtree
     return searchNode(root.left, val)
 
 
 def inorderSuccessor(node):
     # Function to find the inorder successor of a given node
 
     curr = node
     # Loop through the BST unti",Python
"//algorithm for swap nibbles in O(1) time complexity and O(1) space complexity
 
 #include <stdio.h>
 
 int swapnibbles(int num)
 {
     return (((num & 0x0F) << 4) | ((num & 0xF0) >> 4));
 }
 
 int main()
 {   
     //taking input
     int num;
     printf("" Enter a number : \n"");
     scanf(""%d"",&num);
     int result = swapnibbles(num);
     printf(""output is  %d\n"",result);
 }
 
 /*
 Input:
 Enter a number: 50
 Output: 
 35
 */ 
",C
"/*
 What is Insertion Sort?
 Insertion sort is a method of sorting an array by dividing the array into a 'sorted' portion and 'unsorted' portion. Then we compare the unsorted item to see if it is larger than the previous element, if not we insert the new item. Basically we are looking from left to right and sorting as we go.
 
 Let's start building our insertionSort function.
 
 -----------------------------------------------------------------------------------
 |                ALGORITHM                                                         |
 |        Step 1  If it is the first element, it is already sorted. return 1;              |
 |        Step 2  Pick next element                                                        |
 |        Step 3  Compare with all elements in the sorted sub-list                         |
 |        Step 4  Shift all the elements in the sorted sub-list that is greater than the   |
 |                 value to be sorted                                                       |
 |        Step 5  Insert the value                                                         |
 |        Step 6  Repeat until list is sorted                                              |
 |                                                                                  |
 -----------------------------------------------------------------------------------
 
 
 */
 
 const insertionSort = (arr) => {
   const len = arr.length;
   for (let i = 0; i < len; i++) {
     let el = arr[i];
     let j;
 
     for (j = i - 1; j >= 0 && arr[j] > el; j--) {
       arr[j + 1] = arr[j];
     }
     arr[j + 1] = el;
   }
   return arr;
 };
 
 console.log(insertionSort([1, 3, 4, 1, 2]));
",JavaScript
"""""""Length of Longest Common Subsequence problem in Julia
 
 Given two strings, we have to find the largest common subsequence in Julia
 
 The problem can be solved using Dynamic Programming
 """"""
 
 function lengthoflongestcommonsubsequence(S1, S2)
     # Build a 2D matrix in Bottom-Up manner. Every element
     # dp[i][j] contains the length of the longest common subsequence
     # of S1[0 .. i] and S2[0 .. j].
     n = length(S1)
     m = length(S2)
 
     # Fill every element of the 2D matrix with 0 as value
     dp = zeros(Int, n + 1, m + 1)
 
     for i in 1:(n + 1)
         for j in 1:(m + 1)
 
             # length of LCS when one of the string is empty is zero
             if i == 1 || j == 1
                 dp[i,j] = 0
 
             # If the elements of both the strings match, then
             # the value of LCS increments by one.
             elseif S1[i - 1] == S2[j - 1]
                 dp[i,j] = dp[(i - 1),(j - 1)] + 1
             else
             # Either include the last element from one string and exclude it from the other and 
             # compare them and vice versa and pick the one giving the maximum length out of the two 
                 dp[i,j] = max(dp[(i - 1),j], dp[i,(j - 1)])
             end
         end
     end
     return dp[(n + 1),(m + 1)]
 end
 
 
 print(""Enter the first string: "")
 s1 = readline()
 print(""Enter the second string: "")
 s2 = readline()
 res = lengthoflongestcommonsubsequence(s1, s2)
 print(""The length of the longest common subsequence is "")
 print(res)
 
 
 # Time Complexity: O(n * m), where n, m are the size of the given strings
 # Space Complexity: O(n * m)
 
 # SAMPLE INPUT AND OUTPUT
 
 # Enter the first string: cuckoo
 # Enter the second string: cucumber
 # The length of the longest common subsequence is 3
",Julia
"import 'dart:io';
 
 // Calculate factorial of number
 int get_factorial(int number) {
   int count = 1;
   int factorial = 1;
 
   // Iterate from 1 till number
   while (count <= number) {
     factorial *= count;
     count++;
   }
 
   return factorial;
 }
 
 // Main Function, with driver code
 void main() {
   print(""Enter a number:"");
   int input = int.parse(stdin.readLineSync()!);
 
   // Call factorial function
   int factorial = get_factorial(input);
   print(""Factorial of $input is $factorial"");
 }
 /**
  *  Sample input/output:
  * Enter a number:
  * 5
  * Factorial of 5 is 120
  * 
  * Enter a number:
  * 12
  * Factorial of 12 is 479001600
  */
",Dart
"/* This program is the implementation of maximum subarray problem
 using Dynamic Programming in Go. In this problem we need to find a
 sub array such that its sum is maximum among the other possible
 sub arrays.*/
 
 package main
 
 import (
 	""fmt""
 	""math""
 )
 
 // This function returns maximum of two integers
 func get_max(A, B int) int {
 	if(A > B) {
 		return A
 	} else {
 		return B
 	}
 }
 
 // This function returns the sum of max sub-array
 func max_subarray_sum(size int, array []int) int {
 
 	// Variable contains minimum 64 bit int
 	var max_sum int = math.MinInt64
 	dp := 0
 
 	for i := 0; i < size; i++ {
 		/* The maximum possible sum at each step is
 		given by the recursive relation: 
 		dp[i] = maximum sub array sum in A[0.....i].
 		dp[i] = max(A[i], A[i] + Sigma(j = 0 to i-1) A[j])*/
 		dp = get_max(array[i], array[i] + dp)
 		if(max_sum < dp) {
 			max_sum = dp
 		} else {
 			continue
 		}
 	}
 	// Return the max sum
 	return max_sum
 }
 
 func main() {
 
 	// Take length of array as input from the user
 	fmt.Print(""Enter the length of the array: "")
 	var size int
 	fmt.Scan(&size)
 
 	// Take array elements as input from the user
 	array := make([]int, size)
 	fmt.Print(""Enter elements of array followed by spaces: "")
 	for i := 0; i < size; i++ {
 		fmt.Scan(&array[i])
 	}
 
 	// Call the function and print the max sub array sum
 	var maximum int = max_subarray_sum(size, array)
 	fmt.Print(""\nMax sub-array sum possible for the input array is: "", maximum)
 	fmt.Print(""\n"")
 }
 
 /*
 Sample I/O:
 
 Enter the length of the array: 6
 Enter elements of array followed by spaces: 10 -2 1 4 4 -2
 
 Max sub-array sum possible for the input array is: 17
 */
",Go
"/* Find Union and Intersection of two Sorted arrays */
 
 #include<stdio.h>
 
 /* Function for finding Union and Intersection of two Sorted array*/
 void solve()
 {
   /* Input m = size of array 1
      Input n = size of array 2 */
   int m,n;
   scanf(""%d%d"",&m,&n);
 
   /* Create a two empty array */
   int a[m],b[n];
 
   /* Input values in array 1 */
   for (int i = 0; i < m; ++i)
   {
       scanf(""%d"",&a[i]);
   }
 
   /* Input values in array 2 */
   for (int i = 0; i < n; ++i)
   {
       scanf(""%d"",&b[i]);
   }
 
   /* Finding Union */
   int i = 0, j = 0; 
 
   printf(""Union : "");
   while (i < m && j < n) 
   { 
     /* If a[i] < b[j] then print a[i] and increment i. */
     if(a[i] < b[j])
     {
       printf("" %d "", a[i]);
       i++; 
     } 
 
     /* If a[i] > b[j] then print b[j] and increment j. */
     else if(b[j] < a[i]) 
     {
       printf("" %d "", b[j]);
       j++; 
     }  
 
     /* If a[i] = b[j] then print a[i] increment both i and j. */
     else
     { 
       printf("" %d "", b[j]);
       j++; 
       i++; 
     } 
   } 
 
   /* Print remaining elements of the larger array. */
   while(i < m)
   {
     printf("" %d "", a[i]);
     i++;
   }
   while (j < n)
   {
     printf("" %d "", b[j]);
     j++;
   }
 
   printf(""\n"");
 
   /* Finding Intersection */
   int k = 0, l = 0; 
 
   printf(""Intersection : "");
   while (k < m && l < n) 
   { 
     /* If a[i] < b[j] then increment i. */
     if(a[k] < b[l]) 
     {
       k++; 
     }
     
     /* If a[i] > b[j] then increment j. */
     else if(b[l] < a[k]) 
     {
       l++; 
     }
 
     /* If a[i] = b[j] then print a[i] increment both i and j. */
     else
     { 
       printf("" %d "", b[l]);
       l++; 
       k++; 
     } 
   } 
 }  
 
 int main()
 {
   solve();
   return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
         
         5 4
         1 3 4 5 7
         2 3 5 6
 
     Output 1 :
 
         Union : 1 2 3 4 5 6 7
         Intersection : 3 5 
 
     Input 2 :
 
        ",C
"'''
 Reversing individual words of a string using stack data structure
 Algorithm/Approach:
 We iterate through the string character-by-character.
 If the current character is not a space, or not a newline character or not a null character,
 we push it into the stack
 Otherwise, we pop the elements from the stack until it's empty. 
 (Because a space or newline or null character marks the end of a word.)
 '''
 
 def reverseWords(string: str):
     ''' Prints the individual words in a reverse order '''
     stack = []
     for letter in string:
         if letter.isalnum():
             stack.append(letter)  # equivalent to stack.push()
         else:
             while stack != []:
                 print(stack.pop(), end="""")
             print(letter, end="""")
     while stack:
         print(stack.pop(), end="""")
     print()
 
 
 sentence = input(""Enter a sentence:\n"")
 print(""The sentence after reversing individual words is:"")
 reverseWords(sentence)
 
 '''
 Sample I/O:
 Enter a sentence:
 Get me food
 The sentence after reversing individual words is:
 teG em doof
 
 Time complexity = O(n) [since each pop or push takes O(1) times]
 Space Complexity = O(n)
 '''
",Python
"#include <iostream>
 
 using namespace std;
 int n, k;
 int * profit = NULL;
 int * weight = NULL;
 int ** table = NULL;
 int max_profit = 0;
 void input() {
   cin >> n;
   cin >> k;
   profit = new int[n];
   weight = new int[n];
   for (int i = 1; i <= n; i++) {
     cin >> profit[i];
     cin >> weight[i];
   }
   table = new int * [k + 1];
   for (int i = 0; i <= n; ++i)
     table[i] = new int[k + 1];
 
   for (int i = 0; i <= n; i++) {
     for (int j = 0; j <= k; j++)
       table[i][j] = -1;
   }
 }
 
 //finding maximum profit in iterative way
 void knapsack() {
   for (int j = 0; j <= k; j++)
     table[0][j] = 0;
   for (int i = 0; i <= n; i++)
     table[i][0] = 0;
   for (int i = 1; i <= n; i++) {
     for (int j = 1; j <= k; j++) {
       if (j < weight[i]) //when size of knapsack is less than weight of item i
         table[i][j] = table[i - 1][j];
       else
         table[i][j] = max(table[i - 1][j], table[i - 1][j - weight[i]] + profit[i]);
     }
   }
   max_profit = table[n][k];
 }
 
 void display() {
   cout << ""Number of items: "" << n;
   cout << endl << ""knapsack Size: "" << k;
   for (int i = 1; i <= n; i++)
     cout << endl << ""Item "" << i << "" (Prifit,Weight) is: ("" << profit[i] << "","" << weight[i] << "")"";
   cout << endl << ""Max Profit in the knapsack is: "" << max_profit;
 }
 int main() {
   // your code goes here
   input();
   knapsack();
   display();
   return 0;
 }
 
 /*
 Input:
 3
 50
 60 10
 100 20
 120 30
 
 output:
 Number of items: 3
 knapsack Size: 50
 Item 1 (Profit,Weight) is: (60,10)
 Item 2 (Profit,Weight) is: (100,20)
 Item 3 (Profit,Weight) is: (120,30)
 Max Profit in the knapsack is: 220
 
 Complexity:
 Time: O(n*k)
 Space: O(n*k)
 */",C-Plus-Plus
"/*
 Sum of pairwise bit differences
 
 For a given array arr[] of n integers, your task is to find the sum 
 of bit differences in all possible pairs which can be formed out of
 the array elements.
 Bit difference of a pair (x, y) is the count of differet bits
 in two elements at the same position in their binary representation.
 */
 
 import java.io.*;
 import java.util.*;
 
 class Pairwise_bitdiff_sum
 {
     //function to find the sum of bit difference of all posible pairs 
     static int bitdifferenceSum(int arr[])
     {
         int result = 0;
         //we fix the total number of bits to 32
         for(int pass1 = 0; pass1 < 32; pass1++)
         {
             int countBitdiff = 0;
             for(int pass2 = 0; pass2 < arr.length; pass2++)
             {
                 if((arr[pass2] & (1 << pass1)) == 0)
                 {
                     countBitdiff = countBitdiff + 1;
                 }
             }
             //countBitdiff stands for set i.e. count value 1
             // and arr_length - countBitdiff stands for unset i.e. count value 0
             result = result + (countBitdiff * (arr.length - countBitdiff) * 2);
         }
         return result;
     }
 
     //driver code
     public static void main(String[] args)
     {
         Scanner sc = new Scanner(System.in);
         int size;
         System.out.println(""Enter the size of array: "");
         int size = sc.nextInt();
         int arr[] = new int[size];
         System.out.println(""Enter the array elements: "");
         for (int i = 0; i < size; i++) {
             arr[i] = sc.nextInt();
         }
         System.out.println(""Sum of bit difference of all possible pairs made with array is: ""+bitdifferenceSum(arr));
         System.out.println("" "");
     }
 }
 
 /*
 EXAMPLE--
 Input-->
 Enter the size of array: 3
 Enter the array elements: 1, 3, 6
 Sum of bit difference of all possible pairs made with array is: 12
 
 TIME COMPLEXITY --> O(N)
 SPACE COMPLEXITY --> O(1)
 */
",Java
"/*program for calculating HCF of two number.
  *HCF is also known as Greatest Common divisor , HCF of two numbers is the largest 
  *positive integer that divides both the numbers. 
  *For example :
  *let there be two arbitrary numbers such as 30 & 90
  *30 = 3*10    ,   90 = 3*3*10  
  *Common Divisor = 3*10 = 30 
  *Here, the HCF of the two given numbers would be 30 
  *Since it divides every given number without leaving a fraction behind.
 
  *Algorithm
  * - Define two varibales -A,B
  * - Set loop from 1 to max of A,B
  * - Check if both are completely divided by same loop number, if yes, store it
  * - Display the store number is HCF */
 
 import java.util.Scanner;
 public class hcf {
   public static void main(String args[]){
        int dividend , divisor , i , hcf = 0;
        Scanner sc = new Scanner(System.in);
        // Number input from user
        System.out.println(""Enter first number : "");
        dividend = sc.nextInt();
        System.out.println(""Enter second number : "");
        divisor = sc.nextInt();
        
        for(i = 1; i <= dividend|| i <= divisor; i++) {
 	    if( dividend % i == 0 && divisor% i== 0 )
 	     hcf = i ;
        }
        System.out.println(""HCF of given two numbers is : ""+hcf);
    }
 }
 
 /*
  * Example-
  * 1.
  * Enter first number : 4
  * Enter second number : 4
  * HCF of given two number is : 4
  * 
  *  2.
  *  Enter first number : 0
  * Enter second number : 16
  * HCF of given two number is : 16 
  *
  * Time Complexity : O(n)
  * Space Complexity : O(1) 
  */",Java
"/*
 Given a Number. Find it's Sum of Divisors.
 
 The Number can be big such as 10^6 to 10^9
 So, If we do this in O(N) we will get Time Limit Exceeded [TLE]
 Better Approach is run a loop till sqrt(Number)
 Example square root of 10^9 is 31622 (approx), so iteration optimized a lot.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // this get_sum_of_divisors will count the sum of divisors of the number
 long long int get_sum_of_divisors(int Number)
 {
     /* Sum of Divisors may not fit in int range
     so better take long long int */
     long long int sum_of_divisors = 0;
     int limit = (int) sqrt(Number);
     for(int i = 1; i < limit; i++)
     {
         if(Number % i == 0)
         {
             /* Here i is a divisor of that number
             ( Number / i ) is also a divisor
             */
             sum_of_divisors += i;
             sum_of_divisors += (Number / i);
         }
     }
 
     if(Number % limit == 0)
     {
         if(limit * limit == Number)
         {
             //means perfect square number
             sum_of_divisors += limit;
         }
         else
         {
             sum_of_divisors += limit;
             sum_of_divisors += (Number / limit);
         }
     }
     return sum_of_divisors;
 }
 
 int main()
 {
     cout << ""Enter the number : \n"";
     int Number;
     cin >> Number;
     long long int sum_of_divisors = get_sum_of_divisors(Number);
     cout << ""Sum of Divisors of this Number is : "";
     cout << sum_of_divisors << endl;
 }
 
 /*
 Standard Input and Output
 
 Enter the number :
 1000000000
 Sum of Divisors of this Number is : 2497558338
 
 Enter the number :
 456723
 Sum of Divisors of this Number is : 681408
 
 Time Complexity : O( sqrt(N) )
 Space Complexity : O( 1 )
 
 */
",C-Plus-Plus
"/*
 
 Introduction 
 Given a Binary Tree , print all common ancestors of given two nodes
 It is guaranteed that given Binary Tree will have all unique node values
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 Function to find and print all common ancestors of given two nodes
 
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Utility function to print common of both given vectors
 void printCommon(vector<int>a,vector<int>b)
 {
     //As ancestors are pushed ",C-Plus-Plus
"/*    Some information about Banker's algorithm :-
 
        *  The Bankers algorithm is a resource allocation and deadlock avoidance algorithm developed by Edsger Dijkstra.
        *  The time complexity of the Banker's algorithm as a function of the number n of processes and m of resources is o(n*n*m).
        *
       Let Pbe number of process and R be number of resources.
        *  BOOLEAN function SAFESTATE is -- Determines if current state is safe
         { UNSAFE : boolean;
           AVAILABLE : array[1..R] of INTEGER
           FINISH : array[1..P] of boolean = [false, ..,false];
           I : integer;
 
         repeat
             UNSAFE = TRUE;
             for I = 1 to P do
                 if ((not FINISH[i]) and
                     NEEDi <= WORK) then {
                     WORK = WORK + ALLOCATION_i;
                     FINISH[i] = true;
                     UNSAFE = false;
                     }
                 until NOCHANGE;
             return (FINISH == (true, .., true));
        }
 */
 
 #include <stdio.h>
 
 // Calculating the remaining need of the resources for each process.
 void CalculateRemainingNeed(int process, int resource, int need[process][resource], int allocated[process][resource], int max[process][resource]){
     int i,j;
     for(i = 0; i < process; ++i){
         for(j = 0; j < resource; ++j){
             need[i][j] = max[i][j] - allocated[i][j];
         }
     }
 }
 // Checking whether all the processrocess can be executed.
 int CheckDeadlock(int process, int resource, int need[process][resource], int avail[], int allocated[process][resource], int finish[], int seq[]){
     int count = 0, i, j, k, unsafe = 1;
     while (count != process){
         unsafe = 1;
         for(i = 0; i < process; ++i){
             // Checking whether particular process is executed or not.
             if (finish[i] == 0){
                 for(j = 0; j < resource; ++j){
                     // Checking whether the need of any process is ",C
"/*
 Hashtable chaining is a collision resolution technique in hashtables
 The chaining method uses a hashtable as an array of pointers ; each pointer points a linked list.
 For a given key value , the hash address is calculated . It then searches the linked list pointed by
 the pointers at that location. If the element is found it returns the pointer to the node containing
 that key value else inserts the element at the end of that list.
 */
 import java.util.Scanner;
 
 //class for the hashtable
 class HashTable {
     int data;
     HashTable link;
 }
 
 // hash function
 class Code {
     static int hashingFunction(int value) {
         return value % 10;
     }
 
     // Chaining function inserts an element in the hashtable by hashtable chaining
     static void Chaining(HashTable t[], int value) {
         int index = hashingFunction(value);
         HashTable ptr = t[index];
         while (ptr.link != null)
             ptr = ptr.link;
         HashTable New = new HashTable();
         New.data = value;
         New.link = null;
         ptr.link = New;
     }
 
     // print_table function prints the hashtable
     static void print_table(HashTable t[]) {
         HashTable ptr = t[0];
         for (int i = 0; i < 10; i++) {
             if (ptr.link != null) {
                 System.out.print(i + "" -> "");
                 HashTable temp = ptr;
                 while (temp.link != null) {
                     temp = temp.link;
                     System.out.print(temp.data + "" "");
                 }
                 System.out.println();
             }
             ptr = t[i];
         }
     }
 
     // doesExists function searches the hashtable in the chained linked lists
     static int does_exist(HashTable t[], int value) {
         int index = hashingFunction(value);
         HashTable ptr = t[index];
         while (ptr.link != null) {
             ptr = ptr.link;
             if (ptr.data == value)
                 return 1;
         }
         retu",Java
"# Python program to check collinearity of three given points
 
 # We can calculate the area formed by the three points, and if the area is zero then they lie on a same line.
 def check_collinear(ax, ay, bx, by, cx, cy):
     """""" The Area of a Triangle formed by three points (x1, y1), (x2, y2), (x3, y3)
     is determined by the following formula
 
     Area = (1/2) * {x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)} """"""
     area = ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)
     if(area == 0):
         return True
     else:
         return False
 
 
 if __name__ == '__main__':
     print(""Enter the first co-ordinates:  "", end="""")
     ax, ay = [int(x) for x in input().split(' ')]
     print(""Enter the second co-ordinates: "", end="""")
     bx, by = [int(x) for x in input().split(' ')]
     print(""Enter the third co-ordinates:  "", end="""")
     cx, cy = [int(x) for x in input().split(' ')]
     res = check_collinear(ax, ay, bx, by, cx, cy)
     if res:
         print(""The given points are collinear"")
     else:
         print(""The given points are not collinear"")
 
 
 """"""
 Time Complexity: O(1)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the first co-ordinates:  1 1
 Enter the second co-ordinates: 2 2
 Enter the third co-ordinates:  3 3
 The given points are collinear
 """"""
",Python
"/*
     Problem Statement:-Given a sorted array of words to be searched and an array p[0.. n-1] 
     of frequency counts, where p[i] is the number of searches to keys[i]. 
     Also given an array q[0.. n-1] of frequency counts, where q[i] is the number of searches 
     for word keys[i] misspelled by the user. Construct a Binary Search Tree of all words such that 
     the total cost of all the searches(including the misspelled words) is as small as possible.
 */
 
 import java.util.*;
 
 public class Optimal_Binary_Search_tree_using_DP {
     public static void optimal_BST(int p[], int q[], String words[]){
         final int INF = 99999;
 
         //Creating the weight, cost and root matrices to get the Optimal BST
         //Weight matrix is used for creating our Cost Table
         //Cost table has values for optimal BST cost for the selected words everytime
         //root table contains the structure for Optimal BST
         int weight[][], cost[][], root[][];
         weight = new int[q.length][q.length];
         cost = new int[q.length][q.length];
         root = new int[q.length][q.length];
 
         //Creating Memoization Tables
 
         /*Recurrence Relation for Weight Table:-
             if(i == j) -> weight[i][j] = q[i]
             else -> weight[i][j] = weight[i][j-1] +q[j] + p[j-1]
         */
 
         //Filling Weight matrix diagonally
         for (int g = 0; g < q.length; g++) {
             for (int i = 0, j = g; j < q.length; j++, i++) {
                 if (i == j)
                     weight[i][j] = q[i];
                 else {
                     weight[i][j] = weight[i][j-1] +q[j] + p[j-1];
                 }
             }
         }
 
         /*Recurrence Relation for Weight Table:-
             if(i == j) -> cost[i][j] = 0
             else -> cost[i][j] = weight[i][j] + min(cost[i][k] + cost[k+1][j])    where i<=k<j
         */
 
         //Filling Cost matrix diagonally
         for (int g = 1; g < q.length; g++) {
        ",Java
"# Julia program to find the sum of divisors of a number.
 
 function sum_of_divisors(num)
     i = 1
     sum = 0
     while (i <= sqrt(num))
         if num % i == 0 && i == sqrt(num)
             sum = sum + i
         elseif num % i == 0
             sum = sum + i
             sum = sum + (num  i)
         end
         i = i + 1
     end
     return sum
 end
 
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 sum = sum_of_divisors(num)
 print(""The Sum of the Divisors of the given number is $sum."")
 
 """"""
 Time Complexity - O(n^(0.5)), where 'n' given is the number
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the number: 256
 The Sum of the Divisors of the given number is 511.
 
 SAMPLE II
 
 Enter the number: 5687
 The Sum of the Divisors of the given number is 6384.
 """"""
",Julia
"'''
 Theory-
 The diameter of a tree can be defined as the
 maximum distance between two leaf nodes.
 Here, the distance is measured in terms of the
 total number of nodes present along the path
 of the two leaf nodes, including both the leaves.
 '''
 
 
 import queue
 from sys import stdin
 
 
 class Node:
     def __init__(self, data):
         self.data = data
         self.left = None
         self.right = None
 
 
 def levelOrderInput():
     '''
     Summary Line:
     This function helps us to take level order
     input and build the tree.
 
     Args:
     No arguments
 
     Returns:
     Root- root of the tree formed using level
     order input
     '''
     tlist = list(map(int, stdin.readline().strip().split("" "")))
     start = 0
     data = tlist[start]
     start += 1
     if data != -1:
         root = Node(data)
     else:
         return None
     q = queue.Queue()
     q.put(root)
     while not q.empty():
         current = q.get()
         data = tlist[start]
         start += 1
         if data != -1:
             leftChild = Node(data)
             current.left = leftChild
             q.put(leftChild)
         data = tlist[start]
         start += 1
         if data != -1:
             rightChild = Node(data)
             current.right = rightChild
             q.put(rightChild)
     return root
 
 
 def Diameter(root):
     '''
     Summary Line:
     This function helps us to calculate the diameter
     of our tree. Diameter is the number of nodes
     between the two farthest nodes in our tree.
 
     Args:
     root- root of our inputted tree
 
     Returns-
     h- height of the tree
     d- diameter of the tree
 
     Intuition-
     Height is calculated because the diameter
     is the sum of max left and max right heights.
     '''
     if root is None:
         return 0, 0
     lh, ld = Diameter(root.left)
     rh, rd = Diameter(root.right)
     h = 1 + max(lh, rh)
     d = lh + rh
     b = max(d, max(ld, rd))
     return h, b
 
 if",Python
"/*
 A max heap has the property that the parent is greater than or equal to the child nodes. 
 When using a 0-indexed array,
 Left child of a node at i is (2 * i + 1)
 Right child of a node at i is (2 * i + 2)
 Parent is (i - 1) / 2
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 typedef struct heap{
     int currentSize, capacity;
     int *arr;
 }heap;
 
 heap * createHeap(int capacity) {
     heap *h = (heap *)malloc(sizeof(heap));
     h -> arr = (int *)malloc(capacity * sizeof(int));
     h -> currentSize = -1;
     h -> capacity = capacity;
     return h;
 }
 /* to initialize an empty heap of a given capacity */
 
 void search(heap *h, int key) {
     int index;
     for (index = 0; index <= h -> currentSize; index ++) {
         if (h -> arr[index] == key) {
             printf(""Found at position %d!\n"", index + 1);
             return;
         }
     }
     printf(""Not found!\n"");
 }
 /* to search if a given element is present in the heap or not */
 
 void swap(int arr[10], int index1, int index2) {
     int temp = arr[index1];
     arr[index1] = arr[index2];
     arr[index2] = temp;
 }
 /* to swap elements at two positions of array */
 
 void upHeapify(heap *h, int index) {
     int parent = (index - 1) / 2;
     if (h -> arr[parent] < h -> arr[index]) {
         swap(h -> arr, parent, index);
         upHeapify(h, parent);
     }
 }
 /* moving an element up the heap to satisfy the max heap property */
 
 void insert(heap *h, int value) {
     if (h -> currentSize == h -> capacity - 1) {
         printf(""Heap is full. Cannot insert\n"");
         return;
     }
     h -> arr[ ++ h -> currentSize] = value;
     upHeapify(h, h -> currentSize);
     printf(""Inserted!\n"");
 }
 /* inserting an element into the heap */
 
 void downHeapify(heap *h, int index) {
     int lChild = 2 * index + 1, rChild = 2 * index + 2, largest = index;
     if (lChild <= h -> currentSize && h -> arr[lChild] > h -> arr[largest])
         largest = lChild;
     if (rChild <= h -> cu",C
"/* Sieve of Eratosthenes : 
   
   Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to any given limit.
   It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with
   the first prime number, 2. The multiples of a given prime are generated as a sequence of numbers starting from that prime,
   with constant difference between them that is equal to that prime.
 
 */
 
 import java.util.Scanner;
 
 public class SieveOfEratosthenes {
 
 	public static void sieve(int n) {
 	
 		boolean prime[]=new boolean[n+1];
 		
 		for(int i=0;i<=n;i++) {
 			prime[i]=true;
 		}
 		
 		prime[0]=prime[1]=false;
 		
 		for(int i=2;i*i<=n;i++) {
 //	If a number is prime :	
 			if(prime[i]==true) {
 //	Marking all multiples of that number as false
 				for(int j=i*i;j<=n;j+=i) {
 					prime[j]=false;
 				}
 			}
 		}
 		
 //	Printing all prime number less than n :	
 		for(int i=0;i<=n;i++) {
 			if(prime[i]==true) {
 				System.out.print(i+"" "");
 			}
 		}
 		
 	}
 	
 	public static void main(String[] args) {
 
 		Scanner sc=new Scanner(System.in);
 		
 		System.out.print(""Enter a number : "");
 		int n=sc.nextInt();
 		
 		System.out.println(""Prime number less than or equal to ""+n+"" are : "");
 		sieve(n);
 				
 	}
 /*	
  	Sample Input : 
 	Enter a number : 100
  	
 	Sample Output : 
 	Prime number less than or equal to 100 are : 
 	2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 	
 */
 
 }
",Java
"#topological sort
 
 #a key-value pair represent a vertex and all it's outward edges.
 adjacent = {}
 #stores the list of vertex.
 Vertex = []
 # a key-value pair represents a vertex and its parent.
 parent = {}
 #stores the topological sort in reverse order.
 topological_sort = []
 
 def initalizeVertex():
     n = int(input('Enter the no. of vertices.\n'))
     print(""Enter the vertexes."")
     for i in range(n):
         vertex = input()
         Vertex.append(vertex)
         adjacent[vertex] = []
 
 def initalizeDirectedEdges():
     n = int(input(""Enter the no. of edges.\n""))
     print(""Enter the space seperated edges."")
     for i in range(n):
         a,b = input().split()
         adjacent[a].append(b)    
 
 def showVertex():
     print('The vertexes are: ')
     print(vertex)
     print('\n')
 
 def showEdges():
     print('The dictionary of edges are: ')
     print(adjacent)
     print('\n')
 
 def t_sort(s):
     for neighbour in adjacent[s]:
         if neighbour not in parent.keys():
             parent[neighbour] = s
             #stack.append(neighbour)
             t_sort(neighbour)
     topological_sort.append(s)      
 
 
 # program starts here
 
 initalizeVertex()
 initalizeDirectedEdges()  
 #showVertex()
 #showEdges()
 print('Implementing Topological Sort.')
 #for a well connected grapgh, we don't need the below for loop.
 #dfs(starting_vertex) will give correct result.
 #the below for loop is used for unconnected graphs.
 for v in Vertex:
     if v not in parent.keys():
         parent[v] = None
         t_sort(v)
 
 print('Topological sort order is: ')
 print(topological_sort[::-1])
",Python
"#include<bits/stdc++.h>
 using namespace std;
 //Function to find the minimum vertex
 int findMinVertex(int* distance, bool visited[], int n) {
 	//Initialize min value
 	int minVertex = -1;
 	for (int i = 0; i < n; i++) {
 		if (!visited[i] && (minVertex == -1 || distance[i] < distance[minVertex])) {
 			minVertex = i;
 		}
 	}
 	return minVertex;
 }
 
 //Dijkstra function
 void dijkstra(int** edges, int n) {
 	//hold the shortest distance from src to i
 	int* distance = new int[n];
 	//check if it is visited or not?
 	bool* visited = new bool[n];
 	for (int i = 0; i < n; i++) {
 		//Initialize all distances as INFINITE and visited[] as false
 		distance[i] = INT_MAX;
 		visited[i] = false;
 	}
 	distance[0] = 0;
 	//Now pick all corrosponding vertex and explore them
 	for (int i = 0; i < n - 1; i++) {
 		//finding min vertex i,e minimum then source
 		int minVertex = findMinVertex(distance, visited, n);
 		visited[minVertex] = true;
 		//Now check its Neighbour
 		for (int j = 0; j < n; j++ ) {
 			if (edges[minVertex][j] != 0 && !visited[j]) {
 				int dist = distance[minVertex] + edges[minVertex][j];
 				if (dist < distance[j]) {
 					distance[j] = dist;
 				}
 			}
 		}
 	}
 	//print the constructed distance array
 	cout << ""Vertex\tDistance from Source\n"";
 	for (int i = 0; i < n - 1; i++) {
 		cout << i << ""          "" << distance[i] << endl;
 	}
 }
 
 //Main function
 int main() {
 	//Take input from user
 	cout << ""Enter value for node and edge -"";
 	int n, e;
 	cin >> n >> e;
 	int** edges = new int*[n];
 	for (int i = 0; i < n; i++) {
 		edges[i] = new int[n];
 		for (int j = 0; j < n; j++) {
 			edges[i][j] = 0;
 		}
 	}
 	cout << ""Enter value for Adjacency Matrix -"";
 	for (int i = 0; i < e; i++) {
 		int f, s, weight;
 		cin >> f >> s >> weight;
 		edges[f][s] = weight;
 		edges[s][f] = weight;
 	}
 	//Calling  Disjkstra function
 	cout << endl;
 	dijkstra(edges, n);
 }
 
 /*
 Sample Input Output
 
 Enter value for node and edge -
 5 6
 Enter value ",C-Plus-Plus
"/*
 Given a number , check whether the number is power of 2 or not.
 We can check this by doing some bitwise operation.
 Bitwise operations are best because they perform the operation in least possible time.
 */
 
 import java.util.*;
 import java.lang.*;
 public class Powerof2 
 {
 	
 	// This function will tell us whether a number is power of 2
 	static boolean number_is_power_of_2(int number) 
 	{
 		/* if bitwise and of number and number-1 is zero
         then we can say that number is power of 2
         otherwise it is not. */
         if((number & (number - 1)) == 0)
         {
             return true;
         }
         return false;
 	}
 	public static void main(String args[]) 
 	{
 		Scanner scan = new Scanner(System.in);
 		System.out.print(""Enter the number \n"");
 		int number = scan.nextInt();
 		scan.close();
 		
 		// Calling the number_is_power_of_2 function
 		boolean result = number_is_power_of_2(number);
 		if(result) 
 		{
 			System.out.println(""The Number is power of 2\n"");
 		}
 		// else that number is not power of 2
 		else 
 		{
 			System.out.println(""No. the number is not power of 2\n"");
 		}
 	}
 }
 
 /*
 
 Standard Input and Output
 
 Enter the number
 64
 The Number is power of 2
 
 Enter the number
 34
 No. the number is not power of 2
 
 Time Complexity : O(1)
 Space Complexity : O(1)
 
 */
",Java
"/*
 Remove duplicates from an array by using DART.
 
 Given an array, remove duplicate element from it so
 that it only consists of unique elements in the array.
 */
 
 import 'dart:io';
 
 void duplicates(var array) {
   // sorting the array
   array.sort();
   for (int i = 0; i < array.length - 1; i++) {
     // checking if the next element is same
     if (array[i] == array[i + 1]) {
       array.remove(array[i + 1]);
       i -= 1;
     }
   }
 }
 
 void main() {
   var data = [];
 
   // taking input from user and storing it in data array
   var n, ele;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     data.add(ele);
   }
 
   print(""Entered List is: "");
   print(data);
 
   print(""\nList after removing duplicates: "");
   duplicates(data);
   print(data);
 }
 
 /*
 TIME COMPLEXITY: O(n)
 SPACE COMPLEXITY: O(1)
 
 SAMPLE INPUT/OUTPUT:
 Enter the number of Elements:
 5
 Enter Element 1:
 1
 Enter Element 2:
 2
 Enter Element 3:
 2
 Enter Element 4:
 1
 Enter Element 5:
 3
 Entered List is:
 [1, 2, 2, 1, 3]
 
 List after removing duplicates:
 [1, 2, 3]
 */
",Dart
"class String_to_int {
 public:
     int myAtoi(string str) {
     	if (str.empty()) return 0;
     	int i = 0, sign = 1;
     	while (i + 1 < str.size() && isspace(str[i])) ++i;
     	
 	long res = 0;
     	if (str[i] == '-' || str[i] == '+') sign = 44 - str[i++];
     
 	while (i < str.size()) {
              if (isdigit(str[i])) res = 10 * res + str[i++] - '0';
              else return res * sign;
              if (res > INT_MAX) return sign == -1 ? INT_MIN : INT_MAX;
         }
         return res * sign;
     }
 };
 
 /*
 
 TIME COMPLEXITY: 0(N) where N is length of string
 SPACE COMPLEXITY: o(1)
 TEST CASE
 
 Input: ""42""
 Output: 42
 
 Input: ""4193 with words""
 Output: 4193
 
 */
 
",C-Plus-Plus
"/*
 Golomb sequence is a non-decreasing integer sequence where n'th
 term is  equal to the number of times n appears in the sequence 
 */
 
 import 'dart:io';
 
 // Recursive golomb function
 int golomb(int n){
 
     //Base case
     if(n==1){
       return 1;
     }
     // recursive case
     return 1 + golomb(n -golomb(golomb(n - 1)));
 }
 
 // Function to add golomb sequence in a list
 int print_golomb(int n){
   List<int> dp = [];
 
   // Add golomb numbers to the list
   for(int i=1; i<n+1; i++){
     dp.add(golomb(i));
   }
 
   // Print list element at index n
   return dp.elementAt(n-1);
 }
 
 void main(){
   print(""Enter the value of 'n', where you need the n'th number in the golomb sequence:"");
   int num = int.parse(stdin.readLineSync()!);
 
   if (num <= 0){
     print(""The given value of n is invalid."");
   }
 
   // pass input to golomb calculator
   int res = print_golomb(num);
 
   print(""The ${num}th term in the golomb sequence is $res"");
 }
 
 /*
 Time Complexity: O(n), where 'n' is the given number
 Space Complexity: O(n)
 
 Sample I/O:
 
 Enter the value of 'n', where you need the n'th number in the golomb sequence:
 12
 The 12th term in the golomb sequence is 6
 
 Enter the value of 'n', where you need the n'th number in the golomb sequence:
 30
 The 30th term in the golomb sequence is 10
 
 Enter the value of 'n', where you need the n'th number in the golomb sequence:
 60
 The 60th term in the golomb sequence is 15
 */
 
",Dart
"// C Program to implement the Cutting a Rod problem
 /*  
 We are given a rod of length 'n' and the cost of the rod of different length from
 1 to n. We need to find the maximum sell price that can be obtained by cutting the rod
 at any lengths.
  
 This problem can be solved by using Dynamic Programming, 
 */
 #include <stdio.h>
 #include <limits.h>
 //Helper function to find the maximum of two values
 int max(int a, int b)
 {
     if (a > b)
         return a;
     return b;
 }
 
 // We build a dp table in bottom-up manner
 int max_sell_price(int n, int cost[])
 {
     int dp[n + 1];
     dp[0] = 0;
     for (int i = 1; i <= n; i++)
     {
         int curr_max = INT_MIN;
         for (int j = 0; j < i; j++)
             curr_max = max(curr_max, cost[j] + dp[i - j - 1]);
 
         // Stores the maximum cost achieved for a rod of length i
         dp[i] = curr_max;
     }
 
     return dp[n];
 }
 
 int main()
 {
     int n;
     printf(""\nWhat is the length of the rod? "");
     scanf(""%d"", &n);
     int cost[n], max_price;
 
     if (n <= 0)
     {
         printf(""The given rod length is Invalid!!!"");
         return 0;
     }
     // Input the cost of the rod of different length
     printf(""Enter the cost of the rod for length 1 to  %d: "", n);
     for (int i = 0; i < n; i++)
         scanf(""%d"", &cost[i]);
 
     max_price = max_sell_price(n, cost);
 
     printf(""The maximized sell price of the: "");
     // Print the maximized sell price
     printf(""%d "", max_price);
     return 0;
 }
 
 /*
 
 Time Complexity- O(n^2), where 'n' is the length of the rod
 Space Complexity- O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 What is the length of the rod? 5
 Enter the cost of the rod for length 1 to  5: 2 5 7 8 10
 The maximized sell price of the: 12 
 
 
 SAMPLE 2
 What is the length of the rod? 0
 The given rod length is Invalid!!!
 
 */
",C
"#include <iostream>
 using namespace std;
 
 //Recursion+Memoization
 int fib(int n,int dp[]){
 	//base case
 	if(n == 0 || n == 1) return n;
 	//Recursive
 	//Look Up
 	if(dp[n] != 0) return dp[n];
 
 	int ans;
 	ans = fib(n-1,dp)+fib(n-2,dp);
 	return dp[n] = ans;
 }
 
 
 int main() {
  int n;
  cin>>n;
  int dp[n+1]={0};
  cout<<""output :""<<fib(n,dp)<<endl;
 
 return 0;
 }
 
 /*
 sample input output
 input: 10
 output: 55
 */
 
 /*
 Space O(n)
 Time O(n)
 */
",C-Plus-Plus
"/*
 problem link: https://codeforces.com/problemset/problem/431/C
 
 Problem description:
 A k-tree is an infinite rooted tree where:
 - each vertex has exactly k children.
 - each edge has some weight.
 - edge weights will be in order 1,2,..k from left most child to right most child
   of every node in the tree
 
 count number of paths of total weight n (the sum of all weights of the edges in the path),
 starting from the root of a k-tree and also containing at least one edge of weight at least d
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 #define mod 1000000007
 
 int dp[105][2];
 int Number_of_Paths(int n, int k, int d, bool dcaught)
 {
 	// base case.
 	if (n == 0)
 	{
 		return dcaught == true;
 	}
 	/* memoization step: checking whether the current required answer is already caluculated or not
 	   if yes then we will simply return the answer.
 	*/
 	if (dp[n][dcaught] != -1)
 	{
 		return dp[n][dcaught];
 	}
 	// cnt variable has number of paths
 	int cnt = 0;
 	// min(n,k) is used because including edges with weight greater than n wont help us.
 	for (int weight = 1; weight <= min(n, k); weight++)
 	{
 		/* if weight is >=d then we pass decaught as true
 		   else we pass its current value only
 		*/
 		if (weight >= d)
 		{
 			cnt = (cnt % mod + Number_of_Paths(n - weight, k, d, true) % mod) % mod;
 		}
 		else
 		{
 			cnt = (cnt % mod + Number_of_Paths(n - weight, k, d, dcaught) % mod) % mod;
 		}
 	}
 	// according to dp state the required answer will be at dp[n][dcaught]
 	return dp[n][dcaught] = cnt;
 }
 
 int main()
 {
 
 	memset(dp, -1, sizeof(dp));
 	int n, k, d;
 	cin >> n >> k >> d;
 	int ans = Number_of_Paths(n, k, d, false);
 	cout << ans << endl;
 	return 0;
 }
 
 /*
 Time complexity:O(n*k)
 Space complexity:O(n)
 Input: 4 3 2
 output:6
 */
",C-Plus-Plus
"import java.util.Scanner;
 // Java program for Sparse Matrix Representation using Array 
 
 class SparseMatrix {
   public static void main(String[] args) {
     Scanner sc = new Scanner(System. in );
     System.out.println(""Input :"");
     System.out.println(""Enter the row size"");
     int row = sc.nextInt();
     System.out.println(""Enter the column size"");
     int colmn = sc.nextInt();
     int sparseMatrix[][] = new int[row][colmn];
     System.out.println(""Enter the element of 2-D matrix"");
     for (int loop = 0; loop < row; loop++) {
       for (int inloop = 0; inloop < colmn; inloop++) {
         sparseMatrix[loop][inloop] = sc.nextInt();
       }
     }
     int count = 0;
     for (int loop = 0; loop < row; loop++) {
       for (int inloop = 0; inloop < colmn; inloop++) {
         if (sparseMatrix[loop][inloop] != 0) {
           count++;
         }
       }
     }
     /* number of columns in Triplet Matrix(count) must be 
          equal to number of non - zero elements in sparseMatrix */
     int tripletMatrix[][] = new int[count][3];
     /* Making of new matrix called TripletMatrix(row,column,value)
           all the non-zero elements are stored in revised Sparse Matrix */
     int index = 0;
     for (int loop = 0; loop < row; loop++) {
       for (int inloop = 0; inloop < colmn; inloop++) {
         if (sparseMatrix[loop][inloop] != 0) {
           tripletMatrix[index][0] = loop;
           tripletMatrix[index][1] = inloop;
           tripletMatrix[index][2] = sparseMatrix[loop][inloop];
           index++;
         }
       }
     }
     System.out.println(""Output :"");
     System.out.println(""Triplet Matrix Representation :-"");
     System.out.println(""rows columns values"");
     for (int loop = 0; loop < count; loop++) {
       for (int inloop = 0; inloop < 3; inloop++) {
         System.out.print(tripletMatrix[loop][inloop]);
       }
       System.out.println();
     }
   }
 }
 /*
   Input :
   Enter the row size 
   4
   Enter the column si",Java
"/*
 The traversal operation is a frequently used operation on a binary tree. This operation is used to visit each node in the tree exactly once
 A full traversal on a binary tree gives a linear ordering of data in the tree .  This is the iterative postorder tree traversal algorithms
 */
 #include <bits/stdc++.h>
 
 using namespace std;
 //structure for the binary tree node
 class TreeNode
 {
 public:
     char data;
     TreeNode *left;
     TreeNode *right;
 };
 //structure for stack which is used for the iterative traversal algorithms
 //stack is implemented using linked list
 class Stack
 {
 public:
     TreeNode *node;
     Stack *next;
 };
 //push operation for the stack
 void push(Stack **s, TreeNode *node)
 {
     Stack *New = new Stack();
     New->node = node;
     New->next = (*s);
     (*s) = New;
 }
 // pop operation for the stack
 TreeNode *pop(Stack **s)
 {
     if ((*s) != NULL)
     {
         TreeNode *ptr = (*s)->node;
         (*s) = (*s)->next;
         return ptr;
     }
 }
 //checks whether the stack is empty or not
 int isEmpty(Stack **s)
 {
     if ((*s) == NULL)
     {
         return 1;
     }
     return 0;
 }
 //iterative postorder traversal
 void postorder(TreeNode *root)
 {
     Stack *s1 = NULL;
     Stack *s2 = NULL;
     TreeNode *ptr = root;
     push(&s1, root);
     while (!isEmpty(&s1))
     {
         ptr = pop(&s1);
         if (ptr != NULL)
         {
             push(&s2, ptr);
         }
         if (ptr->left)
         {
             push(&s1, ptr->left);
         }
         if (ptr->right)
         {
             push(&s1, ptr->right);
         }
     }
     while (!isEmpty(&s2))
     {
         printf(""%c "", pop(&s2)->data);
     }
 }
 //search function returns the pointer to the node which contains the value key , it is used in the insertion operation
 TreeNode *search(TreeNode *root, int k)
 {
     if (root == NULL)
     {
         return NULL;
     }
     else if (root->data == k)
     {
         return root;
     }
 ",C-Plus-Plus
"import java.util.Scanner;
 
 class RainWaterHarvesting {
 
     public static int saveWater(int[] arr, int size) {
 
         int result = 0;
 
         // traverse the array from second to second last element
         for (int i = 1; i < size - 1; i++) {
 
             // Find maximum element on its left
             int left = arr[i];
             for (int j = 0; j < i; j++) {
                 left = Math.max(left, arr[j]);
             }
 
             // Find maximum element on its right
             int right = arr[i];
             for (int j = i + 1; j < size; j++) {
                 right = Math.max(right, arr[j]);
             }
 
             // Update maximum water value
             result += Math.min(left, right) - arr[i];
         }
         return result;
     }
 
     public static void main(String[] args) {
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter array size:"");
         int size = scanner.nextInt();
         int[] arr = new int[size];
         System.out.println(""Enter array elements:"");
         for (int i = 0; i < size; i++) {
             arr[i] = scanner.nextInt();
         }
         scanner.close();
 
         System.out.println(""Maximum amount of water that can be saved is:"" + saveWater(arr, size));
     }
 }
 
 /*
 * Sample input/output:
 * Enter array size:
 * 10
 * Enter array elements:
 * 0 2 1 3 0 1 2 1 2 1
 * Maximum amount of water that can be saved is:5
 *
 * Time complexity: O(n^2)
 * space complexity: O(1)
 */
",Java
"/*
 Implement the basic functionality of stack using Array Data structure
 @author: Rishikeshrajrxl
 @created: 17/08/2020
 */
 
 #include <iostream>
 using namespace std;
 
 void Push();             //Function declaration
 void Peek();           
 void Pop();
 void Is_Empty();
 void Is_Full();
 void Display();
 void count();
 int stack_size,top=0,stack[100];         
 
 int main()              //Main() starts
 {
 int ch;
 cout<<""ENTER THE STACK SIZE : "";     //taking stack size initally from the user.
 cin>>stack_size;
 cout<< ""\n\n\t Implement the basic functionality of stack""<<endl;         //Displaying the Features in a tabular manner         
 cout<<""\t **************************************************""<<endl;
 do
 {
 cout<<""\t 1) Push\t \t 2) Pop ""<<endl; 
 cout<<""\t 3) Peek\t \t 4) Is_Empty""<<endl;
 cout<<""\t 5) Is_Full\t \t 6) Display""<<endl;
 cout<<""\t 7) count\t \t 8) Exit""<<endl;
 cout<<""\t ***************************************************\nENTER YOUR CHOICE : "";
 cin >>ch;
   switch(ch)
   {
     case 1:
     Push();
     break;
 
     case 2:
     Pop();
     break;
 
     case 3:
     Peek();
     break;
 
     case 4:
     Is_Empty();
     break;
 
     case 5:
     Is_Full();
     break;
 
     case 6:
     Display();
     break;
 
     case 7:
     count();
     break;
     
     case 8:
     exit(0);
     break;
     
     default:
     cout<<""Invalid Input. Please enter the Number between 1 to 8 \n""<<endl;
   }
 }while(ch!=0);
     return 0;
 }                       // Main() Ends
 //--------------------------------------------------------------------------
 void Push()             //Insertion at the top 
 {
     int ele;
     if(top==stack_size){
         cout<<""Stack is Full.""<<endl;
     }
     else{
         cout<<""ENTER THE ELEMENT :"";
         cin>>ele;
         top+=1;
         stack[top]=ele;
         cout<<""Pushed Successfully""<<endl;
     }
 }
 //---------------------------------------------------------------------------
 void Pop()   ",C-Plus-Plus
"/*
  Author : Sarthak Saxena (Sarthak-9).
  Program to evaluate PostFix Expression.Postfix is an arithmetic expression
  in which we place the operator after two operands. It has various applications.
 
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 class Node
 {
 public:
         int data;
         Node *next;
 };
 
 class Stack
 {
 private:
         Node *top;
 
 public:
         Stack();
         ~Stack();
         void push(int x);
         int pop();
         int peek(int index);
         int isEmpty();
         int isFull();
         int stackTop();
 };
 
 Stack::Stack()
 {
         top = nullptr;
 }
 
 Stack::~Stack()
 {
         Node *p = top;
         while (top)
         {
                 top = top->next;
                 delete p;
                 p = top;
         }
 }
 
 void Stack::push(int x)
 {
         Node *t = new Node;
         if (t == nullptr)
         {
                 cout << ""Stack Overflow!"" << endl;
         }
         else
         {
                 t->data = x;
                 t->next = top;
                 top = t;
         }
 }
 
 int Stack::pop()
 {
         Node *p;
         int x = -1;
         if (top == nullptr)
         {
                 cout << ""Stack Underflow!"" << endl;
         }
         else
         {
                 p = top;
                 x = p->data;
                 top = top->next;
                 delete p;
         }
         return x;
 }
 
 int Stack::isFull()
 {
         Node *t = new Node;
         int r = t ? 1 : 0;
         delete t;
         return r;
 }
 
 int Stack::isEmpty()
 {
         return top ? 0 : 1;
 }
 
 int Stack::stackTop()
 {
         if (top)
         {
                 return top->data;
         }
         return -1;
 }
 
 int Stack::peek(int index)
 {
         if (isEmpty())
         {
                 return -1;
         }
         else
         {
                 Node *p = top;
 
                 for (int i = 0; p != nullptr && i < index - 1; i++)
                 {
    ",C-Plus-Plus
"{
   ""nbformat"": 4,
   ""nbformat_minor"": 0,
   ""metadata"": {
     ""colab"": {
       ""name"": ""Naive_Bayes_Classifier.ipynb"",
       ""provenance"": [],
       ""toc_visible"": true
     },
     ""kernelspec"": {
       ""name"": ""python3"",
       ""display_name"": ""Python 3""
     },
     ""language_info"": {
       ""name"": ""python""
     }
   },
   ""cells"": [
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""j6s9d_yfmiGn""
       },
       ""source"": [
         ""# Naive Bayes Classifier in Python""
       ]
     },
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""StR2rQ6wmx86""
       },
       ""source"": [
         ""## Import Libraries""
       ]
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""cdCJCtxz-W6L""
       },
       ""source"": [
         ""# import the libraries\n"",
         ""import numpy as np\n"",
         ""import pandas as pd\n"",
         ""import matplotlib.pyplot as plt\n"",
         ""%matplotlib inline\n"",
         ""import seaborn as sns\n"",
         ""from sklearn import datasets""
       ],
       ""execution_count"": null,
       ""outputs"": []
     },
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""98oRaAjFm5i6""
       },
       ""source"": [
         ""## Import the dataset""
       ]
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""colab"": {
           ""base_uri"": ""https://localhost:8080/"",
           ""height"": 195
         },
         ""id"": ""Dga0bN4X-sNZ"",
         ""outputId"": ""a977574f-7312-4269-f887-adf66c31ab74""
       },
       ""source"": [
         ""# import the dataset\n"",
         ""iris = datasets .load_iris()\n"",
         ""df = pd.DataFrame(iris.data)\n"",
         ""df[4]=iris.target\n"",
         ""df.columns=['sepal_len', 'sepal_wid', 'petal_len', 'petal_wid', 'class']\n"",
         ""df.head()""
       ],
       ""execution_count"": null,
       ""outputs"": [
         {
           ""output_type"": ""execute_result"",
           ""data"": {
       ",Python
"def sort_matrix(mat, size):
     '''
     Takes input as unsorted matrix.
     Creates a 1-d list of len size*size and values 0.
     Sorts this list using python .sort() method.
     Then assigns these values to the original matrix.
     Parameters:
                 unsorted matrix mat
                 size of matrix
     Returns a sorted matrix of dimension size x size
     '''
     temp_mat = [0]*(size*size)
     count = 0
     for i in range(size):
         for j in range(size):
             temp_mat[count] = mat[i][j]
             count += 1
     temp_mat.sort()
 
     count = 0
     for i in range(size):
         for j in range(size):
             mat[i][j] = temp_mat[count]
             count += 1
     return mat
 
 
 def display_matrix(mat, size):
     '''
     Takes input a matrix and its size. Prints the value row wise of the matrix.
     '''
     for i in range(size):
         for j in range(size):
             print(mat[i][j], end=' ')
         print()
 
 
 if __name__ == '__main__':
     size = int(input('Enter size: '))
     mat = []
     for i in range(size):
         print(f'Enter all elements of row {i+1} separated by space: ', end='')
         row = list(map(int, input().split()))
         mat.append(row)
 
     print('Before sorting: ')
     display_matrix(mat, size)
     mat = sort_matrix(mat, size)
     print('After sorting: ')
     display_matrix(mat, size)
 
 
 # Sample Output
 
 # Enter size: 3
 # Enter all elements of row 1 separated by space: 8 3 5
 # Enter all elements of row 2 separated by space: 9 1 2
 # Enter all elements of row 3 separated by space: 4 7 6
 # Before sorting:
 # 8 3 5
 # 9 1 2
 # 4 7 6
 # After sorting:
 # 1 2 3
 # 4 5 6
 # 7 8 9
 
 
 # time complexity = O(n^2log2(n))
 # space complexity = O(n^2)
",Python
"function checkclosingParen(lastParen, currParen) {
   return (
     (lastParen === ""("" && currParen === "")"") ||
     (lastParen === ""["" && currParen === ""]"") ||
     (lastParen === ""{"" && currParen === ""}"")
   );
 }
 
 function BalancedParen(parenString) {
   let pseudoStack = []; // Using Array(object) as stack therefore named as pseudoStack
   for (let i = 0; i < parenString.length; i++) {
     if (
       parenString[i] == ""("" ||
       parenString[i] == ""["" ||
       parenString[i] == ""{""
     ) {
       pseudoStack.push(parenString[i]);
     } else {
       if (pseudoStack.length === 0) return ""Unbalanced"";
       else if (
         checkclosingParen(pseudoStack[pseudoStack.length - 1], parenString[i])
       )
         pseudoStack.pop();
       else return ""Unbalanced"";
     }
   }
   if (pseudoStack.length === 0) return ""Balanced"";
   else return ""Unbalanced"";
 }
 
 let parenString1 = ""[]{}()"";
 let parenString2 = ""[{}()]"";
 let parenString3 = ""[{()}]"";
 let parenString4 = ""][(){"";
 let parenString5 = ""[{]}"";
 
 console.log(BalancedParen(parenString1)); // Balanced
 console.log(BalancedParen(parenString2)); // Balanced
 console.log(BalancedParen(parenString3)); // Balanced
 console.log(BalancedParen(parenString4)); // Unbalanced
 console.log(BalancedParen(parenString5)); // Unbalanced
",JavaScript
"/* 
 Tim Sort:
 Sorting algorithm based on merge sort and insertion sort
 */
 
 import 'dart:io';
 import 'dart:math';
 
 void timSort(var arr, int n) {
   // Setting the RUN (arbitrary size of a section of array) size as 32
   const int RUN = 32;
 
   for (int i = 0; i < n; i += RUN) {
     // Sorting each RUN using insertion sort
     insertionSort(arr, i, min((i + RUN - 1), (n - 1)));
   }
 
   // Merging and doubling the size (initially equal to RUN) after each iteration
   for (int s = RUN; s < n; s = 2 * s) {
     // Doubling the size of subarray after every merge
     for (int left = 0; left < n; left += 2 * s) {
       // Determining the middle and last index of the subarray
       int mid = left + s - 1;
       int right = min((left + 2 * s - 1), (n - 1));
 
       // merging the subarrays
       if (mid < right) {
         merge(arr, left, mid, right);
       }
     }
   }
 }
 
 void merge(var arr, int l, int m, int h) {
   // Setting the length of the new arrays
   int n1 = m - l + 1;
   int n2 = h - m;
 
   // Creating new subarrays to store the values of the array
   List left = new List.filled(n1, null, growable: false);
   List right = new List.filled(n2, null, growable: false);
 
   // Putting the array values in the subarrays
   for (int i = 0; i < n1; i++) {
     left[i] = arr[l + i];
   }
   for (int j = 0; j < n2; j++) {
     right[j] = arr[m + 1 + j];
   }
 
   // Setting the initial index of the subarrays and actual array
   int i = 0;
   int j = 0;
   int k = l;
 
   // Sorting and placing the elements of subarrays in the main array
   while (i < n1 && j < n2) {
     if (left[i] <= right[j]) {
       arr[k] = left[i];
       i += 1;
     } else {
       arr[k] = right[j];
       j += 1;
     }
     k += 1;
   }
 
   // Storing the rest of the elements
   while (i < n1) {
     arr[k] = left[i];
     i += 1;
     k += 1;
   }
 
   while (j < n2) {
     arr[k] = right[j];
     j += 1;
     k += 1;
   }
 }
 
 void insertionSort(var arr, int l, int",Dart
"/**
  * First Negative Integer in Every Window of Size K
  * Java program to find the first negative integer in each subarray 
  * of fixed size K, given an array of integers, using the 'Sliding 
  * Window Technique'. In case there is no negative integer in given
  * window, print 0.  
  */
 
 import java.io.*;
 import java.util.*;
 
 public class FirstNegativeNumber {
 
     public static String findFirstNegativeNumber(int[] numArray, int K) {
         String str = """"; 
 
         //The ArrayDeque contains indices of all negative integers in a given 
         //window, with the first element being the index of first negative
         //integer in given window.  
         ArrayDeque<Integer> adeque = new ArrayDeque<>(); 
 		for(int i=0; i<K; i++){
 		    if(numArray[i] < 0)
 		        adeque.add(i);
 		}
  
 		for(int i=K-1; i < (numArray.length-1); i++) {
 
             //If ArrayDeque is not empty, then its first element is the index
             //of first negative integer in the current window. Once our window 
             //crosses this index, we remove it from the deque. 
 		    if(!adeque.isEmpty()) {
 		        str += (numArray[adeque.peek()] + "" ""); 
 		        if(adeque.peek() <= (i-K+1))
 		            adeque.removeFirst(); 
 		    } else {
                 //When there is no negative integer in the window
 		        str += ""0 ""; 
 		    }
 
             //Checking if the element added for the next window is negative
 		    if(numArray[i+1] < 0) 
 		        adeque.add(i+1); 
 		}
 
         // For printing the first negative integer of last window
 		if(adeque.isEmpty()) 
 		    str += ""0 ""; 
 		else 
 		    str += (numArray[adeque.peek()] + "" ""); 
 		
 		return str;
     }
     public static void main (String[] args) throws IOException {
 	    InputStreamReader read = new InputStreamReader(System.in);
 	    BufferedReader buf = new BufferedReader(read); 
 
         //Taking input from user
         System.out.println(""Enter length of array of integers:",Java
"#include<bits/stdc++.h>
 using namespace std;
 
 /*
 This algorithm is used to calculate ncr under some mod.
 ncr = factorial(n)/(factorial(r)*factorial(n-r))
 ncr%mod = factorial(n)*inverse(factorial(r))%mod*inverse(factorial(n-r)%mod)%mod (here inverse is modinverse)
 
 We use Fermat's little theorem to calculate modinverse of a value
 According to Fermat's little theorem 
 num^(p-1)=1(mod p)
 Multiplying by side by num^-1, we get
 num^(p-2)=num^-1(mod p)
 
 So, to get inverse, we need to calulate (mod-2)th power of num under modulo mod.
 */
 
 long long inverse(long long val,long long mod)
 {
     long long power=mod-2;
     long long answer=1;
     while(power>0)
     {
         if(power%2==1)
         {
             answer=(answer*val)%mod;
         }
         val=(val*val)%mod;
         power=power/2;
     }
     return answer;
 }
 
 long long ncr(long long n,long long r,long long mod)
 {
     long long facn,facr,facnr;
     long long curr_value=1;
     for(int i=1;i<=n;++i)
     {
         curr_value=curr_value*i;
         if(i==n)
         {
             facn=curr_value;
         }
         if(i==r)
         {
             facr=curr_value;
         }
         if(i==n-r)
         {
             facnr=curr_value;
         }
     }
     long long answer=facn*inverse(facr,mod)%mod*inverse(facnr%mod,mod)%mod;
     return answer;
 }
 
 int main()
 {
     long long n,r,mod;
     cout<<""Enter value of n: "";
     cin>>n;
     cout<<""Enter value of r: "";
     cin>>r;
     cout<<""Enter value of mod: "";
     cin>>mod;
     cout<<""ncr%mod = ""<<ncr(n,r,mod)<<""\n"";
 }
 
 /*
 Sample I/0
 
 1. 
     INPUT 
     Enter value of n: 3
     Enter value of r: 2
     Enter value of mod: 1
     OUTPUT
     ncr%mod = 0
 2.
     INPUT
     Enter value of n: 11
     Enter value of r: 7 
     Enter value of mod: 13
     OUTPUT
     ncr%mod = 5
 */
 
 /*
 Time Complexity: O(n)
 Space Complexity: O(1)
 */
 
",C-Plus-Plus
"// C++ program to implement Maximum Sum Decreasing Subsequence
 /*
 In this problem, given an array we have to find the maximum sum a decreasing subsequence of that array can make.
 This problem is a slight modification to the Longest Decreasing subsequence problem.
 The problem can be solved using Dynamic Programming
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 int max_sum_decreasing_subsequence(int arr[], int n)
 {
     int dp[n], max_sum = 0;
 
     /* Initialize the dp array with the array values, as the maximum sum 
        at each point is atleast as the value at that point         */
     for (int i = 0; i < n; i++)
         dp[i] = arr[i];
 
     // Now Lets Fill the dp array in Bottom-Up manner
     /* Compare Each i'th element to its previous elements from 0 to i-1, 
        If arr[i] < arr[j], then it qualifies for decreasing subsequence and
        If dp[i] < dp[j] + arr[i], then that subsequence sum qualifies for being the maximum one */
     for (int i = 1; i < n; i++)
         for (int j = 0; j < i; j++)
             if (arr[i] < arr[j] && dp[i] < dp[j] + arr[i])
                 dp[i] = dp[j] + arr[i];
 
     //Now Find the maximum element in the 'dp' array
     max_sum = *max_element(dp, dp + n);
 
     return max_sum;
 }
 
 int main()
 {
     int n, max_sum;
     cout << ""\nWhat is the length of the array? "";
     cin >> n;
     int arr[n];
     cout << ""Enter the numbers: "";
     for (int i = 0; i < n; i++)
     {
         cin >> arr[i];
     }
     max_sum = max_sum_decreasing_subsequence(arr, n);
 
     cout << ""The maximum sum of an decreasing subsequence of the given array is "" << max_sum;
     return 0;
 }
 
 /*
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 10
 Enter the numbers: 23 14 5 84 24 222 321 43 123 432
 The maximum sum of an  decreasing subsequence of the given array is 444
 
 SAMPLE 2
 
 What is ",C-Plus-Plus
"/**
  * Length of Longest Substring Without Repeating Characters
  * Given a string, print the longest possible substring that has 
  * no repeating characters, i.e., all its characters are distinct. 
  * Consider a String contains upper and lower case alphabets.
  */
 
 import java.io.*; 
 public class LongestSubstringNoRepeatingChar {
 
     //Function returns true only if each character's count 
     //is <= 1, i.e., substring is valid
     static boolean isDistinct(int[] charCount) {
         for(int i=0; i<52; i++) {
             if(charCount[i] > 1)
                 return false; 
         }
         return true; 
     }
 
     public static int findLongestSubstring(String str) {
 
         int charCount[] = new int[52]; //Maintains count of each alphabet
 
         //Variable len stores length of longest valid substring, while start and end
         //are limits of the current window (substring) being considered 
         int len = 0, start=0;
         for(int end=0; end<str.length(); ) {
             char ch = str.charAt(end); 
 
             if(ch >= 'a' && ch <= 'z') //Lower-case letter
                 charCount[ch - 'a']++; 
             else //Upper-case letter
                 charCount[ch - 'A' + 26]++;
             end++;
 
             if(isDistinct(charCount)) {
                 len = Math.max(len, end-start);
                 continue; 
             }
 
             //If there are repeating characters, we shorten substring by removing
             //characters from start, till we get a distinct substring.
             while(!isDistinct(charCount)) {
                 ch = str.charAt(start); 
                 if(ch >= 'a' && ch <= 'z')
                     charCount[ch - 'a']--; 
                 else
                     charCount[ch - 'A' + 26]--;
                 start++; 
             }
             len = Math.max(len, end-start); 
         }
         return len;
     }
     
     public static void main(String[] args) throws IOException{
      ",Java
"/*
 ""Copyright [2021] <Anshika Dubey>""
 Given a string S, compute recursively a new string where identical chars that are adjacent in the original string are separated from each other by a ""*"".
 */
 
 #include <bits/stdc++.h>
 void pairStar(char input[]) {
     int size = 0, i;
     while (input[size] != '\0')
         size++;
     if (input[0] == '\0' || size == 0)
         return;
     if (input[0] == input[1]) {
         input[size+1] = '\0';
         for (int i = size-1; i >= 1; i--) {
             input[i+1] = input[i];
         }
         input[1] = '*';
         pairStar(input+1);
     } else {
         pairStar(input+1);
     }
 }
 int main() {
    char input[100];
    std::cin.getline(input, 100);
    pairStar(input);
    std::cout << input <<std:: endl;
 }
 
 
 /*
 sample input:
 hello
 sample output:
 hel*lo
 
 Time complexity: O(n)
 */
",C-Plus-Plus
"# Level Order Traversal of a Tree
 
 
 class TreeNode:
     def __init__(self, val):
         self.val = val
         self.left = None
         self.right = None
 
 
 class Tree:
     def __init__(self, root):
         self.root = TreeNode(root)
 
     def level_order_traversal(self, root):
         nodes_visited = [root]
         path = ''
         while len(nodes_visited) > 0:
             node = nodes_visited.pop(0)
             if node.left:
                 nodes_visited.append(node.left)
             if node.right:
                 nodes_visited.append(node.right)
 
             path += str(node.val) + ' '
 
         return path
 
 
 # Creating a tree of the following structure:-
 
 #      1
 #    /   \
 #   2     3
 #  / \   / \
 # 4   5 6   7
 
 tree = Tree(1)
 
 tree.root.left = TreeNode(2)
 tree.root.right = TreeNode(3)
 
 tree.root.left.left = TreeNode(4)
 tree.root.left.right = TreeNode(5)
 tree.root.right.left = TreeNode(6)
 tree.root.right.right = TreeNode(7)
 
 # Level Order Traversal
 # In level order traversal, every node at the
 # same level is visited before moving on to the next.
 
 print(tree.level_order_traversal(tree.root))  # Expected Output:- 1 2 3 4 5 6 7
",Python
"/*
 POLYNOMIAL ADDITION USING LINKED LISTS
 2 polynomials are accepted as input from the user
 and stored in linked lists.
 Both polynomials are compared using exponents.
 If a greater exponent is found the term is stored in
 sum polynomial as such.
 If both exponents are equal sum of the coefficients
 are found and corresponding term is added to sum
 polynomial
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //linked list to store coefficients and exponents of polynomials
 typedef struct Polynomial{
     int coef;
     int exp;
     struct Polynomial* link;
 }Polynomial;
 Polynomial* poly1,*poly2;
 
 //to insert into the linked list
 Polynomial* insertAtBeginning(Polynomial* list,int co,int ex){
     Polynomial* temp;
     temp=new Polynomial;
     temp->coef=co;
     temp->exp=ex;
     temp->link=list->link;
     list->link=temp;
     return list;
 }
 
 //to print the polynomial
 void display(Polynomial* list){
     while(list->link!=NULL){
        list=list->link;
        printf(""%dx^%d"",list->coef,list->exp);
        if(list->link!=NULL)
           printf(""+"");
     }
 }
 
 //to add the given polynomials
 Polynomial* sum(Polynomial*a,Polynomial*b){
     Polynomial *sum=new Polynomial;
     Polynomial*ptr1=a->link,*ptr2=b->link,*s=sum,*new_node;
     while(ptr1!=NULL && ptr2!=NULL){
         new_node=new Polynomial;
         if(ptr1->exp>ptr2->exp){
             new_node->exp=ptr1->exp;
             new_node->coef=ptr1->coef;
             s->link=new_node;
             ptr1=ptr1->link;
         }
         else if(ptr1->exp<ptr2->exp){
             new_node->exp=ptr2->exp;
             new_node->coef=ptr2->coef;
             s->link=new_node;
             ptr2=ptr2->link;
         }
         else{
             new_node->coef=ptr1->coef+ptr2->coef;
             new_node->exp=ptr1->exp;
             s->link=new_node;
             ptr1=ptr1->link;
             ptr2=ptr2->link;
         }
         s=new_node;
         s->link=NULL;
     }
     return sum;
 }
",C-Plus-Plus
"/*
 Given an array A[] of N elements. In one operation, you can select any subarray of length 2 and multiply all 
 elements of that subarray by -1. You can do any number of operations (possibly zero). Your task is to maximize 
 the sum of all elements of all subarrays of A[].
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
     int maxSum(int n, vector<int> &arr)
     {
         int sum=0,neg_num=0,maxi=INT_MIN;
         for(int i=0;i<n;i++)
         {
             sum+=abs(arr[i])*(n-i)*(i+1);
             if(arr[i]<0)
             neg_num++;
         }
         
         // if negative elements are even in number then sum will be equal to maximum sum of all element of all subarray of given array .
         if(neg_num %2==0)
         {
             return sum; 
         }
         for(int i=0;i<n;i++)
         {
             maxi=max(maxi,sum-2*(i+1)*(n-i)*abs(arr[i]));
         }
         return maxi;    //maximum sum of subarrays
     }
 
 int main()
 {
         int N;               // length of array
         cin>>N;
         vector<int> A(N);
         for(int i=0;i<N;i++)         // input array elements
         cin>>A[i];
         cout<<maxSum(N, A)<<endl;    // function call
     
     return 0;
 }  
 
 /*
 Input:
          N = 3
          A[] = {-1, -2, -3}
          
  Output: 14
 
 Time Complexity : O(N)
 */
",C-Plus-Plus
"# CAESAR CIPHER
 
 """"""
 The Caesar Cipher technique is one of the earliest and simplest method of encryption technique. Its simply a type of
 substitution cipher,i.e., each letter of a given text is replaced by a letter some fixed number of positions down the
 alphabet. For example with a shift of 1, A would be replaced by B, B would become C, and so on. The method is apparently
 named after Julius Caesar, who apparently used it to communicate with his officials.Thus to cipher a given text we need
 an integer value, known as shift which indicates the number of position each letter of the text has been moved down.
 
 In the below code messages are encrypted with a shift of the value provided as key by users
 """"""
 
 # Decrypt Caesar Cipher Messages
 
 # Function to decrypt a caesar ciphered message
 def decrypt(text, shift):
     message = """"
 
     # Looping through all the characters present in text
     for character in range(len(text)):
 
         # Saving current character in current_character
         current_character = text[character]
 
         # If current characater is space adding it directly to message
         if current_character == ' ':
             message += current_character
             continue
 
         # If current characater is an uppercase letter adding it after shifting with key value to message
         if current_character.isupper():
             message += chr((ord(current_character) - shift - 65) % 26 + 65)
             continue
 
         # If current characater is an lowercase letter adding it after shifting with key value to message
         if current_character.islower():
             message += chr((ord(current_character) - shift - 97) % 26 + 97)
             continue
 
     # Returning the message
     return message
 
 
 # Encrypt Caesar Cipher Messages
 
 # Function to encrypt a message
 def encrypt(text, shift):
     message = """"
 
     # Looping through all the characters present in text
     for character in range(len(text)",Python
"# Calculate factorial using iterative approach
 def fact(x):
     result = 1
     for i in range(1,x):
         result = result * (i+1)
     return result
 
 # Calculate factorial using recursion
 def fact_rec(x):
     if x == 0 or x == 1:
         return 1
     else:
         return x * fact_rec(x-1)
 
 
 if __name__ == ""__main__"":
     n = int(input(""Enter the number: ""))
     print(""The factorial of {} is: {} "".format(n, fact(n)))
",Python
"'''
 Problem statement-
 Given a chain of matrices A1, A2, A3,.....An, we have to figure out the most efficient way to multiply these matrices. In other words, determine where to place parentheses to minimize the number of multiplications.
 
 You will be given an array p[] of size n + 1. Dimension of matrix Ai is p[i - 1]*p[i]. You will have to find the minimum number of multiplications needed to multiply the chain.
 
 Logical Intuition-
 We place out paranthesis in all possible positions and calculate the cost to multiply the matrices. We will store them in the array 'dp'.
 Then we will choose the minimum cost required to multiply the matrices.
 '''
 
 
 import sys
 
 
 def mcm(arr, i, j, dp):
     '''
     Summary line:
         This function helps us to find the minimum cost
         required to multiply matrices.
 
     Args:
         arr: array of dimensions of matrices
         i: starting index of arr
         j: length of arr
         dp: python list used for memoization
 
     Returns:
         Minimum cost to multiply.
 
     '''
     if i >= j: #base case
         return 0
     ans = sys.maxsize
     for k in range(i, j):
         if dp[i][k] != -1:
             ans1 = dp[i][k]
         else:
             ans1 = mcm(arr, i, k, dp)
             dp[i][k] = ans1
         if dp[k+1][j] != -1:
             ans2 = dp[k+1][j]
         else:
             ans2 = mcm(arr, k+1, j, dp)
             dp[k+1][j] = ans2
         ans3 = arr[i-1]*arr[k]*arr[j] #calculating the cost
         cost = ans1+ans2+ans3 #taking sum of cost calculated for a particular position of paranthesis
         ans = min(ans, cost) # returning the min cost
     return ans
 
 if __name__ == ""__main__"":
     n = int(input())
     arr = [int(i) for i in input().split()]
     dp = [[-1 for j in range(n+1)]for i in range(n+1)] #initalizing dp array of size nXn with -1
     print(mcm(arr, 1, n, dp))
 
 
 '''
 Sample input-
 3
 10 15 20 25
 
 Sample output-
 8000
 '''
",Python
"// Randomized sort
 
 #include <iostream>
 using namespace std;
 
 //GENERATES RANDOM NUMBER IN THE GIVEN RANGE
 int random(int min, int max) 
 {
     int range = max - min + 1;
     int num = min + (rand() % range);
     return num;
 }
 //CONVENTIONAL PARTITION
 int partition(int arr[], int p, int r) 
 {
     int x = arr[r];
     int i = p - 1;
     for (int j = p; j <= r - 1; j++)
     {
         if (arr[j] <= x)
         {
             ++i;
              //Swap arr[i] and arr[j]
             int temp = arr[i];
             arr[i] = arr[j];
             arr[j] = temp;
         }
     }
     // Swap arr[i+1] and arr[r]
     int temp = arr[i + 1]; 
     arr[i + 1] = arr[r];
     arr[r] = temp;
     return i + 1;
 }
 //RANDOMIZED PARTITION
 int randomizedPartition(int arr[], int p, int r) 
 {
     int i = random(p, r);
     int temp = arr[r];
     arr[r] = arr[i];
     arr[i] = temp;
     return partition(arr, p, r);
 }
 
 //     RANDOMIZED SELECTION ALGORITHM TO FIND i_th ORDER STATISTIC IN EXPECTED LINEAR TIME.
  //RANDOMIZED SELECT
 int randomizedSelect(int arr[], int p, int r, int i)
 {
     // Checks for base case, when array has just 1 element
     if (p == r) 
         return arr[p];
     int q = randomizedPartition(arr, p, r);
     int k = q - p + 1;
     // The pivot value is the answer
     if (i == k) 
         return arr[q];
         // If this case, the desired value lies on the lower side of partition
     else if (i < k) 
         return randomizedSelect(arr, p, q - 1, i);
     else
         return randomizedSelect(arr, q + 1, r, i - k);
 }
 
 int main()
 {
     int n, i;
     cout << ""Enter number of elements: "";
     cin >> n;
     int A[n];
     cout << ""Enter the elements: "" << endl;
     for (int i = 0; i < n; i++)
         cin >> A[i];
     cout << ""Enter i: "";
     cin >> i;
     cout << randomizedSelect(A, 0, n - 1, i) << endl;
     return 0;
 }
 
 /*
 Time complexity :O(N)
 Space complexity : O(1)
 */
 
 /*
 SAMPLE INPUT/OUTPUT
  INPUT--------",C-Plus-Plus
"/*  Introduction 
     Given Two Strings s1 and s2, determine if they are isomorphic 
     Two strings s1 and s2 are isomorphic if the characters in s1 can be replaced to get s2.
     All occurrences of a character must be replaced with another character while preserving the order of characters.
     No two characters may map to the same character, but a character may map to itself.The Length of the 2 strings will be equal.
 */
 
 /* Code/Solution */
 #include<bits/stdc++.h>
 using namespace std;
 
 // checks whether 2 strings are Isomorphic 
 bool isIsomorphic(string s1, string s2){
 	unordered_map<char,char>mp;
 	unordered_set<int>s;
 	for(int i=0;i<s1.length();i++){
 		
 	//Check if the character is present in the map
 	
 		// Case-1 If the char is found
 		if(mp.find(s1[i])!=mp.end()){
 			/*if the element is not mapped to the previously mapped character */
 			if(mp[s1[i]]!=s2[i])
 			return false; //The Strings cannot be isomorphic
 		}
 		//Case-2 If the Char of First String is not present in the map ans the char of Second string is not present in the set
 		if(mp.find(s1[i])==mp.end() && s.find(s2[i])==s.end()){
 			//Insert into map
 			mp[s1[i]]=s2[i];
 			//Insert into set
 			s.insert(s2[i]);
 		}
 		//If the char is mapped to someother element so duplicates cannot occur
 		else if(mp.find(s1[i])==mp.end() && s.find(s2[i])!=s.end())
 		return false; 
 		}
 	   return true;	
 	}
 
 // Driver Code
 int main(){
 	cout<<""Enter the Strings to check Isomorphism:""<<endl;
 	cout<<""Enter the first String :"";
 	string s1,s2;
 	cin>>s1;
 	cout<<""Enter the Second String :"";
 	cin>>s2;
 	
 	//result stores boolean value returned by isIsomorphic Function
 	bool result=isIsomorphic(s1,s2);
 	if(result==true)
 	cout<<""The given Strings are Isomorphic""<<endl;
 	else
 	cout<<""The given strings are not Isomorphic""<<endl;
 	return 0;
 }
 
 /*
 
   Sample Test Case 1:
   Input:Enter the Strings to check Isomorphism:
         Enter the first String :egg
         Enter the Sec",C-Plus-Plus
"#include<bits/stdc++.h>
 using namespace std;
 
 /* Encrypts the plain text message into a cipher 
 text by simply replacing each letter of a given 
 text by a letter 'key' places down the alphabet. */
 string encode(string plain, int key) {
 	
 	string encrypt = """";
 	int length = plain.length();
 	for(int i = 0;i < length; ++i) {
 		if(plain[i] <= 91) {
 			//uppercase letter
 			encrypt += char((plain[i] - 65 + key)%26 + 65);
 		} else if(plain[i] >= 97) {
 			//lowercase letter
 			encrypt += char((plain[i] - 97 + key)%26 + 97);
 		}
 	}
 	return encrypt;
 }
 
 /* Dencrypts the cipher text message into a plain
 text by simply replacing each letter of a given
 text by a letter 'key' places down the alphabet. */
 string decode(string cipher, int key) {
 	
 	string decrypt = """";
 	int length = cipher.length();
 	for(int i = 0;i < length; ++i) {
 		if(cipher[i] <= 91) {
 			//uppercase letter
 			decrypt += char((cipher[i] - 65 - key + 26)%26 + 65);
 		} else if(cipher[i] >= 97) {
 			//lowercase letter
 			decrypt += char((cipher[i] - 97 - key + 26)%26 + 97);
 		}
 	}
 	return decrypt;
 }
 int main() {
 	
 	int choice;
 	cout << ""Choose 1 for ENCRYPT and 2 for DECRYPT: "";
 	cin >> choice;
 	
 	string text;
 	int shift;
    	if(int(choice) == 1) {
         	cout << ""Enter message to encrypt: "";
         	cin >> text;
         	cout << ""Enter key value: "";
         	cin >> shift;
         	string encrypt = encode(text, shift);
         	cout << ""\nEncrypted message: "" + encrypt << endl;
 	}
     	else if(int(choice) == 2) {
         	cout << ""Enter message to decrypt: "";
         	cin >> text;
         	cout << ""Enter key value: "";
         	cin >> shift;
         	string decrypt = decode(text, shift);
         	cout << ""\nDecrypted message: "" + decrypt << endl;
 	}
     	else {
         	cout << ""\nWrong Choice\n"";
 	}
 }
 
 /*
  
 Sample I/O:
 
 1)
 Enter message to encrypt: NEOALGO
 Enter key value: 12
 
 Encrypted message: ZQAMXSA
 
 2)
 Choose 1 for ENCRYPT and ",C-Plus-Plus
"# Returns index of x in arr if present, else -1 
 # arr is the sorted array that is passed in the function
 # x is the element we are searching for,
 # l is the leftmost element and r the rightmost.
 def binarySearch(arr, l, r, x): 
     # Check base case 
     if r >= l: 
         mid = l + (r - l) // 2
 
         # If element is present at the middle itself 
         if arr[mid] == x: 
             return mid 
         
         # If element is smaller than mid, then it 
         # can only be present in left subarray 
         elif arr[mid] > x: 
             return binarySearch(arr, l, mid-1, x) 
 
         # Else the element can only be present 
         # in right subarray 
         else: 
             return binarySearch(arr, mid + 1, r, x) 
 
     else: 
         # Element is not present in the array 
         return -1
 
 # Driver Code 
 arr = [ 2, 3, 4, 10, 40 ] 
 x = 10
 
 # Function call 
 result = binarySearch(arr, 0, len(arr)-1, x) 
 
 if result != -1: 
     print (""Element is present at index % d"" % result) 
 else: 
     print (""Element is not present in array"") 
",Python
"/*
 Problem: The input is n x n square matrix. The output is minimum number of operations required to convert input
 matrix into the matrix in which sum of elements of each row & column is equal. One operation means incrementing any value of 
 cell of matrix by 1. Also, the converted matrix is displayed on screen.
 For Ex: I/P = 2
 1 2
 3 4
 
 O/P : 4
 4 3
 3 4
 In above example, input matrix is converted so that sum of each row and column of output matrix is 7. The minimum number of
 operations required to do so are 4.
 
 Solution: In find_min_steps function, first the sum of individual row and column is stored in 2 arrays, one for
 storing sum of rows & other for sum of columns. The maximum of both the arrays is calculated(i.e maximum of sum of cells 
 in individual rows & columns.) By iterating over the matrix and performing addition wherever required the sum of all 
 individual rows & columns is made equal to maximum sum.
 */
 
 #include<iostream>
 using namespace std ;
 
 //Function that converts matrix into matrix which contains equal row and column sum & returns number of operations required to do so.
 int find_min_steps(int fn , int **finput_matrix)
 {
     int *rowSum = NULL, *columnSum = NULL ;
     int i = 0, j = 0, maxSum = 0, operations = 0, diff = 0 ;
 
     /*
     Assigning memory to 2 sum arrays. rowSum stores the sum of cells of individual rows & columnSum stores the sum
     of cells of individual columns.
     */
     rowSum = new int[fn] ;
     columnSum = new int[fn] ;
 
     //Calculating sum of cells of each row and column and storing it in array rowSum & columnSum respectively.
     for(i=0 ; i<fn ; ++i)
     {
         for(j=0 ; j<fn ; ++j)
         {
             rowSum[i] = rowSum[i] + finput_matrix[i][j] ;
             columnSum[j] = columnSum[j] + finput_matrix[i][j] ;
         }
     }
 
     //Finding the maximum sum(i.e array element) among 2 arrays rowSum & columnSum.
     for(i=0 ; i<fn ; ++i)
     {
         maxSum = max(maxSum , ",C-Plus-Plus
"/*Problem Statement: 
 You are given a sequence of N integers A denoted by A[1] , A[2]..A[N].
 Each integer in the sequence has a value associated with it W[1],W[2]. W[N].
 You have to select a subsequence of given array A such that all the elements in A are in 
 strictly increasing order and sum of values of elements in this selected subsequence is maximum. 
 You have to print this maximum value. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void compress(int arr[], int n, map<int, int> &m, map<int, int> &rm)
 {
     sort(arr, arr + n);
     int ind = 1;
     for (int i = 0; i < n; i++)
     {
         if (m[arr[i]])
         {
             continue;
         }
 
         m[arr[i]] = ind;
         rm[ind] = arr[i];
         ind++;
     }
 }
 
 void update(int max_elements[], int arr[], int n, int index)
 {
     //traversing to get the largest value
     for (int i = arr[index]; i <= n; i += (i &(-i)))
     {
         max_elements[i] = max(max_elements[i], arr[index]);
     }
 }
 
 int query(int bit[], int max_elements[], int arr[], int w[], int n, int index)
 {
     bit[arr[index]] = max(bit[arr[index]], int(w[index]));
     int maxel = 0;
     /*Traversing the max value before the current value, 
     so that it could be added to the max sum */
     for (int i = arr[index] - 1; i > 0; i -= (i &(-i)))
     {
         maxel = max(maxel, max_elements[i]);
     }
 
     bit[arr[index]] += bit[maxel];
     return bit[arr[index]];
 }
 
 int main()
 {
     int n;
     cout << ""Enter total integers: "" << endl;
     cin >> n;
     int arr[n + 1], w[n + 1], max_elements[1000], array[n];
     int bit[1000];
     cout << ""Enter the associated values: "" << endl;
     for (int i = 1; i <= n; i++)
     {
         cin >> arr[i];
         array[i - 1] = arr[i];
     }
     for (int i = 1; i <= n; i++)
     {
         cin >> w[i];
     }
     map<int, int> m;
     map<int, int> rm;
     compress(array, n, m, rm);
     for (int i = 1; i <= n; i++)
     {
         arr",C-Plus-Plus
"# Importing sys module to initalize the maxsize
 import sys
 ''' Floyd Warshall Algorithm '''
 ''' Problem Statement :The problem is to find shortest distances
                       between every pair of vertices in a given
                       edge weighted directed Graph. The Graph is
                       represented as Adjancency Matrix, and the
                       Matrix denotes the weight of the edegs
                       (if it exists) else INF (1e7).
 '''
 # Assigning max value a variable can take
 INT_MAX = sys.maxsize - 1
 # Initialize Infinity
 INF = 9999999
 # Enter the size of the matrix
 print(""Enter the sides of the Matrix : "")
 print(""Enter the Row and the Column"")
 row = int(input(""Row:""))
 col = int(input(""Column:""))
 # Taking input of list
 print(""Enter the integers:"")
 graph = list(map(str, input().rstrip().rsplit()))
 # Convert the given list into integers
 for i in range(row*col):
     if(graph[i] == ""INF""):
         graph[i] = INF
     else:
         graph[i] = int(graph[i])
 # Constructing a Matrix.
 graph = [graph[i:i + col] for i in range(0, len(graph), col)]
 # Floyd Warshall
 
 
 def FloydWarshall(graph, row, col):
     table = list(map(lambda i: list(map(lambda j: j, i)), graph))
     # Add the vertices
     for k in range(row):
         for i in range(col):
             for j in range(row):
                 table[i][j] = min(table[i][j], table[i][k] + table[k][j])
     return(table)
 # Print List Function
 
 
 def printlist(table):
     for i in table:
         print(*i)
 FW = FloydWarshall(graph, row, col)
 print(""The shortest paths are"".format(printlist(FW)))
 '''
 Sample input:
     Enter the sides of the Matrix :
     Enter the Row and the Column
     Row:4
     Column:4
     Enter the integers:
     0 3 INF 5 2 0 INF 4 INF 1 0 INF INF INF 2 0
 Sample Output:
     The shortest paths are
     0 3 7 5
     2 0 6 4
     3 1 0 5
     5 3 2 0
 '''
",Python
"/*
 Bipartite Graph Check
 ----------------------
 Problem:
 Divide all vertices of the graph in two sets such that
 all the edges of the graph are from set1 to set2
 
 Similar to 2 coloring problem
 
 Algorithm:
 1) If graph is a tree, then YES Bipartite.
 2) If it is not a tree(=> cycle is present)
 	Odd length cycle => NOT Bipartite
 	Even length cycle => YES Bipartite
 
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 // Helper function to run dfs from src node
 bool dfs_helper(vector<int> graph[], int src, int visited[], int parentOf[], int color) {
 
 	// Mark the current node
 	visited[src] = color;
 
 	// Visit all the neighbours of src
 	for (int nbr : graph[src]) {
 		// If neighbour has not been visited yet
 		if (!visited[nbr]) {
 			// Mark src to be the parent of src
 			parentOf[nbr] = src;
 			// Instantiate dfs call at nbr
 			bool oddLenCycleFound = dfs_helper(graph, nbr, visited, parentOf, 3 - color);
 			// If odd length cycle is found at nbr, then immediately return false
 			if (oddLenCycleFound) return 0;
 		} else {
 			// nbr potentially contributes to a cycle
 			if (parentOf[src] == nbr) {
 				// Not a cycle
 			} else {
 				// Yes a cycle
 				// nbrs of src should not have same color
 				if (visited[nbr] == color) return 0;
 			}
 
 		}
 	}
 	return true;
 }
 
 bool isBipartite(vector<int> graph[], int n) {
 
 	// Keeps track of visited nodes
 	int visited[n] = {0};
 	// 0 -> Not visited
 	// 1,2 -> Visited and color is 1,2
 
 	// Stores parent of each node
 	int parentOf[n];
 	for (int i = 0; i < n; i++) {
 		parentOf[i] = i; // Initially each node is a parent of itself
 	}
 
 	bool ans = dfs_helper(graph, 0, visited, parentOf, 1);
 
 	// Print colour of each node
 	for (int i = 0; i < n; i++) {
 		cout << i << "" color="" << visited[i] << endl;
 	}
 
 	return ans;
 }
 
 int main() {
 	// n : Number of vertices
 	// m : Number of edges
 	int n, m;
 	cin >> n >> m;
 
 	// Ajacency List : graph[i] stores all the neighbours of i
 	v",C-Plus-Plus
"/* How to determine if a number is a Magic number.
    We calculate the sum of digits of the number till
    we get a single digit, recursively. If the single
    digit comes out to be 1, then we say that the number
    is a magic number.*/
 
 import java.util.*;
 
 //This function checks if a number is a magic number
 class Magicnumber{
     
     static boolean magicNumber(int n){
          
          int sum = 0;
          /*We loop till the number is greater than 0 or we
            get a single digit sum of the digits of the number*/  
          while(n>0 || sum>9){
                
                //This is the iterating step.
                if(n == 0){
                   n =sum;
                   sum = 0; 
                }
                else{
                   //We find the sum of the digits of number
                   sum += n%10;
                   n = Math.floorDiv(n,10); 
                } 
          }
 
          /*After we get a single digit sum, we check if
            it 1, then it is a magic number and we return True.*/
          if(sum == 1){
             return true;
          }
          else{
             return false;
          }
 
     }    
 
     public static void main(String[] args){
 
          Scanner scan = new Scanner(System.in);
          System.out.print(""Enter the number :"");
          //Taking input from user
          int n = scan.nextInt();
          
          //checker  
          boolean check = magicNumber(n);
          
          //If the above function returns true, it means n is Magic number 
          if(check == true)
              System.out.println(""The given number ""+n+"" is Magic number!"");
          else
              System.out.println(""The given number ""+n+"" is not Magic number!"");       
 
     }     
 
 }
 /*
     Simple I/O :
  
     a) Is a magic number!
        
        Enter the number :112222
        The given number 112222 is Magic number!
 
     b) Is not a Magic number! 
       
        Enter the nu",Java
"/*
 
 Bucket sort aka bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets.
 Algorithm -> Bucket sort works as follows -
              1) Set up an array of intially empty ""buckets""
              2) Put each object in its bucket
              3) Sort each non-empty bucket
              4) Visit the buckets in order and put all elements back into the original array
 
 Time Complexity - O(n + k), where,
                     1) O(n) is complexity of creating buckets
                     2) O(k) is complexity of sorting the buckets
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 function bucketSort(array, size) {
   // If size is not mentioned then assume it to be a random number, here 7
   if (size === undefined) size = 7;
 
   // return if array is empty
   if (array.length === 0) return array;
 
   // Get the min element from array
   let min = Math.min(...array);
   // Get the max element from array
   let max = Math.max(...array);
 
   // Define number of buckets
   let bucketCount = Math.floor((max - min) / size) + 1;
 
   // Creating a buckets of array
   const buckets = [];
   for (let i = 0; i < bucketCount; i++) buckets.push([]);
 
   // Insert elements in the buckets
   for (let k = 0; k < array.length; k++) {
     let key = Math.floor((array[k] - min) / size);
     buckets[key].push(array[k]);
   }
 
   let sorted = [];
   // Sort elements of each array and push it into the sorted array
   for (let m = 0; m < buckets.length; m++) {
     const arr = buckets[m].sort();
     for (let n = 0; n < arr.length; n++) sorted.push(arr[n]);
   }
 
   return sorted;
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let arra",JavaScript
"/**
  * Given a number and you need to check if a number is Automorphic or not. 
  * A number is called Automorphic if the square of the number ends
  * with the number itself.
  * Input:
  * First line of input contains a number of integer data type.
  * Output:
  * A single line telling whether a number is Automorphic or not.
  *
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 int Check_Automorphic(int n)
 {
     int square, temp, remainder, no_digits = 0;
     temp = n;
     square = n * n;
     int flag = 10;
 
     while (n != 0)
     {
         n = n / 10;
         no_digits++;
     }
 
     flag = pow(10, no_digits);
     remainder = square % flag;
 
     if (remainder == temp)
         return 1;
     else
         return 0;
 }
 
 int main()
 {
 
     long long int num;
     cout << ""Enter the number: "" << endl;
     cin >> num;
 
     int result = Check_Automorphic(num);
 
     if (result == 1)
         cout << num << "" is a Automorphic number. "" << endl;
 
     else
         cout << num << "" is not a Automorphic number. "" << endl;
 }
 
 /*
  * Example:
  * Input:
  * 3
  * Output:
  * 3 is not a Automorphic number.
  * 
  * Input:
  * 25
  * Output:
  * 25 is a Automorphic number.
 */
 /*
 *Time complexity : O(n) 
 *Space complexity : O(1)
 */
",C-Plus-Plus
"/* 
 Title: Memory Allocation in Operating Systems in Java
 
 Description:
 (a) First-Fit: 
 - Allocate the first hole that is big enough. 
 - Searching can start either at the beginning of the set of holes or where the previous first search ended. 
 - Stop searching as soon as we find a free hole that is large enough.
 (b) Best-Fit: 
 - Allocate the smallest hole that is big enough. 
 - Search the entire list unless the list is ordered by size.
 (c) Worst-Fit: 
 - Allocate the largest hole. 
 - Search the entire list unless the list is ordered by size.
  
 */
 
 import java.util.ArrayList;
 import java.util.Scanner;
 
 public class memory1 {
  public void first()
  {
   System.out.println(""ENTER THE NUMBER OF PROCESSES"");
         int size = s.nextInt();
         System.out.println(""ENTER THE SIZES OF PROCESSES"");
         int s1[] = new int[size];
         for (int i = 0; i < size; i++) {
           int a = s.nextInt();
           s1[i] = a;
         }
 
         System.out.println(""ENTER THE SIZE OF MEMORY BLOCK"");
         int size1 = s.nextInt();
         System.out.println(""ENTER THE MEMORY PARTITIONS"");
         int s2[] = new int[size1];
         for (int i = 0; i < size1; i++) {
           int a1 = s.nextInt();
           s2[i] = a1;
         }
         int allocation[] = new int[size];
 
         for (int i = 0; i < allocation.length; i++) //initialize to -1
         {
           allocation[i] = -1;
         }
 
         for (int i = 0; i < size; i++) {
           for (int j = 0; j < size1; j++) {
             if (s2[j] >= s1[i]) {
 
               allocation[i] = j;
               s2[j] -= s1[i];
 
               break;
             }
           }
         }   
         System.out.println(""\nProcess No.\t\tProcess Size\t\tBlock no."");
         for (int i = 0; i < size; i++) {
           System.out.print("" "" + (i + 1) + ""\t\t\t"" + s1[i] + ""\t\t\t"");
           if (allocation[i] != -1) System.out.print(allocation[i] + 1);
           else System.out.print(""N",Java
"/* Given two sequences, find the length of longest subsequence present
 in both of them. A subsequence is a sequence that appears in the
 same relative order, but not necessarily contiguous.
 For example, abc, abg, bdf, aeg, acefg, .. etc
 are subsequences of abcdefg. So, the answer will be the longest
 length i.e. 5
 */
 
 package main
 
 import ""fmt""
 
 // function to find the maximum
 func max(a, b int) int {
 	if a > b {
 		return a
 	} else {
 		return b
 	}
 }
 
 // longest common subsequence function
 func lcs(X, Y string, m, n int) int {
 	// creating 2d array
 	L := make([][]int, m+1)
 	for itr := 0; itr <= m; itr++ {
 		L[itr] = make([]int, n+1)
 	}
 
 	// bottom up fashion
 	for i := 0; i <= m; i++ {
 		for j := 0; j <= n; j++ {
 			if i == 0 || j == 0 {
 				L[i][j] = 0
 			} else if X[i-1] == Y[j-1] {
 				L[i][j] = L[i-1][j-1] + 1
 			} else {
 				L[i][j] = max(L[i-1][j], L[i][j-1])
 			}
 		}
 	}
 
 	return L[m][n]
 }
 
 func main() {
 	var str1 string
 	var str2 string
 
 	fmt.Print(""Enter the 1st string : "")
 	fmt.Scan(&str1)
 
 	fmt.Print(""Enter the 2nd string : "")
 	fmt.Scan(&str2)
 
 	m := len(str1)
 	n := len(str2)
 
 	if m < n {
 		fmt.Println(""Length of LCS is: "", lcs(str1, str2, m, n))
 	} else {
 		fmt.Println(""Length of LCS is: "", lcs(str2, str1, n, m))
 	}
 }
 
 /*
 TIME COMPLEXITY: O(M*N)
 SPACE COMPLEXITY: O(M*N)
 
 
 OUTPUT
 
 TEST CASE 1:
 Enter the 1st string : NEOALGO
 Enter the 2nd string : ALGORITHM
 Length of LCS is:  4
 
 TEST CASE 2:
 Enter the 1st string : ABQWERTYCD
 Enter the 2nd string : QWERTY
 Length of LCS is:  6
 */
",Go
"// A perfect number is a number which is equal to sum of its factors other than the number itself
 
 import java.util.Scanner;
 
 public class PerfectNumber {
     public static void main(String[] args) {
         Scanner s = new Scanner(System.in);
         System.out.print(""Enter an integer to check:"");
         int n = s.nextInt();
         if (isPerfectNumber(n)) {
             System.out.println(n + "" is a perfect number"");
         } else {
             System.out.println(n + "" is not a perfect number"");
         }
     }
 
     // Method to check if a number is a perfect number or not
     public static boolean isPerfectNumber(int number) {
         if (number < 1) {
             return false;
         }
         int sum = 0;
         for (int i = 1; i < number; i++) {
             if (number % i == 0) {
                 sum += i;
             }
         }
         return sum == number;
     }
 }
 /*
 Sample Output
 Enter an integer to check:28
 28 is a perfect number
 
 Complexities
 Time Complexity:O(n^0.5)
 Space Complexity:O(1)
  */
 
",Java
"
 /* Here we are given a directed graph and 
    we have to print all paths from the source (src) 
    to the destination (dest) of the graph.
 */
 import java.io.*;
 import java.util.*;
 
 public class Main {
     static class Edge {
         int src;
         int nbr;
         int wt;
 
         Edge(int src, int nbr, int wt) {
             this.src = src;
             this.nbr = nbr;
             this.wt = wt;
         }
     }
 
     public static void main(String[] args) throws Exception {
         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
         int vtces = Integer.parseInt(br.readLine());
         ArrayList<Edge>[] graph = new ArrayList[vtces];
         for (int i = 0; i < vtces; i++) {
             graph[i] = new ArrayList<>();
         }
 
         int edges = Integer.parseInt(br.readLine());
         for (int i = 0; i < edges; i++) {
             String[] parts = br.readLine().split("" "");
             int v1 = Integer.parseInt(parts[0]);
             int v2 = Integer.parseInt(parts[1]);
             int wt = Integer.parseInt(parts[2]);
             graph[v1].add(new Edge(v1, v2, wt));
             graph[v2].add(new Edge(v2, v1, wt));
         }
 
         int src = Integer.parseInt(br.readLine());
         int dest = Integer.parseInt(br.readLine());
 
         boolean[] visited = new boolean[vtces];
         printAllPaths(graph, src, dest, visited, src + """");
     }
 
     // src -> source
     // dest -> destination
     // psf -> path so far
     public static void printAllPaths(ArrayList<Edge>[] graph, int src, int dest, boolean[] visited, String psf) {
         // When the destination vertex is reached print contents of path so for (psf).
         if (src == dest) {
             System.out.println(psf);
             return;
         }
         // Keep storing the visited vertices in an array (visited here) so that the
         // traversal doesnt go in a cycle
         visited[src] = true;
         // traverse throu",Java
"# Implementing stacks using linked list
 
 
 class Node(object):
     def __init__(self, value):
         self.value = value
         self.next = None
 
 
 class Stack(object):
     def __init__(self):
         self.head = None
         self.num_elements = 0
 
     def push(self, value):
         new_node = Node(value)
 
         if self.head is None:
             self.head = new_node
         else:
             new_node.next = self.head
             self.head = new_node
 
         self.num_elements += 1
 
     def size(self):
         return self.num_elements
 
     def is_empty(self):
         return self.num_elements == 0
 
     def pop(self):
         if self.is_empty():
             return None
 
         value = self.head.value
         self.head = self.head.next
         self.num_elements -= 1
         return value
 
 if __name__ == '__main__':
     # Initialize stacks with some values
     stack = Stack()
     stack.push(10)
     stack.push(20)
     stack.push(30)
     stack.push(40)
     stack.push(50)
 
     # Test size()
     print (""Pass"" if (stack.size() == 5) else ""Fail"")
 
     # Test pop()
     print (""Pass"" if (stack.pop() == 50) else ""Fail"")
 
     # Test push()
     stack.push(60)
     print (""Pass"" if (stack.pop() == 60) else ""Fail"")
     print (""Pass"" if (stack.pop() == 40) else ""Fail"")
     print (""Pass"" if (stack.pop() == 30) else ""Fail"")
     stack.push(50)
     print (""Pass"" if (stack.size() == 3) else ""Fail"")
",Python
"""""""
     Purpose: Total number of diffrent binary tree that can be
             made using n keys/nodes.
             We will be using Dynamic Programming
     Intution: Total number of diffrent Binary Trees with N nodes
                 = Catalan(N)*N!
 """"""
 
 # Catalan_Number (N) = ((2*N)!) / ((N+1)!*N!)
 # Binary Tree = Catalan_Number(N)*N!
 
 # Global Variables
 MOD = 10**9+7
 facto = [1]  # Factorial Table
 
 # To construct the factorial numbers using DP
 
 
 def factorial(n):
     global facto
     for i in range(1, n+1):
         facto += [(facto[-1]*i) % MOD]
 
 
 # For Modular Inverse of num with respect to 10^9+7
 def Mod_Inv(num):
     return pow(num, MOD-2, MOD)
 
 
 def Catalan_Number(num):
     if num == 0 or num == 1:
         return 1
 
     Numerator = facto[2*num]
     Denominator = (facto[num+1]*facto[num]) % MOD
 
     Catalan = (Numerator * Mod_Inv(Denominator)) % MOD
     return Catalan
 
 
 def Binary_Trees(N):
     # Constructing Factorial Table
     factorial(2*N)
 
     # Nth Catalan Number
     Cat = Catalan_Number(N)
     return Cat*facto[N]
 
 # ------------------------DRIVER CODE ------------------------
 
 if __name__ == ""__main__"":
     n = int(input(""Enter the number of distinct nodes: ""))
     print(""Total number of Binary Tree = "", Binary_Trees(n))
 
 '''
 Time Complexity:  O(n)
 Space Complexity: O(n)
 '''
 
 """"""
 SAMPLE INPUT/OUTPUT
 
 Enter the number of distinct nodes: 5
 Total number of Binary Tree =  5040
 
 Enter the number of distinct nodes: 10
 Total number of Binary Tree =  60949324800
 
 """"""
 
",Python
"/*
 Trimming Binary Tree
 
 You are given root of the binary search tree 
 and the low and high points, your task is to trim the tree
 so that all its elements lies in low to high range only.
 Trimmimg the tree should not change the relative structure 
 of the elements which will remain in the treeYou need to 
 return the root of the trimmed binary search tree. 
 Note that the root may change depending on the given bounds.
 */
 
 import java.io.*;
 import java.util.Scanner;
 import java.util.*;
 
 //defining a class for storing nodes of tree
 class BTNode 
 {
     int value;
     BTNode left;
     BTNode right;
     BTNode() 
     {}
     BTNode(int value) 
     {
         this.value = value; 
     }
     BTNode(int value, BTNode left, BTNode right) 
     {
         this.value = value;
         this.left = left;
         this.right = right;
     }
 }
 
 public class Trimming_binary_tree
 {
     //function to trim the binary tree
     public BTNode trimBinaryTree(BTNode root, int low, int high)
     {
         //we use recursive approach 
         
         //if the root is empty then the root itself is returned
         if (root == null) 
         {
             return root;
         }
 
         //when BTNode.value will be greater than high 
         //then we know that the trimmed binary tree 
         //would occur to the eft of the node.
         if (root.value > high) 
         {
             return trimBinaryTree(root.left, low, high);
         }
 
         //similarly, when BTNode.value will be less than 
         //low value, then the trimmed binary tree occurs
         //on the right of the node.
         if (root.value < low) 
         {
             return trimBinaryTree(root.right, low, high);
         }
 
         //otherwise, we trim both the sides of the 
         //tree
         root.left = trimBinaryTree(root.left, low, high);
         root.right = trimBinaryTree(root.right, low, high);
 
         //returning the trimmed root
         return root;
 ",Java
"/*
 POLYNOMIAL ADDITION USING ARRAYS
 2 polynomials are accepted as input from the user
 and stored in arrays.
 The degree of the larger polynomial is found and stored in l
 The 2 polynomial arrays are traversed from the end till one
 of the 2 polynomials reaches the beginning
 The coefficients are added and stored in an array sum
 The remaining, terms if present in any polynomial, are added
 to the sum array.
 */
 
 #include <stdio.h>
 
 //to add the 2 polynomials
 void add_polynomials(int *a, int *b, int n, int m)
 {
     int l, i, j, k;
     l = n > m ? n : m;
     int *sum = (int *)malloc(sizeof(int) * l);
 
     //initialize sum array
     for (i = 0; i <= l; i++)
         sum[i] = 0;
     i = n, j = m, k = l;
 
     //add the coefficients of like power terms
     while (i >= 0 && j >= 0)
     {
         sum[k--] = a[i--] + b[j--];
     }
 
     //add the remaining coefficients to sum
     if (i >= 0)
         while (i >= 0)
             sum[k--] = a[i--];
     else if (j >= 0)
         while (j >= 0)
             sum[k--] = b[j--];
             
     //display sum
     printf(""SUM\n"");
     for (i = 0; i <= l; i++)
     {
         printf(""%dx^%d"", sum[i], l - i);
         if (i != l)
             printf("" + "");
     }
 }
 
 //driver code
 int main()
 {
     //accept the polynomials as user input
     int n, m, i;
     printf(""Enter the degrees of the polynomials: "");
     scanf(""%d%d"", &n, &m);
     int *poly1 = (int *)malloc(sizeof(int) * n);
     int *poly2 = (int *)malloc(sizeof(int) * m);
     printf(""Enter the coefficients of first polynomial from highest to least power:\n"");
     for (i = 0; i <= n; i++)
         scanf(""%d"", &poly1[i]);
     printf(""Enter the coefficients of second polynomial from highest to least power:\n"");
     for (i = 0; i <= m; i++)
         scanf(""%d"", &poly2[i]);
     add_polynomials(poly1, poly2, n, m);
     return 0;
 }
 
 /*
 SAMPLE I/O
 Enter the degrees of the polynomials: 3 4
 Enter the coefficients of first polynomial from",C
"/*
 If the ratio of any two consecutive terms is always same for a series, then the 
 given series is said to be in Geometric Progression.
 
 In the below code we check if a given list of elements is in GP or not.
 */
 
 import 'dart:io';
 import 'dart:math';
 
 bool checkGP(List arr, int n) {
   if (n == 1) return true;
 
   // Calculate ratio
   int r = arr[1] ~/ arr[0];
 
   // Check if the ratio is common between the consecutive elements
   for (int i = 1; i < n; i++) {
     if ((arr[i] / (arr[i - 1])) != r) {
       return false;
     }
   }
   return true;
 }
 
 main() {
   // Driver code to take user input
   var array = [];
 
   var n, ele;
   print('Enter the number of elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter value for element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
 
   print('The given list of elements is: $array');
 
   if (checkGP(array, n))
     print('The given series is in GP');
   else
     print('The given series is not in GP');
 }
 
 /*
 
 TIME COMPLEXITY: O(N)
 SPACE COMPLEXITY: O(1)
 
 SAMPLE I/O:
 Enter the number of elements: 
 6
 Enter value for element 1: 
 2
 Enter value for element 2: 
 6
 Enter value for element 3: 
 18
 Enter value for element 4: 
 54
 Enter value for element 5: 
 162
 Enter value for element 6: 
 486
 The given list of elements is: [2, 6, 18, 54, 162, 486]
 The given series is in GP
 
 */
",Dart
"#=Given an Array you need to find the maximum sum of all the 
 subarrays. Subarrays are consecutive elements of the array.
 There are a total of n*(n+1)/2 subarrays in an array with 
 n elements. Out of all these sub arrays find the subarray with
 the maximum sum. Kadane's Algorithm helps us to do this in 
 the least time complexity.=#
 
 ## Function
 
 function maxSubArray(array)
     best = 0
     sum = 0
     for i in array
         sum = max(i, sum + i)
         best = max(sum, best)
     end
     return best
 end
 
 ## Input
 
 n = readline()
 n = parse(Int64, n)
 arr = Int64[]
 for i = 1:n
     temp = readline()
     temp = parse(Int64, temp)
     push!(arr, temp)
 end
 
 ## Calling the function
 
 print(maxSubArray(arr))
 
 #=
 Sample test case:
 Input:
     n = 5
     array = 2 -3 5 4 -7
 Output:
     9
 
 Time complexity: O(N)
 =#
",Julia
"/*Convert the BST into a Min Heap with the condition that all the values in the left subtree of a 
 node should be less than all the values in the right subtree of the node. */
 
 #include <bits/stdc++.h>
 using namespace std;
  
 struct Node
 {
     int data;
     Node *left, *right;
 };
  
 /*  Function to allocate a new node with the given data and NULL left and right pointers. */
 struct Node* getNode(int data)
 {
     struct Node *newNode = new Node;
     newNode->data = data;
     newNode->left = newNode->right = NULL;
     return newNode;
 }
  
 
 void preorderTraversal(Node*);
  
 void inorderTraversal(Node *root, vector<int>& arr)
 {
     if (root == NULL)
         return;
  
     inorderTraversal(root->left, arr);
  
     arr.push_back(root->data);
  
     inorderTraversal(root->right, arr);
 }
  
 void BSTToMinHeap(Node *root, vector<int> arr, int *i)
 {
     if (root == NULL)
         return;
  
     root->data = arr[++*i];
     
  //for left subtree
     BSTToMinHeap(root->left, arr, i);
  
  //for right subtree
     BSTToMinHeap(root->right, arr, i);
 }
  
 // To convert the given BST to MIN HEAP
 void convertToMinHeapUtil(Node *root)
 {
     // vector to store the data of all the
     // nodes of the BST
     vector<int> arr;
     int i = -1;
  
     // inorder traversal
     inorderTraversal(root, arr);
  
     // BST to MIN HEAP conversion
     BSTToMinHeap(root, arr, &i);
 }
  
 //  preorder traversal 
 void preorderTraversal(Node *root)
 {
     if (!root)
         return;
  
     // print the root's data first
     cout << root->data << "" "";
  
     // recur on left subtree
     preorderTraversal(root->left);
  
     // recur on right subtree
     preorderTraversal(root->right);
 }
 void convert(int keys[], int low, int high, Node* &root)
 {
     // base case
     if (low > high) {
         return;
     }
  
     // finding the middle element of the current range
     int mid = (low + high) / 2;
  
     // constructing a new node from the middle e",C-Plus-Plus
"/*
 Minimum XOR value problem in C
 Given an integer array A of N integers, find the minimum XOR value made by a  pair of integers in the array.
 */
 
 #include <stdio.h>
 #include <limits.h>
 #include <stdlib.h>
 
 //Comparator function used by qsort
 int compare(const void *a, const void *b)
 {
     return (*(int *)a - *(int *)b);
 }
 
 void min_xor(int *arr, int n)
 {
     //Temporary variables to store the pair of elements
     int a, b;
     //res will store the minimum xor value
     int res = INT_MAX;
     for (int i = 0; i < n - 1; i++)
     {
         //x will store xor value for each possible pair of elements of array
         int x = arr[i] ^ arr[i + 1];
         if (x < res)
         {
             res = x;
             a = arr[i];
             b = arr[i + 1];
         }
     }
     printf(""The Minimum xor value is : %d \n"", res);
     printf(""The corresponding pair of elements are : %d  and  %d "", a, b);
 }
 
 int main()
 {
     //Input the size of the array
     int n;
     printf(""Enter the size of array : "");
     scanf(""%d"", &n);
     printf(""Enter the array : "");
     int arr[n];
     for (int i = 0; i < n; i++)
         scanf(""%d"", &arr[i]);
     //Sort the array in ascending order
     qsort(arr, sizeof(arr) / sizeof(*arr), sizeof(*arr), compare);
     min_xor(arr, n);
     return 0;
 }
 
 /*
 Time Complexity : O(n * logn), where 'n' is the size of the array
 Space Complexity : O(1)
 
 SAMPLE INPUT AND OUTPUT  
 
 Enter the size of array : 4
 Enter the array : 1 2 3 4
 The Minimum xor value is : 1 
 The corresponding pair of elements are : 2  and  3
 */
",C
"// Transpose of a square matrix is obtained by changing the rows to columns and vice-versa.
 #include <bits/stdc++.h>
 using namespace std;
 
 
 
 void transpose(int *a,int N){
     int i,j;
     for( i=0;i<N;i++){
         for( j=i+1;j<N;j++){
             int temp;
             temp = *(a+ j *N + i);
             *(a+ j *N + i) = *(a+ i *N + j);
             *(a+ i *N + j) = temp;
         }
     }
 }
 
 int main() {
     int N;
     cout<<""Enter the dimension of the matrix:"";
     cin>>N;
 
     int a[N][N];
     cout<<""Enter the elements of the matrix:"";
     for(int i=0;i<N;i++){
         for(int j=0;j<N;j++){
             cin>>a[i][j];
         }
     }
 
     transpose(a[0],N);
 
     cout<<""The transpose of the given matrix is:""<<endl;
     for(int i=0;i<N;i++){
         for(int j=0;j<N;j++){
             cout<<a[i][j]<<"" "";
         }
         cout<<endl;
     }
 
     return 0;
 }
 
 /* Sample I/O
 
 Enter the dimension of the matrix:3
 Enter the elements of the matrix:1 2 3 4 5 6 7 8 9
 The transpose of the given matrix is:
 1 4 7
 2 5 8
 3 6 9
 
 
 Time Compexity: O(n^2)
 Space Complexity: O(1)
 */
",C-Plus-Plus
"/*
 Hashtable chaining is a collision resolution technique in hashtables
 The chaining method uses a hashtable as an array of pointers ; each pointer points a linked list.
 For a given key value , the hash address is calculated . It then searches the linked list pointed by
 the pointers at that location. If the element is found it returns the pointer to the node containing
 that key value else inserts the element at the end of that list.
 */
 #include <stdio.h>
 #include <stdlib.h>
 //structure for the hashtable
 typedef struct HashTable
 {
     int data;
     struct HashTable *link;
 } HashTable;
 //hash function
 int hashingFunction(int value)
 {
     return value % 10;
 }
 
 //Chaining function inserts an element in the hashtable by hashtable chaining
 void Chaining(HashTable *t, int value)
 {
     int index = hashingFunction(value);
     HashTable *ptr = t + index;
     while (ptr->link != NULL)
         ptr = ptr->link;
     HashTable *New = (HashTable *)malloc(sizeof(HashTable));
     New->data = value;
     New->link = NULL;
     ptr->link = New;
 }
 //print_table function prints the hashtable
 void print_table(HashTable *t)
 {
     HashTable *ptr = t;
     for (int i = 0; i < 10; i++)
     {
         if (ptr->link != NULL)
         {
             printf(""%d -> "", i);
             HashTable *temp = ptr;
             while (temp->link != NULL)
             {
                 temp = temp->link;
                 printf(""%d "", temp->data);
             }
             printf(""\n"");
         }
         ptr++;
     }
 }
 //doesExists function searches the hashtable in the chained linked lists
 int does_exist(HashTable *t, int value)
 {
     int index = hashingFunction(value);
     HashTable *ptr = t + index;
     while (ptr->link != NULL)
     {
         ptr = ptr->link;
         if (ptr->data == value)
             return 1;
     }
     return 0;
 }
 // Main function
 int main()
 {
     HashTable *t = (HashTable *)malloc(sizeof(HashTable) * 11);
     for (int i = 0",C
"/*
 	Take as input N, the size of array. Take N more inputs and store that in an array.
 	Take as input target, a number.
 	Write a function which prints all triplets of numbers which sum to target.
 
 For example
 input:
 	9
 	5 7 9 1 2 4 6 8 3
 	10
 	output:
 	1, 2 and 7
 	1, 3 and 6
 	1, 4 and 5
 	2, 3 and 5
 */
 package main
 
 import (
 	""fmt""
 	""sort""
 )
 
 func sumTriplets(arr []int, targetSum int) {
 	left, right := 0, 0
 
 	arrayLength := len(arr)
 
 	// it will count the number of triplets
 	count := 0
 
 	if arrayLength == 0 {
 		// corner case
 		fmt.Println(""Array is empty"")
 	} else {
 		for i := 0; i < arrayLength-2; i++ {
 
 			// Initial condition
 			// index for first element is i
 			// index for second element is 0
 			// index for third element is index of last element
 			left = 0
 			right = arrayLength - 1
 
 			for left < right {
 
 				sum := arr[i] + arr[left] + arr[right]
 
 				// if the sum of all three elementsis equal to targetSum
 				// we should print it and then move forward
 				// to next element by breaking the inner loop
 				if sum == targetSum {
 					fmt.Printf(""Triplet is %d %d %d\n"", arr[i], arr[left], arr[right])
 					count++
 					break
 				} else if sum < targetSum {
 					// if the sum is less than targetSum we should
 					// increase the left index for the next element
 					left++
 				} else {
 					// if the sum is greater than targetSum we should
 					// decrease the right index for the next element
 					right--
 				}
 			}
 		}
 	}
 	// if there is no triplet exist
 	if count == 0 {
 		fmt.Println(""Sorry couldn't found any triplets with target sum"")
 	}
 }
 
 func main() {
 	var length int
 	fmt.Println(""please enter the number of element"")
 	fmt.Scanf(""%d"", &length)
 
 	// making the slice of size length
 	array := make([]int, length)
 	fmt.Println(""enter the space separated elements"")
 	for i := 0; i < length; i++ {
 		fmt.Scanf(""%d"", &array[i])
 	}
 
 	// sort the array in ascending order
 	sort.I",Go
"'''
 INTRODUCTION
 
 The code below calculates and returns the next prime number from the number given by user.
 It takes a number n from user and returns a number x such that
 1. x is greater than n
 2. x is a prime number and 
 3. there are no prime numbers between n and x 
 
 '''
 
 def next_prime(n):
 	# looping from next number to find if it prime or not
 	x = n+1
 	while True:
 		flag = False
 		# checking whether x is divisible by numbers from 2 to it's half
 		for y in range(2,x//2+1):
 			if x%y==0:
 				x+=1
 				flag = True
 				break
 		if flag==False:
 			return(x)
 
 n = int(input(""Enter a number : ""))
 print('Next prime number is ', next_prime(n))
 
 '''
 OUTPUT
 
 Enter a number : 23
 Next prime number is  29
 
 
 TIME COMPLEXITY : O(n)
 SPACE COMPLEXITY : O(1)
 '''
",Python
"/*
  *         Description
  *      
  *   Problem:  Finding median of two sorted array
  *  
  * we will have two sorted arrays of size N and M respectively and element in array, which can be duplicated.
  * we will find median of array without merging the two arrays.
  * example:  A = [1, 5, 8]
  *           B = [1,2, 3,9]
  *          merged : [1,2,3,4,5]  (If we merge, we have to use extra space)
  *          output : 3.0
  *          
  *  If we merge the job is so simple. In this case TC O(N+M) , SC O(N+M)
  *  but we will apply binary search which will do it in TC O(log(max-min)*(logm+logn)), SC O(1).    
  * 
  */
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Scanner;
 public class MedianOfArray {
 	public static double findMedianSortedArrays(final List<Integer> a, final List<Integer> b) {
 		int i, n = a.size(), m = b.size();
 		int low = 0, high = 0;
 		//Handling Edge Case
 		if (n == 0) {
 			low = b.get(0);
 			high = b.get(m - 1);
 		} else if (m == 0) {
 			low = a.get(0);
 			high = a.get(n - 1);
 		} else {
 			low = Math.min(a.get(0), b.get(0));
 			high = Math.max(a.get(n - 1), b.get(m - 1));
 		}
 		//Main Code
 		int k = ((n + m) / 2);
 		double d1 = 0.0, d2 = 0.0;
 		d1 = getAns(low, high, a, b, k);
 		
 		//check for even length median
 		if ((n + m) % 2 == 0) {
 			d2 = getAns(low, high, a, b, k - 1);
 			System.out.println((d1 + d2) / 2);
 			return (d1 + d2) / 2;
 		} else {
 			System.out.println(d1);  //odd length median
 			return d1;
 		}
 	}
 	public static double getAns(int low, int high, List<Integer> a, List<Integer> b, int k) {
 		int mid = 0;
 		while (low <= high) {
 			mid = (high - low) / 2 + low;
 			int p = countLess(a, mid) + countLess(b, mid);
 			int q = countEqual(a, mid) + countEqual(b, mid);
 			if (p > k)
 				high = mid - 1;
 			else {
 				if (p + q <= k)
 					low = mid + 1;
 				else
 					return mid;
 			}
 
 		}
 		return mid;
 	}
 	public static int countLess(List<Integer> a, int x) {
 	",Java
"/*
 Write an algorithm to determine if a number n is happy.
 
 A happy number is a number defined by the following process:
 
 Starting with any positive integer, replace the number by the sum of the squares of its digits.
 Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
 Those numbers for which this process ends in 1 are happy.
 
 Example:
 
 Input: n = 19
 Output: true
 Explanation:
 12 + 92 = 82
 82 + 22 = 68
 62 + 82 = 100
 12 + 02 + 02 = 1
 */
 #include <iostream>
 using namespace std;
 
 class Happy {
     int n;
 public:
     void set_data(){
         cout<<""Enter the number you want to check""<<endl;
         cin>>n;
     }
     bool isHappy(int n) {
         if (n==1)
             return true;
         else if (n!=7 and n < 10)
             return false;
         else
             return isHappy(sq_of_dig(n));
         return false;
     }
     int sq_of_dig(int n){
         int s=0;
         while(n!=0){
             int d= n%10;
             s=s+d*d;
             n=n/10;
         }
         return s;
     }
     void display(){
         if(isHappy(n))
             cout<<""Yes its a happy number"";
         else
             cout<<""No its not a happy number"";
     }
 };
 int main()
 {
     Happy h;
     h.set_data();
     h.display();
 
     return 0;
 }
 /*
 Enter the number you want to check
 Input: 19
 Output: Yes its a happy number
 
 Enter the number you want to check
 Input: 2
 Output: No its not a happy number
 */
",C-Plus-Plus
"/*
 
 Three sum closest to target
 
 You will be given an array of integers arr[], and a target value
 and your task will be to find three such elements whose sum comes
 the closest to the target value.
 The output will be the sum of the set of three numbers whose sum comes is the
 closest to target value.
 
 */
 
 import java.util.*; 
 import java.util.Arrays; 
 
 class 3sum_closest_to_target
 {
     //function to find the closest sum
     public int 3sumClosest(int arr[], int target)
     {
         //storing result
         int res = arr[0] + arr[1] + arr[arr.length-1];
 
         Arrays.sort(arr);
 
         //using two pinter approach
         for(int i = 0; i<arr.length-2; i++)
         {
             int leftptr = i+1;
             int rightptr = arr.length-1;
             while(leftptr<rightptr)
             {
                 int sum = arr[i] + arr[leftptr] + arr[rightptr];
                 if(sum > target)
                 {
                     rightptr--;
                 }
                 else {
                     leftptr++;
                 }
                 if(Math.abs(sum-target) < Math.abs(res-target))
                 {
                     res = sum;
                 }
             }
         }
         return res;
     }
 
     //driver method
     public static void main(String []args)
     {
         Scanner sc = new Scanner(System.in); 
 
         System.out.println(""Enter the size of the array: ""); 
         int size = sc.nextInt(); 
 
         System.out.println(""Enter the target value: ""); 
         int target = sc.nextInt();
 
         int arr[] = new int[size]; 
         System.out.println(""Enter the elements of array: ""); 
         for(int i = 0; i < size; i++) 
         { 
             arr[i] = sc.nextInt(); 
         } 
 
         System.out.println(""Closest sum is: "");
         System.out.print(3sumClosest(arr, target));
 
     }
 }
 
 /* 
 
 EXAMPLES:-
 
 Example 1:
 Input--
 Enter the size of the array: 4
 Enter the target value",Java
"// C Program to find the Sum of Digits of a given number
 #include <stdio.h>
 
 int sum_of_digits(int num)
 {
     int S = 0;
     while (num != 0)
     {
         // Extracting the digits from the number
         int rem = num % 10;
         S += rem;
         // Removing the extracted digit
         num = num / 10;
     }
     return S;
 }
 
 int main()
 {
     int num, sum;
     printf(""\nEnter the number: "");
     scanf(""%d"", &num);
 
     // If the number is negative, convert it into positive
     if (num < 0)
     {
         num = num * -1;
     }
 
     // Call the function
     sum = sum_of_digits(num);
     // Print the obtained sum
     printf(""The sum of the digits of the given number is: %d"", sum);
     return 0;
 }
 
 /*
 
 Time Complexity- O(log(num)), where 'num' is the given num
 Space Complexity- O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number: 1231
 The sum of the digits of the given number is: 7
 */
",C
"def sum(array, initial, to):
     total = 0
     for i in range(initial, to + 1):
         total += array[i]
     return total
 
 
 def partition(array, N, K):
     if K == 1:
         return sum(array, 0, N - 1)
     if N == 1:
         return array[0]
     best = 100000000
     for i in range(1, N + 1):
         best = min(best,
                    max(partition(array, i, K - 1),
                        sum(array, i, N - 1)))
     return best
 N, K, T = map(int, input(""Enter array size, number
                          of painters and time: "").split())
 x = list(map(int, input(""Enter board sizes:"").split()))
 res = partition(x, N, K)
 print(""Minimum time required to paint all the boards: "" + str(res * T))
 
 """"""
 Example 1:
 Sample Input:
 Enter array size, number of painters and time: 2 2 5
 Enter board sizes: 1 10
 Minimum time required to paint all the boards: 50
 
 Time complexityL O(k*N^3) (Exponential)
 """"""
",Python
"/*
 An expression is called prefix , if the operator appears in the expression before the operands. (operator operand operand)
 An expression is called postfix , if the operator appears in the expression after the operands . (operand operand operator)
 The program below accepts an expression in prefix and outputs the corresponding postfix expression .
 */
 #include <bits/stdc++.h>
 using namespace std;
 // if operand function checks if the element is an operand
 int ifoperand(char c)
 {
     if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))
     {
         return 1;
     }
     return 0;
 }
 // prefixtopostfix function converts a prefix expression to postfix
 void prefixtopostfix(string expression)
 {
     stack<string> s;
     int len = expression.length();
     for (int i = len - 1; i >= 0; i--)
     {
         if (ifoperand(expression[i]))
         {
             s.push(string(1, expression[i]));
         }
         else
         {
             string exp(1, expression[i]);
             string op1 = s.top();
             s.pop();
             string op2 = s.top();
             s.pop();
             string temp = op1 + op2 + exp;
             s.push(temp);
         }
     }
     cout << ""the postfix expresssion is : "" << s.top();
 }
 // Driver code
 int main()
 {
     string exp;
     printf(""Enter the prefix expression \n"");
     cin >> exp;
     prefixtopostfix(exp);
     return 0;
 }
 
 /*
 Sample I/O:
 
 Enter the prefix expression
 *+abc
 the postfix expresssion is : ab+c*
 
 Time complexity : O(n)
 space complexity : O (n)
 */
",C-Plus-Plus
"/*
 Length of the longest palindromic subsequence in a string
  ALGORITHM
  *Reverse the string
  *Find the longest common subsequence between the string and its reverse
  */
 #include<bits/stdc++.h>
 using namespace std;
 int longestPalinSubseq(string X,int n)
 {
     string Y=X;
     reverse(Y.begin(),Y.end());
     
     int dp[n+1][n+1];
     //Base conditions
     for(int i=0;i<n+1;i++)
     {
         for(int j=0;j<n+1;j++)
         {
             if(i==0 || j==0)
             dp[i][j]=0;
         }
     }
     for(int i=1;i<n+1;i++)
     {
         for(int j=1;j<n+1;j++)
         {
             if(X[i-1]==Y[j-1])
             dp[i][j]=1+dp[i-1][j-1];
             else
             dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
         }
     }
     return dp[n][n];
 }
 int main()
 {
     string X;
     cin>>X;
     int n=X.length();
     cout<<longestPalinSubseq(X,n)<<""\n"";
 }
 /*
 Time complexity:O(n^2)
 INPUT:
 X=ayan
 OUTPUT:
 3
 */
",C-Plus-Plus
"""""""
     Takes an array of integers sorted in ascending order, a target value and
     finds the starting and ending position of a given target value.
     We will be using Binary Search:
 
 """"""
 
 
 def Binary_Search(nums, target, flag=0):
     """"""
     - Returns the initial found index position of the target value
       if flag is set to 0 (Default)
     - Returns Starting Positon of the target value if flag is set to -1
     - Returns Ending Positon of the target value if flag is set to 1
 
     If the target is not present in the list of numbers,
     -1 is returned irrespective of the flag value
     """"""
     pos = -1
     low, high = 0, len(nums) - 1
     while low <= high:
         mid = (low + high) // 2
         if nums[mid] == target:
             # Checking if target is at mid position
             pos = mid
             if flag == -1:
                 high = mid - 1
             elif flag == 1:
                 low = mid + 1
             else:
                 return pos
         elif nums[mid] < target:
             # Checking if target is greater than the number at mid position
             low = mid + 1
         else:
             high = mid - 1
     return pos
 
 
 def search_range(nums, target):
     """"""
     Performs Binary Search on nums and returns a list of two elements:
     - [<First Positon of the target elemet>, <Last Positon of the target elemet>]
 
     Returns [-1, -1] if the target not exists in the list of numbers
     """"""
     starting_position = Binary_Search(nums, target, -1)
     ending_position = -1
     if starting_position != -1:
         ending_position = Binary_Search(nums, target, 1)
     return [starting_position, ending_position]
 
 
 if __name__ == ""__main__"":
     list_of_nums = [int(x) for x in input().split()]
     key = int(input())
     print(search_range(list_of_nums, key))
 
 # Sample Input-Output:
 # Input 1:
 # 5 7 7 8 8 10
 # 8
 # Output 1: [3,4]
 # The target 8 is found first at index 3
 # and last at index 4 in",Python
"/* 
 	 A string is a pangram if the string contains all the English alphabet letters.
 	 Given a string , the task is to check whether that string is pangram or not.
 	 
 	 Input: str = The quick brown fox jumps over the lazy dog
 	 Output: Yes
 		
 	 Input: str = We promptly judged antique ivory buckles for the prize
 	 Output: No
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int pangram(string &str)
 {
     //map to store the frequency of each alphabet
     map<char, int> frequency;
     //To count number of alphabets
     int count = 0;
     //If 26 alphabets are not present,pangram is impossible
     if (str.size() < 26)
         return -1;
     else
     {
 
         for (int i = 0; i < str.size(); i++)
         {
             //Ignore spaces
             if (str[i] == ' ')
                 continue;
             //Convert each letter to upper case
             str[i] = toupper(str[i]);
             //If the alphabet is not present in frequency map
             if (!frequency[str[i]])
             {
                 //Increase the frequency and the count of alphabets
                 frequency[str[i]]++;
                 count++;
             }
         }
     }
     //26 means all alphabets are present
     if (count == 26)
         return 1;
     else
         return -1;
 }
 int main()
 {
     cout << ""Enter the string:"";
     string s;
     //To get the entire string
     getline(cin, s);
     int result = pangram(s);
 
     if (result == 1)
         cout << ""Yes,the string is a pangram"";
     else
         cout << ""No,the string is not a pangram"";
 
     return 0;
 }
 
 /* 
     Input: str = The quick brown fox jumps over the lazy dog
     
     Output: Yes
 */
 
 /*
 
 	Time Complexity: O(N), where N is the length of the string.
 	Auxiliary Space: O(N),as we have used a map
 */
",C-Plus-Plus
"//double factorial  of a number n (denoted by n!!) is the product of all the integers from 1 up to n that have the same parity(odd or even) as n.
 
 //algorithm to find the double factorial of a number n in O(n) time complexity and O(1) space complexity
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int Recursive(int num)   //recursive approach
 {
     if (num == 0 || num == 1) 
         {
             return 1;
         }
     return num * Recursive(num - 2);
 }
 
 int Iterative(int num)   // Iterative approach
 {
     int ans = 1;
     for (int i = num; i >= 0; i = i - 2) 
     {
         if (i == 0 || i == 1) 
         {
             return ans;
         } 
         else 
         {
             ans *= i;
         }
     }
     return ans;
 }
 
 int main() {
     //taking input from the user
     int num;
     cout << ""Please Enter a number\n"";
     cin >> num;
     cout << ""Which way would you like to use?\n"";
     cout << ""1. Iterative\n"";
     cout << ""2. Recursive\n"";
     int way;
     cin >> way;
     if (way == 1)
     {
         cout << Iterative(num) << endl;
     }
     else if (way == 2)
     {
         cout << Recursive(num) << endl;
     }
     else
     {
         cout << ""Invalid choice"" << endl;
     }    
     
     
     return 0;
 }
 
 /*
   Sample input/output
   Enter the number:
   13
   Which way would you like to use?
   1 Iterative
   2 Recursive
   
   Output  = 135135
  */
",C-Plus-Plus
"/*
 
 A JavaScript program for creating a well known data structure ""Hash Table"". A hash table (often called a hash map) is a data structure 
 that maps keys to values. Hash tables combine lookup, insert, and delete operations in an efficient way. Hash tables can perform in constant time.
 In the worst-case scenario, the performance of hash tables can be as low as O(n).
 
 In this program, user can provide a choice to perform operations on a Hash Table. It is created using a ES6 class syntax. 
 prompt & colors are node packages for taking user input and displaying text in different colors respectively. 
 
 */
 
 const prompt = require(""prompt-sync"")({ sigint: true });
 const colors = require(""colors"");
 
 // Setting the Color schema
 colors.setTheme({
   display: ""green"",
   insert: ""white"",
   delete: ""red"",
   leave: ""yellow"",
   end: ""rainbow"",
   wrong: ""america"",
 });
 
 class HashTable {
   constructor(size) {
     // Set Hash Table size
     this.data = new Array(size);
   }
 
   // Generate a location using simple hash logic
   _hash(key) {
     let hash = 0;
     for (let i = 0; i < key.length; i++) {
       // Location mapping
       hash = (hash + key.charCodeAt(i) + i) % this.data.length;
     }
 
     return hash;
   }
 
   // Set the location of item in hash
   set(key, value) {
     let address = this._hash(key);
     if (!this.data[address]) {
       this.data[address] = [];
     }
 
     // Insert item at the desired location with [key, value] pair
     this.data[address].push([key, value]);
     return this.data;
   }
 
   // Get the location of item in hash table
   get(key) {
     let address = this._hash(key);
     const currentBucket = this.data[address];
     // Item at the location is not found , return undefined
     if (!currentBucket) return undefined;
 
     if (currentBucket.length) {
       for (let i = 0; i < currentBucket.length; i++) {
         if (currentBucket[i][0] === key) {
           return {
             data: [currentBucket[i",JavaScript
"/*
 -SRTF(Shortest Remaining Time First) is the preemptive version of SJF scheduling. 
 -In SRTF, the execution of the process can be stopped after certain amount of time. 
 -At the arrival of every process, the short term scheduler schedules the process 
 with the least remaining burst time among the list of available processes and the 
 running process.
 */
 
 import java.util.Scanner;
 
 class process {
     int arrivalTime, burstTime, completionTime, turnaroundTime, waitingTime, remainingTime;
     int id;
     String name;
 
     process() {
         arrivalTime = 0;
         burstTime = 0;
         completionTime = 0;
         turnaroundTime = 0;
         waitingTime = 0;
         name = "" "";
     }
 }
 
 public class CPU_Scheduling_SRTF {
     public static void main(String[] args) {
         Scanner SC = new Scanner(System.in);
         int num;
         int total_time = 0;
         float average_waiting_time = 0;
         float average_turnaround_time = 0;
         int min, select;
 
         System.out.println(""Enter no of processes: "");
         num = SC.nextInt();
 
         process process[] = new process[20];
 
         for (int i = 0; i < num; i++) {
             process[i] = new process();
             System.out.println(""Enter burst time: "");
             process[i].burstTime = SC.nextInt();
             process[i].remainingTime = process[i].burstTime;
             System.out.println(""Enter arrival time: "");
             process[i].arrivalTime = SC.nextInt();
             System.out.println(""Enter name of process: "");
             process[i].name = SC.next();
         }
 
         for (int i = 0; i < num; i++) {
             total_time = total_time + process[i].burstTime; // Calculation of total time
         }
 
         System.out.println(""Total time: "" + total_time);
 
         String gantt[] = new String[total_time]; // Array of gantt chart
 
         for (int i = 0; i < total_time; i++) {
             min = total_time;
             select = 0;
",Java
"/*
 Problem statement : 
 There is a fence with n posts, you are given k colors to paint the fence. 
 Each post can be painted with one of the k colors. You have to paint all the posts 
 with the k colors such that atmost two adjacent posts have the same color. 
 You have to find the total number of ways to paint the fence.
 */
 
 import java.util.Scanner;
 
 class Code {
     // paintfence function uses permutations to find the number of ways of painting
     // fences
     static int paintfence(int n, int k) {
         int total, diff, same;
         same = k;
         diff = k * (k - 1);
         total = k * k;
         for (int i = 1; i < n - 1; i++) {
             same = diff;
             diff = total * (k - 1);
             total = same + diff;
         }
         return total;
     }
 
     public static void main(String[] args) {
         int n, k;
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the number of posts"");
         n = sc.nextInt();
         System.out.println(""Enter the number of colors"");
         k = sc.nextInt();
         System.out.println(""The number of ways of painting the fence is : "" + paintfence(n, k));   
     }
 }
 
 /*
 Sample I/O:
 Enter the number of posts
 3
 Enter the number of colors
 2
 The number of ways of painting the fence is : 6
 
 Time complexity : O(n)
 Space complexity : O(1)
 */
",Java
""""""" Julia Program to implement the Cutting a Rod problem
   
 We are given a rod of length 'n' and the cost of the rod of different length from
 1 to n. We need to find the maximum sell price that can be obtained by cutting the rod
 at any lengths.
  
 This problem can be solved by using Dynamic Programming
 """"""
 
 # Build a dp Table in Botom-Up manner, such that the n'th element stores
 # the maximum price obtained by a rod of length 'n'
 function max_sell_price(m, cost)
     dp = zeros(Int, n + 1)
     for i in 1:n
         curr_max = -1
         for j in 0:(i - 1)
             # Maximum Price obtained by cutting a rod of length zero is zero
             if ((i - j - 1) == 0)
                 curr_max = max(curr_max, cost[j + 1])
             else
                 curr_max = max(curr_max, cost[j + 1] + dp[i - j - 1])
             end
         end
         #  Stores the maximum cost obtainable for a rod of length i
         dp[i] = curr_max
     end
     return dp[n]
 end
 
 print(""What is the length of the rod? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""The given rod length is Invalid!!!"")
     exit()
 end
 cost = Int[]
 print(""Enter the cost of the rod for length 1 to $n :  "")
 cost = [parse(Int, num) for num in split(readline())]
 max_price = max_sell_price(n, cost)
 print(""The maximized sell price of the: $max_price"")
 
 
 """"""
 Time Complexity- O(n^2), where 'n' is the length of the rod
 Space Complexity- O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the rod? 5
 Enter the cost of the rod for length 1 to 5: 2 5 7 8 10
 The maximized sell price of the: 12 
 
 SAMPLE 2
 
 What is the length of the rod? -3
 The given rod length is Invalid!!!
 
 """"""
",Julia
"# Program to calculate the depth of a Tree
 # Note that the levels start from 0(Zero).
 
 
 class TreeNode:
     def __init__(self, val):
         self.val = val
         self.left = None
         self.right = None
 
 
 class Tree:
     def __init__(self, root):
         self.root = TreeNode(root)
 
     def get_node_depth(self, node, val, depth):
         if node is None:
             return -1
 
         if node.val is val:
             return depth
 
         l_depth = self.get_node_depth(node.left, val, depth+1)
         r_depth = self.get_node_depth(node.right, val, depth+1)
 
         return max(l_depth, r_depth)
 
     def get_maximum_depth(self, node, depth):
         if node is None:
             return -1
 
         l_depth = 1 + self.get_maximum_depth(node.left, depth+1)
         r_depth = 1 + self.get_maximum_depth(node.right, depth+1)
 
         return max(l_depth, r_depth)
 
 
 # Creating a tree of the following structure:-
 
 #      1
 #    /   \
 #   2     3
 #  / \   / \
 # 4   5 6   7
 
 tree = Tree(1)
 
 tree.root.left = TreeNode(2)
 tree.root.right = TreeNode(3)
 
 tree.root.left.left = TreeNode(4)
 tree.root.left.right = TreeNode(5)
 tree.root.right.left = TreeNode(6)
 tree.root.right.right = TreeNode(7)
 
 # Printing the depth of each node
 for i in range(1, 8):
     print(tree.get_node_depth(tree.root, i, 0))
     # Should print : 0 1 1 2 2 2 2
 
 # Printing the maximum depth of the tree
 print(""Maximum Depth: "", tree.get_maximum_depth(tree.root, 0))
 # Should print: 2
 
 # Print -1 for the depth if the node is not present in the tree
 print(""If element not present"", tree.get_node_depth(tree.root, 10, 0))
 # Should print: -1
",Python
"/*
 Given a number's base and power.
 return the number.
 base and power can be large as 10^6 to 10^9
 so we need to mod with some big number in order to get the number
 this can be done by bigmod algorithm
 */
 
 #include <stdio.h>
 #include <math.h>
 
 // this get_new_number_by_bigmod will give us the new number
 long long int get_new_number_by_bigmod(long long int base, long long int power, long long int mod_number)
 {
     long long int new_number;
     if(power == 0)
     {
         // no matter what base is , as power is 0 answer 1
         return 1;
     }
     else if(power % 2 == 0)
     {
         /* as power is even,
         we will divide the power each step by 2
         9^18 will be 9^9 , 9^9
         and thus goes on  by recursive call
         */
         new_number = get_new_number_by_bigmod(base , power / 2, mod_number);
         return ((new_number * new_number) % mod_number);
 
     }
     else
     {
          /* as power is odd,
         we will  take power - 1
         9^15 = 9^14 , 9^1
         and thus goes on  by recursive call
         */
         long long int temp = get_new_number_by_bigmod(base , power - 1 , mod_number);
         return ((( base % mod_number)* temp)% mod_number);
 
     }
 }
 
 int main()
 {
     printf(""Enter the base number and power number : "");
     long long int base , power;
     scanf(""%lld %lld"", &base, &power);
     printf(""Enter the mod number: "");
     long long int mod_number;
     scanf(""%lld"", &mod_number);
 
     long long int new_number = get_new_number_by_bigmod(base, power, mod_number);
 
     printf(""After applying Bigmod algorithm the new number is : \n"");
     printf(""%lld \n"", new_number);
 }
 
 /*
 Standard Input and Output
 
 Enter the base number and power number :
 45 67
 Enter the mod number: 1000456
 
 After applying Bigmod algorithm the new number is :
 595941
 
 Time Complexity : O( log N )
 Space Complexity : O( 1 )
 
 */
",C
"/*
 The program is to check whether a given number is a special number or not.
 A special number is a number whose all digits are 1
 Example-11,111
 */
 import java.util.*;
 class special
 {
      static void number(int x)
     {
 
         int s=0,c=0;
         while(x!=0)
         {
             int b=x%10;
 	     /*sum of digits*/
             s=s+b;
          /*count of digits*/
             c++;
             x=x/10;
         }
          /*If the sum of digits and count
          of digits is equal 
          then special*/
         if(s==c)
         System.out.println(""The given number is special"");
         else
         System.out.println(""The given number is not special"");
     }
     public static void main()
     {
         Scanner sc=new Scanner(System.in);
 	  /*Input number 
         which is to be checked*/
         System.out.println(""Enter the number"");
         int n=sc.nextInt();
         number(n);
     }
 }
 
 /*
 Time Complexity:O(n)
 Space Complexity:O(1)
 Input/Output:-
 Enter the number 
 1111
 The given number is special
 */
",Java
"#=Given a number N, find its factorial using recursion. It is quite easy
 but we want to add recursion algorithms in Julia.=#
 
 ## Function 
 
 function fact(n)
     if (n == 0)
         return 1
     end
     if (n == 1)
         return 1
     end
     return n * fact(n - 1)
 end
 
 ## Input
 
 n = readline()
 n = parse(Int64, n)
 
 ## Calling the Function
 
 fact(n)
 
 #=
 Sample Test Case:
 Input:
     n=10
 Output:
     3628800
 Time complexity: O( N )
 =#
",Julia
"#Python Program for Target Sum of Triplets
 #In this we have to enter range for the input and take input from the user and set target and generate unique triplets for that
 def targettriplets(lst, rang, target):   
     lst.sort() # Sorting the list in ascending order
     i = 0
     for i in range(rang):
         left = i + 1
         right = rang - 1
         current = lst[i]
         while left < right:
             if current + lst[left] + lst[right] == target: # Checking for the sum if it's equal to target
                 print(current, ' ',lst[left], ' ', lst[right])
                 left += 1
                 right -= 1
             elif current + lst[left] + lst[right] < target: # Checking sum is less than target if it is then increment left
                 left += 1
             else: # Otherwise decrement right
                 right -= 1  
                 
 lst = []
 rang = int(input('Enter the Range for the Triplet:'))  
 for i in range(rang):
     inp = int(input()) # Taking the input from the user
     lst.append(inp) # Appending the input elements at the end of the list
 op = int(input('Enter the target for triplet:'))
 print('The Target Triplet is')
 targettriplets(lst, len(lst), op)   
 
 """"""Input and Output
 Enter the Range for the Triplet:9
 1
 3
 4
 2
 5
 9
 6
 7
 8
 Enter the target for triplet:10
 1   2   7
 1   3   6
 1   4   5
 2   3   5
 """"""
",Python
"/*
 	Sieve of Atkin is a modern algorithm for finding all prime numbers up to a
 	specified integer. Compared with the ancient Sieve of Eratosthenes, which
 	marks off multiples of primes, the Sieve of Atkin does some preliminary work
 	and then marks off multiples of squares of primes, thus achieving a better 
 	theoretical asymptotic complexity.
  	
  	We are going to check the following condition and according to that we
  	decide prime numbers
  	a) a = (4*i*i)+(j*j) has odd number of  
        solutions, i.e., there exist 
        odd number of distinct pairs (i, j)  
        that satisfy the equation and 
         n % 12 = 1 or n % 12 = 5. 
     b) n = (3*i*i)+(j*j) has odd number of  
        solutions and n % 12 = 7 
     c) n = (3*i*i)-(j*j) has odd number of  
        solutions, i > j and n % 12 = 11 
 	   
 */
 
 
 #include<iostream>		//Header file
 using namespace std;	//For cin and cout
 
 
 int Sieve_Of_Atkin(int n) 
 { 
     // Printing 2 and 3 as prime numbers 
     if (n > 2) 
         cout << 2 << "" ""; 
     if (n > 3) 
         cout << 3 << "" ""; 
     // Creating a array of boolean type of size n and
 	// initialize it with false value    
     bool sieve[n]; 
     for (int i = 0; i < n; i++) 
         sieve[i] = false; 
 		
 	// Iterating over the numbers
 	//If it is prime we make sieve[a]=true  
     for (int i = 1; i * i < n; i++) { 
         for (int j = 1; j * j < n; j++) { 
               
             // Making equations for prime numbers 
             int a = (4 * i * i) + (j * j); 
             if (a <= n && (a % 12 == 1 || a % 12 == 5)) 
                 sieve[a] = true; 
   
             a = (3 * i * i) + (j * j); 
             if (a <= n && a % 12 == 7) 
                 sieve[a] = true; 
   
             a = (3 * i * i) - (j * j); 
             if (i > j && a <= n && a % 12 == 11) 
                 sieve[a] = true; 
         } 
     } 
   
     // Mark all multiples of squares as non-prime 
     for (int k = 5; k * k < n; k++) { 
   ",C-Plus-Plus
"/*
  
  * Dart Program to find Binary Exponent Iteratively and Recursively. 
   
  * Here we calculate a^b using two different methods: iteratively and recursively
  
  */ 
 
 import 'dart:io';
 
 // Iterative function to calculate exponent.
 
 int binExpo_iterate(int a, int b) {
   int res = 1;
   while (b > 0) {
     if (b % 2 != 0) {
       res = res * a;
     }
     a = a * a;
     b = (b / 2).floor();
   }
   return res;
 }
 
 // Recursive function to calculate exponent.
 
 int binExpo_recurse(int a, int b) {
   if (b == 0) {
     return 1;
   }
   int res = binExpo_recurse(a, (b / 2).floor());
   if (b % 2 != 0) {
     return res * res * a;
   } else {
     return res * res;
   }
 }
 
 // Main function
 
 void main() {
   print(""Lets calculate Binary Exponent a^b"");
   print(""Enter a"");
   int a = int.parse(stdin.readLineSync()!);
 
   print(""Enter b"");
   int b = int.parse(stdin.readLineSync()!);
 
   if (a == 0 && b == 0) {
     print(""Math Error"");
   } else if (b < 0) {
     print(""Exponent must be Positive"");
   } else {
     int resIterate = binExpo_iterate(a, b);
     int resRecurse = binExpo_recurse(a, b);
 
     print(""a^b calculated iteratively: $resIterate"");
     print(""a^b calculated recursively: $resRecurse"");
   }
 }
 
 /**
 Sample Input and Output :
 
 Lets calculate Binary Exponent a^b
 Enter a
 3
 Enter b
 5
 a^b calculated iteratively: 243
 a^b calculated recursively: 243
 
 
 Time complexity = O(n)
 Space complexity = O(1)
  */
",Dart
"/*Problem Statement: 
 You are given a tree with cycle present in it. Your task is to remove the cycle and make it into 
 a Linked List */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int cycle = 0;
 class Node
 {
     public:
         int data;
     Node * next;
 
     Node(int num)
     {
         data = num;
         next = NULL;
     }
 };
 
 void addToTail(Node* &head, Node *nodeToAdd)
 {
     int flag = 0;
     Node * save;
     if (head == NULL)
     {
         head = nodeToAdd;
         return;
     }
 
     Node *temp = head;
     while (temp->next != NULL)
     {
         if (temp->data == nodeToAdd->data)
         {
             flag = 1;
             save = temp;
         }
 
         temp = temp->next;
     }
 
     if (flag == 0)
     {
         temp->next = nodeToAdd;
     }
     else
     {
         temp->next = save;
         cycle = 1;
     }
 }
 
 void print(Node *head)
 {
     Node *tmp = head;
     while (tmp != NULL)
     {
         cout << tmp->data << ""-->"";
         tmp = tmp->next;
     }
 
     cout << endl;
 }
 
 Node* createTree()
 {
     int num;
     Node *head = NULL;
 
     while (cin >> num && num != -1)
     {
         if (cycle == 1)
         {
             break;
         }
 
         Node *newNode = new Node(num);
         addToTail(head, newNode);
     }
 
     return head;
 }
 
 Node* detectcycle(Node *head)
 {
     Node *temp = head;
     Node *temp1 = head;
     while (temp != NULL)
     {
         temp = temp->next;
         temp1 = temp1->next->next;
         /*If temp1 pointer meets the temp pointer before reaching NULL, 
          then cycle is present */
         if (temp == temp1)
         {
             break;
         }
     }
 
     return temp1;
 }
 
 void breakcycle(Node *head, Node *node1)
 {
     if (node1 == head)
     {
         Node *kk = head->next;
         /*While the next node of the current node doesn't reach the head node,
         because that will be the cycle point */
         while (kk->next",C-Plus-Plus
"/*
 Introduction 
 Given a Binary Tree , Print it in Zig Zag level order.
 (i.e., from left to right, then right to left for the next level and alternate between).
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 // Function to print Tree in zig zag level order
 void ZigZagLevelOrderTraversal(struct Node* root)
 {
     // If root is NULL , return 
     if (root == NULL)
         return ;
 
     vector<int>v;
     //Define a variable to s",C-Plus-Plus
"/*
 Given a Number. Find it's Number of Divisors.
 The Number can be big such as 10^6 to 10^9
 So, If we do this in O(N) we will get Time Limit Exceeded [TLE]
 Better Approach is run a loop till sqrt(Number)
 Example square root of 10^9 is 31622 (approx), so iteration optimized a lot.
 */
 
 #include <stdio.h>
 #include <math.h>
 
 // this get_number_of_divisors will count the number of divisors of the number
 int get_number_of_divisors(int Number)
 {
     int number_of_divisors = 0, i = 0;
     int limit = (int) sqrt(Number);
     for(i = 1; i < limit; i++)
     {
         if(Number % i == 0)
         {
             /* Here i is a divisor of that number
             ( Number / i ) is also a divisor
             */
             number_of_divisors += 2;
         }
     }
 
     if(Number % limit == 0)
     {
         if(limit * limit == Number)
         {
             //means perfect square number
             number_of_divisors++;
         }
         else
         {
             number_of_divisors += 2;
         }
     }
     return number_of_divisors;
 }
 
 int main()
 {
     printf(""Enter the number : \n"");
     int Number;
     scanf(""%lld"", &Number);
     int number_of_divisors = get_number_of_divisors(Number);
     printf(""Number of Divisors of this Number is : "");
     printf(""%d\n"", number_of_divisors);
 }
 
 /*
 Standard Input and Output
 
 Enter the number :
 1000000000
 Number of Divisors of this Number is : 100
 
 Enter the number :
 4567323
 Number of Divisors of this Number is : 16
 
 Time Complexity : O( sqrt(N) )
 Space Complexity : O( 1 )
 
 */
",C
"/**An array element is a peak if it is NOT smaller than
 its neighbours. For corner elements, we need to
 consider only one neighbour.
 Since an array always have a maximum value therefore an peak element always be there and there can be many peak element.
 Approach :If the middle element is not the peak element, then check if the element on the right side is greater than the middle element 
 then there is always a peak element on the right side. 
 If the element on the left side is greater than the middle element then there is always a peak element on the left side.
 **/
 #include <bits/stdc++.h>
 using namespace std;
 
 // recursive approach
 int find_peak_recursive(vector<int> v, int l, int r)
 {
 	if (l < r)
 	{
 		int mid = l + (r - l) / 2;
 		// for corner cases
 		if (mid == 0 || mid + 1 == v.size())
 		{
 			if (mid == 0)
 			{
 				if (v[0] >= v[1])
 					return v[0];
 				else
 					return v[1];
 			}
 			else
 			{
 				if (v[mid] >= v[mid - 1])
 					return v[mid];
 				else
 					return v[mid - 1];
 			}
 		}
 		else if (v[mid] >= v[mid - 1] && v[mid] >= v[mid + 1])
 			return v[mid];
 
 		else if (v[mid] < v[mid + 1])
 			return find_peak_recursive(v, mid + 1, r);
 
 		else
 			return find_peak_recursive(v, l, r - 1);
 	}
 
 	return -1;
 }
 
 // using while loop approach
 int find_peak_iter(vector<int> arr)
 {
 	int start = 0, n = arr.size();
 	int end = n - 1;
 	while (start <= end)
 	{
 		int mid = start + (end - start) / 2;
 		if (mid - 1 >= 0 && mid + 1 < n)
 		{
 			if (arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1])
 			{
 				return arr[mid];
 			}
 			else if (arr[mid] < arr[mid - 1])
 			{
 				end = mid - 1;
 			}
 			else
 			{
 				start = mid + 1;
 			}
 		}
 
 		// for corner cases
 		else if (mid == 0)
 		{
 			if (arr[0] > arr[1])
 			{
 				return arr[0];
 			}
 			else
 			{
 				return arr[1];
 			}
 		}
 
 		// for corner cases
 		else if (mid == n - 1)
 		{
 			if (arr[n - 1] > arr[n - 2])
 			{
 				return arr[n - 1];
 			}
 	",C-Plus-Plus
"/* We reverse the list taking k elements at a time i.e. we reverse the list in groups of k elements.
 If size of linkedlist n = 9 and k=3
 I/P  9 4 1 7 8 3 2 6 5
 O/P  1 4 9 3 8 7 5 6 2
 */
 #include <iostream>
 using namespace std;
 
 class node{
     public:
     int data;
     node* next;
     node(int d){
         data = d;
         next = NULL;
     }
 };
 
 node* kReverse(node* head,int k){
     node* current = head;
     node* previous = NULL;
     node* n = NULL;
     int count = 0;
     while(count<k and current!=NULL){
         n = current->next;
         current->next = previous;
         previous = current;
         current = n;
         count++;
     }
     if(n != NULL){
         head->next = kReverse(n,k);
     }
     return previous;
 }
 
 void insertAtTail(node* &head,int d){
     if(head == NULL){
         head = new node(d);
         return;
     }
     node* tail = head;
     while(tail->next!=NULL){
         tail  = tail->next;
     }
     node* n = new node(d);
     tail->next = n;
 }
 
 node* takeInput(int n){
     node* head = NULL;
     while(n!=0){
         int d;
         cin>>d;
         insertAtTail(head,d);
         n--;
     }
     return head;
 
 }
 
 void print(node* head){
     while(head!=NULL){
         cout<<head->data<<"" "";
         head = head->next;
     }
     cout<<endl;
 }
 
 int main() {
 	int n,k;
 	cout<<""Enter the size of LinkedList: "";
 	cin>>n;
 	cout<<""Enter the no. of elements to be taken at a time: "";
 	cin>>k;
 	cout<<""Enter the elements of the LinkedList: "";
 
 	//To take input from user
 	node* head  = takeInput(n);
 
 	//To reverse the elements in groups of k
 	node* newHead = kReverse(head,k);
 
 	cout<<""The final list after kReverse is:     "";
 	print(newHead);
 	return 0;
 }
 
 /* Sample I/O
 Enter the size of LinkedList: 9
 Enter the no. of elements to be taken at a time: 3
 Enter the elements of the LinkedList: 9 4 1 7 8 3 2 6 5
 The final list after kReverse is:     1 4 9 3 8 7 5 6 2
 
 Time Complexity:  ",C-Plus-Plus
"/*
 
 A sorting algorithm which is famously known as odd-even sort ( or Parity sort or Brick sort ) is a modification of bubble sort.
 Algorithm -> Divide into the two phases - 
              1. Odd Phase ( Perform bubble sort on odd indexed elements )
              2. Even Phase ( Perform bubble sort on even indexed elements )
 
 Time Complexity -> O(N^2) where, N is the number of elements in the input array
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // perform bubblesort operation w.r.t to the passed indexes
 function bubbleSort(array, start, end) {
   let isSorted = true;
   for (let i = start; i <= end; i += 2) {
     if (array[i] > array[i + 1]) {
       [array[i], array[i + 1]] = [array[i + 1], array[i]];
       isSorted = false;
     }
   }
 
   return isSorted;
 }
 
 // perform bricksort
 function brickSort(array) {
   let isSorted = false;
 
   while (!isSorted) {
     isSorted = true;
 
     isSorted = bubbleSort(array, 1, array.length - 2);
     isSorted = bubbleSort(array, 0, array.length - 2);
   }
 
   return array;
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered value is number or not
   if (array.includes(NaN)) return console.log(""Only numbers are allowed"");
 }
 
 console.log(""Your array - "", array);
 
 // Call the algorithm
 brickSort(array);
 console.log(""Sorted array"", array);
 
 // Sample I/O
 
 /*
 
 > node BrickSort
 
 Enter array length - 7
 Enter 1 element - 56
 Enter 2 element - 89
 Enter 3 element - 40
 Enter 4 element - 60
 Enter 5 element - 21
 Enter 6 element - 90
 Enter 7 eleme",JavaScript
"// C program implementation for Fibonacci Search 
 
 // Worst case time complexity: (logn)
 // Average case time complexity: (log n)
 // Best case time complexity: (1)
 // Space complexity: (1)
 
 
 #include <stdio.h>
 #include <string.h>
  
 int Fibonacci_Search(int a[], int n, long x)
 { 
     int index = 0, position, k;
     static int n_1= -1, n_2 = -1;
     
     // Precomputed Fibonacci numbers from F_0 up to F_46.
     static int fib[]={0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 98,
     1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811,
     514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817,
     39088169, 63245986, 102334155, 165580141};
     if (n_2 != n)
     { 
         k = 0;
         while (fib[k] < n)
             k++;
         n_1 = k;
         n_2 = n;
     }
     else
         k = n_1;
     while (k > 0)
     {
         position = index + fib[--k];
         if ((position >= n) || (x < a[position]));
         else if (x > a[position])
         {
             index = position + 1;
             k--;
         }
         else {
             return position;
         }
     }
     return -1;
 }
 void main()
 {
     int no_element=0;
     printf(""Enter the no of element in the array: ""); 
         scanf(""%d"", &no_element);
     int arr[no_element];
 
     // taking input 
     printf(""Enter the array: \n""); 
     for(int z=0; z < no_element; z++){
         scanf(""%d"", &arr[z]);
     }
     int num;
     printf(""Enter an element to search: "");
     scanf(""%d"", &num);
 
     (Fibonacci_Search(arr, 10, num) == -1) ? printf(""Element NOT found!! "") :
     printf(""Element is at index : %d"", Fibonacci_Search(arr, 10, num));
  
 }
 /*
 ____Example-1____
 Enter the no of element in the array: 5                                                                                            
 Enter the array:                                                                             ",C
"/*
 Cutting a Rod problem
 We are given a rod of length 'n' and the cost of the rod of different length from
 1 to n. We need to find the maximum sell price that can be obtained by cutting the rod
 at any lengths.
 */
 
 import 'dart:io';
 
 // Function to get maximum selling price
 int maximum_sp(int length, List cost) {
   // Initialising dynamic programming list
   List<int> dp = [];
   dp.add(0);
 
   // iterate to find out all possible prices and push to list
   for (int count1 = 1; count1 <= length; count1++) {
     int max_sp_this = -2147483647 - 1;
     for (int count2 = 0; count2 < count1; count2++) {
       max_sp_this = getMax(max_sp_this,
           cost.elementAt(count2) + dp.elementAt(count1 - count2 - 1));
     }
     dp.add(max_sp_this);
   }
 
   // return Selling price for given length
   return dp.elementAt(length);
 }
 
 // Function to return maximum out of two numbers
 int getMax(int num1, int num2) {
   if (num1 > num2) {
     return num1;
   }
   return num2;
 }
 
 // main function with driver code
 void main() {
   print(""Enter the length of the rod:"");
   int length = int.parse(stdin.readLineSync()!);
   List arr = [];
 
   print(""Enter the cost of the rod from 1 to $length:"");
   for (int i = 0; i < length; i++) {
     arr.add(int.parse(stdin.readLineSync()!));
   }
 
   // Pass array and length to Maximum price function
   int max_price = maximum_sp(length, arr);
   print(""The maximum seeling price is $max_price"");
 }
 
 /*
 Time Complexity- O(n^2)
 Space Complexity- O(n)
 
 Sample I/O:
 
 Enter the length of the rod:
 4
 Enter the cost of the rod from 1 to 4:
 12
 9
 21
 13
 The maximum seeling price is 48
 
 Enter the length of the rod:
 5
 Enter the cost of the rod from 1 to 5:
 2
 5
 7
 8
 10
 The maximum seeling price is 12
 */
 
",Dart
"/*
 1. We have to find the length of the longest increasing subsequence in the input array. 
 2. Longest Increasing Subsequnce is length of the longest strictly increasing subsequence.
 3. The problem can be solved using Dynamic Programming. 
 4. The approch is to find the LIS for each element and return the largest of them. 
 */
 
 //Function that finds the length of the longest increasing subsequence
 let FindLIS = (list, len) => {
   //creating a new array of size len to store the LIS value
   let lis = new Array(len);
 
   //lis[i] stores the length of the longest increasing subsequence upto list[i]
   //Initializing lis[0] to be 1 as LIS for 1 element is 1
   lis[0] = 1;
 
   for (let i = 1; i < len; ++i) {
     lis[i] = 1;
     for (let j = 0; j < i; ++j) {
       //checking if i list[i] has a smaller element to its left so that list[i] can be updated
       if (list[j] < list[i] && lis[i] < lis[j] + 1) {
         lis[i] = lis[j] + 1;
       }
     }
   }
 
   //variable that stores the length of the longest increasing subsequence of the array
   let sizeOfLIS = 0;
 
   //finding the largest value in the lis array
   for (let i = 0; i < len; ++i) {
     sizeOfLIS = Math.max(sizeOfLIS, lis[i]);
   }
 
   //returning the LIS value
   return sizeOfLIS;
 };
 
 //Using the readline() function of JavaScript to take input from the user
 console.log(
   ""Enter the elements of the array for which length of Longest Increasing Subsequence has to be found""
 );
 
 //list is input array
 let list = readline()
   .split("" "")
   .map((x) => parseInt(x));
 
 //n is length of the input array
 let n = list.length;
 
 //storing LIS
 let lengthOfLongestIncreasingSubsequence = FindLIS(list, n);
 
 //printing the answer
 console.log(
   `The length of the longest increaing subsequnce is ${lengthOfLongestIncreasingSubsequence}`
 );
 
 /*
 Time complexity of the program - O(N^2)
 Space Complexity of the program - O(N)
 */
 
 /*
 Sample Input Output : 
 
 Input 1 : 
 list = [10, 22, 9,",JavaScript
"using System;
 
 /*  Radix sort is a sorting technique that sorts the elements by 
     first grouping the individual digits of the same place value. 
     Then, sort the elements according to their increasing/decreasing order.
 */
 
  class RadixSort{
   static void radixSort(int[] arr){
     int size = arr.Length;
     int max_element = arr[0];
     
     for (int i=1; i<size; i++){  
       if(max_element < arr[i])
         max_element = arr[i];
     }
 
     for (int x = 1; max_element/x > 0; x *= 10){ 
       countingSort(arr, x); 
       }
   }
 
  
   static void print_arr(int[] arr){ 
     int size = arr.Length; 
    
     Console.Write(""\n""); 
   } 
   
     static void countingSort(int[] arr, int x){   
     int size = arr.Length;    
     int[] new_arr = new int[size];
     
     int[] fr = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
 
     for(int i = 0; i < size; i++){
       fr[(arr[i]/x)%10]++;
       }
 
     for (int i = 1; i < 10; i++){ 
       fr[i] += fr[i - 1];     
       }
 
     for (int i = size - 1; i >= 0; i--){ 
       new_arr[fr[(arr[i]/x)%10] - 1] = arr[i]; 
       fr[(arr[i]/x)%10]--; 
     } 
   
     for (int i = 0; i < size; i++){ 
       arr[i] = new_arr[i]; 
      } 
   }
 
 
   public static void Main(string[] args){
     int n = Convert.ToInt32(Console.ReadLine());
     int[] a = new int[n];
    
    int i,j;
     for(i=0; i<n;i++){
         Console.Write(""Element {0} : "", i);
         a[i] = Convert.ToInt32(Console.ReadLine());
     }
     Console.Write(""Unsorted array: "");
     for (j=0; j<n; j++){
       Console.Write(a[j] + "" ""); 
     } 
       
     Console.Write(""\n"");
     
     radixSort(a);
     
     Console.Write(""Sorted array: "");
      for (j=0; j<n; j++){
       Console.Write(a[j] + "" ""); 
       } 
   }
 }
 
 /* Input
     6                                                                                         
     Element 0 : 87                                                                            
     Element 1 : 1",C-Sharp
"""""""Julia program to check if a number is a Perfect number or not.
     Perfect Number is a number if it is equal to the sum of its proper divisors excluding the number itself.""""""
 
 
 """"""Iterate from 1 till the square root of the given number.
     Identify the divisors and take thier sum. And then check
     If the sum is equal to given number""""""
 function perfect_number(num)
     # variable to store the sum of the proper divisors, initialized to one
     sum = 1
     # Index to iterate from 1 till the square root
     div = 2
     while((div * div) <= num)
         # Check if the current 'div' number is a divisor or not.
         if(num % div == 0)
             sum = sum + div + num  div
         end
         div = div + 1
     end
     if(sum == num && num != 1)
         return true
     else
         return false
     end
 end
 
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 res = perfect_number(num)
 if res
     println(""The given number $num is a Perfect Number."")
 else
     println(""The given number $num is not a Perfect Number."")
 end
 
 
 """"""
 Time Complexity: O(n^(0.5)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 8128
 The given number 8128 is a Perfect Number.
 
 SAMPLE 2
 Enter the number: 8129
 The given number 8129 is not a Perfect Number.
 """"""
",Julia
"/*
 
 Introduction 
 Given a Binary Tree calculate maximum root to leaf path sum
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 Function  updates maximum root to leaf path sum
 
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h> 
 using namespace std;
 //Declare a global variable and keep updating it
 long maxRootToLeafPathSum;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Utility Function to calculate sum of given path vector
 long SumOfPath(vector<int>path)
 {
     long sum=0;
    for( int i: path )   sum=sum+i;
    return su",C-Plus-Plus
"#include<bits/stdc++.h>
 #define Graph unordered_map<int, vector<int>>
 #define vb vector<bool>
 using namespace std;
 
 bool dfs (int curr, vb visited, Graph graph) {
   if(!visited[curr]) {
 
     visited[curr] = true;
     for(int i=0; i < graph[curr].size(); i++)
       return dfs(graph[curr][i], visited, graph);
 
   } else
     return true;
 }
 
 bool detectCycle(int edges, Graph graph) {
 
   vb visited(edges, false);
 
   for(auto it : graph) {
     visited[it.first] = true;
     int sz = it.second.size();
 
     for(int i=0; i<sz; i++) {
         // do dfs and check for visited is once againg visiting or not
         if(dfs( it.second[i], visited, graph))
           return true;
     }
     visited[it.first] = false;
   }
 
   // dfs checked for all vertices and there we found no Cycle
     return false;
 }
 
 int main() {
   std::cout << ""Enter total number of edges in your graph : "";
 
   freopen(""input.txt"",""r"",stdin);
   freopen(""output.txt"",""w"",stdout);
 
   int edges;
   cin>>edges;
 
 // data structure used for creation of graph
   Graph graph;
 
 // creation of graph
 int traversegde = edges;
   while (traversegde--) {
     int x;
     int y;
     cin >> x >> y;
     graph[x].push_back(y);
   }
 
   detectCycle( edges, graph )
   ? std::cout << ""Yes there is Cycle in graph"" << '\n'
   : std::cout << ""No there isn't any Cycle in graph"" << '\n';
 
   return 0;
 }
",C-Plus-Plus
"/* Problem Statement:
 Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero.
 The task is to return true if and only if we can do this in a way such that the resulting number is a power of 2.
 
 Constraints:
 1 <= N <= 10^9
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 bool reorderedPowerOf2(int N) {
     string num = to_string(N);
     int n = num.size();
     int base = 1, x = 1;
     unordered_map<int, vector<int>> powers2; //size of string, powers of 2 of that length
 
     while(x <= n) {
         powers2[x].push_back(base);
         base *= 2;
         x = to_string(base).size();
     }
 
     vector<int> countDigits(10, 0); //stores freq of digits of string num
     for(int i = 0; i < n; i++) {
         countDigits[num[i] - '0']++;
     }
 
     for(auto power : powers2[n]) {
         string x = to_string(power);
         int nx = x.size();
         vector<int> countDigitsx (10, 0);
         for(int i = 0; i < nx; i++) {
             countDigitsx[x[i] - '0']++;
         }
 
         bool f = 1;
         for(int i = 0; i < 10; i++) {
             if(countDigitsx[i] != countDigits[i]){
                 f = 0;
                 break;
             }
         }
         if(f == 1) {
             return true;
         }
     }
     return false;
 }
 
 int main() {
     int n;
     cin >> n;
     reorderedPowerOf2(n) == 1 ? cout << ""true"" : cout << ""false"";
     return 0;
 }
 
 /*Examples:
 1.  Input: 10
     Output : false
 2.  Input: 46
     Output: true
 */
",C-Plus-Plus
"/* This code checks if a number is a happy number. A number is
    called happy if it becomes 1 after iterating thorugh a several
    number of steps wherein each step the number is replaced by the
    sum of its digits.*/
 
 import java.util.*;
 //import java.lang.*;
 
 class HappyNumber{
    
    /*This function takes a number as input and returns
      sum of its digits.*/
    static int sumOfSquares(int n){
       
        int sum = 0;
        while(n != 0){
            /*Taking mod of number with 10 each time
             gives its units place digit. We add its
             square to the sum.*/
            int d = n%10;
            sum += d*d;
            //Replace the number with number / 10.
            n = Math.floorDiv(n,10);
        }
 
        return sum;
    }   
        
    /*This function takes a number as input and checksif the number is a 
      happy number.*/
    static boolean happyNumber(int n){
        
        int first = n;
        int second = n;
 
        while(true){
 
           //The first variable calling sum of digits function once 
           first = sumOfSquares(first);
 
           //The second variable calling sum of digits function twice
           second = sumOfSquares(second);
           second = sumOfSquares(second);
 
           /*If the first one equals the second, we break out of the loop. Otherwise,
             it will run into an infinite loop.*/
           if(first == second)
              break;
           else
              continue;    
        }   
 
        /*The number is happy if at the end of iterations the number
           becomes 1. If it is one, then we return True*/ 
        if(first == 1)
           return true;
        else
           return false; 
 
    }
 
    public static void main(String[] args){
      
        Scanner scan = new Scanner(System.in);
        System.out.print(""Enter the number :"");
        //Taking input from the user 
        int n = scan.nextInt();
        scan.close();       
      ",Java
"// C program to check collinearity of three given points
 #include <stdio.h>
 #include <stdbool.h>
 
 typedef struct Point
 {
     int x;
     int y;
 } Point;
 
 /*
 We can calculate the area formed by the three points, and if the area is
 zero then they lie on a same line. 
 */
 bool check_collinear(Point a, Point b, Point c)
 {
     int area = 0;
 
     /*
     The Area of a Triangle formed by three points (x1, y1), (x2, y2), (x3, y3)
     is determined by the following formula
     
     Area = (1/2) * {x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)}     
     */
     area = a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);
 
     if (area == 0)
         return true;
     else
         return false;
 }
 
 int main()
 {
     int x, y;
     Point a, b, c;
     printf(""\nEnter the first co-ordinates:  "");
     scanf(""%d %d"", &a.x, &a.y);
     printf(""Enter the second co-ordinates: "");
     scanf(""%d %d"", &b.x, &b.y);
     printf(""Enter the third co-ordinates:  "");
     scanf(""%d %d"", &c.x, &c.y);
 
     if (check_collinear(a, b, c))
     {
         printf(""\nThe given points are collinear\n"");
     }
     else
     {
         printf(""\nThe given points are not collinear"");
     }
     return 0;
 }
 
 /*
 Time Complexity: O(1)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the first co-ordinates:  1 1
 Enter the second co-ordinates: 2 2
 Enter the third co-ordinates:  3 3
 The given points are collinear
 */
",C
"
 /*
 Checking for a strong number using indirect recursion
 Strong Number = 145
 1! + 4! + 5! =145
 sumOfFactorialOfDigit(int n) - extracts digit of n and calls factorial(n). Returns sum of factorial of digits
 factorial(n)- returns factorial of extracted digits passed in the argument
 */
 
 import java.util.*;
 class check_strong_number {
     /*recursive function for sum of factorial of digits*/
     public static int sumOfFactorialOfDigit(int n)
 
     {
         if (n == 0)
             return n;
         else
             return (factorial(n % 10) + sumOfFactorialOfDigit(n / 10));
 
     }
     /*recursive function to find the factorial of n */
     public static int factorial(int n) {
         if (n == 0)
             return 1;
         else
             return (n * factorial(n - 1));
     }
 
     public static void main() {
         Scanner sc = new Scanner(System.in);
         System.out.print("" Enter Number. N = "");
         int num = sc.nextInt();
         if (num == sumOfFactorialOfDigit(num))
             System.out.println("" It is a Strong Number"");
         else
             System.out.println("" It is not a Strong Number"");
     }
 }
 
 /*
 Sample Input And Output :
 N = 145
 It is a Strong Number
 N = 534
 It is not a Strong Number
 
 Time Complexity : O(n)
 Space Complexity : 1
 */
",Java
"/* COUNT OF LEAF NODES IN BINARY SEARCH TREE
     Binary Search Tree is a special type of binary tree where 
     1. The value of all the nodes in the left sub-tree is less than or equal to the value of the root.
     2. The value of all the nodes in the right sub-tree is greater than value of the root.
     3. This rule will be recursively applied to all the left and right sub-trees of the root.
 
     Leaf node is a node which does not have left or right child
     No. of leaf nodes varies with the order in which the nodes are inserted
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 /* Declare treeNode with data , rc (right child) and lc (left child )
     Initially count of leaf nodes is set as 0
 */
 typedef struct treeNode
 {
     int data;
     struct treeNode *lc;
     struct treeNode *rc;
 } treeNode;
 
 int count = 0;
 
 //to insert a node into BST
 treeNode *insertIntoTree(treeNode *root, int data)
 {
     //If tree is empty insert as root node
     if (root == NULL)
     {
         treeNode *ptr;
         ptr = malloc(sizeof(treeNode));
         ptr->data = data;
         ptr->lc = NULL;
         ptr->rc = NULL;
         root = ptr;
     }
     else
     {
         // insert recursively in accordance with BST properties
         if (root->data >= data)
         {
             root->lc = insertIntoTree(root->lc, data);
         }
         else if (root->data < data)
         {
             root->rc = insertIntoTree(root->rc, data);
         }
     }
     return root;
 }
 
 //to count the leaf nodes
 int leaf_nodes(treeNode *root)
 {
     //If tree is not empty
     if (root)
     {
         //If the node doesn't have any child increment count
         if (root->lc == NULL && root->rc == NULL)
             count++;
         else
         {
             //recursively check left and right sub-trees
             if (root->lc)
                 leaf_nodes(root->lc);
             if (root->rc)
                 leaf_nodes(root->rc);
         }
     }
     return",C
"/* Jump search is a searching algorithm for sorted arrays. In this algorithm, we jump ahead by a fixed number of steps each time, instead
    of traversing the whole array. Suppose array is of size 10, and jump is 3, then, we check array[0], array[3], array[6], array[9]. We get
    an interval in which we are searching for is present. We then traverse the interval lineally to get the exact index of the element.
    The optimal jump size of sqrt(size of the array). This can be easily proved. */
 
 /* REMEMBER : If the array is not sorted, jump search won't work. */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <math.h>
 
 /* This is the function which implements the jump search algorithm.
    The input to the function is the sorted array, the key which we 
    are looking for and the size of the sorted array. */
 
 int jumpSearch(int array[], int key, int size) {
 
 	//Size to jump
 	int jump = sqrt(size);
 
 	int initial = 0;
 
 	/*Ensures that value of jump does not cross the size of the array.
 	  And also checks if the value at that jump is less than key or not.*/
 
 	while(jump < size && array[jump] <= key) {
 
 		/*This keeps track of the lower bound of the interval
 		  in which key could be present*/
 
 		initial = jump;
 
 		//Everytime we increase jump by sqrt(size of the array)
 		jump = jump + sqrt(size);
 
 		/*If jump exceeds the size of the array, then we set jump as 
 		  the last index  of array + 1*/
 
 		if(jump >= size) {
 			jump = size;
 		}
 	}
 
 	/*As the while loop ends, we are sure that the key, if present in the array
 	  is present between index initial and jump.
 	  We linearlly travere that interval to look for the key*/
 
 	for(int i = initial; i <= jump - 1; i++) {
 
 		//If we find the key, we return the index of the key
 		if(array[i] == key) {
 			return i;
 		}
 
 		else {
 			continue;
 		}
 	}
 
 	//We reuturn -1 if we did not find the key in the array
 	return -1;
 }
 
 int main() {
 	
 	//Size of the array
 	int size;
 ",C
"# Python Program to find Binary Exponent Iteratively and Recursively.
 
 # Iterative function to calculate exponent.
 def binExpo_iterate(a,b):
     res=1
     while b>0:
         if b%2==1:
             res=(res*a)
         a=a*a
         b//=2
     return res
 
 # Recursive function to calculate exponent.
 def binExpo_recurse(a,b):
     if b==0:
         return 1
     res=int(binExpo_recurse(a,b//2))
     res=res*res
     if b%2==1:
         return (res*a)
     else:
         return res
 
 # Main function
 a=int(input())
 b=int(input())
 
 if a==0 and b==0:
     print(""Math error"")
 elif b<0:
     print(""Exponent must be positive"")
 elif a==0:
     print(0)
 else:
     resIterate=binExpo_iterate(a,b);
     resRecurse=binExpo_recurse(a,b);
     print(resIterate)
     print(resRecurse)
",Python
"/*
 Toggle kth bit from the right.
 i.e. For a given number n, if k-th bit from right is 0, then toggle it to 1
 and if it is 1 then, toggle it to 0.
 */
 
 #include <iostream>
 using namespace std;
 
 int main() {
 	int n, k;
 	//n=integer
 	cin >> n >> k;
 	int ans = (n ^ (1 << (k - 1)));
 	cout << ans;
 	return 0;
 }
 
 
 /*
   input:
   6 2
   ouput:
   4
   constraint:
   n is positive
 */
 
 /*
   time-complexity: O(1)
 */
",C-Plus-Plus
"/*
 Best First Search Algorithm is a search algorithm that is used to find a path between source vertex 
 and target vertex in an undirected weighted graph. It is a search algorithm that works on a specific
 rule. It is an example of ""Informed Search"" algorithm as it uses an evaluation function to decide 
 which adjacent is most promising and then explores it.
 It uses the concept of a priority queue (min heap) to store costs of nodes.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //Function to implement best first search algorithm
 void bestFirstSearchAlgorithm(int sv, int tv, int n, vector<vector<pair<int, int> > > graph)
 {
 
     //array for keeping track of visited vertices
     vector<bool> visited(n, false);
 
     //min heap priority queue for storing cost of nodes
     priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > pq;
 
     //inserted source position in the priority queue
     pq.push(make_pair(0, sv));
 
     //mark source vertex as visited
     visited[sv] = true;
 
     //array to store path from the source to the target vertex
     vector<int> path;
 
     while (!pq.empty()) {
 
         int temp = pq.top().second;
 
         path.push_back(temp);
         pq.pop();
 
         //If target vertex is found then exit from the loop
         if (temp == tv)
             break;
 
         for (int i = 0; i < graph[temp].size(); i++) {
             //For each neighbouring vertex of temp
             // Continue if it is already visited
             if (visited[graph[temp][i].second])
                 continue;
             //Else mark it visited and insert it in the priority queue
             else {
                 visited[graph[temp][i].second] = true;
                 pq.push(graph[temp][i]);
             }
         }
     }
 
     cout << ""Path between source vertex and target vertex: "" << endl;
     for (int i = 0; i < path.size(); i++) {
         cout << path[i] << "" "";
     }
     cout << endl;
 }
 
 in",C-Plus-Plus
"import java.util.*;
 
 public class FirstMissingPositiveNumber {
 
     private static void swap(int arr[], int i, int j) {
         int temp = arr[i];
         arr[i] = arr[j];
         arr[j] = temp;
     }
 
     private static int findMissingPositive(int arr[]) {
         // we firstly separate the positive numbers from negative numbers
         int j = 0, i;
         // j is for counting non-positive integers
         for (i = 0; i < arr.length; i++) {
             if (arr[i] <= 0) {
                 swap(arr, i, j);
                 j += 1;
             }
         }
 
         // getting array for only positive numbers in arr2
         int arr2[] = new int[arr.length - j];
         i = j;
         j = 0;
         for (; i < arr.length; i++) {
             arr2[j] = arr[i];
             j += 1;
         }
 
         // marking the number visited by its negative
         // for only those that don't go beyond length of the
         // array of positive numbers
         for (i = 0; i < arr2.length; i++) {
             int checkNum = Math.abs(arr2[i]);
             if (checkNum - 1 < arr2.length && arr2[checkNum - 1] > 0) {
                 arr2[checkNum - 1] = -arr2[checkNum - 1];
             }
         }
 
         for (i = 0; i < arr2.length; i++) {
             if (arr2[i] > 0) {
                 return i + 1;
             }
         }
         return arr2.length + 1;
     }
     
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
 
         //taking input array
         System.out.println(""Enter size of array:"");
         int size = sc.nextInt();
         int arr[] = new int[size];
         System.out.println(""Enter array elements:"");
         for (int i=0; i<size; i++) {
             arr[i] = sc.nextInt();
         }
         sc.close();
 
         int missingNum = findMissingPositive(arr);
 
         System.out.println(""Lowest missing positive integer in the array is:"" + missingNum);
     }
 }
 /**
  * Sample input/",Java
"/*
 The script below determines if a number is Disarium or not.
 A disarium number is a number in which the sum of each digit raised to the power
 of its position in the number is equal to the actual number.
 */
 
 import 'dart:io';
 import 'dart:math';
 
 bool checkDisarium(int no) {
   // Counting the number of digits in the number
   int num_digits = 0;
   int temp1 = no;
   while (temp1 != 0) {
     temp1 = (temp1 / 10).floor();
     num_digits += 1;
   }
 
   // Getting sum of individual digits raised to the power of their position
   int total = 0;
   int temp2 = no;
   while (temp2 != 0) {
     int last = temp2 % 10;
     total = total + pow(last, num_digits--).toInt();
     temp2 = (temp2 / 10).floor();
   }
 
   // If the computed sum is equal to the actual number, we return true
   if (total == no) return true;
   return false;
 }
 
 main() {
   // Taking user input
   var number;
   print('Enter a number: ');
   number = stdin.readLineSync();
   number = int.parse(number);
 
   // Function to check if a number is Disarium
   bool result = checkDisarium(number);
 
   // Displaying the results
   if (result)
     print('$number is a Disarium Number');
   else
     print('$number is not a Disarium Number');
 }
 
 /*
 TIME COMPLEXITY: O(log N)
 SPACE COMPLEXITY: O(1)
 
 SAMPLE I/O 1:
 Enter a number: 
 89
 89 is a Disarium Number
 Explanation:
 8^1 + 9^2 = 89
 
 SAMPLE I/O 2:
 Enter a number: 
 49
 49 is not a Disarium Number
 Explanation:
 4^1 + 9^2 = 85
 */
",Dart
"'''
 PROBLEM STATEMENT:
 Given a binary tree, the task is to print its right view. Right view of
 a binary tree is defined as the nodes which will be visible if the tree
 is viewed from the right side. The input for the binary tree is in the
 form of preorder and entering '-1' denotes a null node.
 For example:
 Input: 3 4 -1 6 -1 -1 5 1 -1 -1 -1
 The above input will have the following structure:
     3
    / \
   4   5
   \   /
    6  1
 Output: 3 5 1, as as these are the nodes that will be visible from right.
 '''
 
 
 # A class to create a node
 class Node:
     # Constructor to initialize node
     def __init__(self, data):
         self.data = data
         self.left = None
         self.right = None
 
 
 # A function to build the tree in preorder form
 def BuildTree():
     d = int(input())
     if d == -1:
         return None
     root = Node(d)
     root.left = BuildTree()
     root.right = BuildTree()
     return root
 
 
 # A function to print the right view of the binary tree
 def RightView(root, level, maxlevel):
     # base case
     if root is None:
         return
     if level > maxlevel[0]:
         print(root.data, end="" "")
         maxlevel[0] = level
     # Recursive case
     RightView(root.right, level + 1, maxlevel)
     RightView(root.left, level + 1, maxlevel)
 
 
 print(""Enter values in a binary tree:"")
 # A function call to build the tree and return root node
 root = BuildTree()
 # maxlevel is defined as a list because it is mutable and we want the changes
 # made to it gets reflected outside the function
 maxlevel = [-1]
 print(""Right view of the binary tree is:"")
 RightView(root, 0, maxlevel)
 
 
 '''
 TEST CASE:
 1.
 Input:
 Enter values in a binary tree:
 2
 4
 7
 8
 -1
 -1
 -1
 5
 -1
 -1
 3
 9
 -1
 6
 -1
 1
 -1
 -1
 -1
 Output:
 Right view of the binary tree is:
 2 3 9 6 1
 Explanation:
 The structure of the tree is:
             2
           /   \
          4     3
         / \   /
        7   5 9
       /       \
      8         6",Python
"// C program to implement Maximum Sum Decreasing Subsequence
 /*
 In this problem, given an array we have to find the maximum sum an decreasing subsequence of that array can make.
 This problem is a slight modification to the Longest Decreasing subsequence problem.
 The problem can be solved using Dynamic Programming
 */
 #include <stdio.h>
 
 int max_sum_decreasing_subsequence(int arr[], int n)
 {
     int dp[n], max_sum = 0;
 
     /* Initialize the dp array with the array values, as the maximum sum 
        at each point is atleast as the value at that point         */
     for (int i = 0; i < n; i++)
         dp[i] = arr[i];
 
     // Now Lets Fill the dp array in Bottom-Up manner
     /* Compare Each i'th element to its previous elements from 0 to i-1, 
        If arr[i] < arr[j], then it qualifies for decreasing subsequence and
        If dp[i] < dp[j] + arr[i], then that subsequence sum qualifies for being the maximum one */
     for (int i = 1; i < n; i++)
         for (int j = 0; j < i; j++)
             if (arr[i] < arr[j] && dp[i] < dp[j] + arr[i])
                 dp[i] = dp[j] + arr[i];
 
     //Now Find the maximum element in the 'dp' array
     //Now Find the maximum element in the 'dp' array
     for (int i = 0; i < n; i++)
     {
         if (dp[i] > max_sum)
             max_sum = dp[i];
     }
 
     return max_sum;
 }
 
 int main()
 {
     int n, max_sum;
     printf(""\nWhat is the length of the array? "");
     scanf(""%d"", &n);
     int arr[n];
     printf(""Enter the numbers: "");
     for (int i = 0; i < n; i++)
     {
         scanf(""%d"", &arr[i]);
     }
     max_sum = max_sum_decreasing_subsequence(arr, n);
 
     printf(""The maximum sum of an decreasing subsequence of the given array is %d"", max_sum);
     return 0;
 }
 
 /*
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 10
 Enter the numbers: 23 14 5 84 24 222 321 43",C
"# Naive Bayes Algorithm 
 
 import numpy as np 
 
 
 class NaiveBayesClassifier:
 
     
     def __init__(self):
         pass
 
 
     # divides the dataset into a subset of data belonging to each class
     def divide_classes(self, X, Y):
         """"""
         X: list of features
         Y: list consisting of target
         The function returns: A dictionary with Y as keys and assigned X as values.
         """"""
         divided_classes = {}
         
         for i in range(len(X)):
             values = X[i]
             target_class_name = Y[i]
             if target_class_name not in divided_classes:
                 divided_classes[target_class_name] = []
             divided_classes[target_class_name].append(values)
             
         return divided_classes
 
 
     # standard deviation and mean are required for the (Gaussian) distribution function
     def info(self, X):
         """"""
         X: list of features
         The function returns: A dictionary with standard deviation and mean as keys and assigned features as values.
         """"""
         for i in zip(*X):
             yield {
                 'std' : np.std(i),
                 'mean' : np.mean(i)
                   }
             
             
     # fitting data that would be required to train the model
     def fit_data (self, X, Y):
         """"""
         X: training features
         y: target variable
         The function returns: A dictionary with the probability, mean, and standard deviation of each class.
         """"""
 
         divided_classes = self.divide_classes(X, Y)
         self.summary = {}
 
         for target_class_name, values in divided_classes.items():
             self.summary[target_class_name] = {
                 'given_prob': len(values)/len(X),
                 'summary': [i for i in self.info(values)]
                             }
         return self.class_summary
 
 
     # Gaussian distribution function
     def Gaussian_distribution(self, X, mean, std):
",Python
"import java.util.*;
 public class Stack
 {
   static Node top;
   class Node
   {
 	public int data;
 	public Node next;
 	Node(int data)
 	{
 		this.data=data;
 	}
   }
   void push(int data)
   {
 	Node ptr = new Node(data);
 	if(top==null)
 	{
 		top=ptr;
 		ptr.next=null;
                 System.out.println(data+"" is successfully added to the stack"");
 	}
 	else 
 	{
 		Node ctr=top;
 		ptr.next=ctr;
 		top = ptr;
 		System.out.println(data+"" is successfully added to the stack"");
 	}
   }
   boolean isEmpty()
   {
 	if(top==null) 
 		return true;
 	return false;
   }
   void peek()
   {     if(!isEmpty())
 	  System.out.println(top.data);
         else 
           System.out.println(""Stack is empty"");
   }
   void count()
   {
 	  int count = 0;
 	  Node ptr = top;
 	  while(ptr!=null)
 	  {
 		  count++;
 		  ptr = ptr.next;
 	  }
 	  System.out.println(""The stack has ""+count+"" elements""); 
   }
   void pop()
   {
 	Node ctr=top;int data;
 	if(ctr==null)
 	{
 		System.out.println(""Stack is empty"");
 		return ;
 	}
 	else if(ctr!=null && ctr.next==null)
 	{       data = top.data;
 		top = null;
 	}
 	else 	
 	{       data = top.data;
 		top = top.next;
 	}
 	  System.out.println(data+"" is successfully removed from the stack"");
   }
   void display()
   {   if (isEmpty())
         {
 	    System.out.println(""The stack is empty"");
         }
       else 
       { System.out.println(""The stack is "");
 	Node ctr=top;
 	while(ctr!=null)
 	{
 		System.out.print(ctr.data+"" "");
 		ctr=ctr.next;
 	}
 	System.out.println();
   }
   }
   public static void main(String[] args)
   {
 	Stack st=new Stack();
 	Scanner sc=new Scanner(System.in);
 	System.out.println(""Stack"");
 	int choice; boolean f=true;
 	while(f) 
 	{
 		System.out.println(""Enter 1 to input data, 2 to delete data from stack, 3 to peek data from stack,4 to count the number of elements in the stack, 5 to display all elements in the stack and 6 to exit"");
 		choice=sc.nextInt();
 		switch(choice) 
 		{
 		 case",Java
"/* 
   This program is to find the Path from a Node of the Binary Tree to Root of that Binary Tree
   1. We are given a partially written BinaryTree class.
   2. We are given an element.
   3. We are required to complete the body of find and nodeToRoot function. The functions are expected to 
       3.1. find -> return true or false depending on if the data is found in binary tree.
       3.2. nodeToRoot -> returns the path from node (correspoding to data) to root in 
       form of an arraylist (root being the last element)
 */
       
     
 import java.io.*;
 import java.util.*;
 
 public class nodetorootpath_ {
   // This class can be used as a reference to create a new Node in a Binary Tree
   public static class Node {
     int data;
     Node left;
     Node right;
 
     Node(int data, Node left, Node right) {
       this.data = data;
       this.left = left;
       this.right = right;
     }
   }
 
   public static class Pair {
     Node node;
     int state;
 
     Pair(Node node, int state) {
       this.node = node;
       this.state = state;
     }
   }
 
   // This function pushes all Node values into a stack
   public static Node construct(Integer[] arr) {
     Node root = new Node(arr[0], null, null);
     Pair rtp = new Pair(root, 1);
 
     Stack<Pair> st = new Stack<>();
     st.push(rtp);
 
     int idx = 0;
     while (st.size() > 0) {
       Pair top = st.peek();
       if (top.state == 1) {
         idx++;
         if (arr[idx] != null) {
           top.node.left = new Node(arr[idx], null, null);
           Pair lp = new Pair(top.node.left, 1);
           st.push(lp);
         } else {
           top.node.left = null;
         }
 
         top.state++;
       } else if (top.state == 2) {
         idx++;
         if (arr[idx] != null) {
           top.node.right = new Node(arr[idx], null, null);
           Pair rp = new Pair(top.node.right, 1);
           st.push(rp);
         } else {
           top.node.right = null;
         }
 
         top",Java
"'''
 Maze Generation Visualizer using Backtracking Algorithm
 
 Python scripts for generating random solvable mazes using the depth-first search and recursive backtracking algorithms.
 The code also implements a recursive backtracking pathfinding algorithm for solving the generated mazes. 
 
 '''
 
 import pygame
 import random
 pygame.init()
 
 
 #Initialise screen and define Cell dimensions
 width = 15
 height = 15
 screen = pygame.display.set_mode((735,735))
 pygame.display.set_caption('Maze')
 
 
 class Cell():
     #Cell class that defines each walkable Cell on the grid
     def __init__(self, x: int, y: int):
         self.x = x
         self.y = y
         self.visited = False
         self.walls = [True, True, True, True] # Left, Right, Up, Down
 
 
     def getChildren(self, grid: list) -> list:
         #Check if the Cell has any surrounding unvisited Cells that are walkable
         a = [(1, 0), (-1,0), (0, 1), (0, -1)] # Surrounding squares
         children = []
 
         for x, y in a:
             if self.x+x in [len(grid), -1] or self.y+y in [-1, len(grid)]: # Check if the neighbouring square is within range
                 continue
         
             child = grid[self.y+y][self.x+x] # Get the child cell
 
             if child.visited: # Check if the child has already been visited
                 continue
 
             children.append(child)
         return children
 
 
     def show(self, width: int, height: int, c: int, c2: int):
         #Draw a Cells existing walls
         x = self.x
         y = self.y
 
         if self.walls[0]:
             pygame.draw.rect(screen, (20,20,20), (width*x+c-width, height*y+c2, width, height))
         if self.walls[1]:
             pygame.draw.rect(screen, (20,20,20), (width*x+c+width, height*y+c2, width, height))
         if self.walls[2]:
             pygame.draw.rect(screen, (20,20,20), (width*x+c, height*y+c2-height, width, height))    
         if self.walls[3]:
             pygame.draw.rect(scree",Python
"#include<bits/stdc++.h>
 using namespace std;
 
 //CONVERSION OF DECIMAL NUMBER TO HEXADECIMAL NUMBER
 void decimal_to_hexadecimal(int n)
 {
   int i=0;
   string ans="""";
   int last_digit=0;
   char x;
   while(n)
   {
     last_digit=n%16;
     n=n/16;
     /*  Condition checking :
         If digit greater than 9, X will be alphabet
         Else X will be a number  */
     if(last_digit>9)
        x=last_digit+'A'-10;
     else
       x=last_digit+'0';
     ans[i]=x;
     i++;
   }
   //Loop for printing reverse String
   cout<<""\n The Required Hexadecimal Number is::"";
   for(int k=i-1;k>=0;k--)
     cout<<ans[k];
 }
 int main()
 {
   int decimal;
   cout<<""\n ENTER THE DECIMAL NUMBER::"";
   cin>>decimal;
   decimal_to_hexadecimal(decimal);
   return 0;
 }
 
 /* Testcases:
 
   INPUT-
   ENTER THE DECIMAL NUMBER::463
   OUTPUT-
   The Required Hexadecimal Number is::1CF
 
   INPUT-
   ENTER THE DECIMAL NUMBER::100
   OUTPUT-
   The Required Hexadecimal Number is::64
 
   INPUT-
   ENTER THE DECIMAL NUMBER::516042
   OUTPUT-
   The Required Hexadecimal Number is::7DFCA
 
   Time Complexity- O(n);
   Space Complexity- O(1);
 
 */
",C-Plus-Plus
"/* 
 Divisors of a natural number.
 
 For a given natural number num,
 your task is to find out all the possible divisors of the given natural number and print them.
 It is given that the output should have all the distinct divisors.
 And the output is expected to be always sorted in ascending order.
 
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 //function to print all the possible divisors of num.
 void divisorsOfNumber(int num)
 {
     int pass;
 
     for(pass = 1; pass*pass < num; pass++)
     {
         if(num % pass == 0)
         {
             cout << pass << "" "";
         }
     }
 
     for(pass = sqrt(num); pass >= 1; pass--)
     {
         if(num % pass == 0)
         {
             cout << (num/pass) << "" "";
         }
     }
     cout << endl;
 }
 
 //main function
 int main()
 {
     int testCases;
     cout << ""Enter the number of testcases: "";
     cin >> testCases;
     
     while(testCases--)
     {
         int num;
         cout << ""Enter a natural number: "";
         cin >> num;
 
         cout << ""All the possible divisors of "" << num << "" are: "";
         //calling the function divisorsOfNumber() by passing the natural number, which will print the divisors 
         divisorsOfNumber(num); 
     }
 
     return 0;
 }
 
 /*
 
 FOR EXAMPLE:--
 
 Example 1:
 Input:-
 Enter the number of testcases: 1
 Enter a natural number: 60
 Output:-
 All the possible divisors of 60 are: 1 2 3 4 5 6 10 12 15 20 30 60
 
 Example 2:
 Input:-
 Enter the number of testcases: 1
 Enter a natural number: 101
 Output:-
 All the possible divisors of 101 are: 1 101
 
 Example 3:
 Input:-
 Enter the number of testcases: 2
 Enter a natural number:40
 Enter a natural number:70
 Output:-
 All the possible divisors of 40 are: 1 2 4 5 8 10 20 40
 All the possible divisors of 70 are: 1 2 5 7 10 14 35 70
 
 SPACE COMPLEXITY = O(sqrt(N))
 TIME COMPLEXITY = O(1)
 
 */
",C-Plus-Plus
"/*Problem Statement: 
 Given a 1 to N snakes and ladders board, starting and the ending points of all snakes and ladders.
 You have to find out the minimum number of dice throws to win the game.
 Each dice throw can have any number from 1 to 6. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 class graph
 {
     int V;
     list<int> *a;
 
 public:
     graph(int v)
     {
         V=v;
         a=new list<int> [v];
     }
 
     void AddEdge(int u,int v,bool bidir=true)
     {
         a[u].push_back(v);
         if(bidir)
         {
             a[v].push_back(u);
         }
     }
 
     void bfs(int src,int dest)
     {
         queue<int> q;
         bool *visited=new bool[V]{0};
         int *dist=new int[V+1]{0};
         int *parent=new int[V+1];
         for(int i=0;i<V;i++)
         {
             parent[i]=-1;
         }
 
         q.push(src);
         visited[src]=true;
         while(!q.empty())
         {
             int node=q.front();
             q.pop();
             for(int neighbour: a[node])
             {
                 if(!visited[neighbour])
                 {
                     q.push(neighbour);
                     visited[neighbour]=true;
                     dist[neighbour]=dist[node]+1;
                     parent[neighbour]=node;
                 }
             }
         }
         cout<<""Minimum number of moves: ""<<dist[dest]<<endl; 
     }
 };
 
 int main()
 {
     int board[200]={0};
     int total_jumps;
     cout<<""Enter total number of ladders and snakes present in board: ""<<endl;
     cin>>total_jumps;
     cout<<""Enter the points where the ladders and snakes are present(add negative jump for snakes): ""<<endl;
     for(int i=0;i<total_jumps;i++)
     {
         int temp,jump;
         cin>>temp>>jump;
         board[temp]=jump;
     }
     int board_size;
     cout<<""Enter board size: ""<<endl;
     cin>>board_size;
     graph game_board(board_size);
     for(int i=0;i<36;i++)
     {
         for(int dice=1;dice<=6;d",C-Plus-Plus
"/*Problem Statement:
 SuperComputer Inc. have built a super-fast computer server consisting of N hyper-scalar lightning-fast processors 
 Beta 007. These processors are numbered from 1 to N and are used to process independent jobs.
 Every new incoming job is assigned to an arbitrary processor. 
 Sometimes, a processor may be assigned too many jobs while other processors have a relatively light load 
 (or even wait idly). 
 In that case, the whole system undergoes rebalancing.
 Rebalancing proceeds in rounds. In each round, every processor can transfer at most one job to each of its neighbors 
 on the bus. 
 Neighbors of the processor i are the processors i-1 and i+1 (processors 1 and N have only one neighbor each, 
 2 and N-1 respectively). 
 The goal of rebalancing is to achieve that all processors have the same number of jobs.
 Given the number of jobs initially assigned to each processor, 
 you are asked to determine the minimal number of rounds needed to achieve the state when every processor has the 
 same number of jobs, or to determine that such rebalancing is not possible. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int balanceLoad(int n,int arr[],int load,int max_load,int diff)
 {
 		load=load/n;
 		diff=0;
 		for(int i=0;i<n;i++)
 		{
 			diff+=(arr[i]-load);
 			int ans=max(diff,-diff);
 			max_load=max(max_load,ans);
 		}
 	return max_load;
 }
 int main()
 {
 	int arr[9000];
 	int n,i,val,diff;
 	int max_load=0,load=0;
 	cout<<""Enter the number of processors: ""<<endl;
 	cin>>n;
 	cout<<""Enter the jobs: ""<<endl;
 	for(int i=0;i<n;i++)
 	{
 		cin>>arr[i];
 		load+=arr[i];
 	}
 	if(load%n!=0)
 	{
 		cout<<""-1""<<endl;
 	}
 	cout<<""minimal number of rounds: ""<<balanceLoad(n,arr,load,max_load,diff)<<endl;
 	return 0;
 }
 /*Example:
 Input:-
 Enter the number of processors:
 3
 Enter the jobs:
 0 99 3
 Output:-
 minimal number of rounds: 34
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
"""""""
    Tower of Hanoi 
 Problem:
 Given three rods and disks
 The objective of the puzzle is to move the 
 entire stack of disks to another rod.
 The following rules needs to be followed:
     *Only one disk can be moved at a time.
     *Each move consists of taking the upper disk from one of the stacks and placing it on top
       of another stack i.e. a disk can only be moved if it is the uppermost disk on a stack.
     *No disk may be placed on top of a smaller disk.
     
 Input:
 n_disks : number of disks
 Output:
 result: stack of disks moved from one rod to
         another based on the rules
 """"""
 #function for tower of hanoi
 #we have three rods source , auxilary and target
 #putting n_disk from source rod  to the target rod using auxiallary rod
 
 def tower_of_hanoi(n_disks, source, auxiliary, target):
     
     #if only one disk is on the rod
     if(n_disks == 1):  
         print('Move disk 1 from rod {} to rod {}.'.format(source, target))  
         return  
     # move one disc from source to target      
     tower_of_hanoi(n_disks - 1, source, target, auxiliary)  
     print('Move disk {} from rod {} to rod {}.'.format(n_disks, source, target)) 
     
     # move `N-1` discs from auxiliary to target using 
     #the source as an intermediate pole
     tower_of_hanoi(n_disks - 1, auxiliary, source, target)  
   
   
 if __name__ == ""__main__"":
     # here source is X, auxiliary is Y and target is Z  
     n_disks = int(input('Enter the number of disks: '))
     tower_of_hanoi(n_disks, 'X', 'Y', 'Z') 
 
 """""" 
 Sample Input/Output
 
 Enter the number of disks: 3
 
 Move disk 1 from rod X to rod Z.
 Move disk 2 from rod X to rod Y.
 Move disk 1 from rod Z to rod Y.
 Move disk 3 from rod X to rod Z.
 Move disk 1 from rod Y to rod X.
 Move disk 2 from rod Y to rod Z.
 Move disk 1 from rod X to rod Z.
 
 number of moves  2n - 1.
 Time Complexity  O(2^n)  
 """"""
",Python
"/* You are given two lists of integers weights and values which have 
 the same length and an integer capacity. weights[i] and values[i] 
 represent the weight and value of the ith item. Given that you can 
 take at most capacity weights, and that you can take a fraction of 
 an item's weight with proportionate value, return the maximum amount
 of value you can get, rounded down to the nearest integer. */
 
 
 import java.util.*;
 
 public class FractionalKnapsack {
 
     /* Pair class used to store the weight, value, and ratio of value:weight of a particular item */
     static class Pair{
         int wt;
         int val;
         double ratio;
     }
     
     /* Used to sort all items based on their value:weight ratio in descending order */
     static class SortByRatio implements Comparator<Pair>{
         public int compare(Pair a, Pair b){
             if(b.ratio >= a.ratio){
                 return 1;
             }else{
                 return -1;
             }
         }
     }
 
     /* Function created to get maximum Profit */
     public static int getMaxProfit(int[] weights, int[] values, int capacity) {
 
         /* Creating a pairs array which stores all the items according to their weight,value and ratio */
         Pair pairs[] = new Pair[weights.length];
 
         /* Adding items to the pairs array */
         for(int i=0; i<weights.length; i++){
 
             Pair p = new Pair();
             p.val = values[i];
             p.wt = weights[i];
             double wt = weights[i];
             double val = values[i];
             
             p.ratio = val/wt;       
             pairs[i] = p; 
         }
 
         /* Sorting the pairs array based on their ratio */
         Arrays.sort(pairs, new SortByRatio());
 
         /* Initializing an ans variable */
         int ans = 0;
 
         /* Traversing through all items in the array */
         for(Pair p : pairs){
 
             /* Including a particular item, if we can accommodate it */",Java
"/*
 * The Problem is finding the largest Kth item in Two Separated sorted Arrays
 * Complexity O(log(N))
 */
 using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
 
 namespace NeoAlgo
 {
     class Program
     {
         private static int KElement(int[] A1, int s1, int e1, int[] A2, int s2, int e2, int k)
         {
             int mid1 = (e1 - s1) / 2;
             int mid2 = (e2 - s2) / 2;
 
             if (s1 == e1)
                 return A2[s2 + k];
             if (s2 == e2)
                 return A1[s1 + k];
             /*
              * Ex: 1 4 8 , 2 10 15 K = 2
              * Trying to neglect one half of the arrays 
              */
             else if (mid1 + mid2 < k)
             {
                 /*
                  * if A1[s1 + mid1] > A2[s2 + mid2]
                  * So I am Sure I can neglect first half of second array
                  */
                 if (A1[s1 + mid1] > A2[s2 + mid2])
                     return KElement(A1, s1, e1, A2, s2 + mid2 + 1, e2, k - mid2 - 1);
                 /*
                  * if A1[s1 + mid1] <= A2[s2 + mid2]
                  * So I am Sure I can neglect first half of first array
                  */
                 else if (A1[s1 + mid1] <= A2[s2 + mid2])
                     return KElement(A1, s1 + mid1 + 1, e1, A2, s2, e2, k - mid1 - 1);
 
             }
             else
             {
                 if (A1[s1 + mid1] >= A2[s2 + mid2])
                     return KElement(A1, s1, s1 + mid1, A2, s2, e2, k);
                 else if (A2[s2 + mid2] > A1[s1 + mid1])
                     return KElement(A1, s1, e1, A2, s2, s2 + mid2, k);
 
             }
             return 0;
         }
         public static int GetKthItem(int[] arr1, int[] arr2, int N, int M, int K)
         {
 
             /*
              * Find the Position of Element if the two arrays was merged
              * EX:
              * In A1: 1 5 6  A2: 7 ",C-Sharp
"/**
  * Longest Substring with k Distinct Characters
  * Given a string, print the longest possible substring that 
  * has exactly K unique characters.
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int kUniqueChar(string str, int k)
 {
     //2 Pointers to point to start and end of current window
     int start = 0, end = 0;
     int len = str.length();
     //Map maintains current count of each letter
     map<char, int> charCount;
     //Variable ans stores the length of longest possible substring that has exactly n unique characters
     int ans = 0;
     //Iterate until end of current window reaches end of string
     while (end < len) {
         //Updating count of current letter
         charCount[str[end]]++;
         //unique elements less than required increase window size
         if (charCount.size() < k)
             end++;
         /*if unique element equals to required we need to check
           if on increasing the window size whether repetitive element is present or not
           if present then update it as ans and increase window size*/
         else if (charCount.size() == k) {
             ans = max(ans, end - start + 1);
             end++;
         }
         else if (charCount.size() > k) {
             /*If there are more than k unique characters in
               current window, remove element from left side*/
             while (charCount.size() > k) {
                 charCount[str[start]]--;
                 // If occurence of character becomes 0,then we will remove it from map
                 if (charCount[str[start]] == 0)
                     charCount.erase(str[start]);
                 start++;
             }
             /*move forward
               increment end*/
             end++;
         }
     }
     return ans;
 }
 
 int main()
 {
     string str;
     int k;
     cout << ""Enter a string: "";
     cin >> str;
     cout << ""Enter number of distict characters: "";
     cin >> k;
     cout << ""Longest substring w",C-Plus-Plus
"import java.util.*;
 class Longest_Substring {
     public int lengthOfLongestSubstring(String s) {
         if (s.length() == 1) return 1;
         
         ArrayList<Character> arrLL = new ArrayList<>();
         int si = 0;
         int ei = 0 ;
         int currlen = 0;
         int maxlen = 0;
         
         while (ei < s.length() && si < s.length()){
 
             if (!arrLL.contains(s.charAt(ei))){
                 arrLL.add(s.charAt(ei));
                  ei++;
                 currlen = ei - si;
                 if (maxlen < currlen) maxlen = currlen;
             }
 
             else{
                 arrLL.remove(Character.valueOf(s.charAt(si)));
                 si++;
             }
         }
         return maxlen;
     }
     
     public void main(){
         Scanner s = new Scanner(System.in);
         String str = s.next();
         int ans = lengthOfLongestSubstring(str);
         System.out.println(ans);
 }
 
 /*
 TIME COMPLEXITY O(N) where n is length of the the given string
 SPACE COMPLEXITY O(1)
 
 TEST CASE
 
 INPUT
 s = ""bbbbb""
 OUTPUT
 1
 
 INPUT 
 s = ""abcabcbb""
 OUTPUT
 3
 
 */
 
",Java
"'''
 here : https://www.hackerrank.com/challenges/climbing-the-leaderboard/problem
 
 An arcade game player wants to climb to the top of the leaderboard and track their ranking.
  The game uses Dense Ranking, so its leaderboard works like this:
 
 The player with the highest score is ranked number 1 on the leaderboard.
 Players who have equal scores receive the same ranking number, and the next player(s) receive the immediately following ranking number.
 
 '''
 def calc_alice_rank(
     score_board, alice_score, alice_games
 ):
     score_board_hash = {}
     for score in score_board:
         if score in score_board_hash:
             continue
         else:
             score_board_hash[score] = 1
     score_board = list(score_board_hash.keys())
 
     alice_score_hash = {}
     for score in alice_score:
         if score in alice_score_hash:
             alice_score_hash[score] += 1
         else:
             alice_score_hash[score] = 1
 
     alice_rank_counter = 0
     for index in reversed(range(len(score_board))):
         if alice_rank_counter >= alice_games:
             break
         while alice_score[alice_rank_counter] <= score_board[index]:
             current_score = alice_score[alice_rank_counter]
             if score_board[index] == current_score:
                 for _ in range(alice_score_hash[current_score]):
                     print(index + 1)
                 alice_rank_counter += alice_score_hash[current_score]
             elif score_board[index] > current_score:
                 for _ in range(alice_score_hash[current_score]):
                     print(index + 2)
                 alice_rank_counter += alice_score_hash[current_score]
             elif index == 0 and current_score > score_board[index]:
                 print(1)
                 alice_rank_counter += 1
             if alice_rank_counter >= alice_games:
                 break
 
         if index == 0:
             for _ in range(alice_games - alice_rank_counter):
         ",Python
"# Program to find the longest common prefix 
 
 def findMinLength(array, size): 
     minimum = len(array[0]) 
     for i in range(1,size): 
         if (len(array[i])< minimum): 
             minimum = len(array[i]) 
 
     return(minimum) 
 
 # A Function that returns the longest common prefix from the array of strings 
 def commonPrefix(array, size): 
 
     minimmum_length = findMinLength(array, size) 
     result ="""" 
     for i in range(minimmum_length): 
         common_char = array[0][i] 
 
         for j in range(1,size): 
             if (array[j][i] != common_char): 
                 return result 
 
         # Append to result 
         result = result+common_char 
 
     return (result) 
 
 array = []
 size = int(input(""Enter size:""))
 for i in range(size):
     item=input()
     array.append(item)
 
 answer = commonPrefix (array, size) 
 
 if (len(answer)): 
     print(""The longest common prefix is "",answer) 
 else: 
     print(""There is no common prefix"") 
 
 
 '''
 Sample I/O:
     Input:
     Enter size: 3
     star
     start
     stardom
 
     Output:
     The longest Common Prefix is : star
 
 Time Complexity: O(size*M) (M = Length of the largest string)
 Space Complexity:O(1)
 
 '''
",Python
"""""""Julia program to implement Interpolation Search algorithm.
 It is simliar to a person searching for a name in a telephone directory 
 The algorithm calculates where in the remaining array space the required item would be, 
 based on the values at the bounds of the search space and the required element, usually via a linear interpolation
 """"""
 
 function interpolation_search(arr, n, ele)
     low = 1
     high = n
     while low <= high && ele >= arr[low] && ele <= arr[high]
         if(low == high)
             # If element found
             if(arr[low] == ele)
                 return true
             end
             return false
         end
         # Formula to return the value of 'pos'
         pos = low + (((high - low)  (arr[high] - arr[low]))* (ele - arr[low]))
         # If the pos element is the required element, return that index
         if(arr[pos] == ele)
             return true
         end
         # Else find the section of the array in which the required element belongs to
         if(arr[pos] < ele)
             low = pos + 1
         else
             high = pos - 1
         end
     end
     return false
 end
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""Array is Empty!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())] 
 print(""Which number do you want to search in the array? "")
 ele = readline()
 ele = parse(Int, ele)
 # Sort the array in ascending order
 arr = sort(arr)
 res = interpolation_search(arr, n, ele)
 if (res == 0)
     print(""The number $ele is not present in the array"")
 else
     print(""The number $ele is present in the array."")
 end
 
 
 
 """"""
 Time Complexity - O(log(n)), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 How many numbers are present in the array? 5 
 Enter the numbers: 1 2 3 4 5
 Which number do you want to search",Julia
"import java.util.Scanner;
 import java.util.Arrays;
  
 /**Flood Fill Class**/
 public class FFill
 {
    /**Fill Grid Function**/
     private void fGrid(char[][] a, int x, int y) 
     {
         if (a[x][y] == 'X')
         {
             a[x][y] = 'W';
             output(a);
  
             fGrid(a, x + 1, y);
             fGrid(a, x - 1, y);
             fGrid(a, x, y + 1);
             fGrid(a, x, y - 1);
         }
     }
     /**Display Output of the program**/
     private void output(char[][] a)
     {
         System.out.println(""\nGrid : "");
         for (int i = 1; i < a.length - 1; i++)
         {
             for (int j = 1; j < a[i].length - 1; j++)
                 System.out.print(a[i][j] +"" "");
             System.out.println();
         }
     }
  
    /**Main Class Begain**/ 
     public static void main(String[] args) 
     {
         Scanner scan = new Scanner( System.in );        
         /**Input Dimensions**/
         System.out.println(""Enter dimensions: "");
         int M = scan.nextInt();
         int N = scan.nextInt();
  
         
         char[][] array = new char[M + 2][N + 2];
         for (int i = 0; i < M + 2; i++)
             Arrays.fill(array[i], 'O');
  
         
         System.out.println(""Enter grid with 'X'=passage and 'Y'=obstacle"");
  
         for (int i = 1; i < M + 1; i++)
             for (int j = 1; j < N + 1; j++)
                 array[i][j] = scan.next().charAt(0);    
  
         System.out.println(""Enter coordinates: "");
         int sx = scan.nextInt();
         int sy = scan.nextInt();
  
         if (array[sx][sy] != 'X')
         {
             System.out.println(""Invalid coordinates!"");
             System.exit(0);
         }
  
         FFill ff = new FFill();
         ff.fGrid(array, sx, sy);    
  
     }  
     /**End Main Function**/  
 }
 
 /**
 Sample Input output
 Enter dimensions:
 5 5
 Enter grid with 'X'=passage and 'Y'=obstacle
 X X X X X
 Y X Y X Y
 Y Y X X Y
 X Y Y Y Y
 X Y Y Y Y
 Enter c",Java
"/* 
 Description: An integer matrix of size (M x N) has been given. Find 
 out the minimum cost to reach from the cell (0, 0) to (M - 1, N - 1).
 The cost of a path is defined as the sum of each cell's values through
 which the route passes.
 */
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStreamReader;
 public class Solution {
     public static int minCostPathDP(int[][] input) {
     	  int m = input.length;
         int n = input[0].length;
         int storage[][] = new int[m][n];
         storage[m-1][n-1] = input[m-1][n-1];
         for(int j = n-2; j >= 0; j--) {
         	storage[m-1][j] = storage[m-1][j+1] + input[m-1][j];
         }
         for(int i = m-2; i >=0; i--) {
         	storage[i][n-1] = storage[i+1][n-1] + input[i][n-1];
         }
         for(int i = m-2; i>=0; i--) {
          	for(int j = n-2; j >= 0; j--) {
         		storage[i][j] = input[i][j] + Math.min(storage[i][j+1], Math.min(storage[i+1][j+1], storage[i+1][j]));
         	}
         }
         return storage[0][0];
     }
     static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
     public static int[][] take2DInput() throws IOException {
         System.out.println(""Enter the number of rows & columns: "");
         String[] strRowsCols = br.readLine().trim().split(""\\s"");
         int mRows = Integer.parseInt(strRowsCols[0]);
         int nCols = Integer.parseInt(strRowsCols[1]);
         if (mRows == 0) {
             return new int[0][0];
         }
         int[][] mat = new int[mRows][nCols];
         System.out.println(""Enter The matrix elements: "");
         for (int row = 0; row < mRows; row++) {
             String[] strNums; 
             strNums = br.readLine().trim().split(""\\s"");
             for (int col = 0; col < nCols; col++) {
                 mat[row][col] = Integer.parseInt(strNums[col]);
             }
         }
         return mat;
     }
   //Drive Code
   public static void main(String[] args)",Java
"//headers
 #include <stdio.h> 
 #include <stdbool.h>
 //defining the size of the queue we are taking here
 #define size 5  
 
 //defining a structure
 typedef struct 
 {
     // creating the queue structure with data, front and rear nodes pointing to front and the last(behind) node
     int data[5]; 
     
     //a node containg the value of a pointer/address pointing to the front node
     int front;
     
     //a node containing the value of a pointer/address pointing to the back/behind/rear node
     int rear;
 } mainf;
 
 //the name of the structure
 mainf queuestructure;
 
 //In the circular queue, in the last node, the front pointer points to the first node.
 int enque(int number)
 { 
     //adding a value to the queue
     //if the queue is full user cant add anything more
     if (queuestructure.front == queuestructure.rear + 1) 
     {
         printf(""Queue is full!\n"");
     }
     else if (queuestructure.rear == size - 1)
     {
         queuestructure.rear = 0;
         printf(""Rear resetted to one.\n"");
     }
     else
     {
         queuestructure.rear++;
         //adding the value to the queue
         queuestructure.data[queuestructure.rear] = number; 
         printf(""%d -> Added! \n"", queuestructure.data[queuestructure.rear]);
     }
 }
 
 
 void dequeue()
 //removing a specific node from the queue
 {
     //the element which is being removed
     int out;
     queuestructure.front++;
     out = queuestructure.data[queuestructure.front];
 
     printf(""%d -> Removed! \n"", out);
 }
 
 int main(void)
 {
     int user, value;
     //setting the front pointer to null
     queuestructure.front = -1; 
     //setting the rear pointer to null
     queuestructure.rear = -1; 
     //this means that our queue is empty at the beginning
     bool out = true;
 
     printf(""Enter 1 to enqueue queue.\n"");
     printf(""Enter 2 to dequeue queue.\n"");
     printf(""Enter 3 to exit.\n"");
     
     while (out = true)
     {
         scanf(""%d"", &user);
 
        ",C
"/* program for executing merge sort in a iterative manner*/
 /* TIME COMPLEXITY: O(nlogn) */
 
 #include <stdio.h>
 #include<stdlib.h>
 
 //function for taking input
 void input(int a[],int n)
 {
     for(int i=1; i<=n; i++)
     {
       printf(""\nElement: "" );
       scanf(""%d"",&a[i] );
     }
 }
 
 //function for swapping
 void swap(int *x,int *y)
 {
   int temp=*x;
   *x=*y;
   *y=temp;
 }
 
 //function for merging element
 void Merge(int A[],int l,int mid,int h)
 {
   //variable declaration
   int i=l,j=mid+1,k=l;
   int B[100];
 
   //loop for merging element
   while(i<=mid && j<=h)
   {
     if(A[i]<A[j])
     {
       B[k++]=A[i++];
     }
     else
     {
       B[k++]=A[j++];
     }
   }
 
   //loops for leftover element
   for(;i<=mid;i++)
   {
     B[k++]=A[i];
   }
   for(;j<=h;j++)
   {
     B[k++]=A[j];
   }
   for(i=l;i<=h;i++)
   {
      A[i]=B[i];
   }
 }
 void IMergeSort(int A[],int n)
 {
   //variable declaring
   int p,l,h,mid,i;
 
   //loop for executing iterative merge sort
   for(p=2;p<=n;p=p*2)
   { for(i=0;i+p-1<=n;i=i+p)
     {
       //calculating value for low, high and mid
       l=i;
       h=i+p-1;
       mid=(l+h)/2;
       //function calling
       Merge(A,l,mid,h);
     }
   }
 
   //if p/2 is less than n
   if(p/2<n)
   {
     //function calling
     Merge(A,0,p/2-1,n);
   }
 
 }
 int main()
 {
   //declaring and inputting array
   int size,*p;
   printf(""\nEnter size of array: "" );
   scanf(""%d"",&size );
   p=(int * )malloc(size*sizeof(int));
   input(p,size);
 
   //calling iterative merge sort
   IMergeSort(p,size);
 
   //loop for displaying
   printf(""\nSorted Array:\n "" );
   for(int i=0;i<size;i++)
   {
     printf(""%d "",p[i]);
   }
   printf(""\n"");
 
   return 0;
 }
 
 /*sample input/output */
 /*
 Enter size of array: 5
 
 Element: 80
 
 Element: 100
 
 Element: 20
 
 Element: 60
 
 Element: 40
 
 Sorted Array:
  20 40 60 80 100
 
 Press any key to continue . . .
 */
",C
"#include<iostream>
 using namespace std;
 
 //creating structure for node
 struct Node {
     char data;
     struct Node *left;
     struct Node *right;
 };
 
 // Insert Function
 Node* Insert(Node *root, char data) {
     //if root have no value
     //then create a node and insert values
     if (root == NULL) {
         root = new Node();
         root->data = data;
         root->left = root->right = NULL;
     }
     //check if data is less than root value
     //then insert into left subtree
     else if (data <= root->data)
         root->left = Insert(root->left, data);
     //check if data is less than root value
     //then insert into right subtree
     else
         root->right = Insert(root->right, data);
     return root;
 }
 
 //Inorder Function
 void Inorder(Node *root) {
     // if tree is empty then return
     if (root == NULL) return;
     //visit left subtree
     Inorder(root->left);
     //Print data
     printf(""%c "", root->data);
     //Visit right subtree
     Inorder(root->right);
 }
 //Main Function began
 int main() {
     Node* root = NULL;
     //input values
     root = Insert(root, 'M');
     root = Insert(root, 'B');
     root = Insert(root, 'Q');
     root = Insert(root, 'Z');
     root = Insert(root, 'A');
     root = Insert(root, 'C');
     //Print Nodes in Preorder.
     cout << ""\tOUTPUT\n"";
     cout << ""In-order traversal : "";
     Inorder(root);
     cout << ""\n"";
 }
 //Main Ends
 
 /*
 Sample Input Output:
 
 Input -> M B Q Z A C
 
 OUTPUT:
 Postorder traversal : A B C M Q Z
 
 Time Complexity: O(n)
 */
",C-Plus-Plus
"/*
 AIM :: To take any decimal number from the user 
        and convert that given decimal number into binary number
        using stack (by Array represention).
 */
 
 #include <stdio.h>
 //MACRO definition
 #define SIZE 50
 
 //Array representation of stack
 int stack[SIZE];
 int top = -1;
 
 //function to check whether stack is empty or not by returning 1 for empty and 0 for non-empty
 int isEmpty()
 {
     if (top == -1)
         return 1;
 
     return 0;
 }
 
 //function to check whether stack is full or not by returning 1 for full and 0 for not-full
 int isFull()
 {
     if (top == SIZE - 1)
         return 1;
 
     return 0;
 }
 
 //function to insert value into the stack
 void push(int r)
 {
     if (isFull())
         printf(""\nSTACK OVERFLOW\n"");
     else
         stack[++top] = r;
 }
 
 //function for delete value from the stack
 int pop()
 {
     if (isEmpty())
         printf(""\nSTACK UNDERFLOW\n"");
     else
         return stack[top--];
 }
 
 int main()
 {
     //number for storing decimal number given by user
     int number, num, reminder;
 
     printf(""\nEnter decimal number: "");
     scanf(""%d"", &number);
 
     //preserving original number for further use
     num = number;
     while (num >= 1)
     {
         reminder = num % 2;
         push(reminder);
         num = num / 2;
     }
 
     printf(""\nDECIMAL :: %d\n"", number);
     printf(""BINARY  :: "");
 
     while (!isEmpty())
         printf(""%d"", pop());
 
     return 0;
 }
 
 /*
 TEST CASE
 
 Enter decimal number: 10
 
 DECIMAL :: 10
 BINARY  :: 1010
 
 TIME COMPLEXITY  :: O(n)
 SPACE COMPLEXITY :: O(1)
 
 */
",C
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# Amazon Alexa Reviews Analysis""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### The aim is to analyse Alexa's reviews by performing NLP and using logistic regression. If the feedback is positive, the result is 1, else it is 0. ""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the dataset: [Amazon Alexa Reviews](https://www.kaggle.com/sid321axn/amazon-alexa-reviews)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [
     {
      ""name"": ""stderr"",
      ""output_type"": ""stream"",
      ""text"": [
       ""[nltk_data] Downloading package stopwords to\n"",
       ""[nltk_data]     C:\\Users\\DELL\\AppData\\Roaming\\nltk_data...\n"",
       ""[nltk_data]   Package stopwords is already up-to-date!\n""
      ]
     }
    ],
    ""source"": [
     ""import pandas as pd\n"",
     ""import nltk \n"",
     ""nltk.download('stopwords')                 # download the stopwords from NLTK\n"",
     ""\n"",
     ""import re                                  # library for regular expression operations\n"",
     ""import string                              # for string operations\n"",
     ""\n"",
     ""from nltk.corpus import stopwords          # module for stop words that come with NLTK\n"",
     ""from nltk.stem import PorterStemmer        # module for stemming\n"",
     ""from nltk.tokenize import TweetTokenizer   # module for tokenizing strings\n"",
     ""\n"",
     ""from sklearn.linear_model import LogisticRegression  \n"",
     ""from sklearn.feature_extraction.text import CountVectorizer  \n"",
     ""from sklearn.model_selection import train_test_split  \n"",
     ""from sklearn.metrics import roc_auc_score\n"",
     ""from sklearn.metrics import confusion_matrix\n",Python
"/*
  - Maximum Function (in Java) :
      A sequence is given A1,A2,,An (atleast 3 elements you need to give)
      Find the maximum value of the expression |Ax  Ay|+|Ay  Az|+|Az  Ax|
      over all triples of pairwise distinct valid indices (x,y,z).
 
  - Approach :
      1. We need to sort the given array
      2. To find maximum difference of two elements we will subtract 1st element with the last element of the array (|Ax  Ay|)
      3. Next, we can take middle element as 2nd element of the array (Az)
      4. That means, Ax = 1st element of the sorted array, Ay = last element, Az = 2nd element
      5. Therefore, adding |Ax  Ay|+|Ay  Az|+|Az  Ax| will give maximum result everytime
  */
 
 import java.util.Arrays;
 import java.util.Scanner;
 
 class MaximumFunction {
 	//main method
 	public static void main(String[] args) {
 
 		Scanner sc = new Scanner(System.in);
 
 		System.out.println(""Enter number of elements you want in array"");
 		//Input the number of elements you want in the array
 		long n = sc.nextLong();
 
 		//Creating array of n Elements
 		long[] array = new long[(int)n];
 
 		System.out.println(""Enter all the elements"");
 		//putting elements in the array
 		for(long t = 0 ; t<n ; t++) {
 			array[(int)t] = sc.nextLong();
 		}
 		//sorting the array
 		Arrays.sort(array);
 		//calculating max
 		long max = Math.abs(array[0] - array[1]) + Math.abs(array[1] - array[(int)n-1]) + Math.abs(array[(int)n-1] - array[0]);
 		//printing max
 		System.out.println(""Result = "" + max);
 	}
 }
 /*
  - Test Cases :
     1.  Input : Enter number of elements you want in array
                 10
                 Enter all the elements
                 7 5 3 9 1 2 7 3 8 9
        Output : Result = 16
 
  - Complexity Analysis :
     * Time Complexity : O(n)
          We are using only one for loop, so it iterates maximum 'n' times while traversing for loop
 
     * Space Complexity : O(n)
          Auxiliary space : O(1)  +  input space : O",Java
"/*SELECTION SORT: 
     * inplace comparison-based sorting algorithm.
     * list is divided into two parts, the sorted part at the left end and the unsorted part at the right end. 
     * The smallest element from the unsorted array is found and swapped with the leftmost element.
       ie, added to the sorted array. 
     * This process continues moving unsorted array boundary by one element to the right.
 */
 
 //importing readline module for dynamic input 
 var readline = require('readline');
 //initialising inputstream and outstream to process.stdin and process.stdout respectively.
 var rl = readline.createInterface(
     process.stdin, process.stdout);
 
 const selectionSort = (arr) => {
     let n = arr.length;
     // i is the current index
     for(let i=0; i<n-1; i++){
         //minPos stores the position of smallest element
         let minPos = i;
 
         //finding the minimum element from arr.
         for(let j=i+1; j<n; j++){
             if(arr[j] < arr[minPos]){
                 minPos = j;
             }
         }
         //swapping current element and smallest element;
         let temp = arr[minPos];
         arr[minPos] = arr[i];
         arr[i] = temp;
     }
     return arr;
 }
 
 //Reading input from console as a string and converting it to array 
 rl.question('Enter array elements comma separated: ', (input) => {
     let numbers = input.split("","");
     numbers = numbers.map( (x) => parseInt(x));
     console.log(selectionSort(numbers));
     rl.close();
 });
 
 /*
 CASE 1:
 input = [1, 8, 7, 61, 5, 4, 11];
 EXPECTED: [1,4,5,7,8,11,61]
 
 CASE 2:
 input = [1,8,3,9,10,10,2,4];
 EXPECTED: [1,2,3,4,8,9,10,10]
 
     Time Complexity - O(n^2)
     Space Complexity - O(1)
 
 */
",JavaScript
"#include <bits/stdc++.h>
 using namespace std;
 
 int maxSizeSquareWithOnes(int** input, int row, int col, int i, int j, int* ans, int** output){
     if(i == 0 || j == 0){
         output[i][j] = input[i][j];
         return input[i][j];
     }
     if(i < 0 || j < 0)
         return INT_MAX;
     if(output[i][j] > -1)
         return output[i][j];
     int option1 = maxSizeSquareWithOnes(input, row, col, i-1, j, ans, output);
     int option2 = maxSizeSquareWithOnes(input, row, col, i-1, j-1, ans, output);
     int option3 = maxSizeSquareWithOnes(input, row, col, i, j-1, ans, output);
     int res = min(option1, min(option2, option3));
     if(input[i][j] == 1)
         res++;
     if(input[i][j] == 0)
         res = 0;
     *ans = max(*ans, res);
     output[i][j] = res;
     return res;
 }
 
 int main()
 {
     int row,col;
     cout << ""Enter number of rows and colums: "" << endl;
     cin >> row >> col;
     int** input = new int*[row];
     int** output = new int*[row];
     cout << ""Enter elements for input matrix: "" << endl;
     for(int i = 0; i < row; i++){
         input[i] = new int[col];
         output[i] = new int[col];
         for(int j = 0; j < col; j++){
             cin >> input[i][j];
             output[i][j] = -1;
         }
     }
 
     int ans = INT_MIN;
     maxSizeSquareWithOnes(input, row, col, row-1, col-1, &ans, output);
     cout << ""Size of Maximum Square Matrix with all 1s is: "" << ans << endl;
 
     for(int i = 0; i < row; i++){
         delete[] input[i];
         delete[] output[i];
     }
     delete[] input;
     delete[] output;
     return 0;
 }
 
 /*
 Sample input/output:
 Enter number of rows and colums:                                                                                                
 6 5                                                                                                                             
 Enter elements for input matrix:                                                                 ",C-Plus-Plus
"/*
 C# program for jump Search
 Jump Search -
 Jump Search is a searching algorithm for sorted arrays. The basic idea
 is to check fewer elements (than linear search) by jumping ahead by 
 fixed steps or skipping some elements in place of searching all elements.
 */
 using System;
 
 public class JumpSearch
 {
     public static int JumpSearchAlgo(int[] arr, int x)
     {
         int n = arr.Length;
 
         //Finding Block size to be jumped
         int step = (int)Math.Floor(Math.Sqrt(n));
 
         //Finding the block where element is present (if it is present)
         int prev = 0;
         while (arr[Math.Min(step, n) - 1] < x)
         {
             prev = step;
             step += (int)Math.Floor(Math.Sqrt(n));
             if (prev >= n)
                 return -1;
         }
 
         //Doing a linear search for x in block beginning with prev.
         while (arr[prev] < x)
         {
             prev++;
 
             //if we reached next block or end of array,element is not present.
             if (prev == Math.Min(step, n))
                 return -1;
 
         }
 
         //if element is found 
         if (arr[prev] == x)
             return prev;
 
         return -1;
     }
 
     public static void Main()
     {
         Console.WriteLine(""Enter size of array that you like to create"");
         int n = int.Parse( Console.ReadLine());
         
         int[] arr = new int[n];
         Console.WriteLine(""Enter values in array"");
         
         for (int i = 0; i < n; i++)
         {
             arr[i] = int.Parse( Console.ReadLine());
         }
 
         Console.WriteLine(""Enter value that you like to find in array"");
         int x = int.Parse(Console.ReadLine());
 
         int index = JumpSearchAlgo(arr, x);
         if (index >= 0)
             Console.WriteLine(""Found at index: "" + index);
         else
             Console.WriteLine(x + "" isn't present in the array"");
     }
 }
 /*
 Sample Input
 Enter size of array that you l",C-Sharp
"/*
 A pronic number is a number which is the product of two consecutive integers.
 Such as 2=2*1 (2 and 1 are consecutive numbers)
         12=4*3
              
 This program will print the pronic numbers in the given range.        
 */
 
 #include <iostream>
 #include <math.h>
 using namespace std;
 
 /* Function to check whether number is pronic or not
 A number is pronic if the root of equation i^2+i-num=0 is real and integer.
 So, the discriminant of equation should be positive, odd  and perfect square for number to be pronic*/
 bool is_pronic(int num)
 {
     int dis = 1 + 4 * num;
     //checking discriminant is  positive,odd and perfect square
     if (dis >= 0 && floor(sqrt(dis)) == sqrt(dis))
         return true;
     else
         return false;
 }
 
 int main()
 {
     int ll, hl;
     cout << ""Enter the range for which you want to print PRONIC NUMBERS:\n"";
     cout << ""Enter lower limit:"";
     cin >> ll;
     cout << ""Enter higher limit:"";
     cin >> hl;
 
     //Printing pronic numbers in given range
     cout << ""Pronic numbers from "" << ll << "" to "" << hl << "" are:\n"";
     for (int i = ll; i <= hl; i++)
     {
         if (is_pronic(i))
             cout << i << "" "";
     }
 }
 
 /*
 
 Sample Input/Output:
 
 Input:
 Enter the range for which you want to print PRONIC NUMBERS:
 Enter lower limit:1
 Enter higher limit:1000
 
 Output:
 Pronic numbers from 1 to 1000 are:
 2 6 12 20 30 42 56 72 90 110 132 156 182 210 240 272 306 342 380 420 462 506 552 600 650 702 756 812 870 930 992
 
 Time Complexity:O(n) where n is total numbers in range
 Time Complexity of is_pronic()=O(1) 
 Space Complexity:O(1)
 
 */
",C-Plus-Plus
"/*
 Introduction 
 Given a Binary Tree , Print all vertical level sum's.
 It is guaranteed that all node's have unique key values.
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 //Declare Global maps to maintain sum of all vertical levels
 map<int,int>verticalLevelSum;
 //Define Global variable to keep track leftmost level and right most level
 int LeftMostLevel;
 int RightMostLevel;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Utility function to update levels of roots recurs",C-Plus-Plus
"/*
 This code gets the values of binary tree from the user and then convert the binary tree to doubly linked list.
 The formed Doubly linked list will have elements in the same order as that of inorder traversal of binary tree. 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 struct TreeNode{
 	int value;
 	TreeNode* left = NULL;
 	TreeNode* right = NULL;
 };
 
 TreeNode* newNode(int n){
 	TreeNode* t = new TreeNode;
 	t->value = n;
 	t->left = NULL;
 	t->right = NULL;
 }
 
 //This function inserts node into the binary tree
 TreeNode* insert(TreeNode* t, queue<TreeNode* > &q, int v){		
 	TreeNode* temp = newNode(v);
 	if(v==-1){
 		temp = NULL;
 	}
 	if(t==NULL){
 		t = temp;
 	}
 	else if(q.front()->left==NULL){
 		q.front()->left = temp;
 	}
 	else{
 		q.front()->right = temp;
 		q.pop();
 	}
 	q.push(temp);
 	return t;
 }
 
 //This function converts given vector into Binary Tree
 TreeNode* make_tree(vector<int> v){		
 	queue<TreeNode* > q;
 	TreeNode* t = NULL;
 	for(int i=0;i<v.size();i++){
 		t = insert(t,q,v[i]);
 	}
 	return t;
 }
 
 //This function prints all the elements of doubly linked list
 void print_elements(TreeNode* &T){		
 	TreeNode* temp = T;
 	cout<<""The elements of doubly linked list are: "";
 	while(temp!=NULL){
 		cout<<temp->value<<"" "";
 		temp = temp->right;
 	}
 }
 
 //This function converts Binary tree to doubly linked list
 void to_dll(TreeNode* T, TreeNode* &temp){		
 	if(T==NULL){
 		return;
 	}
 	to_dll(T->right,temp);
 	T->right = temp;
 	
 	if(temp!=NULL){
 		temp->left = T;
 	}
 	temp = T;
 	to_dll(T->left,temp);
 }
 
 void to_doubly_linked_list(TreeNode* T){		
 	TreeNode* h = NULL;
 	to_dll(T,h);
 	print_elements(h);
 }
 
 int main(){
 	cout<<""Enter number of nodes of binary tree: ""<<endl;
 	int node;		//number of nodes of binary tree
 	cin>>node;
 	
 	cout<<""Enter the values of nodes level by level and enter -1 if node is NULL: ""<<endl;
 	vector<int> binary_tree_values;
 	
 	while(node){		//asking user for elements of Binar",C-Plus-Plus
"/* SORTING USING BINARY SEARCH TREE
     Binary Search Tree is a special type of binary tree where
     1. The value of all the nodes in the left sub-tree is less than or equal to the value of the root.
     2. The value of all the nodes in the right sub-tree is greater than value of the root.
     3. This rule will be recursively applied to all the left and right sub-trees of the root.
 
     Inorder traversal
     1. Traverse the left subtree
     2. Visit the root.
     3. Traverse the right subtree
 
     Inorder traversal in BST gives sorted list
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // Declare treeNode with data , rc (right child) and lc (left child )
 typedef struct treeNode
 {
     int data;
     struct treeNode *lc;
     struct treeNode *rc;
 } treeNode;
 
 int count = 0;
 
 //to insert a node into BST
 treeNode *insertIntoTree(treeNode *root, int data)
 {
     //If tree is empty insert as root node
     if (root == NULL)
     {
         treeNode *ptr;
         ptr = new treeNode;
         ptr->data = data;
         ptr->lc = NULL;
         ptr->rc = NULL;
         root = ptr;
     }
     else
     {
         // insert recursively in accordance with BST properties
         if (root->data >= data)
         {
             root->lc = insertIntoTree(root->lc, data);
         }
         else if (root->data < data)
         {
             root->rc = insertIntoTree(root->rc, data);
         }
     }
     return root;
 }
 
 //to sort-inorder traversal gives sorted list
 void inorder(treeNode *root)
 {
     //If tree is empty
     if (root)
     {
         // recursively visit left sub-tree,root and right sub-tree
         inorder(root->lc);
         printf(""%d "", root->data);
         inorder(root->rc);
     }
 }
 
 // driver code
 int main()
 {
     //Initialize tree as empty
     treeNode *root;
     root = NULL;
     int n, data;
     //Accept the no. of elements and elements as user input
     scanf(""%d"", &n);
     for (int i = 0; i < n; i++)",C-Plus-Plus
"# Find array union of two arrays
 def union_of_arrays(arr1, arr2):
     # let's sort both arrays
     arr1.sort()
     arr2.sort()
     
     # iterators for arr1, arr2
     firstelement = 0
     secondelement  = 0
     # result
     union = []
 
     # then go along both arrays
     while firstelement < len(arr1) and secondelement < len(arr2):
         # if an element is lower than another, increment iterator in that array
         if arr1[firstelement] < arr2[secondelement]:
             firstelement += 1
         elif arr1[firstelement] > arr2[secondelement]:
             secondelement += 1
         else:
             # if we find equal elements
             union.append(arr1[firstelement]) # add element to the result
             # increment iterators of both arrays 
             firstelement += 1
             secondelement += 1
 
     return union
 
 
 if __name__ == ""__main__"":
     arr1 = list(map(int,input(""Enter the Number in list 1:\n"").split()))
     arr2 = list(map(int,input(""Enter the Number in list 2:\n"").split()))
     print(union_of_arrays(arr1, arr2))
 
 '''
 Time Complexity : O((n+m)log(n+m))
 Space Complexity : O(n+m)
 
 INPUT:
     Enter the list 1: 
     1 2 3 2 0
 	Enter the list 2: 
     5 1 2 7 3 2
 
 OUTPUT  
     [1, 2, 2, 3]
 '''",Python
"/*
 PREVIOUS GREATER ELEMENT USING STACK
 =========================================
 An Efficient Approach to find Previous Greater Element for every 
 element in an array. Given an array of Distinct Integers, find closest 
 (Positive-Wise) greater on left of every element. If there is no 
 greater element on left then print -1.
 
 Time Complexity: O(n)
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /* This function is used to check if top of the 
 stack is smaller we remove it or if top is 
 greater, then this element is previous greater
 element and print it.
 */
 
 void printPrevGreater(int arr[],int n){
     //Stack to store Previous Greater on top of stack.
     stack<int>s;
 
     /*Store first element of array to 
     check if top item is smaller then
     current item.*/
     s.push(arr[0]);
 
     /* This loop will help to find the 
        previous greater element from 
        the current value and simply print
        it and if not found print -1.
        NOTE : After every iteration whaterever the remaining element is 
        present at the top is Previous Greater and if stack is empty
        then previous Greater is -1. 
     */
     for(int i=0;i<n;i++){
         while(s.empty()==false && s.top()<=arr[i])
             s.pop();
 
         //pg : Previous Greater
         int pg=s.empty()?-1:s.top();
         cout<<pg<<"" "";
         s.push(arr[i]);
     }
 }
 // Driver's Code
 int main() 
 { 
     int n;
     cin>>n;
     int arr[n];
     for(int i=0;i<n;i++){
         cin>>arr[i];
     }
     printPrevGreater(arr,n);
     return 0; 
 }
 /*
 Testcase '1' :
 
 N = 5
 Input : arr[N] = {20, 30, 10, 5, 15}
 Output : -1  -1  30  10 30
 */
",C-Plus-Plus
"/*
 String Concatenation 
 Problem Statement : Take n string from user and concatenate them together.
 Input Format : First line takes number of strings to be concatenated.
                Next n lines contains the strings to be concatenated.
 Output Format : Print a single line that contains the concatenated string.
 Note : No space is there in between a single string.
 
 Approach : Take n strings as input using loop.
            Take a string variable and update it using append() function each time a new sting is entered.
            Print the string.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //within concat_str(...) final string is calculated sing append()
 void concat_str(vector<string> str,int size)
 {
     string f_str="""";
     for(int i=0;i<size;i++)
     {   
         f_str.append(str[i]);
     }
     cout<<f_str;
 }
 
 int main() 
 {
     vector<string> s;
     //n stores the no. of string
     int n; 
     cin>>n; 
     //loop for taking n strings from user 
     for(int i=0;i<n;i++)
     {
         string a;
         cin>>a;
         s.push_back(a);
     }
     concat_str(s,n);
     return 0;
 }
 
 /*
 Time Complexity : O(n*m), where m is maximum length of string a
 Space Complexity : O(k), where k is final length of f_str
 
 Sample Test Case :
 Input : 4
         ""This""
         ""is""
         ""Concatenated""
         ""String.""
 Output : ""ThisisConcatenatedString.""
 */
",C-Plus-Plus
"// C++ program to sort integers by the number of set bits present in their binary equivalence
 /*
 Given an integer array of numbers, We have to sort these integers in the ascending order by the 
 number of set bits(1's) present in their binary equivalence. In case two integers have equal 
 number of set bits we have to sort them in ascending order of magnitude.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /* We modify the compare method to sort the numbers w.r.t their number of set bits */
 static bool compare(const int &a, const int &b)
 {
     /* count stores the number of set bits
         and temp variables hold the values of a and b temporarily */
     int count_a_1 = 0, count_b_1 = 0, temp_a = a, temp_b = b;
     // Count number of set bits in a
     while (temp_a)
     {
         temp_a = temp_a & (temp_a - 1);
         count_a_1++;
     }
     // Count number of set bits in b
     while (temp_b)
     {
         temp_b = temp_b & (temp_b - 1);
         count_b_1++;
     }
 
     // If their counts are equal, check their magnitude.
     if (count_a_1 == count_b_1)
         return a < b;
     return count_a_1 < count_b_1;
 }
 
 int main()
 {
     int n, ele;
     cout << ""How many numbers do you want to sort w.r.t the number of set bits? "";
     cin >> n;
     if (n == 0)
     {
         cout << ""There are no numbers to sort!!"";
         return 0;
     }
     vector<int> arr;
     cout << ""Enter the numbers:"";
     for (int i = 0; i < n; i++)
     {
         cin >> ele;
         arr.push_back(ele);
     }
     // Call the sort method, with our modified compare method
     sort(arr.begin(), arr.end(), compare);
     cout << ""\nThe sorted array is: "";
     for (int i = 0; i < n; i++)
     {
         cout << arr[i] << "" "";
     }
 
     return 0;
 }
 
 /*
 
 Time Complexity: O(logn)
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 How many numbers do you want to sort w.r.t the number of set bits? 5
 Enter the numbers: 13 2 9 34 22 
 
 The sorted ",C-Plus-Plus
"// Two ocurring number
 
 #include<bits/stdc++.h>
 using namespace std;
 int main()
 {
 	int n;
 	cout<<""Enter number of elements \n"";
 	cin>>n;
     vector<int>arr;
     int a;
     for(int i=0;i<n;i++)
     {
     	cin>>a;
     	arr.push_back(a);
 	}
    int xors = 0, res1 = 0, res2 = 0; 
         
         for (int i = 0; i < n; i++) 
         xors = xors ^ arr[i]; 
   
    
         int sn = xors & (~(xors - 1)); 
   
     
         for (int i = 0; i < n; i++) 
         { 
             if ((arr[i] & sn) != 0) 
                 res1 = res1 ^ arr[i]; 
             else
                 res2 = res2 ^ arr[i]; 
         } 
         
         
         cout <<  res1 << "" "" << res2;
 	  
 }
 
 /*
 Time Complexity: O(n) 
 Space Complexity: O(1)
 */
 
 /*Sample Input:
 Example 1:- 
 Enter number of elements
 8
 2 2 3 8 4 4 1 1
 Example 2:-
 Enter number of elements
 7
 1 1 2 2 5 3 3
 
 Sample Output:
 Example 1:- 
 3 8
 Example 2:-
 5 0
 */
 
",C-Plus-Plus
"import java.util.Scanner;
 
 /**
  * <h1>Modified Caesar Cipher</h1>
  * <p>
  * To Implement Modified Version of Caesar Cipher
  * </p>
  * <b>Description</b>
  * <p>
  * class ModifiedCaesarCipher is used to encrypt plainText to cipherText using Modified Caesar Algorithm and decrypt
  * cipherText to plainText using the respective algorithm, in Modified Caesar Cipher the encryption takes place by
  * increasing or decreasing the key-value to the character based on its index number from A-Z series, instead of just
  * increasing the key to the character which was done in Caesar Cipher, which provides more enhancement in security and
  * decreases the chances of attack.
  * </p>
  * <b>Requirements</b>
  * <p>
  * A string plain text and an integer key are required for encryption and for decryption the cipher text which is
  * calculated from the given key and the key itself.
  * </p>
  * 
  * <b>Reference for understanding the algorithm</b>
  * <a href=""https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.402.8295&rep=rep1&type=pdf""> Modified CaesarCipher
  * for Better Security Enhancement </a>
  * 
  */
 public class ModifiedCaesarCipher
 {
     /**
      * <p>
      * This is a public method used to encrypt plainText using integer key using Modified Caesar Cipher algorithm.
      * </p>
      * <b>Process</b>
      * <ul>
      * <li>a string plain text and integer key are taken as input</li>
      * <li>iteratively each character of plain text is encrypted
      * <ul>
      * <li>The character index of the current character is calculated, if the character is whitespace then it is not
      * calculated</li>
      * <li>If the character index is even then the character value is incremented by the key-value, else decremented</li>
      * <li>If the sum of the character value and key-value extends or descends within the letter group range (A-Z,a-z,0-9),
      * then the values are circulated and encrypted unless and until their encrypted value comes it the r",Java
"""""""Julia program to implement Bubble Sort
 In Bubble Sort we compare the adjacent elements and swap them such that the greater
 element among them comes in the right-side. After each iteration, one smallest element
 goes towars the end of the array.
 """"""
 
 function bubble_sort(arr, n)
     # Iterate the entire array
     for i in 1:n
         # Iterate till the concerned part only.
         for j in 1:(n-i)
             # Swap adjacent elements if they are in wrong order
             if(arr[j] > arr[j+1])
                 arr[j], arr[j+1] = arr[j+1], arr[j]
             end
         end
     end
 end
             
 
 print(""How many numbers do you want to sort? "")
 n = readline()
 n = parse(Int64, n)
 if (n <= 0)
     println(""No numbers to sort!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 bubble_sort(arr, n)
 print(""The numbers in sorted order is "")
 print(arr)
 
 
 
 """"""
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 How many numbers do you want to sort? 5
 Enter the numbers: 4 2 5 1 3
 The numbers in sorted order is [1, 2, 3, 4, 5]
 
 """"""
",Julia
"/*Problem Statement:
 Given n Circles present in x-y plane such that all the circles have their centre aligned on the x-axis.
 The task is to remove some of them, such that no two circles are intersecting. 
 Find the minimum number of circles that need to be removed. */ 
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /* this function will help in sorting the circles on the 
 basis of their radius */
 bool compare(pair<int, int> a, pair<int, int> b)
 {
     if ((a.first + a.second) == (b.first + b.second))
     {
         return (a.first - a.second) < (b.first - b.second);
     }
     else
     {
         return (a.first + a.second) < (b.first + b.second);
     }
 }
 
 int main()
 {
     int ans = 1;
     int n, center, radius;
     cout<<""Enter total number of circles: ""<<endl;
     cin >> n;
     vector<pair<int, int> > v;
 
     for (int i = 0; i < n; i++)
     {
         cout<<""Enter the center and the radius respectively: ""<<endl;
         cin >> center >> radius;
         v.push_back(make_pair(center, radius));
     }
 
     sort(v.begin(), v.end(), compare);
 
     int val = v[0].first + v[0].second;
 
     for (int i = 0; i < n - 1; i++)
     {
         if (val <= v[i + 1].first - v[i + 1].second)
         {
             ans++;
             val = v[i + 1].first + v[i + 1].second;
         }
     }
 
     cout <<""Minimum circles that are to be removed: ""<< (n - ans) <<endl;
     return 0;
 }
 /*Example:
 1)Input:
 Enter total number of circles:
 4
 Enter the center and the radius respectively:
 1 1
 Enter the center and the radius respectively:
 2 1
 Enter the center and the radius respectively:
 3 1
 Enter the center and the radius respectively:
 4 1
 Output:
 Minimum circles that are to be removed: 2
 Time Complexity: O(nlogn)
 Space Complexity: O(nlogn) 
 */
 
",C-Plus-Plus
"#Python program to implement Selection Sort
 
 def selectionSort(array, n):
     i = 0
     while i < n:
         #Initilizing mini as i
         mini = i
         j = i + 1
         while j < n:
             #If element at j is smaller than mini then change mini to j
             if array[j] < array[mini]:
                 mini = j
             j += 1
         #swapping elements at mini and i    
         (array[i], array[mini]) = (array[mini], array[i])
         i += 1          
 
 
 data = []
 n = int(input(""Enter the size of array :""))
  
 print('Enter the elements of array:');
 for i in range(n):
     data.append(int(input()))
     
 # Sending element to get sorted
 selectionSort(data, n)
  
 # Priting Elements after Getting Sorted
 for d in data:
     print(d, end = "" "")
 
 """"""
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 INPUT
 Enter the size of array: 5
 Enter the elements of array: 
 5
 4 
 3 
 2 
 1
 
 OUTPUT
 1 2 3 4 5
 
 """"""",Python
"/*
     Comb Sort is a relatively simple sorting algorithm. It is an improvement over Bubble sort
     by using gap of size more than 1. The gap starts with a large value and starts shrinking by
     1.3 in every iteration until it reaches the value 1.
     You can check out more about this Sorting Algorithm here:- https://en.wikipedia.org/wiki/Comb_sort
 */
 
 import java.util.Scanner;
 
 public class CombSort_implementation {
     public static void main(String[] args) {
         Scanner input = new Scanner(System.in);
         System.out.println(""Enter the size of the array:- "");
         int n = input.nextInt();
 
         int arr[] = new int[n];
         System.out.println(""Enter the elements of the array:- "");
         
         for(int i =0; i<n; i++){
             arr[i] = input.nextInt();
         }
 
         comb_sort(arr);
 
         System.out.println(""\nSorted Array is:- "");
         for(int i = 0; i<n; i++){
             System.out.print(arr[i] + "" "");
         }
     }
 
     //Method to swap two elements of an Array
     public static void swap_elements_in_array(int idx_1, int idx_2, int arr[]){
         int temp;
         temp = arr[idx_1];
         arr[idx_1] = arr[idx_2];
         arr[idx_2] = temp;
     }
 
     public static void comb_sort(int arr[]){
         int gap = arr.length;
         //A flag is use to check whether the elements of the array in a gap are sorted or not.
         boolean flag = true;
         while(gap != 1 || flag){
             //Dividing size of gap in every iteration by 1.3
             gap = (int)Math.floor(gap/1.3);
             if(gap < 1){
                 gap = 1;
             }
             flag = false;
 
             for(int i = 0; i <= arr.length-gap-1; i++){
                 if(arr[i] > arr[i+gap]){
                     swap_elements_in_array(i, i+gap, arr);
                     flag = true;
                 }
             }
         }
     }
 }
 
 /*
     Time Complexity:- Best Case - O(n*logn)
             ",Java
"'''
 Keyword cipher is a form of monoalphabetic substitution. Now a encryption is 
 pad is formed of alphabets from [a-z] such that the first part of encrption 
 contains unique letters of the key and the rest are the remaining alphabets 
 from [a-z]. That is, until the key is used up, whereupon the rest of the 
 ciphertext letters are used in alphabetical order, excluding those already 
 used in the key.
 '''
 
 import string
 
 ''' This function maintains a list of characters occuring in the key.
     It counts each character once. It returns the list.'''
 def find_unique_char(key):
 
  
     unique = []
     for i in key:
         if((i not in unique) and i != "" ""):
             unique.append(i)
     return unique
 
 ''' This function forms the padding. It takes output of the above
     function and then appends remaining of [a-z] in the list
     and returns the list.'''
 def find_pad(pad_key):
 
 
     # Calls the above function
     key = find_unique_char(pad_key)
 
     # This contains all character from a to z
     ALPHABET = string.ascii_lowercase
 
     for i in ALPHABET:
         if i not in key:
             key.append(i)
     return key
 
 ''' This function takes plaintext and key as input.
     It pads the plaintext using the keyword formed
     by calling above function.'''
 def encrypt_plaintext(message, key):
 
     
     ALPHABET = string.ascii_lowercase
     enc = """"
     pad = find_pad(key)
 
     ''' This loop iterates through the whole message.
          Find index of each character in normal [a-z].
          Replaces it by the character present at the
          same index of pad.'''
     for i, j in enumerate(message):
         if j != "" "":
             if j.islower():
                 index = ALPHABET.index(j)
                 enc += pad[index]
             else:
                 index = ALPHABET.index(j.lower())
                 enc += pad[index].upper()
         else:
             enc += "" ""
     return enc
 
 
 # Calling the driver functio",Python
"/*
 Program to input an string to obtain the reversal string and it's length using recursion.
 */
 
 #include<stdio.h>
 #include<string.h>
 
 void org_str(char *str);
 void rev_str(char *str);
 int length(char *str);
 
 void org_str(char *str )
 {
 	if(*str == '\0')
 	    return;
 	putchar(*str );
 	org_str(str+1);
 }
 
 void rev_str(char *str )	
 {
 	if(*str == '\0')
 	    return;
 	rev_str(str+1);
 	putchar(*str );
 }
 
 main( )
 {
 	char str[100];
 	printf(""Enter the string : \n"");
 	gets(str);
 	printf(""Your entered string is : \n"");
 	org_str( str );
 	printf(""\n"");
 	printf(""The reversed string is : \n"");
 	rev_str(str);
 	printf(""\n"");
 	printf(""The length of the string is : \n"");
 	printf(""%d"",strlen(str));
 	printf(""\n"");
 }	
 
 /*
 Enter the string :                                                                                                                                               
 string                                                                                                                                                           
 Your entered string is :                                                                                                                                         
 string                                                                                                                                                           
 The reversed string is :                                                                                                                                         
 gnirts                                                                                                                                                           
 The length of the string is :                                                                                                                                    
 6
 
 Time Complexity : O(n)
 Space Complexity : o(1)
 */
",C
"/*
 Count Complete Tree Nodes
 
 You are provided the roots of
 the complete binary tree, Your task is to 
 find out the total numbers of nodes of the complete 
 tree and return it.
 A complete tree has every level, except the last one, 
 completely filled and all nodes in the last level 
 are as far left as possible. The total number of nodes, 
 lies between 1 to 2^h nodes, inclusive at the last 
 level h.
 */
 
 import java.io.*;
 import java.until.*;
 
 //defining a class for storing nodes of tree
 class BTNode 
 {
     int value;
     BTNode left;
     BTNode right;
     BTNode() 
     {}
     BTNode(int value) 
     {
         this.value = value; 
     }
     BTNode(int value, BTNode left, BTNode right) 
     {
         this.value = value;
         this.left = left;
         this.right = right;
     }
 }
 
 public class CountCompleteTreeNode
 {
     //fuction to count the nodes of the 
     //complete tree
     public int compTreeNodes(BTNode root)
     {
         //if the root is empty then simply return 0
         if(root == null)
         {
             return 0;
         }
 
         BTNode left = root, right = root;
         //Initializing two pointers for incrementing level for
         //each side left and right 
         int heightLeft = 0, heightRight =0;
 
         //for counting nodes on left side
         while(left != null)
         {
             heightLeft++;
             left = left.left;
         }
 
         //for counting nodes of right side
         while(right != null)
         {
             heightRight++;
             right = right.right;
         }
 
         //if the pointers are at same level then 
         if(heightLeft == heightRight)
         {
             return (1 << heightLeft) - 1;
         }
 
         //otherwise we recursively call function 
         //for left and right roots and increment the result 
         //by 1, and return it
         return 1 + compTreeNodes(root.left) + compTreeNodes(root.right);
     }
 
     //dri",Java
"/*
 There is an array of n integers. There are also 2 disjoint sets, A and B, each containing m integers.
 You like all the integers in set A and dislike all the integers in set B. Your initial happiness is 0.
 For each i integer in the array, if i e A , you add 1 to your happiness. If i e B, you add -1 to your happiness.
 Otherwise, your happiness does not change. Output your final happiness at the end.
 	Input Format
 
 	The first line contains integers n and m separated by a space.
 	The second line contains n integers, the elements of the array.
 	The third and fourth lines contain m integers, A and B, respectively.
 
 	Output Format
 
 	Output a single integer, your total happiness.
 
 Problem Link: https://www.hackerrank.com/challenges/no-idea/problem
 */
 
 import java.util.Scanner;
 
 public class HappinessProblem {
     public static int findHappiness(int[] arr, int A[], int B[]) {
         int happiness = 0;
         for (int i = 0; i < arr.length; i++) {
             for (int j = 0; j < A.length; j++) {
                 if (arr[i] == A[j]) {
                     happiness++;
                     break;
                 }
                 if (arr[i] == B[j]) {
                     happiness--;
                     break;
                 }
             }
         }
         return happiness;
     }
 
     public static void main(String[] args) {
 
         Scanner sc = new Scanner(System.in);
 
         System.out.println(""Enter n and m:"");
         // 1st line of input
         int n = sc.nextInt(), m = sc.nextInt();
         int[] A = new int[m], B = new int[m], arr = new int[n];
 
         System.out.println(""Enter elements of array:"");
         // 2nd Line of input
         for (int i = 0; i < n; i++) {
             arr[i] = sc.nextInt();
         }
 
         System.out.println(""Enter elements of A:"");
         // 3rd line of input
         for (int i = 0; i < m; i++) {
             A[i] = sc.nextInt();
         }
 
         System.out.println(""Enter ",Java
"//This program solves the problem of placing N chess queens on an NN chessboard so that no two queens attack each other.
 #include<stdio.h>
 
 #include<conio.h>
 #define INF 9999
 char board[20][20];
 int n, count;
 int getMarked(int row)
 {
   int i;
   for(i=0;i<n;i++)
   {
     if(board[row][i] == 'Q')
     {
       return i;
     }
   }
   return INF;
 }
 int feasible(int row, int col)
 {
 int i, tcol;
 for(i=0;i<n;i++)
   {
     tcol = getMarked(i);
     if(col==tcol || abs(row-i)==abs(col-tcol))
     {
       return 0;
     }
   }
   return 1;
 }
 void printSolution()
 {
   int i, j;
   printf(""\n__Solution %d__\nCoordinates: "", count);
   for(i=0;i<n;i++)
   {
     for(j=0;j<n;j++)
     {
       if(board[i][j] == 'Q')
       {
         printf(""(%d, %d)"", i+1, j+1);
       }
     }
   }
   printf(""\nBoard: __"", count);
   for(i=1;i<=n;i++) 
   { 
     printf(""___"");
   }
   printf(""\n      |  "");
   for(i=1;i<=n;i++) 
   { 
     printf("" %d "", i);
   }
   printf(""|\n"");
   for(i=0;i<n;i++)
   {
     printf(""      |%d "", i+1);
     for(j=0;j<n;j++)
     {
       printf("" %c "", board[i][j]);
     }
     printf(""|\n"");
   }
   printf(""       __"");
   for(i=1;i<=n;i++) 
   { 
     printf(""___"");
   }
   printf(""\n"");
   getch();
 }
 void nQueens(int row)
 {
   int i;
   if(row<n)
   {
     for(i=0;i<n;i++)
     {
       if(feasible(row,i))
       {
         board[row][i] = 'Q';
         nQueens(row+1);
         board[row][i] = '-';
       }
     }
   } 
   else
   {
     count++;
     printSolution();
   }
 }
 void main()
 {
   int i, j;
   clrscr();
   printf(""No of Queen (N) = "");
   scanf(""%d"", &n);
   for(i=0;i<n;i++)
   {
     for(j=0;j<n;j++)
     {
       board[i][j] = '-';
     }
   }
   nQueens(0);
   printf(""\nTotal Solutions: %d"", count);
   getch();
 }
",C
"/*
 Quick sort algorithm starts by choosing a pivot element around which other elements are
 arranged by moving the elements smaller to the left while the larger elements are moved to the right.
 */
 
 #include <stdio.h>
 
 int partitionArray(int a[], int low, int high){
 
     //selecting the pivot as the highest element
     int pivot = a[high];
     int i = low - 1;
 
     
     for(int j = low; j < high; j++){
         //check for current element with reference to pivot
         if(a[j] < pivot){
             //if less then increase the position
             i++;
             int temp = a[i];
             a[i] = a[j];
             a[j] = temp;
         }
     }
     int temp = a[i + 1];
     a[i + 1] = a[high];
     a[high] = temp;
     //returning the correct position of the index
     return (i + 1);
 }
 void quickSort(int a[], int low, int high){
     if(low < high){
         //storing the correct position of the pivot in indexPos
         int indexPos = partitionArray(a, low, high);
 
         //iterating on the left partition
         quickSort(a, low, indexPos-1);
         //iterating on the right partition
         quickSort(a, indexPos + 1, high);
     }
 }
 void printArray(int a[], int size){
     printf(""The sorted array: "");
     int  i;
     for(i = 0; i < size; i++){
         printf(""%d "",a[i]);
     }
 }
 int main(){
     //array to hold elements for sorting
     int A[100];
 
     int size,i,j;
 
     printf(""Enter the size of the array: "");
     scanf(""%d"", &size);
 
     //Entering the elements of the array
     printf(""Enter the array elements : "");
     for(i = 0; i <size; i++){
         scanf(""%d"",&A[i]);
     }
 
     printf(""\n"");
 
     quickSort(A, 0, size - 1);
 
     printArray(A, size);
 }
 
 /*Sample Output:
 Enter the size of the array: 5
 Enter the array elements : 4 6 8 3 1
 The sorted array: 1 3 4 6 8
 */
 /*
 Space complexity: O(N log N)
 Time Complexity:
 Best Case: (N log N)		
 Average Case: (N log N)
 Worst Case: O(N^2)
 *",C
"# Program to implement QuickSort Algorithm in Python
 
 
 '''
 This function takes last element as pivot, places  the pivot element at
 its correct position in sorted  array, and places all smaller(smaller than
 pivot) to left of pivot and all greater elements to right  of pivot
 '''
 
 
 def partition(arr, low, high):
     '''
     The value of i is initialized to (low-1) since initially first element
     is swapped by itself
     Reason: no greater element has been encountered apart from itself
     '''
     pivotElement = arr[high]
     i = (low - 1)
 
     for j in range(low, high):
         if arr[j] < pivotElement:
             i += 1
             # swap elements arr[i] and arr[j]
             arr[i], arr[j] = arr[j], arr[i]
 
     # swap pivot element with element at index=(i + 1) since loop ended,
     # to obtain LHS of pivot
     arr[i + 1], arr[high] = arr[high], arr[i + 1]
 
     return(i + 1)
 
 '''
 This is the calling function that implements QuickSort algorithm, where:
 arr = input array given by user
 low = starting index
 high = ending index
 '''
 
 
 def quickSort(arr, low, high):
     if low < high:
 
         # pi is partitioning index, arr[p] is now at right place
         pi = partition(arr, low, high)
 
         # Separately sort elements before partition and after partition
         quickSort(arr, low, pi-1)
         quickSort(arr, pi+1, high)
 
 # main function
 if __name__ == ""__main__"":
     n = int(input())
     arr = list(map(int, input().split()))
     quickSort(arr, 0, n-1)
 
     # print the final sorted array in ASCending order
     for i in range(n):
         print(arr[i], end="" "")
     print()
",Python
"#Function to convert a positive decimal number into its binary equivalent
 '''
 By using the double dabble method, append the remainder
 to the list and divide the number by 2 till it is not
 equal to zero
 '''
 def DecimalToBinary(num):
     #the binary equivalent of 0 is 0000
     if num == 0:
         print('0000')
         return
     else:
         binary = []
         while num != 0:
             rem = num % 2
             binary.append(rem)
             num = num // 2
     #reverse the list and print it
     binary.reverse()
     for bit in binary:
         print(bit, end="""")
 
 #executable code
 decimal = int(input(""Enter a decimal number to be converted to binary : ""))
 print(""Binary number : "")
 DecimalToBinary(decimal)
 
 '''
 Sample I/O :
 Input :
 Enter a decimal number to be converted into binary: 8
 
 Output:
 Binary number:
 1000
 
 Time Complexity : O(n)
 Space Complexity : O(1)
 '''
",Python
"/* 
 this is a backtracking problem which is used for solving sudoku
 in sudoku there should be no repetition of number int same row, same column and same grid which of 3*3 size
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 // to check whether we can place a particular number in the given cell or not
 bool isSafe(int mat[][9], int i, int j, int n, int number){
     /* we will check row and column of a cell whether given number is present or not
      if present then we will return false */
     for(int x=0;x<n;x++){
         if(mat[x][j] == number || mat[i][x] == number){
             return false;
         }
     }
 
     //sub grid check
     int root = sqrt(n);
     int sx = (i/root)*root;
     int sy = (j/root)*root;
     // iterating the grid
     for(int x=sx;x<sx+root;x++){
         for(int y=sy;y<sy+root;y++){
             if(mat[x][y] == number){
                 return false;
             }
         }
     }
 
     //The number can be placed
     return true;
 }
 
 // function to create a sudoku solver
 bool sudoku_solver(int mat[][9], int i, int j, int n){
     //base case
     if(i == n){
         // if all the rows are completely filled
         //print the solution
         for(int i=0;i<n;i++){
             for(int j=0;j<n;j++){
                 cout<<mat[i][j]<<"" "";
             }
             cout<<endl;
         }
         return true;
     }
 
     /*
     if all the columns of a particular row is filled then we will move to next row
     and will start from the 0th column  */
     if(j == n){
        return sudoku_solver(mat,i+1,0,n);
     }
     
     // if the number filled is not 0 then we will skip it move to next column
     if(mat[i][j] != 0){
        return sudoku_solver(mat,i,j+1,n);
     }
 
     /* recursive case
     fill the current cell with possible options */
     for(int number=1;number<=n;number++){
         if(isSafe(mat,i,j,n,number)){
             // assume that it is correct not at correct position
             mat[i",C-Plus-Plus
"/* GIVEN A LINKED LIST ,TASK IS TO REVERSE THE LINKED LIST BY REVERSING THE LINKS */
 #include<stdio.h>
 #include<malloc.h>
 
 /* structure containing data part and link part */
 struct node
 {
 	int data;
 	struct node *link;
 };
 
 void append(struct node** ,int);
 void display(struct node*);
 void reverse(struct node **);
 
 int main()
 {
     struct node* head = NULL;  
     int i,p,c;
     
     printf(""ENTER THE NUMBER OF ELEMENTS IN LINKED LIST ""); 
     scanf(""%d"",&i); 
     for(p=i;p>0;p--)  
     {  
         printf(""\nENTER THE ELEMENT "");
         scanf(""%d"",&c);
         append(&head,c);  
     }
 	
 	printf(""LINKED LIST: \n"");
 	display(head);
 	reverse(&head);
 	printf(""\nREVERSED LINKED LIST: \n"");	
 	display(head);
 						
 	return 0;
 }
 
 /*adds node at the end of a linked list*/
 void append(struct node **head_ref,int num)
 {
 	struct node *temp,*r;
 	
 	if(*head_ref==NULL)
 	{
 		temp=(struct node*)malloc(sizeof(struct node));
 		temp->data=num;
 		temp->link=NULL;
 		*head_ref=temp;
 	}
 	else
 	{
 		temp=*head_ref;
 		/* go to last node */
 		while(temp->link != NULL)
 		{
 			temp = temp->link;
 		}
 		/* add node at end */
 		r=(struct node*)malloc(sizeof(struct node));
 		r->data=num;
 		r->link=NULL;
 		temp->link=r;
 	}
 }
 
 /* displays the content of linked list */
 void display(struct node *head_ref)
 {	
 	/* traverse the entire linked list */
 	while(head_ref!=NULL)
 	{
 		printf(""%d\t"",head_ref->data);
 		head_ref=head_ref->link;
 	}
 }
 
 /*reverses the linked list*/
 void reverse(struct node **head_ref)
 {
 	struct node *cur,*prev,*next;
 	
 	cur=*head_ref;
 	prev=NULL;
 	next=NULL;
 	
 	/*traverse the entire linked list*/
 	while(cur!=NULL)
 	{
 		next=cur->link;
 		/*reverse current node pointers*/
 		cur->link=prev;
 		/*move pointers one position ahead*/
 		prev=cur;
 		cur=next;
 	}
 	
 	*head_ref=prev;
 }
 
 /*
 SAMPLE INPUT OUTPUT
 
 ENTER THE NUMBER OF ELEMENTS IN LINKED LIST 5
 
 ENTER THE ELEMENT 4
 
 ENTER THE ELEMENT 12",C
"/*Given a value V, if we want to make change for V cents, and we have infinite supply of each of C = { C1, C2, .. , Cm} valued coins, what is the minimum number of
 coins to make the change?
 Examples:
 
 Input: coins[] = {25, 10, 5}, V = 30
 Output: Minimum 2 coins required
 We can use one coin of 25 cents and one of 5 cents 
 
 Input: coins[] = {9, 6, 5, 1}, V = 11
 Output: Minimum 2 coins required
 We can use one coin of 6 cents and 1 coin of 5 cents */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 int main()
 {
 	int n, coin[100], tot, i, j;
 	cout << ""Enter number of coins"" << endl;
 	cin >> n;
 	cout << ""Enter denominations of coins"" << endl;
 	for(i = 0; i < n; i++){
 		cin >> coin[i];
 	}
 	cout << ""Enter value"" << endl;
 	cin >> tot;
 	int dp[tot + 1] = {0};
 	for(i = 1; i <= tot; i++)
 	{
 		int num = INT_MAX;
 		for(j = 0; j < n; j++)
 		{
 			if(coin[j] <= i)
 			num = min(num, dp[i - coin[j]] + 1);    /*bottom-down approach*/
 		}
 		dp[i] = num;
 	}
 	cout << dp[tot];
 	return 0;
 }
",C-Plus-Plus
"/* C program to find whether a linked list is palindrome or not.
 We need to detect whether the front half of the list is the reverse of the second half.
 By reversing the front half of the list and for that stack can be used.
 
 We know the size of the linked list, we can iterate onto the first half of the elements in a for loop,
 pushing each element onto a stack. Now, we iterate the rest of the linked list. At each step, we compare
 the node to the top of the stack. If we complete the iteration without finding the difference, 
 then the linked list is a palindrome.
 
 */
 #include <bits/stdc++.h>
 #include <stdio.h>
 
 // structure of a node in a linked list
 struct Node {
   int value;
   struct Node *next;
 };
 
 struct Node *head = NULL;
 
 // Dynamically generate the node
 struct Node *gen_node(int val) {
   struct Node *newnode;
   newnode = (struct Node *)malloc(sizeof(struct Node));
   if (newnode == NULL) {
     printf(""\nMemory was not allocated"");
     return 0;
   } else {
     newnode->value = val;
     newnode->next = NULL;
     return newnode;
   }
 }
 
 // Insert node at the beginning of the linked list
 void insert_node_first() {
   int val;
   struct Node *newNode, *temp;
   printf(""\nEnter the value for the node:"");
   scanf(""%d"", &val);
   newNode = gen_node(val);
   if (head == NULL) {
     head = newNode;
     head->next = NULL;
   } else {
     temp = head;
     head = newNode;
     head->next = temp;
   }
 }
 
 // Find palindrome in the linked list
 int find_Palindrome(int size) {
   int arr[size / 2], i = 0, j = 0;
   struct Node *fast = head;
   struct Node *slow = head;
   /* Push elements from first half of the linked list onto array.
   When fast pointer (which is moving at 2x speed)reaches the end of the linked
   list, then we know we are at the middle
   */
   while (fast != NULL && fast->next != NULL) {
     arr[i] = slow->value;
     slow = slow->next;
     fast = fast->next->next;
     i++;
   }
 
   // Has odd number of elements",C
"'''
 Purpose : 
 In a trading system a product is bought in the morning and sold out on the same day. 
 If a person can make only 2 transactions a day with a condition that second transaction is followed only after first then find the maximum profit the person could get.
 
 Input formate : 
 Line1 : Number of test cases
 Line2 : Length of the prices array
 Line3 : prices array separated with a space
 
 Output formate : 
 The maximum profit
 
 Method :
 Dynamic programming 
 
 Intuition : 
 Storing the maximum possible profit of every subarray in a table named profit 
 Finally returning the profit[n-1]
 
 
 Argument: Array 
 return : int 
 
 '''
 
 
 def maxProfit(price, n):
 
 	# Create profit array and initialize it as 0
 	profit = [0]*n
 
 	''' Get the maximum profit with only one transaction allowed.
 	After this loop,profit[i] contains maximum profit from price[i..n-1] using at most one trans.
 	max_price = price[n-1] '''
 	
 	for i in range(n-2, 0, -1):
 
 		if price[i] > max_price:
 			max_price = price[i]
 
 		''' we can get profit[i] by taking maximum of:
 		a) previous maximum,i.e., profit[i+1]
 		b) profit by buying at price[i] and selling at max_price'''
 		
 		profit[i] = max(profit[i+1], max_price - price[i])
 
 	'''Get the maximum profit with two transactions allowed
 	After this loop, profit[n-1] contains the result'''
 	
 	min_price = price[0]
 
 	for i in range(1, n):
 
 		if price[i] < min_price:
 			min_price = price[i]
 
 		'''Maximum profit is maximum of:
 		a) previous maximum,i.e., profit[i-1]
 		b) (Buy, Sell) at (min_price, A[i]) and 
 		profit of other trans.stored in profit[i]'''
 		
 		profit[i] = max(profit[i-1], profit[i]+(price[i]-min_price))
 
 	result = profit[n-1]
 
 	return result
 
 # Driver function
 def main():
     for _ in range(int(input())):
         price = []
         length=int(input())
         price=list(map(int,input().split()))
         print (""Maximum profit is"", maxProfit(price,length),""\n"")
 
 	
 if __name__==""__ma",Python
"/*
 Description : 
         Geek created a random series and given a name geek-onacci series. Given four 
         integers x, y, z, N. x, y, z represents the first three numbers of geek-onacci series. 
         Find the Nth number of the series. The nth number of geek-onacci series is a sum of the 
         last three numbers (summation of N-1th, N-2th, and N-3th geek-onacci numbers).
 */
 
 #include <iostream>
 using namespace std;
 
 //function to find geek number
 int geek_num(int a, int b, int c, int n)
 {
     int sum;
     for (int i = 4; i <= n; i++)
     {
         sum = a + b + c;
         a = b;
         b = c;
         c = sum;
     }
     return sum;
 }
 
 int main()
 {
     int a, b, c, n;
     cout << ""Enter first , second , third and Nth number : "" << endl;
     cin >> a >> b >> c >> n;
     cout << ""Nth number of the series : "" << endl;
     //function call
     cout << geek_num(a, b, c, n) << endl;
 
     return 0;
 }
 
 /*
 Time complexity : O(log n)
 Space complexity : O(1)
 */
 
 /*
 Test Case :
  Input :
  Enter first , second , third and Nth number : 
  1 3 2 4
 
  Output :
  Nth number of the series :
  6
 */
 
",C-Plus-Plus
"import java.util.Objects;
 
 
 /**
  * 
  * This is an implementation of Complex numbers in Java. 
  * 
  * @author Ricardo Prins
  * @since 12-01-2019
  * @version 1.0.0
  * 
  */
 public class Complex {
     private double real;   // the real part
     private double imaginary;   // the imaginary part
 
     /**
      * Creates a complex number.
      * @param real
      * @param imaginary
      */
     public Complex(double real, double imaginary) {
         this.real = real;
         this.imaginary = imaginary;
     }
     public double getReal() {
         return real;
     }
     public double getImaginary() {
         return imaginary;
     }
     public void setReal(double real) {
         this.real = real;
     }
     public void setImaginary(double imaginary) {
         this.imaginary = imaginary;
     }
     /**
      * @return modulus/absolute value of a given complex number
      */
     public double abs() {
         return Math.hypot(real, imaginary);
     }
     /**
      * @return angle/phase/argument, normalized to be between -pi and pi
      */
     public double phase() {
         return Math.atan2(imaginary, real);
     }
     /**
      * @param b complex to be added
      * @return new Complex object whose value is (this + b)
      */
     public Complex add(Complex b) {
         Complex a = this;
         double real = a.real + b.real;
         double imag = a.imaginary + b.imaginary;
         return new Complex(real, imag);
     }
     /**
      * Static version of add method
      * @param a
      * @param b
      * @return
      */
     public static Complex add(Complex a, Complex b) {
         double real = a.real + b.real;
         double imag = a.imaginary + b.imaginary;
         return new Complex(real, imag);
     }
     /**
      * @param b
      * @return a new Complex object whose value is (this - b)
      */
     public Complex subtract(Complex b) {
         Complex a = this;
         double real = a.real - b.real;
         double ",Java
"
 /*
 Problem:
 Given an array of size n sorted in ascending order is rotated at an unknown pivot index x (0 <= x<n), 
 such that the resulting array is [arr[x], arr[x+1], ..., arr[n-1], arr[0], arr[1], ..., arr[x-1]](0-indexed).
 Given the array arr[] after the rotation and an integer target, return the index of target if it is in array,
  or -1 if it is not in array.
 
 Write an algorithm with O(log n) runtime complexity.
 */
 
 
 #include <iostream>
 #include <vector>
 using namespace std;
 
 // function to search target element
  int search(vector<int>& arr, int target) {
        int answer=-1;
         
         int i=0;
         int j=arr.size()-1;
         
         if(arr[i]==target)
                 return i;
             
             if(arr[j]==target)
                 return j;
               
         while(i<j)
         {
             int mid= i+(j-i)/2;
             
             if(arr[mid]==target)
                 return mid;
             
             if(arr[i]==target)
                 return i;
             
             if(arr[j]==target)
                 return j;
             
             if(arr[mid]>arr[mid+1] && mid+1<arr.size())
             {
                 if(target>=arr[i] && target<=arr[mid])
                 {
                     j=mid;
                 }
                 else
                 {
                     i=mid+1;
                 }
             }
             else
             {
                 i++;
                 j--;
             }
             
         }
         
         return answer;
     }
 
 int main()
 {
     int n;  
     cout<<""Enter number of Element: "";
     cin>>n;
 
     vector<int> arr;
     
     cout<<""Enter array Elements: "";  
     for(int i=0;i<n;i++)
     {
         int x;
         cin>>x;
         arr.push_back(x);
     }
    
      int target;
      cout<<""Enter the traget element: "";   
      cin>>target;
   
      int result= search(arr,target);
 
      cout<<""Target Element found at inde",C-Plus-Plus
"def calculate_gcd(a, b):
     while b:
         a, b = b, a % b
     return a
 
 if __name__ == '__main__':
     print(calculate_gcd(36, 20))  # Should print 4
     print(calculate_gcd(16, 24))  # Should print 8
",Python
"/**
  * Longest Subarray Having Sum K
  * Given an array of integers, find the length of the longest sub-array 
  * having sum equal to the given value K.
  */
 
 import java.io.*;
 import java.util.*; 
 public class LongestSubarraySum {
 
     public static int findLongestSubarray(int[] numArray, int K) {
 
         //HashMap containing (sum, index) key:value pairs
         HashMap<Long, Integer> hMap = new HashMap<>(); 
 
         long sum = 0l; //Stores cumulative sum as we traverse the integer array
         int length = 0; //Stores length of longest valid subarray
 
         for(int i=0; i<numArray.length; i++) {
             sum += numArray[i]; 
 
             if(sum == K)
                 length = Math.max(length, i+1); 
 
             //Only the first index of occurrence of a particular sum is stored,
             //as we need to find length of longest valid subarray
             if(!hMap.containsKey(sum)) 
                 hMap.put(sum, i); 
 
             //Checking if HashMap contains (sum-K) as we know that:
             // (sum - (sum - K)) = K, which is the required sum
             if(hMap.containsKey(sum - K))
                 length = Math.max(length, i - hMap.get(sum - K)); 
         }
 
         return length; 
     }
     
     public static void main(String[] args) throws IOException{
         InputStreamReader read = new InputStreamReader(System.in);
 	    BufferedReader buf = new BufferedReader(read); 
 
         //Taking input from user
         System.out.println(""Enter length of array of integers: "");
 	    int len = Integer.parseInt(buf.readLine());
         System.out.println(""Enter array of integers: "");
 	    StringTokenizer st = new StringTokenizer(buf.readLine());
 	    int numArray[] = new int[len];
 	    for(int i=0; i<len; i++) {
 	        numArray[i] = Integer.parseInt(st.nextToken()); 
 	    } 
         System.out.println(""Enter sum: "");
 	    int K = Integer.parseInt(buf.readLine()); 
 	    
         System.out.print(""Length of ",Java
"import java.util.Scanner;
 
 public class RemoveDuplicateElement {
 
     /**
      *
      * Method 1 Using extra space
      *
      */
 
 
 
 //     The function remove the duplicate element
 //     Function take two argument array 'a' of size 'n'.
     static int DuplicateElement(int[] a, int n){
 
 //        check if array is empty or it has only 1 element
 
         if (n==0 || n==1)
             return n;
 
 //        Now we create an temporary array of  size an
 //        it stores the unique element
 
         int[] temp = new int[n];
 
         int j=0;
 
 //        start traversing the array
 
         for (int i=0; i<n-1; i++){
             // If current element is not equal
             // to next element then store that
             // current element
 
             if (a[i] != a[i+1]){
 
                 temp[j++] = a[i];
 
             }
         }
         // Store the last element as whether
         // it is unique or repeated, it hasn't
         // stored previously
         temp[j++] = a[n-1];
 
 //        modify original array
 
         for (int i=0; i<j; i++){
             a[i] = temp[i];
         }
         return j;
     }
 
     public static void main(String[] args) {
         
         // taking the input from the user
         Scanner sc = new Scanner(System.in);
         System.out.print(""Enter the length of the array : "");
         int n = sc.nextInt();
         
         int a[] = new int[n];
         System.out.println(""Enter the values for the array elements : "");
         // taking the values for the array from the user
         for(int i=0; i<n; i++)
         {
             a[i] = sc.nextInt();
         }
 
         n = DuplicateElement(a,n);
 
 //        print the updated array
         for (int i=0; i<n; i++){
             System.out.print(a[i] + "" "");
         }
 
     }
 
 }
 
 /*
 
 Example : 
 
 Input:
 Enter the length of the array : 4
 Enter the values for the array elements : 
 1 1 2 2
 
 Output:
 1 2
 
 */
",Java
"""""""
 Python program to print the n'th term in the Golomb sequence
 Golomb sequence is a non-decreasing integer sequence where n'th
 term is  equal to the number of times n appears in the sequence
 """"""
 
 
 def golomb_sequence(n):
 
     # Create a dp array, with value initialized as 0.
     dp = [0 for i in range(n+1)]
 
     dp[1] = 1
     # Identify the previous term 'prev' and go prev terms behind and find a number.
     # Now assign the current element with an incremented value of that element.
     for i in range(2, n + 1):
         prev = dp[i - 1]
         back_index = i - dp[prev]
         dp[i] = 1 + dp[back_index]
     return dp[n]
 
 if __name__ == '__main__':
     print(""Enter the value of n?, where you need the n'th number in the golomb sequence. "", end="""")
     num = int(input())
     if num <= 0:
         print(""The given value of n is invalid."")
         exit()
     res = golomb_sequence(num)
     print(""The {}'th term in the golomb sequence is {}."".format(num, res))
 
 """"""
 Time Complexity: O(n), where 'n' is the given number
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the value of n?, where you need the n'th number in the golomb sequence. 5
 The 5'th term in the golomb sequence is 3.
 
 SAMPLE 2
 
 Enter the value of n?, where you need the n'th number in the golomb sequence. 867
 The 867'th term in the golomb sequence is 79.
 """"""
",Python
"#= The famous Tower of Hanoi question where there are 3 towers with discs in them. You need
 to transfer all the discs from A to C =#
 
 ## Function 
 
 function towerOfHanoi(discs, source = ""A"", destination = ""C"", helper = ""B"")
     if (discs == 0)
         return
     end
     towerOfHanoi(discs - 1, source, helper, destination)
     println(""Move from $(source) to $(destination)"")
     towerOfHanoi(discs - 1, helper, destination, source)
 end
 
 ## Input 
 
 println(""Enter the number of discs: "")
 n = readline()
 n = parse(Int64, n)
 
 ## Calling the function 
 
 towerOfHanoi(n)
 
 #=
 Sample Test Case:
 Input: 
     Enter the number of discs: 3
 Output:
     Move from A to C
     Move from A to B
     Move from C to B
     Move from A to C
     Move from B to A
     Move from B to C
     Move from A to C
 Time complexity: O(2^N)
 =#
",Julia
"/**
  * time complexity O(n*n) - space complexity O(1)
  */
 
 function BubbleSort(arr) {
   for (let i = 0; i < arr.length; i++) {
     // outer loop
     let isSwapped = false; //  create a boolean to keep track of whether or not there was a successful comparison made
     for (let j = 0; j < arr.length - 1; j++) {
       // inner loop
       if (arr[j] > arr[j + 1]) {
         // check if the current value is greater than next value
         [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; // Swap the current value and next value
         isSwapped = true; // Set swap variable to true
       }
     }
     if (!isSwapped) {
       // if there's no swap, the arr is fully sorted and can exit there, we break.
       break;
     }
   }
 
   return arr; // return the sorted array
 }
 
 console.log(BubbleSort([4, 2, 1, 3]));
 // output should be => [1, 2, 3, 4]
 
 console.log(BubbleSort([-4, 18, 2, 0, 6]));
 // output should be => [-4, 0, 2, 6, 18]
",JavaScript
"""""""
 Python program to find the number of bits to be flipped to convert one number to another
 
 Inorder to compare the individual bits of given the numbers, we can compute
 the number of set bits in thier XOR, as we know that XOR operation yields
 set bits, only when two same bits are XORed.
 """""" 
 
 
 def get_num_flips(n1, n2):
     count = 0
     n = n1 ^ n2
     while(n != 0):
         if(n & 1 == 1):
             count = count + 1
         n = n >> 1
     return count
 
 if __name__ == '__main__':
     print(""Enter the first number:"", end="""")
     n1 = int(input())
     print(""Enter the second number:"", end="""")
     n2 = int(input())
     res = get_num_flips(n1, n2)
     print(""Number of flips required to inter-convert the given numbers is: {}"".format(res))
 
     
 
 """"""
 Time Complexity: O(log(n)), where n is the greater of the input number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the first number:12
 Enter the second number:24
 Number of flips required to inter-convert the given numbers is: 2
 """"""
",Python
"""""""
 Bipartite Graph: A Bipartite Graph is a graph whose vertices can be
         divided into two independent sets, U and V such that every
         edge (u, v) either connects a vertex from U to V or a vertex
         from V to U. A bipartite graph is possible if the graph
         coloring is possible using two colors such that vertices
         in a set are colored with the same color.
 
 Purpose: To check whether the given undirected graph is Bipartite
         Graph or not.
 
 Method: Breadth First Search (BFS)
 Intution: Following is a simple algorithm to find out whether a given graph
         is Birpartite or not using Breadth First Search (BFS).
 
         1. Assign RED color to the source vertex (putting into set U).
         2. Color all the neighbors with BLUE color (putting into set V).
         3. Color all neighbors neighbor with RED color (putting into set U).
         4. This way, assign color to all vertices such that it satisfies all
             the constraints of m way coloring problem where m = 2.
         5. While assigning colors, if we find a neighbor which is colored with
             same color as current vertex, then the graph cannot be colored with
             2 vertices (or graph is not Bipartite)
 
 Time Complexity:  O(N+M)
 Space Complexity: O(N)
 
 Argument: Dictionary ( Graph where each vertex is numbered from 1 to N )
 Reaturn : Boolean    ( The Graph is Bipartite or not )
 
 """"""
 from collections import defaultdict, deque
 
 
 def BFS(graph, node, color):
 
     # Initilize the color of the source node to be 1
     color[node] = 1
 
     # Initilise the queue with the source node
     queue = deque([node])
 
     while queue:
         v = queue.popleft()
 
         # Base Case: Self looped Graph is not Bipartite
         if v in graph[v]:
             return False
 
         # Check for each adjacent node
         for each in graph[v]:
 
             # If not colored, Mark its color to be XOR of its preceding node
           ",Python
"""""""
 Topological Sorting:- a topological sort or topological ordering of a
         directed graph is a linear ordering of its vertices such that
         for every directed edge uv from vertex u to vertex v, u comes
         before v in the ordering. Topological Sorting is not possible
         in a cyclic graph.
 
 Purpose: To return the topological ordreing of the of the vertices of
         the provided Directed Acyclic Graph (DAG). The nodes of the
         graph are numbered from 1 to N.
 
 Method: Depth First Search
 Intution: Using DFS we can recursively traverse the adjacent vertices
         to find the sink vertex and then storing them in the Topological
         sort array/list.
 
 Time Complexity:  O(N+M)
 Space Complexity: O(N)
 
 Argument: Dictionary  ( Graph )
 Return  : List        ( Topological Sort )
 
 """"""
 from collections import defaultdict
 
 
 def DFS(graph, node, visited, topo):
 
     # Mark the node Visited
     visited[node] = 1
 
     # Recursively call all its adjacent nodes
     for each in graph[node]:
 
         # Check wether it is visited or not
         if not visited[each]:
             DFS(graph, each, visited, topo)
 
     # After visiting all adjacent node, append the node to the topological list
     topo += [node]
 
 
 def Topological_Sort(n, graph):
 
     # Initialize the topo list to store the topological ordering
     # And keep atrack to visited graph
     topo = []
     visited = [0] * (n + 1)
 
     # Now recursively call for each unvisited Node
     for i in range(1, n + 1):
         if not visited[i]:
             DFS(graph, i, visited, topo)
 
     return topo[::-1]
 
 # -------------------------------DRIVER CODE ---------------------------------
 
 
 if __name__ == ""__main__"":
     n, m = map(int, input(""Enter the number of vertex and edges: "").split())
     print(""Enter the edges: "")
     graph = defaultdict(list)
 
     # Initializing the Directed Graph
     for i in range(m):
         a, b = map(int, input().sp",Python
"/*
 C Program to check whether a number is Palindrome or not
 An integer is a palindrome if the reverse of that number is equal to the original number.
 Example of Palindromes are 11,44,101,121,
 */
 #include <stdio.h>
 
 int reverse_num(int);
 int main()
 {
 	int n, rev;
 	printf(""\n Enter a number:"");
 	scanf(""%d"", &n);
 	rev = reverse_num(n);
 	if (rev == n)
 	{
 		printf(""\n %d is a palindrome"", n);
 	}
 	else
 	{
 		printf(""\n %d is not a palindrome"", n);
 	}
 	return 0;
 }
 int reverse_num(int num)
 {
 	int rev = 0;
 	int rem;
 	while (num > 0)
 	{
 		rem = num % 10;
 		rev = rev *10 + rem;
 		num = num / 10;
 	}
 	return rev;
 }
 
 /*
 Sample Output
 Enter a number: 121
 121 is a palindrome
 
 Complexities
 Time Complexity: O(n)
 Space Complexity: O(1)
 */
 
",C
"/*
 Given an array of N elements and a value K (K <= N) , calculate maximum summation of K consecutive elements in the array.
 We can solve this problem by using Sliding Window Technique. 
 This technique will allow us to solve this problem in O(N)
 */
 
 import java.util.Scanner;
 import java.lang.*;
 
 public class SlidingWindow
 {
     // this function  will give us the maximum sum
     static int max_sum_by_sliding_window(int ar[] , int number , int K)
     {
         int final_sum = 0;
         if(number == K)
         {
             int sum = 0;
             // max_sum will be the sum of all elements of array.
             for(int i = 0; i < number; i++)
             {
                 sum += ar[i];
             }
             final_sum = sum;
         }
         if(number > K)
         {
             // calculate sum of first window of size K
             int max_sum = 0, win_sum = 0;
             for(int i = 0; i < K; i++)
             {
                 max_sum += ar[i];
             }
 
             /* calculate sum of remaining windows
              by removing elements from first window simultaneously add elements to current window */
             win_sum = max_sum;
             for(int i = K; i < number; i++)
             {
                 win_sum += (ar[i] - ar[i - K]);
                 if(win_sum > max_sum)
                 {
                     max_sum = win_sum;
                 }
             }
             final_sum = max_sum;
         }
         return final_sum;
     }
     
 
 
     public static void main(String args[])  
     {
        Scanner scan = new Scanner(System.in);
        System.out.print(""Enter the size of array \n"");
        int number = scan.nextInt();
        int K = scan.nextInt();
        int[] ar = new int[number];
        System.out.println(""Enter array elements \n""); 
        for(int i = 0; i < number; i++)
        {
 	   ar[i] = scan.nextInt();
        }
        int solve = max_sum_by_sliding_window(ar, number , K);
    ",Java
"/* C++ Code for Combination Sum Problem.
 Problem Statement:
 Given an array of integers and a target value, the unique combination of values in array should sum up to the target value. 
 The same number can be chosen multiple times.
 
 For Example:
 Input: array = [4,2,8,6], target = 8
 Output: [2,2,2,2], [4,4], [2,6], [8], [2,2,4]
 
 Constraints:
 1. The array should have distinct elements.
 2. 1 <= target <= 500
 3. 1 <= arr.size() <= 50
 4. 1 <= arr[i] <= 200
 */
 #include<bits/stdc++.h>
 using namespace std;
 
 void combinationSum(vector<int> &arr, int target, vector<vector<int>> &ans, vector<int> &combn, int beg)
 {
     if(!target) {
         ans.push_back(combn);
         return;
     } 
     for(int i=beg; i!=arr.size() && target >= arr[i]; ++i) {
         combn.push_back(arr[i]);
         combinationSum(arr, target-arr[i], ans, combn, i);
         combn.pop_back();
     }
 }
 int main() {
     int n; 
     cout << ""\nEnter Array Size: ""; cin >> n;
 
     vector<int> arr (n);
     cout << ""\nEnter Array Elements: "";
     for(int i=0; i<n; ++i)
         cin >> arr[i];
 
     int target;
     cout << ""\nEnter Target Sum: ""; cin >> target;
     //Sorting the array
     sort(arr.begin(), arr.end());
     vector<vector<int> > ans;
     vector<int> combination;
     combinationSum(arr, target, ans, combination, 0);
     for(int i=0; i<ans.size(); ++i) {
         if(ans[i].size() > 0) {
             cout << ""\n["";
             for(int j=0; j<ans[i].size(); ++j) 
                 if(j == ans[i].size() - 1) cout << ans[i][j]; 
                 else cout << ans[i][j] << "", "";
             cout << ""]"";
         }
     }
     return 0;
 }
 /* Sample Input
 Enter Array Size: 4
 Enter Array Elements: 1 2 3 4
 Enter Target Sum: 10
 
 Output:
 [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
 [1, 1, 1, 1, 1, 1, 1, 1, 2]
 [1, 1, 1, 1, 1, 1, 1, 3]
 [1, 1, 1, 1, 1, 1, 2, 2]
 [1, 1, 1, 1, 1, 1, 4]
 [1, 1, 1, 1, 1, 2, 3]
 [1, 1, 1, 1, 2, 2, 2]
 [1, 1, 1, 1, 2, 4]
 [1, 1, 1, 1, 3, 3]
 [1, 1, 1, 2",C-Plus-Plus
"/****************************************************************************
  Author: @Suvraneel Bhuin
 
  Create a singly linked list X of integers. A pair (xi,xj) is called an inversion of X if for i < j , xi > xj. The inversion vector of X is the sequence of integers d1, d2,.. dn such that dj is the number of elements greater than xj and to its left in the sequence, so 0 <= dj < j. Compute the inversion vector for a given permutation.
  Ex: Given link list X : 4-> 3-> 5-> 2-> 1->
  Inversion of X: 0, 1, 0, 3, 4
  ***************************************************************************/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //node structure
 typedef struct node
 {
     int value;
     struct node *next;
 }node;
 
 //global nodes
 node *newnode, *ptr, *inv;
 node *first = NULL, *last = NULL;
 
 //creation of new node
 node* create_node(int val)
 {
     newnode = (node *)malloc(sizeof(node));
     if (newnode == NULL)
     {
         cout << endl << ""Creation unsuccessful"";
         return 0;
     }
     else
     {
         newnode->value = val;
         newnode->next = NULL;
         return newnode;
     }
 }
 
 //function to insert node at end
 void insert_node()
 {
     int val;
     cout << ""Enter value of the Node:\t"";
     cin >> val;
     newnode = create_node(val);
     if (first == last && last == NULL)
     {
         first = last = newnode;
         first->next = NULL;
         last->next = NULL;
     }
     else
     {
         last->next = newnode;
         last = newnode;
         last->next = NULL;
     }
  cout << val << "" inserted as node"";
 }
 
 //Function to calculate inversion vector
 void inversion()
 {
     //Empty condition
     if (first == NULL)
     {
         cout << endl << ""No nodes in the list"";
     }
     else
     {   
         //for every x
         for (ptr = first; ptr != NULL; ptr = ptr->next)
         {
             //set new count to zero
             int inversion_count = 0;
             //traverse from be",C-Plus-Plus
"# Python program to Right Rotate a number by a specific bits.
 
 # Right Rotate 'cnt' number of bits of the given number 'n'
 def right_rotate_bits(n, cnt):
     cnt = cnt % 31
     while(cnt > 0):
         # Store the current LSB in a temporary variable
         lsb = n & 1
         # Right rotate the given number by one bit and drop its LSB
         n = (n >> 1) & (~(1 << 31))
         # Set the dropped LSB as the new MSB
         n = n | (lsb << 31)
         # Decrement cnt
         cnt = cnt - 1
     return n
 
 
 if __name__ == '__main__':
     print(""Enter the number? "", end="""")
     num = int(input())
     print(""How many bits do you want to rotate? "", end="""")
     cnt = int(input())
     right = right_rotate_bits(num, cnt)
     print(""The Right-rotated number is: {}"".format(right))
 
 """"""
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 52
 How many bits do you want to rotate? 29
 The Right-rotated number is: 416
 """"""
",Python
"/*Bubble Sort Algorithm is the sorting algorithm in which each element is compared to its adjacent element 
 and if first elememt is greater than second element ,then the swapping occurs.
 The swapping occurs till the array is sorted.
 */
 
 #include <stdio.h>
 #include <stdbool.h>
 
 void swap(int *, int *);
 bool optimised_bubble(int[], int);
 int main()
 {
 	int size, arr[size], temp;
 	//Reading Input
 	printf(""Input :\n"");
 	printf(""Enter the size of an array : \n"");
 	scanf(""%d"", &size);
 	printf(""Enter the elements of an array :\n"");
 	for (int index = 0; index < size; index++)
 	{
 		scanf(""%d"", &arr[index]);
 	}
 
 	optimised_bubble(arr, size);
 	//Displaying Output
 	printf(""Output :\n"");
 	printf(""The sorted array is :\n"");
 	for (int index = 0; index < size; index++)
 	{
 		printf(""%d "", arr[index]);
 	}
 
 	return 0;
 }
 
 // Function to sort the array in an optimised way
 bool optimised_bubble(int arr[], int size)
 {
 	int index;
 	bool sort = true;
 	for (int index = 0; index < size; index++)
 	{
 		for (int j = 0; j < size - 1 - index; j++)
 		{
 			if (arr[j] > arr[j + 1])
 			{
 				swap(&arr[j], &arr[j + 1]);
 				sort = false;
 			}
 		}
 
 		if (sort)
 		{
 			break;
 		}
 	}
 }
 
 // Function to swap two numbers
 void swap(int *a, int *b)
 {
 	int temp;
 	temp = *a;
 	*a = *b;
 	*b = temp;
 }
 
 /*
  Input:
  Enter the size of an array: 5
  Enter the elements of an array :
  7 9 8 2 4
  Output :
  2 4 7 8 9
  Time Complexity :  O(n)
  Space Complexity : O(1)
 */
 
",C
"/*
 	Given a string s consists of some words separated by spaces,
 	return the length of the last word in the string. 
 	If the last word does not exist, return 0.
 	A word is a maximal substring consisting of non-space characters only.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /*
 		Well, the basic idea is very simple. 
 		Start from the tail of s and move backwards to find the first non-space character. 
 		Then from this character, move backwards and count the number of non-space characters 
 		until we pass over the head of s or meet a space character.
 		The count will then be the length of the last word.
 */
 
 int lengthOfLastWord(string s)
 {
     int lengthofword = 0, tail = s.length() - 1;
     while (tail >= 0 && s[tail] == ' ')
         tail--;
     while (tail >= 0 && s[tail] != ' ')
     {
         lengthofword++;
         tail--;
     }
     return lengthofword;
 }
 
 int main()
 {
     cout << ""Enter the string:"";
     string str;
     getline(cin, str);
 
     int ans = lengthOfLastWord(str);
     cout << ""The length of the last word in the string is: "" << ans;
 }
 
 /*
 	   Input:Hello World
 	   Output:5
 */
 /*
 	   Time Complexity:O(n),where n is the length of the string
 	   Space Complexity:O(1)
 */
",C-Plus-Plus
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# INCOME CLASSIFICATION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [Income Evaluation](https://www.kaggle.com/overload10/adult-census-dataset)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### The aim is to classify the income of a person as <=50K or >50K.""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import numpy as np\n"",
     ""from sklearn import preprocessing\n"",
     ""label_encoder = preprocessing.LabelEncoder()\n"",
     ""from statsmodels.stats.outliers_influence import variance_inflation_factor\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.ensemble import RandomForestClassifier\n"",
     ""import matplotlib.pyplot as plt\n"",
     ""from scipy import stats\n"",
     ""import seaborn as sns\n"",
     ""from sklearn.metrics import roc_auc_score\n"",
     ""from sklearn.metrics import confusion_matrix""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting our Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n"",
        ""<table border=\""1\"" class=\""datafra",Python
"/*
 Given an infix expression, the aim is to convert it into prefix expression.
 In order to do this, we first reverse the expression, and find it's postfix expression.
 (Postfix expression can be found with the help of an operator stack, and precedence of operators)
 The reverse of this resulting expression gives us the final infix expression.
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
 #include <string.h>
 
 typedef struct stack {
     int capacity, top;
     char *arr;
 } stack;
 
 stack * createStack(int size) {
     struct stack *s = (struct stack *) malloc(sizeof(struct stack));
     s -> arr = (char *)malloc (size * sizeof(char));
     s -> top = -1;
     s -> capacity = size;
     return s;
 }
 
 int isEmpty(stack *s) {
     /* tells whether the stack is empty or not */
     return  s -> top == -1;
 }
 
 int isFull(stack *s) {
     /* tells whether a stack is full or not */
     return s -> top == s -> capacity - 1;
 }
 
 void push(stack *s, int data) {
     /* push a given element into the stack */
     s -> arr[ ++ s -> top] = data;
 }
 
 char pop(struct stack *s) {
     /* to pop the top element from stack */
     return s -> arr[s -> top --];
 }
 
 char peek(struct stack *s) {
     /* to get the top element of stack */
     return s -> arr[s -> top];
 }
 
 int precedence(char ch) {
     /* gives the precedence of operators */
     switch(ch) {
         case '+':
         case '-': return 1;
         case '/': 
         case '*': return 2;
         case '^': return 3;
         case ')': return 4;
     }
 }
 
 stack * infToPost(char infixExp[100]) {
     /* To reverse a given infix expression and convert to postfix expression */
     int index = 0;
     int contains = 0; /* using a variable to see if the operator stack contains a '(' at any time */
     int len = strlen(infixExp);
     stack *operatorStack = createStack(len);
     stack *postfixExp = createStack(len + 1);
 
     /* converting the reverse of given expression into pos",C
"#include<iostream>        //Header file
 using namespace std;      //For cin and cout
 
 /*
     Merge sort is an efficient, general-purpose, comparison-based sorting algorithm.
     It is a divide and conquer algorithm that was invented by John von Neumann in 1945.
 
     @author Aditya Saxena
     @since 26-7-2020
 */
 
 
 //Implement merge function
 void merge( int a[], int start, int end){
 
     int temp[10000];        //Temprory array to store while merging the arrays
     int mid= ( start + end ) / 2; 
 
     int i= start, j= mid+1, k= start;
 
     //Compare and fill temp
      while( i<= mid && j<= end ){
 
         if(a[i]<a[j]){
             temp[k++]=a[i++];
         }
         
         else{
             temp[k++]=a[j++];
         }
     }
 
     //Fill remaining elements in temp
     while(i<=mid){
         temp[k++]=a[i++];
     }
     while(j<= end){
         temp[k++]=a[j++];
     }
 
     //Copy elements of temp in a
     for(int i= start; i<= end; i++){
         a[i]= temp[i];
     }
 
     return; 
 } 
 
 //Implement Merge Sort Function
 void mergeSort( int a[], int start, int end){
 
     //Base Case
     //If start (index) crosses end (index), there are no elements to sort further, thus return
     if( start >= end ){
         return;
     }
 
     //Find the mid index
     int mid= ( start + end ) / 2;
 
     //Recursively sort the array in two halves
     //Sort first half
     mergeSort( a, start, mid);
     //Sort second half
     mergeSort( a, mid + 1, end);
 
     //Merge the sorted halves
     merge( a, start, end);
 
     return;
 
 }
 
 
 int main(){
 
     int n;                  
     cout<<""Enter the number of elements of the array to be sorted: "";
     cin>>n;
 
     int a[n];
     cout<<""Enter the elements of the array: "";
     
     for(int i= 0; i<n; i++){        //For loop to input n elements into the array
         cin>>a[i];
     }
 
     //Call the merge sort function on the array - mergeSort( array_name, start, end);
     ",C-Plus-Plus
"import java.util.Scanner;
 
 public class RecursionCount {
 
     public static void main(String args[]) {
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter first string:"");
         String str1 = scanner.nextLine();
         System.out.println(""Enter second string:"");
         String str2 = scanner.nextLine();
         scanner.close();
 
         System.out.println(""Number of occurrences of \"""" + str2 + ""\"" in \"""" + str1 + ""\"":"" + countSubstring(str1, str2));
     }
 
     static int countSubstring(String str1, String str2) {
         // recursive function
         if(str1.contains(str2)) {
             return 1 + countSubstring(str1.replaceFirst(str2, """"), str2);
         } else {
             return 0;
         }
     }
 }
 /*
 * Sample input/output:
 * Enter first string:
 * abcdabc
 * Enter second string:
 * abc
 * Number of occurrences of ""abc"" in ""abcdabc"":2
 *
 * Time complexity: O(n)
 */
",Java
"/*
 Evaluate string expression using BODMAS
 ==============================
 Evaluate a string expression containing (,),+,-,/ and * using BODMAS rules
 Application: Stack data structure
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
 #include<iostream>
 #include<string>
 #include<stack>
 using namespace std;
 
 //Function to remove spaces from string and return trimmed string.
 string removeSpaces(string &s){
 	int n = s.length();
 	string trimmed;
 
 	for(int i = 0; i < n; i++){
 		if(s[i] != ' '){
 			trimmed.push_back(s[i]);
 		}
 	}
 	return trimmed;
 }
 
 //In Expression containing only '*','/','+' and '-' '*' and '/' have the highest precedence followed by '+' and '-'
 int precedence(char c){
 	if(c == '*' || c == '/'){
 		return 3;
 	}
 	else if(c == '+' || c == '-'){
 		return 2;
 	}
 	else{
 		return 1;
 	}
 }
 
 //calculate function is used to calculate a value given two operandsand one operator
 int calculate(int num1, int num2, char symbol){
 	if(symbol == '*'){
 		return num1 * num2;
 	}
 	else if(symbol == '/'){
 		return num1 / num2;
 	}
 	else if(symbol == '+'){
 		return num1 + num2;
 	}
 	else if(symbol == '-'){
 		return num1 - num2;
 	}
 	return -1;
 }
 
 //Two stacks are used. 'values' stack is used to store the operands
 //'operators' stack is used to hold the operators
 int evaluate(string token){
 	stack<int>values;
 	stack<char>operators;
 	int i;
 	
 	//get length of given expression
 	int n = token.length();
 	
 	for(i = 0; i < n; i++){
 		if(isdigit(token[i])){
 			int value = 0;
 			
 			//there may be more than one digit number e.g(48+5) '48' has 2 digits
 			while(i<n && isdigit(token[i])){
 				value = value * 10 + (token[i] - '0');
 				i++;
 			}
 			
 			values.push(value);
 			i--;
 	
 		}
 
 		//if opening paranthesis is encontered push it in 'operators' stack
 		else if(token[i] == '('){
 			operators.push('(');
 		}
 
 		//If a closing paranthesis is encountered continue to evaluate the expression 
 		//until an opening ",C-Plus-Plus
"/*
 Given a string S encode it according to the Dynamic Huffman Encoding Technique.
 In Dynamic Huffman encoding technique we generate new code for each character dynamically i.e. it changes after we scan a new character.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 class TreeNode
 {
 public:
     int freq;
     char symbol;
     TreeNode *parent;
     TreeNode *left;
     TreeNode *right;
     TreeNode()
     {
         //Intially Frequency of non character element is zero
         this->freq = 0;
         //Root is represented by '*'
         this->symbol = '*';
         this->left = NULL;
         this->right = NULL;
         this->parent = NULL;
     }
 };
 
 //Function to print the corresponding Dynamic Huffman Tree during Dynamic encoding of each character
 void printTree(TreeNode *root)
 {
     //Using queue to print Tree level order wise
     queue<TreeNode *> q;
     q.push(root);
     q.push(NULL);
     while (!q.empty())
     {
         TreeNode *curr = q.front();
         q.pop();
         //Marking end of current level
         if (curr == NULL)
         {
             cout << endl;
             if (!q.empty())
                 q.push(NULL);
             continue;
         }
         //Printing of symbol along with its frequency
         cout << curr->symbol << curr->freq;
         cout << ""  "";
         //Pushing children of current node to the queue
         if (curr->left != NULL)
         {
             q.push(curr->left);
         }
         if (curr->right != NULL)
         {
             q.push(curr->right);
         }
     }
 }
 
 //Function to Return Reverse Level Order of the given tree to check Balancing.
 vector<TreeNode *> ReverseLevelOrder(TreeNode *root)
 {
     //vector to store reverse level order
     vector<TreeNode *> reverse_level_order;
     //To help in reversing of level order
     vector<TreeNode *> current;
     //queue to store Treenode
     queue<TreeNode *> q;
     q.push(root);
     q.push(NULL);
     while (!q.em",C-Plus-Plus
"/*
 CODE DESCRPTION:
 XOR Linked List is memory efficient Doubly Linked List .
 It's Memory Efficient as the list uses bitwise XOR operation to save space for one address.
 Instead of storing actual memory addresses, every node stores the XOR of addresses of previous and next nodes. 
 */
 
 #include<stdio.h>
 #include<conio.h>
 #include<stdlib.h>
 #include<inttypes.h>
 
 /* Structure of a Node has the data and XOR of the previous and next address i.e npx */
 struct node
 {
   	int data;
   	struct node *npx;
 };
 
 /*Function to create the XOR Linked List */
 struct node *xor(struct node *prev,struct node *next)
 {
   	return (struct node *)((uintptr_t)(prev)^(uintptr_t)(next));
 }
 
 struct node *header,*last;
 
 /* Function to create a Linked List */
 void create()
 {
 	/*Allocate memory for the New node*/
   	struct node *temp= malloc(sizeof(struct node));
   	printf(""\nEnter value of Node : "");
   	scanf(""%d"",&temp->data);
 	
 	/*Initialize temp npx's as NULL*/
   	temp->npx=NULL;
   	
   	/* If list is empty */
   	if(header==NULL)
   	{
     	header=last=temp;
     	return;
   	}
 	/* If linked list is not empty, then present head node's npx 
 	will be xor of temp and npx of current head node */
   	else
   	{
    	 	last->npx=xor(last->npx,temp);
     	temp->npx=last;
 		/*Update last as temp*/
     	last=temp;
     	return;
   	}	
 }
 
 /* Function to display the Nodes of a Linked List */
 void show()
 {
   	struct node *t1=header;
   	struct node *prev,*current;
   	prev=current=NULL;
 
   	while(t1!=NULL)
   	{
 		/* Print current node */
    	 	printf(""->%d"",t1->data);
 		/* Update prev and current for next iteration */
     	current=t1;
     	t1=xor(prev,t1->npx);
     	prev=current;
   	}
 }
 
 void main()
 {
   	int i,num;
 	printf(""Enter number of nodes: "");
 	scanf(""%d"",&num);
 	
 	for(i=0;i<num;i++)
 	create();
 	
   	printf(""\nXOR LINKED LIST IS \n"");
   	show();
 }
 
 /*
 COMPLEXITY 
 Time Complexity : O(n)
 Space Complexity : O(1)
 
 OUTPUT:
 Ent",C
"/*
     Euclidean Algorithm to find GCD in DART
 
     This algorithm follows the fact that the remainder a' of  a/b is also divisible by the gcd of a and b (i.e. d)
 
      Lets prove this fact
     
     let d be the GCD of a & b 
     let a>b
     now    a/b   =>    a   =   a'  +   bq
     
     dividing both sides by d, where d is their gcd
 
     =>  a/d   =   (a'  +   bq)/d
     =>  a/d   =   a'/d  +   q*(b/d)
 
     a/d and b/d are in P/Q form where Q=1 since d is their GCD
     
     =>  a/d   -   q*(b/d) =   a'/d
     =>        X           =   a'/d where X is a positive integer
 
     this also implies that a'/d is also an integer (in p/q form where q=1)
 
     so it is proved that the remainder a' of  a/b is also divisible by the gcd of a and b (i.e. d)
     i.e. a,b,d have common gcd (You are going to get it at the end of calculation ---- consider example2)
 
 */
 
 import 'dart:io';
 
 int gcd(int a, int b) {
   if (b == 0) return a;
 
   return gcd(b, a % b);
   /* 
     Why return gcd(b, a % b) and not gcd(a % b, b)???
 
     for gcd(a,b), considering a>b, we can only do gcd(b,a') 
     here we cant do gcd(a',b) because a'<b always
 
     further repeating this same recursively we ultimately get the remainder part to be 0. 
 
     i.e. in gcd(x,y) where the remainder part y is 0 
     i.e. gcd(x,y) = gcd (x,0) where x will be the gcd of gcd(a,b).
 
     The largest common divisor of k and zero = k. 
     So gcd(k, 0) = gcd(0,k) = k.
   */
 }
 
 int main() {
   print(""Enter the two numbers whose GCD is to be found"");
   stdout.write(""Enter the first number: "");
   int a = int.parse(stdin.readLineSync());
   stdout.write(""Enter the second number: "");
   int b = int.parse(stdin.readLineSync());
 
   /*
     here a>b or b>a does not matter
     because a will be the greater in the algo's 1st recursion. for example:-
     gcd(25,100)
     = gcd(100,25) here 25%100=25
   */
   stdout.write(""GCD of $a and $b is: "");
   int result = gcd(a, b);
   stdout.wr",Dart
"#include <stdio.h>
 #define MAX 100
 
 /*Bubble sort is an algorithm that compares the adjacent elements and swaps 
 their positions if they are not in the intended order. 
 The order can be ascending or descending.
 */
 
 //prototyping the bubble sort function
 void bubble_sort(int a[], int len); //utility function to sort
 void print_array(int a[], int n);   //utility function for printiong an array
 //initializing main function
 
 int main(int argc, char const *argv[])
 {
     //initial array to store elements for sorting.
     int A[MAX];
 
     //size element to define the size of the array.
     int size, i, j;
 
     printf(""enter the size of array you want:"");
     scanf(""%d"", &size);
 
     //taking the elements in the array
 
     for (i = 0; i < size; i++)
     {
         /* take the elements from user */
         printf(""\n"");
         printf(""enter the element of the array:"");
         scanf(""%d"", &A[i]);
     }
 
     printf(""\n"");
     printf(""the initial unsorted array:"");
     print_array(A, size);
 
     bubble_sort(A, size);
 
     printf(""\n\n"");
     printf(""The final sorted array:"");
     print_array(A, size);
 
     return 0;
 }
 
 void bubble_sort(int a[], int n)
 {
 
     int i, j;
     for (i = 0; i < n - 1; i++)
     {
         j = i;
         for (j = 0; j < n - i - 1; j++)
         {
             if (a[j] > a[j + 1])
             {
                 /* code */
                 int temp = a[j];
                 a[j] = a[j + 1];
                 a[j + 1] = temp;
             }
         }
     }
 }
 
 void print_array(int a[], int n)
 {
     for (int i = 0; i < n; i++)
     {
         /* code */
         printf("" %d "", a[i]);
     }
 }",C
"'''
 
 What is Pancake Sorting??
 Given an array of integers, sort the array using a given Flip operation.
 This is called Pancake sorting because this uses Flip operation which is analogous to flipping pancakes.
 For example, if there are 5 pancakes stacked one of top of the other, then Flip operation is when a spatula is inserted at any point in the stack and then turned upside down flipping all pancakes above it.
 
 '''
 
 
 '''
 Pancake sorting uses only one operations i.e. flip operation 
 flip(arr,i): Reverse array from 0 to i
 '''
 
 '''
 Algorithm for Pancake Sorting
 1.) Start form the length of the array and reduce it by one while its greater than one
 1 Let current length be length. do following for len 
 --- Find index of maximum element in arr[0..length-1].Let the index of maximum element be i.
 --- Call flip(arr,i)
 --- Call flip(arr,length-1)
 '''
 
 
 #Python Program for sorting the array
 
 #Reverse the array[0..i]
 def flip(arr,i):
     st = 0
     while st < i:
         temp = arr[st]
         arr[st]  = arr[i]
         arr[i] = temp
         st+=1
         i-=1
 
 
 #Return index of maximum element in
 def maxx(arr,n):
     maxx=0
     for i in range(0,n):
         if arr[i]>arr[maxx]:
             maxx=i
     return maxx
 
 
 
 #Writing the function for Pancake Sorting using array arr and length of arr n as parameters
 def PancakeSoritng(arr,n):
 
     #Taking the cuurent length of array as length
     # and reducing it by 1
     length = n
     while length > 1:
         #finding index of maximum element
         # in arr[0..length-1]
         i = maxx(arr,length)
 
         #Moving maximum elelemnt to end
         #if not present already
         if i!=length-1:
             #first moving maximum element to beginning
             flip(arr,i)
 
             #now moving maximum element to end
             flip(arr,length-1)
         length-=1
 
 
 #Testing our function on a user array
 user_input = input(""Enter input numbers separated by a comma",Python
"/*Problem Statement:
 You are given a binary tree, 
 your task is to replace each node of the binary tree by the sum of its child nodes. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class node
 {
     public:
         int data;
         node * left;
         node * right;
 
     node(int d)
     {
         data = d;
         left = NULL;
         right = NULL;
     }
 };
 
 node* buildTree()
 {
     int d;
     cin >> d;
 
     if (d == -1)
     {
         return NULL;
     }
 
     node *root = new node(d);
     root->left = buildTree();
     root->right = buildTree();
     return root;
 }
 
 void print(node *root)
 {
     if (root == NULL)
     {
         return;
     }
 
     cout << root->data << "" "";
     print(root->left);
     print(root->right);
 }
 
 int replaceSum(node *root)
 {
     if (root == NULL)
     {
         return 0;
     }
 
     if (root->left == NULL and root->right == NULL)
     {
         return root->data;
     }
 
     int lsum = replaceSum(root->left);
     int rsum = replaceSum(root->right);
     int temp = root->data;
     root->data = lsum + rsum;
 
     return temp + root->data;
 }
 
 int main()
 {
     cout << ""Enter the nodes of the binary tree: "" << endl;
     node *root = buildTree();
     cout << ""Initial tree: ""<<endl;
     print(root);
     replaceSum(root);
     cout << ""Final tree: ""<<endl;
     print(root);
     return 0;
 }
 
 /*
 Example: 
 Input:-
 Enter the nodes of the binary tree:
 1 2 -1 -1 3 -1 -1
 
 Output:-
 Initial tree: 1 2 3
 Final tree: 5 2 3
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
"/*
 Given an array of N elements , find it's prefix sum array. 
 In Competitive Programming, many times we need to calculate prefix sum array to solve our problem.
 */
 
 import java.util.Scanner;
 import java.lang.*;
 
 public class PrefixSum 
 {
     // this function will give us prefix sum of the array
 	static void prefix_sum_array(int ar[], int N)
 	{
 	    int pref_ar[] = new int[N];
 	   
 	    pref_ar[0] = ar[0];
 	    /* we will add the current element of ar[] array
          and previous element of pref_ar [] array */
         for(int i = 1; i < N; i++)
         {
            pref_ar[i] = ar[i] + pref_ar[i - 1];
         }
         System.out.println(""The New Prefix sum array is \n"");
 		for (int i = 0; i < N; i++)
         {
             System.out.print(pref_ar[i] + "" "");
         }
         System.out.println('\n');
 	}
     
 	public static void main(String args[]) 
 	{
 		Scanner scan = new Scanner(System.in);
 		System.out.print(""Enter the size of array \n"");
 		int number = scan.nextInt();
 		
 		int[] ar = new int[number];
 		System.out.println(""Enter array elements \n""); 
 		for(int i = 0; i < number; i++)
 		{
 		    ar[i] = scan.nextInt();
 		}
 		scan.close();
 		prefix_sum_array(ar,number);
 		
 		}
 }
 /*
 
 Standard Input and Output
 
 Enter the size of array 
 7
 Enter array elements
 10 4 16 34 23 5 90
 
 The New Prefix sum array is
 10 14 30 64 87 92 182
 
 Time Complexity : O(N)
 Space Complexity : O(N)
 
 
 */
",Java
"/* Description :
      The idea of Radix Sort is to do digit by digit sort starting from least significant 
      digit to most significant digit. Radix sort uses counting sort as a subroutine to sort.
 */
 
 /* JAVA SCRIPT CODE */
 
 (function (exports) {
   'use strict';
   var radixSort = (function () {
 
     var getDigit = function (number, lsdOffset) {
       var size = number.toString().length;
       var digit;
       if (lsdOffset >= 0 && lsdOffset < size) {
         digit = number.toString()[size - 1 - lsdOffset];
       }
       return digit;
     };
     
     return function (array) {
       var size = array.length;
       var R = 10;   /* Alphabet size ([0-9] for integers) */
       var count;
       var digit;
       var i;
       var j;
       /* Find maximum key size */
       var maxKeySize = (array[0] || '').toString().length;
       for (i = 1; i < size; i += 1) {
         var numStr = array[i].toString();
         if (numStr.length > maxKeySize) {
           maxKeySize = numStr.length;
         }
       }
       for (i = 0; i < maxKeySize; i += 1) {
         /* Initialize count */
         count = [];
         for (j = 0; j < R; j += 1) {
           count[j] = 0;
         }
         /* Count frequency of each array element */
         for (j = 0; j < size; j += 1) {
           digit = getDigit(array[j], i) || 0;
           count[digit] += 1;
         }
         /* Compute cumulates */
         for (j = 1; j < R; j += 1) {
           count[j] += count[j - 1];
         }
         /* Move elements to auxiliary array */
         var aux = [];
         for (j = size - 1; j >= 0; j -= 1) {
           digit = getDigit(array[j], i) || 0;
           count[digit] -= 1;
           aux[count[digit]] = array[j];
         }
         /* Copy elements back from auxilary array */
         for (j = 0; j < size; j += 1) {
           array[j] = aux[j];
         }
       }
       return array;
     };
   })();
   exports.radixSort = radixSort;
 })(typeof window === ",JavaScript
"/*
 Query : Job Scheduling with Maximum Profit (using Recursion)
 
 Task:
 We are given X number of Jobs and their starting time, end time, and profit value of accomplishing them.
 We have to find the maximum profit of any subset of them such that there is no overlapping 
 between the time durations of the jobs.
 
 Input is three arrays: BeginTime , EndTime , Profit
 Output is an integer of Maximum profit of subset of Jobs
 
 */
 // Including the libraries
 #include<bits/stdc++.h>
 using namespace std;
 
 /*Defining class for jobs 
 The attributes of jobs as the 
 members of the class namely:
  	a)begin: starting time of the job
  	a)end : ending time of the job
  	c)profit: profit you gain by completing that job
 */
 class Jobs
 {
 	public:
 		int begin, end, profit; 
 	
 };
 
 /*Sorting the activities according to their 
 ending times to get the correct ordering of 
 the jobs
 */
 static bool sort_Order(Jobs job1, Jobs job2)
 {
 	return (job1.end < job2.end);
 }
 
 /*
 Recursive solution for optimizing the maximum 
 profits for jobs without overlapping the job duration
  Here job[]: Array of jobs
 	  job_curr : Current job
 */
 
 int Optimal_profit_Rec(Jobs job[], int job_curr)
 {
 	if(job_curr < 0)
 		return 0;
 	if (job_curr == 1) 
 		return job[job_curr-1].profit;
 
 	int include,exclude;
 	
 	/*a) to include the current job:
 	 We need to find the last job(nearest_job) that
 	 doesn't overalp with current job(job_curr).
 	 we can find that using linear search.
 	  Then we will recursively find the result for all jobs till that job(nearest_job) and
 		add profit of current job(job_curr) to the output.
 	*/
 	int nearest_job=-1;
 	int job_idx;       // to iterate the jobs
 	job_idx = job_curr - 1;
 	
 	while (job_idx>=0)
 	{
 		if (job[job_idx].end <= job[job_curr-1].begin){
 			nearest_job=job_idx; // This is the last non-overlapping job
 			break;
 		}
 		job_idx--;
 	}
 	
 	
 	//Including the job , hence adding the profit to the result
 	include= job[job_curr",C-Plus-Plus
"/**
  * @author omkarlanghe
  * Given a string S. The task is to print all permutations of a given string.
  * Input:
  * The first line of input contains an integer T, denoting the number of test cases.
  * Each test case contains a single string S in capital letter.
  * 
  * Output:
  * For each test case, print all permutations of a given string S with single space
  * and all permutations should be in lexicographically increasing order.
  * 
  * Example:
  * Input:
  * 2
  * ABC
  * ABSG
  * 
  * Output:
  * ABC ACB BAC BCA CAB CBA 
  * ABGS ABSG AGBS AGSB ASBG ASGB BAGS BASG BGAS BGSA BSAG BSGA GABS GASB GBAS GBSA GSAB GSBA SABG SAGB SBAG SBGA SGAB SGBA
 */
 #include <iostream>
 #include <cstring>
 
 /** @brief function to swap two characters */
 void swap(char *x, char *y) {
     char temp = *x;
     *x = *y;
     *y = temp;
 }
 
 /** @brief function to find all permutations of a given string */
 void string_permutations(char str[], int l, int r) {
     int i;
     if (l == r) {
         std::cout << str << "" "";
     } else {
         for (int i = l ; i <= r ; i++) {
             swap((str + l), (str + i));
             string_permutations(str, l + 1, r);
             swap((str + l), (str + i));
         }
     }
 }
 
 /** Main function */
 int main() {
     int t, n;
     std::cout << ""Enter test cases : "" << std::endl;
     std::cin >> t;
 
     while (t--) {
         char str[5];
         std::cout << ""Enter the string : "" << std::endl;
         std::cin >> str;
         int n = strlen(str);
         string_permutations(str, 0, n-1);
         std::cout << std::endl;
     }
     return (0);
 }
",C-Plus-Plus
""""""" Julia program to find the Length of Longest Decreasing Subsequence
 
 In this problem, given an array we have to find the length of the longest decreasing subsequence that array can make.
 The problem can be solved using Dynamic Programming.
 """"""
 
 function length_longest_decreasing_subsequence(arr, n)
     max_len = 0
     # Initialize the dp array with the 1 as value, as the maximum length
     # at each point is atleast 1, by including that value in the sequence
     dp = ones(Int, n)
 
     """""" Now Lets Fill the dp array in Bottom-Up manner
     Compare Each i'th element to its previous elements from 0 to i-1, 
     If arr[i] < arr[j](where j = 0 to i-1), then it qualifies for decreasing subsequence and
     If dp[i] < dp[j] + 1, then that subsequence  qualifies for being the longest one""""""
     for i in 1:n
         for j in 1:(i-1)
             if(arr[i] < arr[j] && dp[i] < dp[j] + 1)
                 dp[i] = dp[j] + 1
             end
         end
     end
 
     # Now Find the largest element in the dp array 
     max_len = findmax(dp)[1]
     return max_len
 end
 
 
 print(""What is the length of the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""No numbers present in the array!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 res = length_longest_decreasing_subsequence(arr, n)
 print(""The length of the longest decreasing subsequence of the given array is $res"")
 
 
 """"""
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 What is the length of the array? 5
 Enter the numbers: 5 4 3 2 1
 The length of the longest decreasing subsequence of the given array is 5
 
 SAMPLE II
 
 What is the length of the array? 10
 Enter the numbers: 15 248 31 66 84 644 54 84 5 88
 The length of the longest decreasing subsequence of the given array is 4
 
 """"""
",Julia
"/*
 Description : 
     Given an input string, write a code that returns the Run Length Encoded string for the input string.
     For example, if the input string is wwwwaaadexxxxxx, then the function should return w4a3d1e1x6
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // function to incode
 void encode(string str)
 {
     // length of the string
     int len = str.length();
     for (int i = 0; i < len; i++)
     {
         int counter = 1;
         while (i < len - 1 and str[i] == str[i + 1])
         {
             // updating the counter
             counter++;
             i++;
         }
         // printing the updated  counter
         cout << str[i] << counter;
     }
     cout << endl;
 }
 
 int main()
 {
     // input string
     string str;
     cout << ""Enter the string to encode : "" << endl;
     cin >> str;
 
     cout << ""Encoded string : "" << endl;
     encode(str);
     return 0;
 }
 /*
 Time complexity : O(N)
 Space complexity : O(1)
 */
 
 /*
 Test Case : 
   Input :
     Enter the string to encode : 
     xxxxyyyyaa
   Output :
     Encoded string : 
     x4y4a2
 */
 
",C-Plus-Plus
"/* A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations, which is a linked list 
 consists of nodes where each node contains a data field and a reference(link) to the next node in the list */
 
 #include <iostream>
 using namespace std;
 int count =0;
 class Node{   //To create Node in heap with data and next pointer
 public:
     int data;
     Node *next;
 };
 
 class LinkedList{     //creates Linked List with help of class Node
     
 private:
     Node *first;
     
 public:
     LinkedList()     
     {
         first=NULL;
     }
     
     LinkedList(int arr[],int n)  //Takes input as array and its size from main to create Linked List 
     {
         Node *tmp,*last;
         first=new Node;
         first->data = arr[0];  //First element in array is First Node in Linked List
         first->next = NULL;
         last = first;
         for(int i=1;i<n;i++)   //Remaining Elements are followed by first Node
         {
             tmp = new Node;
             tmp->data = arr[i];
             tmp->next=NULL;
             last->next=tmp;
             last=tmp;
         }
    }
  
 void display()          // To Display an Linked List
 {
     Node *p=first;
     cout << ""Nodes in Linked List are: "" << endl;
     while(p)
     {
         cout << p->data << "" ""<< endl;
         p=p->next;
     }
 }
 
 
 int countNodes(Node *p)  //To return total count of Nodes in Linked List
 {
     if(p==NULL)
         return 0;
     else
     {
         count++;
          return countNodes(p->next) + 1;
     }
     
 }
 
 
 void InsertNode(int index,int x)  //Takes index and Node's Data to be insterted into Linked List
 {
     Node *p=first;
     Node *tmp;
     if(index < 0 || index > countNodes(p))
     {
         return;
     }
     tmp = new Node;
     tmp->data=x;
     if(index==0)
     {
         tmp->next=p;
         first=tmp;
     }
 else
     {
     for(int i=0;i<index-1;i++)
     {
         p=p->next;
     }
     ",C-Plus-Plus
"""""""
 Hamiltonian Path: a Hamiltonian path (or traceable path) is a path
     in an undirected or directed graph that visits each vertex exactly
     once.
 
 Problem Link: https://en.wikipedia.org/wiki/Hamiltonian_path
 Purpose: To determine the existance of a Hamiltonian Path in the provided
         undirected graph and return the path if such path exist.
         The nodes are numbered from 1 to N
 Method : Depth First Search
 
 Time Complexity:  O(N^2)
 Space Complexity: O(N)
 
 Argument : Graph (Dictionary)
 Return   : Hamiltonian Path (List)
 
 """"""
 from collections import defaultdict
 
 
 def DFS(n, graph, pos, ans):
     # Base Case: If all the node is visited, Hamiltonian Path is achieved
     if pos == n:
         return ans
 
     current = ans[-1]
 
     # Check for each of the adjoining vertices
     for i in graph[current]:
 
         # Check wether the node is already visited or not
         if i not in ans:
             ans += [i]
             temp = DFS(n, graph, pos + 1, ans)
             if temp:
                 return temp
 
             ans.pop()
 
     return False
 
 
 def Hamiltonial_Path(n, graph):
     # To keep a track of already visited node and the answer
     # We will start exploring the graph from Vertex 1
     answer = [1]
 
     # Start Exploring from eac node/vertex
     for i in range(1, n + 1):
         
         ans = DFS(n, graph, 1, [i])
         if ans:
             return ans
 
     return False
 
 
 # ------------------------DRIVER CODE ------------------------
 if __name__ == ""__main__"":
     n, m = map(int, input(""Enter the number of vertex and edges: "").split())
     print(""Enter the edges: "")
     graph = defaultdict(list)
     for i in range(m):
         a, b = map(int, input().split())
         graph[a] += [b]
         graph[b] += [a]
     ans = Hamiltonial_Path(n, graph)
     if not ans:
         print(""Hamiltonian Path is not possible in the Given graph"")
     else:
         print(""Hamiltonian Path is possible in t",Python
"/*
 matrix multiplication is a binary operation that produces a product matrix 
 from two matrices . To multiply two matrices, the number of columns of first 
 matrix should be equal to the number of rows to second matrix.
 This program finds the product of two given matrices
 */
 
 function matrix_multiplication(a_1, n1, m1, a_2, n2, m2) {
     //res is the result array
     let res = new Array(n1);
     for (let i = 0; i < n1; i++) {
         res[i] = new Array(m2);
     }
     for (let i = 0; i < n1; i++) {
         for (let j = 0; j < m2; j++) {
             res[i][j] = 0;
             for (let k = 0; k < m1; k++) {
                 res[i][j] += a_1[i][k] * a_2[k][j]
             }
         }
     }
     return res;
 }
 
 
 const readline = require('readline');
 
 const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
 
 const getLine = (function () {
     const getLineGen = (async function* () {
         for await (const line of rl) {
             yield line;
         }
     })();
     return async () => ((await getLineGen.next()).value);
 })();
 
 const main = async () => {
     console.log(""Enter the number of rows in the first matrix"");
     let n1 = Number(await getLine());
     console.log(""Enter the number of columns in the first matrix"");
     let m1 = Number(await getLine());
     console.log(""Enter the elements of the first matrix"");
     //initializing array
     let a_1 = new Array(n1);
     for (let i = 0; i < n1; i++) {
         a_1[i] = new Array(m1);
     }
     for (let i = 0; i < n1; i++) {
         for (let j = 0; j < m1; j++) {
             console.log(""Enter the element at position "" + i + "" , "" + j);
             a_1[i][j] = Number(await getLine());
         }
     }
     console.log(""Enter the number of rows in the second matrix"");
     let n2 = Number(await getLine());
     console.log(""Enter the number of columns in the second matrix"");
     let m2 = Number(await getLine());
     console.log(""Enter the ele",JavaScript
"#Find total number of Squares in a N*N cheesboard.
 
 class Solution:
     # using mathematical logic
     def squares(self, N):
         
         sum=0
         for i in range(1,N+1):
             s=i*i
             sum+=s
         return sum
 
 #taking input
 num = int(input(""Enter the number :""))
 obj = Solution()
 print(""The square : "")
 print(obj.squares(num))
 
 '''
 Time complexity : O(N)
 Space complexity : O(1)
 
 Input :
 Enter the number :  1
 Output :
 The square is : 1
 '''",Python
"/**
  * Infix to Prefix Expression
  * 
  * Algorithm Used:
  * First the given infix expression is reversed.
  * By reversing, every '(' becomes ')' and vice versa.
  * Then, we obtain the postfix of the reversed expression.
  * Now, we reverse this postfix expression to obtain the Prefix expression.
  * 
  * Author: iamvs-2002
  */
 
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Scanner;
 import java.util.Stack;
 
 public class InfixtoPrefix 
 {
     public static void main(String[] args) 
     {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Kindly enter the infix expression: "");
         String infix = sc.nextLine();
 
         InfixtoPrefix x = new InfixtoPrefix();
         String prefix = x.infixtoprefix(infix);
         
         System.out.println(""Prefix Expression: ""+prefix);
     }
 
     static int priority(char c)
     {
         /**
          * '+' and '-' have priority=1
          * '*' and '/' have priority=2
          * '^' has priority=3
          */
         switch (c)
         {
             case '+':
                 return 1;
             case '-':
                 return 1;
             case '*':
                 return 2;
             case '/':
                 return 2;
             case '^':
                 return 3;
             default:
                 return -1;
         }
     }
 
     private String infixtoprefix(String expression)
     {
         //initially an empty string
         String result = """";
 
         //reversing the given infix expression
         char[] array = new char[expression.length()];
         for (int j = expression.length()-1; j >=0 ; j--) { 
             array[expression.length()-j-1] = expression.charAt(j);
         }
 
         Stack<Character> stack = new Stack<>();
 
         int i=0;
         for (i = 0; i < array.length; i++) 
         {
             if (array[i] == '(')
             {
                 array[i] = ')';
                 i++;
       ",Java
"/*
 A pronic number is a number which is the product of two consecutive integers.
 Such as 2=2*1 or 12=4*3
 */
 
 import 'dart:io';
 import 'dart:math';
 
 // Check if number is pronic or no
 bool isPronic(int number) {
   int sqt = sqrt(number).toInt();
 
   for (int index = 1; index <= sqt; index++) {
     // Check multiplication of contious numbers
     if (index * (index + 1) == number) {
       return true;
     }
   }
 
   return false;
 }
 
 // Main Function, with driver code
 void main() {
   print(""Enter a number:"");
   int input = int.parse(stdin.readLineSync()!);
 
   // Call isPronic function on input
   if (isPronic(input)) {
     print(""$input is a pronic number"");
   } else {
     print(""$input is not a pronic number"");
   }
 }
 
 /**
 Time Complexity: O(sqt(n))
 Space Complexity: O(1)
 
 Sample input/output:
 Enter a number:
 12
 12 is a pronic number
 
 Enter a number:
 32
 32 is not a pronic number
 */
 
",Dart
"//C program to check if two input strings are anagrams or not
 
 #include <stdio.h>
 #include <string.h>
 void sort_strings(char str[]) //sort the strings
 {
   int loop1, loop2;
   char temp;
   for (loop1 = 0; str[loop1] != '\0'; loop1++)
   {
     for (loop2 = 0; str[loop2] != '\0'; loop2++)
     {
       if (str[loop2] > str[loop1])
       {
         temp = str[loop1]; //swapping
         str[loop1] = str[loop2];
         str[loop2] = temp;
       }
     }
   }
 }
 int check_anagram(char str1[], char str2[], int len)
 {
   int loop_num;
   for (loop_num = 0; loop_num < len; loop_num++)
   {
     if (str1[loop_num] != str2[loop_num])
       return -1;
   }
   return 0;
 }
 int main()
 {
   char str1[50], str2[50];
   int len1, len2;
   printf(""Enter two strings:\n"");
   scanf(""%s%s"", str1, str2); //strings to be checked
   len1 = strlen(str1);
   len2 = strlen(str2);
   //if length of strings is not equal they cannot be anagrams
   if (len1 != len2)
     printf(""The given strings are not anagrams"");
   else
   {
     sort_strings(str1);
     sort_strings(str2);
     if (check_anagram(str1, str2, len1) == 0) //len1=len2
       printf(""The given strings are anagrams"");
     else
       printf(""The given strings are not anagrams"");
   }
   return 0;
 }
 
 /*
     TIME COMPLEXITY-O(nlogn)
     SPACE COMPLEXITY-O(n)
 
     SAMPLE INPUT
     restful
     fluster
 
     OUTPUT
     The given strings are anagrams
 */
",C
"'''
 This is a simple program of appliaction of hashing , we have to find the maximum distance between same elements
 for eg : if array is [1,2,3,4,2,1] then max distance is between 1 at 0 index and 1 at 5 index so the output will be
 5-0 = 5
 Approch : First of all we make a dummy array of all zeros.
           Then we will create a hashmap and check if element is in hashmap or not .
           If element is not in hashmap then we will store the position (first occurence) of element.
           else we will find the difference in current position and first occurence and store it to dummy array.
           After this we just have to return the max difference.        
 '''
 
 # This function will return a intger as max distance
 def maxDistance(arr, n):
     arr2 = [0*x for x in range(n)]
     #This dictionary works as hashmap for hashing
     dict1 =  {}
     res = 0
     for i in range(n):
         if arr[i] not in dict1.keys():
             dict1[arr[i]] = i
         else:
             first_occ = dict1[arr[i]]
             diff = i - first_occ
             try:
                 if diff >= arr2[arr[i]]:
                     arr2[arr[i]] = diff
             except:
                 pass
             if diff>=res:
                 res = diff
     return res
 
 # Driver Code Starts
 if __name__=='__main__':
     print(""Enter the no of Elements in Array"")
     n = int(input())
     print(""Enter the Array"")
     arr = list(map(int, input().strip().split()))
     print(maxDistance(arr, n))
 # Driver Code Ends
 
 '''
 Sample Input/Output :
 
 - Test case 1:
 Enter the no of Elements in Array : 5
 Enter the Array : 1 2 3 3 3 4 1
 Output : 6
 
 - Test case 2:
 Enter the no of Elements in Array : 11
 Enter the Array : 1 2 3 3 3 4 1 2 2 3 4 
 Output : 7
 
 Time complexity : 0(n)
 Space complexity : 0(n)
 '''
",Python
"#include <bits/stdc++.h>
 using namespace std;
 
 int kadane(int* arr, int n){
     int curr_sum = 0, best_sum = 0;
     int flag = -1;
     for(int i = 0; i < n; i++){
         curr_sum += arr[i];
         if(best_sum < curr_sum){
             best_sum = curr_sum;
             flag = 0;
         }
         if(curr_sum < 0)
             curr_sum = 0;
     }
     if(flag != -1)
     	return best_sum;
     best_sum = INT_MIN;
     for(int i = 0; i < n; i++){
         best_sum = max(arr[i], best_sum);
     }
     return best_sum;
 }
 
 int maxSumRect(int** input, int row, int col){
     int maxSum = INT_MIN,sum;
     for(int l = 0; l < col; l++){
         int* arr = new int[row];
         fill(arr, arr+row, 0);
         for(int r = l; r < col; r++){
             for(int i = 0; i < row; i++){
                 arr[i] += input[i][r];
             }
             sum = kadane(arr, row);
             maxSum = max(maxSum, sum);
         }
         delete[] arr;
     }
     return maxSum;
 }
 
 int main()
 {
     int row,col;
     cout << ""Enter no. of rows and columns: "" << endl;
     cin >> row >> col;
     cout << ""Enter matrix elements: "" << endl;
     int** input = new int*[row];
     for(int i = 0; i < row; i++){
         input[i] = new int[col];
         for(int j = 0; j < col; j++){
             cin >> input[i][j];
         }
     }
     
     cout << ""Maximum Sum is: "" << maxSumRect(input, row, col) << endl;
     
     for(int i = 0; i < row; i++){
         delete[] input[i];
     }
     delete[] input;
     return 0;
 }
 
 /*
 Sample input/output:
 Enter no. of rows and columns:                                                                                                
 4 5                                                                                                                           
 Enter matrix elements:                                                                                                        
 1 2 -1 -4 -20                             ",C-Plus-Plus
"// Description: Given two strings, check if they are anagrams or not.
 // An anagram of a string is another string that contains same characters, only the order of characters can be different.
 // For example: 'word' and 'ordw' are anagrams, 'abcd' and 'abcdb' are not anagrams.
 #include <bits/stdc++.h>
 using namespace std;
 
 bool check_anagrams(string s1, string s2){
     if(s1.size() != s2.size()){          //If two strings don't have equal length, that means they are not anagrams.
         return false;
     }
     int count[256] = {0};               //Take a count array of size 256(because of 256 ascii characters) and set all the positions to 0 initially
     for(int i = 0; i < s1.size(); i++){ //We are traversing through s1 and incrementing each s1's character frequency
         count[s1[i]]++;
     }
     for(int i = 0; i < s2.size(); i++){ //Here, we are traversing through s2 and decrementing s2's character frequency
         count[s2[i]]--;
     }
     for(int i = 0; i < 256; i++){       //Traversing through the count array
         if(count[i] != 0){              //If two strings are anagrams, all the count elements should be zero, and if they are not zero, we return false
             return false; 
         }
     }
     return true;                       //If all elements of count array are zero, s1 and s2 are anagrams
 }
 
 int main(){
     string s1, s2;
     cout << ""Enter s1: "";
     cin >> s1;
     cout << ""Enter s2: "";
     cin >> s2;
     cout << ""Anagrams or not: "";
     if(check_anagrams(s1, s2)){
         cout << ""yes"";
     }
     else{
         cout << ""no"";
     }
     return 0;
 }
 // Sample test case:
 // s1 = 'abcd' and s2 = 'abcdb'
 // count of a, b, c, d become 1 while traversing through s1
 // count of a, b, c, d become 0, -1, 0, 0 respectively, while traversing through s2
 // Since one element of count array is not 0, we return false
",C-Plus-Plus
"#include<bits/stdc++.h>
 using namespace std;
 class heap{
     int n;
     int arr[];
     public:
     heap(){
         cout<<""Enter the total no. of elements in a heap u want ?""<<endl;
         cin>>n;
         arr[n+1];
         memset(arr,0,n+1);       //initialising the value 0 
     }
     void max_heap(){            //max heap function accepting values and calling insert_max to insert element to acc to max heap condition
         char ch;
         int j = n;
         int m ,i=1;
         do{
             cout<<""Enter element ""<<i<<"" :"";
             cin>>m;
             arr[i] = m;
             insert_max(i);
             i++;
             j--;
         }while(j>=1);
         disp();
     }
     void insert_max(int i){ //always checking from its parent element if smaller then swapping is to be done
         int elem = arr[i];
         while(i>1 && arr[i/2]<elem){
             arr[i] = arr[i/2];
             i = i/2;
         }
         arr[i] = elem;
     }
     void min_heap(){ //min heap function accepting values and calling insert_min to insert element to acc to min heap condition 
         char ch;
         int j = n;
         int m ,i=1;
         do{
             cout<<""Enter element ""<<i<<"" :"";
             cin>>m;
             arr[i] = m;
             insert_min(i);
             i++;
             j--;
         }while(j>=1);
         disp();
     }
     void insert_min(int i){
         int elem = arr[i];
         while(i>1 && arr[i/2]>elem){      //always checking from its parent element if greater then swapping is to be done
             arr[i] = arr[i/2];
             i = i/2;
         }
         arr[i] = elem;
     }
     void disp(){
         for(int i=1;i<n+1;i++){
             cout<<arr[i]<<""\t"";
         }
         cout<<""\n"";
     }
 };
 int main()
 {
     heap h;
     int ch;
     do{
         cout<<""Enter the choice below :\n1.MAX heap \n2.MIN heap \n3.EXIT\n"";
         cin>>ch;
         switch(ch)
         {
             case 1:
            ",C-Plus-Plus
"/* 
 WIGGLE SORT
 This program accepts an array of unsorted numbers and
 sorts the array such that arr[0]<arr[1]>arr[2]<arr[3]...
 */
 
 #include<stdio.h>
 #include <stdlib.h>
 
 //to merge the sorted arrays
 void merge(int *ar, int l, int mid, int r)
 {
     int i = l, j = mid + 1, k = 0, c[r - l + 1];
     while (i <= mid && j <= r)
     {
         if (ar[i] <= ar[j])
             c[k++] = ar[i++];
         else
             c[k++] = ar[j++];
     }
     if (i > mid && j <= r)
     {
         for (int m = j; m <= r; m++)
             c[k++] = ar[m];
     }
     else if (i <= mid && j > r)
     {
         for (int m = i; m <= mid; m++)
             c[k++] = ar[m];
     }
     for (int m = 0; m < k; m++)
         ar[l++] = c[m];
 }
 
 //to sort the array using merge sort
 void merge_sort(int *ar, int l, int r)
 {
     if (l < r)
     {
         int mid = l + (r-l) / 2;
         merge_sort(ar, l, mid);
         merge_sort(ar, mid + 1, r);
         merge(ar, l, mid, r);
     }
 }
 
 void wiggle_sort(int n, int* arr)
 {
     int left, right;
     //A new vector res is initialized to store sorted array
     int* res = malloc(sizeof(int)*n);
     for(int i=0;i<n;i++)
         res[i]=arr[i];
     //res is sorted with the built-in sort() function.
     merge_sort(res,0, n-1);
 
     /*res is partitioned into two such that left sub-array
       contains elements less than the elements in right sub-array*/
 
     // left points to the end of left sub-array
     left = (n - 1) / 2;
     // right points to the end of right sub-array
     right = n - 1;
 
     //Elements in the left sub-array  are added to the even indices of vector res
     for (int k = 0; k < n; k += 2)
         // left is decremented
         arr[k] = res[left--];
 
     //Elements in the right sub-array are added to the odd indices of vector x
     for (int k = 1; k < n; k += 2)
         // right is decremented
         arr[k] = res[right--];
 
     for (int i = 0; i < n; i++)
     { //for printing the wigg",C
"// https://en.wikipedia.org/wiki/KnuthMorrisPratt_algorithm
 
 // Time Complexity:-O(N+M).
 // Space Complexity:-O(M).
 
 #include <iostream>
 #include <vector>
 #include <string>
 
 using namespace std;
 
 // Fills lps for given patttern pat[0..M-1]
 void computeLPS(string &patt, vector<int> &lps)
 {
     int M = patt.size();
     // length of the previous longest prefix suffix
     int len = 0;
 
     lps[0] = 0;
 
     int i = 1;
     // the loop calculates lps[i] for i = 1 to M-1
     while (i < M)
     {
         if (patt[i] == patt[len])
         {
             len++;
             lps[i] = len;
             i++;
         }
         else
         {
             if (len != 0)
             {
                 len = lps[len - 1];
             }
             else
             {
                 lps[i] = 0;
                 i++;
             }
         }
     }
 }
 
 
 // Prints occurrences of patt in text
 void searchByKMP(string &text, string &patt)
 {
     int N = text.size(), M = patt.size();
 
     // create lps vector that will hold the longest prefix suffix values for pattern
     vector<int> lps(M);
 
     // Preprocess the pattern(calculate lps vector)
     computeLPS(patt, lps);
 
     int i = 0, j = 0;
 
     while (i < N)
     {
         if (patt[j] == text[i])
         {
             i++;
             j++;
         }
 
         if (j == M)
         {
             cout << ""Pattern found at index "" << i - j << endl;
             j = lps[j - 1];
         }
         else if (i < N && patt[j] != text[i])
         {
             if (j == 0)
                 i++;
             else
                 j = lps[j - 1];
         }
     }
 }
 
 int main()
 {
     string text = """", patt = """";
 
     int n;
 
     cout << ""Enter Number of test Cases:"";
     cin >> n;
 
     while (n)
     {
         cout << endl;
         cout << ""Enter the text string:"";
         cin >> text;
 
         cout << endl << ""Enter the pattern string:"";
         cin >> patt;
 
         ",C-Plus-Plus
"/*
 AIM :: TO IMPLEMENT ASCENDING PRIORITY QUEUE
 
 
                     WHAT IS ASCENDING PRIORITY QUEUE ?
  In ascending order priority queue, a lower priority number is given as a higher priority in a priority. 
  For example, we take the numbers from 1 to 5 arranged in an ascending order like 1,2,3,4,5; therefore, 
  the smallest number, i.e., 1 is given as the highest priority in a priority queue.
 
 */
 
 #include <iostream>
 using namespace std;
 
 //Prototypes
 void enq(int *, int &, int &, int); // for insertion
 void deq(int *, int &, int &, int); // for deletion
 void display(int *, int, int);      // for display
 
 int q_full(int, int);  // for checking queue is full or not
 int q_empty(int, int); // for checking queue is empty or not
 
 int main()
 {
     int size = 100, choice;
     int Q[size];
 
     //initially front and rear will be at -1
     int front = -1; // deletion will be done from front end
     int rear = -1;  // insertion will be done from rear end
 
     cout << ""\t\t\nASCENDING PRIORITY QUEUE"" << endl;
 
     while (true)
     {
         cout << ""\n1. ENQ\n2. DEQ\n3. DISPLAY\n4. EXIT"" << endl;
         cout << ""Enter your choice :: "";
         cin >> choice;
 
         switch (choice)
         {
         case 1:
             enq(Q, front, rear, size);
             break;
 
         case 2:
             deq(Q, front, rear, size);
             break;
 
         case 3:
             display(Q, front, rear);
             break;
 
         case 4:
             cout << ""\nexiting..."" << endl;
             exit(0);
             break;
 
         default:
             cout << ""\nInvalid choice :("" << endl;
             break;
         }
     }
     return 0;
 }
 
 void enq(int Q[], int &front, int &rear, int size)
 {
     int data, temp;
 
     if (q_full(front, size))
         cout << ""QUEUE OVERFLOW"" << endl;
     else
     {
         cout << ""Enter the data :: "";
         cin >> data;
 
         if (front == -1) // means inserting for first",C-Plus-Plus
"// Author : @belikesayantan
 
 package main
 
 import (
 	""bufio""
 	""errors""
 	""fmt""
 	""log""
 	""os""
 	""strconv""
 	""strings""
 	""time""
 )
 
 func main() {
 	var strArray []string
 	var intArray []int
 
 	fmt.Println(""Enter an array with spaces"")
 	reader := bufio.NewReader(os.Stdin)
 	arr, err := reader.ReadString('\n')
 	if err != nil {
 		inputErr := errors.New(""something is wrong with your array input"")
 		log.Fatal(inputErr)
 	}
 	arr = strings.TrimSpace(arr)
 	strArray = strings.Split(arr, "" "")
 
 	for _, val := range strArray {
 		ele, err := strconv.Atoi(val)
 		if err != nil {
 			panic(err)
 		}
 		intArray = append(intArray, ele)
 	}
 
 	start := time.Now() // timer starts and records running time of QuickSort Algorithm
 	fmt.Println(""Sorted Array is: "", QuickSort(intArray, 0, len(intArray)-1))
 	end := time.Now() // timer stops and recording running time of QuickSort Algorithm is completed
 
 	fmt.Println(""\nRunning Time of QuickSort Algorithm is: "", end.Sub(start))
 }
 
 // QuickSort Algorithm Time Complexity : O(n^2)
 func QuickSort(arr []int, start, end int) []int {
 	if len(arr) == 0 {
 		return nil
 	}
 
 	if len(arr) == 1 {
 		return arr
 	}
 
 	if start < end {
 		pivotIndex := partition(arr, start, end)
 		QuickSort(arr, start, pivotIndex-1)
 		QuickSort(arr, pivotIndex+1, end)
 	}
 
 	return arr
 }
 
 func partition(arr []int, start, end int) int {
 	pivot := arr[end]
 	pivotIndex := start - 1
 
 	for i := start; i < end; i++ {
 		if arr[i] < pivot {
 			pivotIndex++
 			swap(arr, i, pivotIndex)
 		}
 	}
 	swap(arr, pivotIndex+1, end)
 	return pivotIndex + 1
 }
 
 func swap(arr []int, i, j int) {
 	temp := arr[i]
 	arr[i] = arr[j]
 	arr[j] = temp
 }
 
 /*
 	I/O Sample:
 
 	Sample 1:
 	 go run quickSort.go
 	Enter an array with spaces
 	5 3 2 4 5 84 6 1 54
 	Sorted Array is:  [1 2 3 4 5 5 6 54 84]
 
 	Running Time of QuickSort Algorithm is:  46.35s
 
 
 	Sample 2:
 	 go run quickSort.go
 	Enter an array with spaces
 	5 8 6 9 1 3 2 7 4
 	Sorted",Go
"""""""
 AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot be more than one for 
 all nodes and if at any time they differ by more than one, rebalancing is done to restore this property. Each node maintains extra information 
 called a balance factor whose value is either -1, 0 or +1 where balance factor of a node in an AVL tree is the difference between the height of 
 the left subtree and that of the right subtree of that node.
 """"""
 class avlnode:
     def __init__(self, value):
         self.left = None
         self.right = None
         self.value = value
 
 class avltree():
     def __init__(self):
         self.node = None
         self.height = -1
         self.balancefactor = 0
 
     """"""
     Insert new value into AVL Tree
     """"""
     def insert(self, value):
         tree = self.node
         new_node = avlnode(value)
 
         if tree is None:
             self.node = new_node
             self.node.left = avltree()
             self.node.right = avltree()
 
         elif value < tree.value:
             self.node.left.insert(value)
 
         elif value > tree.value:
             self.node.right.insert(value)
 
         self.rebalance()
 
     def get_height(self):
         if self.node:
             return self.node.height
         else:
             return 0
 
     # Rotate left (RL)
     def rotate_left(self):
         old_root = self.node
         new_root = self.node.right.node
         new_right = new_root.left.node
 
         self.node = new_root
         old_root.right.node = new_right
         new_root.left.node = old_root
 
     #Rotate right (RR)
     def rotate_right(self):
         old_root = self.node
         new_root = self.node.left.node
         new_left = new_root.right.node
 
         self.node = new_root
         old_root.left.node = new_left
         new_root.right.node = old_root
 
     """"""
     Rebalance a tree after insertion or deletion of a node
     """"",Python
"/* 
 
 3 Sum problem
 
 For a given array nums[], your task is to find the triplets  
 whose sum add up to the target value given. 
 The output is the triplet of the numbers which add up to target. 
 For example:- 
 if A + B + C = target then the output will be A, B, C. 
 It is given that all the sets of triplets should be unique. 
 
 */  
 
 import java.util.Scanner; 
 import java.util.Arrays; 
 import java.util.ArrayList; 
 import java.util.List; 
 
 class three_Sum_problem 
 { 
     //method for printing triplet 
     public List<Integer[]> threeSum(int nums[], int target) 
     { 
         Set<List<Integer[]>> tripletEvaluated = new Hashset<>(); 
 
         //if the array has no elements then we simpliy return  
         //empty list 
         if(nums.length == 0) 
             return new ArrayList<>(tripletEvaluated); 
 
         //else 
         Arrays.sort(nums); 
 
         //using two pointer approach 
         for(int i=0; i<nums.length; i++) 
         { 
             int leftptr = i + 1; 
 
             int rightptr = nums.length - 1; 
 
             while(leftptr < rightptr)
             { 
                 int complement = target - num[i]; 
 
                 int sum = nums[leftptr] + nums[rightptr]; 
 
                 if(sum == complement) 
                 { 
                     tripletEvaluated.add(Arrays.asList(nums[i], nums[leftptr], nums[rightptr])); 
                     leftptr++; 
                     rightptr--; 
                 } 
 
                 else if(sum > complement) 
                 { 
                     rightptr--; 
                 } 
 
                 //else if sum < complement 
                 else 
                 { 
                     leftptr++; 
                 } 
             } 
         } 
         return new ArrayList<>(tripletEvaluated); 
     } 
 
     //driver method 
     public static void main(String []args) 
     { 
 
         Scanner sc = new Scanner(System.in); 
 
         System.out.println(""Enter the ",Java
"//C program to calculate the nth fibonacci term using DP memoization
 #include<stdio.h>
 
 //Global array storing the nth term index wise,the size can be changed as per use.
 int f[1000];
  
 //Fibonnaci function 
 int fibonacci(int n)
 {
   //Fibonnaci series:
   //f[0]=0 and f[1]=1
   //base condition:
   if(n<=1)
   {
     f[n]=n;
     return n;
   }
   //Recursive function:
   //f[n]=f[n-1]+f[n-2]
   else{
 
     if(f[n-2]==-1)
 
       f[n-2]=fibonacci(n-2);
 
     if(f[n-1]==-1)
 
       f[n-1]=fibonacci(n-1);
 
     return f[n-1]+f[n-2];
   }
 }
  
 //Main Function 
 int main()
 {
   
     int i, n;
     printf(""Enter the number the indexing starts from 1\n"");
     scanf(""%d"",&n);
     if(n<=0)
     printf(""Wrong Input\n"");
     else
     {
 	    for(i=0;i<n;i++)
 	      f[i]=-1;
 	    fibonacci(n);
 	 
 	    printf(""The nth fibonacci term is: %d"",f[n-1]);
     }
     
     return 0;
 }
 /* Author : Chandan Kumar Sahu (@chandansahuji)
 contributing as a part of hackinCodes 2020
 
 Sample Input:
 enter the number
 n=5
 
 sample output:
 The nth fibonacci term is:3
 
 Time Complexity-O(n)
 Space Complexity-O(n)
 */
 
",C
"/*
  Introduction
  Given Postorder and Inorder traversals, construct the binary tree.Output the Preorder Traversal of the Tree
  Inorder Traversal = left Root Right
  Postorder Traversal = Left Right Root
 */
 
 /* Code/Solution */
 #include <bits/stdc++.h>
 using namespace std;
 
 /* Definition for a binary tree node.  */
 struct TreeNode
 {
 	int val;
 	TreeNode *left;
 	TreeNode *right;
 };
 
 //Preorder resulatant vector
 vector<int> preoderRes;
 
 //Function to allocate new node with given data
 TreeNode *newNode(int data)
 {
 	TreeNode *node = new TreeNode();
 	node->val = data;
 	node->left = node->right = NULL;
 	return (node);
 }
 
 TreeNode *helper(vector<int> inorder, vector<int> postorder, int Instart, int InEnd, int Poststart, int PostEnd)
 {
 
 	//Base Condition
 	if (Instart > InEnd)
 		return NULL;
 
 	//The last element of the Postorder traversal gives the Root of the Tree
 	int rootVal = postorder[PostEnd];
 	TreeNode *root = newNode(rootVal);
 	int rootIndex;
 	//calling for left
 	for (rootIndex = Instart; rootIndex <= InEnd; rootIndex++)
 	{
 		//We have completely traversed left Subtree
 		if (inorder[rootIndex] == rootVal)
 			break;
 	}
 	//length of left Tree
 	int leftTree = rootIndex - Instart;
 	//Length of right Tree
 	int rightTree = InEnd - rootIndex;
 
 	//Recursively building the left subTree
 	root->left = helper(inorder, postorder, Instart, rootIndex - 1, Poststart, Poststart + leftTree - 1);
 	//Recursively building the Right subTree
 	root->right = helper(inorder, postorder, rootIndex + 1, InEnd, PostEnd - rightTree, PostEnd - 1);
 	return root;
 }
 
 TreeNode *buildTree(vector<int> inorder, vector<int> postorder)
 {
 
 	int len = inorder.size();
 
 	//helper function recursively constructs the Tree
 	// takes inorder , preorder , start and end of preorder and postorder
 	return helper(inorder, postorder, 0, len - 1, 0, len - 1);
 }
 
 void preoderTraversal(TreeNode *root)
 {
 	//Base Condittion
 	if (root == NULL)
 		return;
 	",C-Plus-Plus
"""""""
 Python program to reverse the bits of a number
 Given an integer, reverse its bits in its binary equivalent and
 print the new number obtained in its decimal form
 """"""
 
 
 def reverse_bits(n):
     rev = 0
 
     while(n > 0):
         # Shift the bit of the reversed(answer) number to the right
         rev = rev << 1
         #  Stores the temporary lsb of the given number
         rem = n & 1
         # Set the lsb of the answer variable with the stored value
         rev = rem | rev
         # Drops the already processed lsb of the given number
         n = n >> 1
     return rev
 
 
 if __name__ == '__main__':
     print(""Enter the number? "", end="""")
     num = int(input())
     rev = reverse_bits(num)
     print(""The bits-reversed number is: {}"".format(rev))
 
 """"""
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 39
 The bits-reversed number is: 57
 """"""
",Python
"/*
 Word Ladder problem
 
 Given two words, startWord and endWord, and a dictionary wordsList.
 Find the shortest transformation sequence startWord -> s1 -> s2 -> ... -> endWord such that
     1. Every adjacent pair of words differ by a single character.
     2. There is no guarantee that both the start and end words exist in the words.
 
 Return the minimum number of words in the shortest transformation sequence from startWord to endWord, or 0 if no such sequence exists.
 
 
 Input: startWord, endWord, a list of words in dictionary
 Output: an integer denoting the length of minimum transformation sequence.
 
 Thoughts:
 Let's visualize this as a graph problem. If you can imagine each word in the wordList as a node (vertex) and there exists an edge with each ""potential"" word. 
 Then the problem reduces to finding the shortest path from the startWord to the endWord. 
 
 By ""potential"" I mean that every possible word that we can obtain from the given word by replacing that character by any of the 26 characters.
 
 As this is an unweighted graph, Breadth First Search (BFS) gives us the shorest path in lesser time.
 But, doing Bi-directional BFS can give us our required answer in even lesser time!
 
 Approach:
 We use Bi-directional Breadth First Search to solve this problem. Instead of queues, we can also use set here.
 We start BFS from the either of the ends and keep adding the next set of possible words to our set at every step.
 The moment we find the endWord in the current set, we can break out or return the number of steps recorded till now.
 
 The below code is contributed by Jahnavi Majji as a part of GSSoC'21.
 */
 
 import java.util.*;
 
 public class WordLadder {
     public static void main(String[] args) {
         //driver code
         Scanner scanner = new Scanner(System.in);
         
         //take necessary input: startWord, endWord, dictionary
         System.out.println(""Enter the start word: "");
         String startWord = scanner.nextLine();
   ",Java
"# Importing sys module to initalize the maxsize
 import sys
 ''' Longest Increasing Subsequence '''
 
 '''Problem Statement :Given an array of integers,
                       find the length of the
                       longest (strictly) increasing subsequence
                       from the given array.
 '''
 # Assigning max value a variable can take
 INT_MAX = sys.maxsize - 1
 # Taking input of first string
 print(""Enter the list of integers:"")
 int_list = list(map(int, input().rstrip().rsplit()))
 # Calculate the sizes of the list
 n = len(int_list)
 # Constructing a table of size (x+1)*(y+1). Initialize all the
 # value with 1 since the min length has to be 1.
 table = [1]*n
 # Memorization Apporach
 # Longest Increasing Subsequence function
 
 
 def longestincreasingsubsequence(int_list, n, table):
     for i in range(1, n):
         for j in range(0, i):
             # Check if the element in the give position
             # is larger then the one in the previous position or not
             if int_list[i] > int_list[j] and table[i] < table[j] + 1:
                 table[i] = table[j] + 1
     return(max(table))
 max_len = longestincreasingsubsequence(int_list, n, table)
 print(""The longest increasing subsequence is {}"".format(max_len))
 ''' 
 Sample input:
     Int List = 10, 22, 9, 33, 21, 50, 41, 60
 Sample Output:
     The longest increasing subsequence is 5
 '''
 
",Python
"import java.util.*;
 class Sort_2D_Array {
     public static void main(String args[]) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter number of rows and columns"");
         int m = sc.nextInt();
         int n = sc.nextInt();
         int arr[][] = new int[m][n];
         System.out.println(""Enter the elements of the array"");
         for (int i = 0; i < m; i++)
             for (int j = 0; j < n; j++)
                 arr[i][j] = sc.nextInt();
 
         System.out.println(""Enter the column to be sorted"");
         int k = sc.nextInt();
         sort(arr, k, m);
 
     }
 
     public static void sort(int[][] arr, int col, int row) {
         int max = 0, ind = -1;
         for (int j = 0; j < row - 1; j++) {
             max = arr[j][col];
             ind = -1;
             for (int i = (j + 1); i < row; i++) {
                 if (arr[i][col] > max) {
                     max = arr[i][col];
                     ind = i;
                 }
             }
 
             if (ind != -1) {
                 for (int k = 0; k <= col; k++) {
                     int temp = arr[j][k];
                     arr[j][k] = arr[ind][k];
                     arr[ind][k] = temp;
                 }
             }
         }
         for (int[] x : arr) {
             for (int y : x) {
                 System.out.print(y + ""        "");
             }
             System.out.println();
         }
 
     }
 }
 /*
 Enter number of rows and columns
 4
 4
 Enter the elements of the array
 39 27 11 42
 10 93 91 90
 54 78 56 89
 24 64 20 65
 Enter the column to be sorted
 3
 10        93        91        90
 54        78        56        89
 24        64        20        65
 39        27        11        42
 
 Space Complexity : O(1)
 Time Complexity : O(m^2)
  */
",Java
"/*
 Construction of binary tree from inorder and preorder traversal
 binary tree can be uniquely constructed if it's preorder and inorder traversals
 are given.
 The following steps need to be followed
 1. From the preorder traversal , it is evident that the first element is the root node
 2. In inorder traversal, all the nodes which are on the left side of root (from preorder)
 belong to the left sub-tree and those which are on right side of the root (from preorder)
 are on right side of root (from preorder) belong to right sub-tree
 3. Now the problem reduces to form sub-trees and the same procedure can be applied
 repeatedly.
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 //struct for binary tree
 typedef struct Tree
 {
     char data;
     struct Tree *left;
     struct Tree *right;
 } TreeNode;
 // search function searches the inorder traversal and returns the index if found
 int search(char in[], int start, int end, char key)
 {
     for (int i = start; i <= end; i++)
     {
         if (in[i] == key)
         {
             return i;
         }
     }
 }
 
 // Build Tree Builds the tree from preorder and inorder traversals
 
 TreeNode *BuildTree(char in[], char pre[], int start, int end)
 {
     //preindex is static as it should get incremented after each recursive calls
     static int preindex = 0;
     if (start > end)
     {
         return NULL;
     }
     //get New node and make left and right as null
     TreeNode *node = (TreeNode *)malloc(sizeof(TreeNode));
     node->data = pre[preindex];
     node->left = NULL;
     node->right = NULL;
     preindex++;
     //if there is only one node return that node
     if (start == end)
     {
         return node;
     }
     // find the location of the root from the preorder traversal in the inorder
     //traversal and store it in loc
     int loc = search(in, start, end, node->data);
     //the elements to the left of the inorder traversal forms the left subtree
     node->left = BuildTree(in, pr",C-Plus-Plus
"/*
 About Play Fair Cipher: In Play fair, The Key Matrix will be always 5x5 dimension. It neither depends on key nor on plain text. 
                         We have to build always a 5x5 matrix. Now, this 5x5 grid of matrix consists of alphabets(a-z) which is used to encrypt/decrypt the text. 
                         Each of the 25 alphabets must be unique and we have to assume I and J as a single char(it's our choice to select I or J). 
                         Because, 5x5 grid contains only 25 slots. If the plaintext contains J/I, then it is replaced by I/J(based on our assumption).
 
 Rules:
     1. Form a rectangle with the two letters and take the letters on the horizontal opposite corner of the rectangle.
     2. If both the letters are in the same row: Take the letter to the right of each one (going back to the leftmost if at the rightmost position).
     3. If both the letters are in the same column: Take the letter below each one (going back to the top if at the bottom).
 */
 
 #include <bits/stdc++.h>
 #define dim 5 //dimension 5x5
 
 std::string resulttext;
 char matrix[dim][dim], choosechar(int a, int b);
 bool chooseindex(char l, int &a, int &b);
 void formmatrix(std::string k, bool ij);
 
 // Argument e_d: Encryption or Decryption(true/false)
 std::string play_fair(std::string key, std::string text, bool ij, int e_d)
 {
     formmatrix(key, ij);
     // Placing I/J in one cell in matrix
     for (std::string::iterator i = text.begin(); i != text.end(); ++i)
     {
         *i = toupper(*i);
         if (*i < 65 || *i > 90)
             continue;
         if (*i == 'J' && ij)
             *i = 'I';
         else if (*i == 'Q' && !ij)
             continue;
         resulttext += *i;
     }
     // For Encryption
     if (e_d)
     {
         std::string temptext = """";
         size_t len = resulttext.length();
         for (size_t x = 0; x < len; x += 2)
         {
             temptext += resulttext[x];
             if (x + 1 < len)
             {
 ",C-Plus-Plus
"/*
 A postfix expression is a collection of operators and operands in which the operator is placed after the operands. 
 To evaluate a postfix expression using Stack data structure we can use the following steps...
 1.Create an empty stack and start scanning the postfix expression from left to right. 
 2.If the element is an operand, push it into the stack.
 3.If the element is an operator O, pop twice and get A and B respectively. Calculate B operator A and push it back to the stack.
 4.When the expression is ended, the value in the stack is the final answer.
 */
 
 #include <stdio.h>
 #include <unistd.h>
 struct stack
 {
     int top;
     float a[50];
 }
 s;
 int EvalPostfix(char postfix[])
 {
     float num1,num2,num3;
     int i;
     s.top = -1;
     printf(""\n\n Enter the postfix expression: "");
     scanf(""%s"", postfix);
     for (i = 0; postfix[i] != '\0'; i++)
     {
         switch (postfix[i])
         {
             case '0':
             case '1':
             case '2':
             case '3':
             case '4':
             case '5':
             case '6':
             case '7':
             case '8':
             case '9':
                 s.a[++s.top] = postfix[i] - '0';
                 break;
             case '+':
                 num1 = s.a[s.top--];
                 num2 = s.a[s.top--];
                 s.a[++s.top] = num1 + num2;
                 break;
             case '-':
                 num2 = s.a[s.top--];
                 num1 = s.a[s.top--];
                 s.a[++s.top] = num1 - num2;
                 break;
             case '*':
                 num2 = s.a[s.top--];
                 num1 = s.a[s.top--];
                 s.a[++s.top] = num1 * num2;
                 break;
             case '/':
                 num2 = s.a[s.top--];
                 num1 = s.a[s.top--];
                 s.a[++s.top] = num1 / num2;
                 break;
         }
     }
 }
 int main()
 {
     char postfix[50];
     EvalPostfix(postfix);
     pri",C
"/*
 ___Paint Fence Algorithm___
 Problem:
 Given a fence with n posts and k colors
 Find out the number of ways of painting the fence
 such that at most 2 adjacent posts have the same color.
 Input:
 n : number of posts
 k : number of colors
 Output:
 result: number of ways of painting
         considering the condition above
 */
 
 import java.util.*;
 
 public class Paint_Fence{
 
     //function uses permutation logic to output number of possible ways of painting
 
     public int paint_fence(int n,int k){
         if(n<2 | k<(n/2)){
             return -1;
         }
         int[] same = new int[n-1];
         int[] diff = new int[n-1];
         int[] total = new int[n-1];
         same[0]=k;
         diff[0]=k*(k-1);
         total[0]=k*k;
         for(int i=1;i<(n-1);++i){
             same[i]=diff[i-1];
             diff[i]=total[i-1]*(k-1);
             total[i]=diff[i]+same[i];
         }
         return total[n-2];
     }
     public static void main(String[] args){
         int n,k;
         Scanner input = new Scanner(System.in);
         System.out.println(""Enter n,Number of Posts"");
         n=input.nextInt();
         System.out.println(""Enter k,Number of Colors"");
         k=input.nextInt();
         Paint_Fence obj = new Paint_Fence();
         int result = obj.paint_fence(n,k);
         if(result==-1){
             System.out.println(""Painting is not possible following the condition"");
         }
         else{
             System.out.println(""Number of Possiblities: ""+result);
         }
         input.close();
     }
 }
 
 /*Sample Input/Output
 Enter n,Number of Posts
 3
 Enter k,Number of Colors
 5
 Number of Possiblities: 120
 
 Enter n,Number of Posts
 10
 Enter k,Number of Colors
 4
 Painting is not possible following the condition
 
 Enter n,Number of Posts
 5
 Enter k,Number of Colors
 3
 Number of Possiblities: 180
 
 Time Complexity  O(n)
 Space Complexity O(n) 
 */
",Java
"#!/usr/bin/python
 # -*- coding: utf-8 -*-
 
 '''
 PROBLEM STATEMENT
 
 Given a string of '(' , ')' and lowercase english characters.
 
 The task is to remove the minimum number of parentheses so
 that the resulting parentheses string is valid.
 A parentheses string is valid if and only if:
 1.It is the empty string, contains only lowercase characters, or
 2.It can be written as AB (A concatenated with B), where A and B are valid strings, or
 3.It can be written as (A), where A is a valid string.
 
 Implementation By: Nandini Bansal (GitHub: nandinib1999)
 
 Method:
 We can process a string which may possbily have unbalanced parentheses.
 It makes use of a stack to store in the indices of the opening parenthesis
 when encountered one and pops the index from the top of the stack when a
 closing parenthesis is encountered. If a closing parentheses is encountered
 while the stack is empty, its index is saved in an array ""indx"".
 At the end of string traversal, we combine the ""stack"" and ""indx"" as
 they contain the indices of unpaired opening and closing brackets.
 An output string is generated after skipping the characters at indices
 left in ""stack"" and ""indx"".
 
 Argument: string (Input string with parenthesis)
 Return: string (Output string with balanced parenthesis)
 '''
 
 
 def remove_parenthesis(string):
     '''
     Returns a string after removing minimum number of parentheses to make it balanced.
 
     Parameters:
             string (str): A string input
 
     Returns:
             op_str (str): A valid parentheses string
     '''
     stack = []
     indx = []
     for (i, s) in enumerate(string):
         if s == '(':
             # save the index of ( in stack
             stack.append(i)
         elif s == ')':
             if len(stack) > 0:
                 # pop the index of ( on the top of stack if stack is not empty
                 _ = stack.pop()
             else:
                 # if stack is empty, save the index of ) in indx array
         ",Python
"""""""Julia program to check if a number is automorphic or not.
 An Automorphic Number is such a number whose square ends in the same digits as  the number itself.""""""
 
 
 function check_automophic(num)
     temp = num * num
 
     while(num > 0)
         # Extract the last digits of the given number and its square.
         lastNum = num % 10
         lastSquare = temp % 10
 
         # Check if they are equal
         if(lastNum != lastSquare)
             return ""The given number $n is not an Automorphic Number.""
         end
 
         num = num  10
         temp = temp  10
     end
 
     return ""The given number $n is an Automorphic Number.""
 end
 
 print(""Enter the number: "")
 n = readline()
 n = parse(Int, n)
 res = check_automophic(abs(n))
 print(res)
 
 
 """"""
 Time Complexity: O(log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number: 24
 The given number 24 is not an Automorphic Number.
 
 SAMPLE 2
 
 Enter the number: 25
 The given number 25 is an Automorphic Number.
 """"""
 
",Julia
"/*
 Construction of binary tree from inorder and preorder traversal
 
 binary tree can be uniquely constructed if it's preorder and inorder traversals
 are given.
 The following steps need to be followed
 1. From the preorder traversal , it is evident that the first element is the root node
 2. In inorder traversal, all the nodes which are on the left side of root (from preorder)
 belong to the left sub-tree and those which are on right side of the root (from preorder)
 are on right side of root (from preorder) belong to right sub-tree
 3. Now the problem reduces to form sub-trees and the same procedure can be applied
 repeatedly.
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 //struct for binary tree
 typedef struct Tree
 {
     char data;
     struct Tree *left;
     struct Tree *right;
 } TreeNode;
 // search function searches the inorder traversal and returns the index if found
 int search(char in[], int start, int end, char key)
 {
     for (int i = start; i <= end; i++)
     {
         if (in[i] == key)
         {
             return i;
         }
     }
 }
 
 // Build Tree Builds the tree from preorder and inorder traversals
 
 TreeNode *BuildTree(char in[], char pre[], int start, int end)
 {
     //preindex is static as it should get incremented after each recursive calls
     static int preindex = 0;
     if (start > end)
     {
         return NULL;
     }
     //get New node and make left and right as null
     TreeNode *node = (TreeNode *)malloc(sizeof(TreeNode));
     node->data = pre[preindex];
     node->left = NULL;
     node->right = NULL;
     preindex++;
     //if there is only one node return that node
     if (start == end)
     {
         return node;
     }
     // find the location of the root from the preorder traversal in the inorder
     //traversal and store it in loc
     int loc = search(in, start, end, node->data);
     //the elements to the left of the inorder traversal forms the left subtree
     node->left = BuildTree(in, pre, star",C
"#include<iostream>
 #include<thread>
 #include<chrono>
 #include<vector>
 
 std::vector <int> Sorted;
 
 void CountDown(int Sec)
 {
 	std::this_thread::sleep_for(std::chrono::seconds(Sec));
 	Sorted.push_back(Sec);
 }
 
 void Multithread(int NumList[], int n){
     std::vector <std::thread> Threads;
     for (int i = 0; i <= n; i++)
 	{
 		Threads.push_back(std::thread(CountDown, NumList[i]));
 	}
 	for (auto& thread : Threads)
 	{
 		thread.join();
 	}
 }
 
 int main()
  {
     	int n,i;
 	std::cin >> n;
 	int NumList[n];
 	for(i = 0; i < n; i++)
 	{
            std::cin >> NumList[i];
 	}
 	Multithread(NumList, n);
 	for (auto& Num : Sorted)
 	{
 		std::cout << Num<<std::endl;
 	}
     return 0;
 }
 
 /*
 Sample Input : n = 3
 	       89
 	       12
                26
 Sample Output: 12
 	       26
                89
 Time Complexity : O(NlogN + max(input)) where input is maximum of input array elements.
 Space Complexity : All the things are done by the internal priority queue of the OS. Hence auxiliary space is ignored
 */
",C-Plus-Plus
"/**
 Josephus problem is a famous problem.
 In each iteration we kill the every kth
 person in a circular arrangement of n persons.
 Find the person who is alive at the end.
 0-based indexing
 link to the problem : https://en.wikipedia.org/wiki/Josephus_problem
 **/
 
 #include <iostream>
 using namespace std;
 
 int solution(int n, int k) {
 	if (n == 1)
 		return 0;
 	return (k + solution(n - 1, k)) % n;
 }
 
 int main() {
 	int people, gap;
 	cin >> people >> gap;
 	cout << solution(people, gap) << '\n';
 	return 0;
 }
 
 /**
 Input :
 4 2
 Output :
 0
 
 Time Complexity : O(n)
 Space Complexity : O(1)
 **/
",C-Plus-Plus
"/*
 Given a sorted and rotated array.
 The array is rotated between 1 and n times[ n = array size]
 find the minimum element of the input array.
 array may contain duplicate elements.
 */
 
 #include <stdio.h>
 
 // this function  will give us the minimum element
 int get_minimum_element(int ar[], int N)
 {
     int first = 0, last = N - 1;
     int minelement = -1;
     while(first < last)
     {
         //if ar[first] > ar[last] then we will increment first and last remains same
         if(ar[first] > ar[last])
         {
             first++;
             minelement = ar[last];
 
         }
         //if ar[first] <=  ar[last] then we will decrement last and first remains same
         if(ar[first] <= ar[last])
         {
             last--;
             minelement = ar[first];
 
         }
     }
     return minelement;
 }
 int main()
 {
     printf(""Enter the size of the array : \n"");
     int N;
     scanf(""%d"", &N);
     int ar[N + 1];
     printf(""Enter array elements :\n"");
     for (int i = 0; i < N; i++)
     {
 	    scanf(""%d"", &ar[i]);
     }
     int minimum_element = get_minimum_element(ar, N);
     printf(""Minimum Element of the array is: \n"");
     printf(""%d \n"", minimum_element);
 
 }
 
 /*
 
 Standard Input and Output
 
 Enter the size of the array :
 12
 Enter array elements :
 465 7878 3535 68 3435 89897 466 878 44 7879 3 67868
 
 Minimum Element of the array is:
 3
 
 Time Complexity : O( N )
 Space Complexity : O(1)
 
 */
",C
"/******************************************************************************
 Author: @Suvraneel Bhuin
 
 * Lee's Algorithm *
 The objective is to find the length of the shortest path in a maze from a given source to a given destination,
 Given the maze in form of a binary rectangular matrix.
 
 -> Modify as required: 
     Definitions of ROW, COL
     Input `maze`, `src`, `dest` in main function
 *******************************************************************************/
 #include <bits/stdc++.h>
 using namespace std;
 // define no. of rows & columns
 #define ROW 10
 #define COL 10
 
 // Node Structure
 // consists of x, y coordinates and the distance 
 struct Node{
     int x, y, distance;
 };
  
 // movement in 4 directions
 int direction[4][2] = {{1, 0}, {0, 1}, { -1, 0}, {0, -1}};
  
 // check whether a valid position (i.e, within grid & is unvisited).
 bool check(int mat[][COL], bool visited[][COL], int row, int col){
     return mat[row][col] && (row > -1) && (row <= ROW-1) && (col > -1) && (col <= COL-1) && !visited[row][col];
 }
 
 // shortest possible route
 int bfs(int mat[][COL], int startX, int startY, int endX, int endY){
     // Queue to keep track of all the cells accounted for in the path so far
     queue<Node> Q;
     bool visited[ROW][COL];
     // mark all boxes unvisited initially
     // memset: sets memory pointed to by first `sizeof(visited)` characters of array `visited` to 0
     memset(visited, 0, sizeof(visited));
     // set the starting cell as visited and enqueue cell
     visited[startX][startY] = 1;
     Q.push({startX, startY, 0});
     // stores shortest path as of yet
     // initialised to INT_MAX so that any value can replace it
     int ans = INT_MAX;
 
     while (!Q.empty()){
         Node cell = Q.front();
         Q.pop();
         int i = cell.x, j = cell.y, distance = cell.distance;
  
         // if the destination is found, update minimum distance & break while loop
         if (i == endX && j == endY){
       ",C-Plus-Plus
"//Queue implemetation Its readme file in wiki
 import java.util.*;
 import java.lang.*;
 class myq<E> {
     static class Node<E>{
         E data;
         Node<E> next;
         Node(E a){
             this.data=a;
             next=null;
         }
     }
     Node<E> front;
     Node<E> rear;
     int c=0;
     boolean isempty(){
         return front==null;
     }
     void Enqueue(E a){
         Node<E> temp=new Node<E>(a);
         if(isempty()){
             front=temp;
             rear=temp;
             c++;
             return;
         }
         else{
             rear.next=temp;
             rear=temp;
             c++;
             return;
         }
     }
     E Dequeue() throws Exception{
         Node<E> t;
         if (isempty()){
             throw new Exception(""EEEEEmpty"");
         }
         else if(c==1){
             t=front;
             front=null;
             rear=null;
             c--;
         }
         else{
             t=front;
             front=front.next;
             c--;
         }
         return t.data;
     }
     E Front(){
         if (isempty()){
             return null;
         }
         else{
             return front.data;
         }
     }
     E Rear(){
         if (isempty()){
             return null;
         }
         else{
             return rear.data;
         }
     }
 }
 public class Queuell {
     public static void main(String[] args) throws  Exception{
         myq<Integer> qe = new myq<Integer>();
         qe.Enqueue(10);
         qe.Enqueue(20);
         qe.Enqueue(30);
         qe.Enqueue(40);
         System.out.println(qe.Front());
         System.out.println(qe.Rear());
         System.out.println(qe.Dequeue());
         System.out.println(qe.Dequeue());
         System.out.println(qe.Front());
         System.out.println(qe.Dequeue());
         System.out.println(qe.Dequeue());
         System.out.println(qe.Dequeue());
 
     }
 }
 /*
 output:
 10
 40
 10
 20
 30
 30
 40
 Exception in thr",Java
"// Author : @belikesayantan
 
 package main
 
 import (
 	""bufio""
 	""errors""
 	""fmt""
 	""log""
 	""os""
 	""strconv""
 	""strings""
 	""time""
 )
 
 func main() {
 	var strArray []string
 	var intArray []int
 
 	fmt.Println(""Enter an array with spaces"")
 	reader := bufio.NewReader(os.Stdin)
 	arr, err := reader.ReadString('\n')
 	if err != nil {
 		inputErr := errors.New(""something is wrong with your array input"")
 		log.Fatal(inputErr)
 	}
 	arr = strings.TrimSpace(arr)
 	strArray = strings.Split(arr, "" "")
 
 	for _, val := range strArray {
 		ele, err := strconv.Atoi(val)
 		if err != nil {
 			panic(err)
 		}
 		intArray = append(intArray, ele)
 	}
 
 	start := time.Now() // timer starts and records running time of BubbleSort Algorithm
 	fmt.Println(""Sorted Array is: "", BubbleSort(intArray))
 	end := time.Now() // timer stops and recording running time of BubbleSort Algorithm is completed
 
 	fmt.Println(""\nRunning Time of BubbleSort Algorithm is: "", end.Sub(start))
 }
 
 // BubbleSort Algorithm Time Complexity : O(n^2)
 func BubbleSort(arr []int) []int {
 	if len(arr) == 0 {
 		return nil
 	}
 
 	if len(arr) == 1 {
 		return arr
 	}
 
 	for i := 0; i < len(arr); i++ {
 		for j := 0; j < len(arr)-i-1; j++ {
 			if arr[j] > arr[j+1] {
 				arr[j], arr[j+1] = swap(arr[j], arr[j+1])
 			}
 		}
 	}
 
 	return arr
 }
 
 func swap(i, j int) (a, b int) {
 	i = i + j
 	j = i - j
 	i = i - j
 	return i, j
 }
 
 /*
 	I/O Sample:
 
 	Sample 1:
 	 go run bubbleSort.go
 	Enter an array with spaces
 	5 3 2 4 5 84 6 1 54
 	Sorted Array is:  [1 2 3 4 5 5 6 54 84]
 
 	Running Time of BubbleSort Algorithm is: 90.154s
 
 
 	Sample 2:
 	 go run bubbleSort.go
 	Enter an array with spaces
 	5 8 6 9 1 3 2 7 4
 	Sorted Array is:  [1 2 3 4 5 6 7 8 9]
 
 	Running Time of BubbleSort Algorithm is:  116.805s
 
 
 
 	Time Complexity:
 		1. (n) in best case
 		2. O(n^2) in average case
 		3. O(n^2) in worst case
 
 	Space Complexity: O(1) in worst case
 
 */
",Go
"# Python program to Find the Sum of Digits of a Number
 
 
 def sum_of_digits(num):
     # Extracting Each digits
     # and compute thier sum in 's'
     s = 0
     while num != 0:
         s = s + (num % 10)
         num = num // 10
     return s
 
 
 if __name__ == '__main__':
     # Input the number And
     # Call the function
     print(""Enter the number: "", end="""")
     n = int(input())
     S = sum_of_digits(abs(n))
     print(""The sum of digits of the given number is {}."".format(S))
     
 '''    
 Time Complexity: O(log(num)), where ""num"" is the length of the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number: -12
 The sum of digits of the given number is 3.
 
 SAMPLE 2
 
 Enter the number: 43258
 The sum of digits of the given number is 22.
 '''
",Python
"#include <stdio.h>
 #include <string.h>
 #define MAX 10
 
 void decode(char *code, char *ans, int i, int j) {
 	// i is index of code array
 	// j is index of ans array
 	if (i >= strlen(code)) {
 		printf(""%s "", ans);
 		return;
 	}
 	// getting all possible sequences recursives
 	if (code[i + 1] != '0') {
 		ans[j] = (code[i] - '0' + 96);
 		decode(code, ans, i + 1, j + 1);
 	}
 	// converting a num to char
 	if (code[i + 1]) {
 		int result = (code[i] - '0') * 10 + (code[i + 1] - '0') - 1;
 		if (result <= 25) {
 			ans[j] = result + 97;
 			ans[j + 1] = '\0';
 			decode(code, ans, i + 2, j + 1);
 		}
 	}
 }
 int main() {
 	// creating a null string
 	char ans[50] = { '\0' };
 	// input string
 	char code[MAX];
 	printf(""Enter the code: "");
 	scanf(""%s"", code);
 	decode(code, ans, 0, 0);
 }
 
 /*
 OUTPUT:
 Enter the code: 1123
 aabc aaw alc kbc kw
 Time Complexity : O(n)
 Space complexity : O(n)
 */
",C
"/* Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, 
 return the volume of water it can trap after raining. */
 
 import java.util.*;
 
 class Trapping_rain_water_2D {
 
     public static void main(String[] args) {
         Scanner scn = new Scanner(System.in);
         
         // Taking user input
         System.out.println(""Enter the number of rows: "");
         int rows = scn.nextInt();
         System.out.println(""Enter the number of columns: "");
         int columns = scn.nextInt();
         
         // creating 2D Matrix
         int[][] arr = new int[rows][columns];
 
         // Filling the array
         System.out.println(""Enter the Elements: "");
         for (int i = 0; i < rows; i++) {
             for (int j = 0; j < columns; j++) {
                 arr[i][j] = scn.nextInt();
             }
         }
 
         int water = trapRainWater(arr);
         System.out.println(""Water it can trap is: "" + water +"" units"");
 
         scn.close();
     }
 
     // Creating helper class to store value and row, column numbers
     public static class Pair implements Comparable<Pair> {
         // declaring instance variables
         int i;
         int j;
         int val;
 
         // constructor
         public Pair(int i, int j, int val) {
             this.i = i;
             this.j = j;
             this.val = val;
         }
 
         // Overriding method of Comparable interface to compare objects on basis of val
         @Override
         public int compareTo(Pair object) {
             return this.val - object.val;
         }
         // if +ve value returned -- object.val is selected
         // if -ve value returned -- this.val is selected
         // if 0 is returned -- any value between the two can be selected
     }
 
     public static int trapRainWater(int[][] heightMap) {
         // storing the lengths of row and column in m and n respectively
         int m = heightMap.length, n = h",Java
"/*Bubble Sort Algorithm is the simplest sorting algorithm in which each element is compared to its adjacent element 
 and if first elememt is greater than second element ,then the swapping occurs.
 The swapping occurs till the array is sorted.
 */
 #include <bits/stdc++.h>			//Header file
 using namespace std;	//For cin and cout
 void bubblesort(int[], int);
 int main()
 {
 	int n, arr[100], num;	//Declarartion of required variables
 	cout << ""Enter the number of elements of the array: "";
 	cin >> n;	//Getting the number of elements of the array from the user
 	cout << endl << ""Enter the elements of the array to be sorted: "" << ""\n"";
 	for (int i = 0; i < n; i++)
 	{
 		//For loop for taking elements of the array from the user, can be space-seperated as well
 		cin >> num;
 		arr[i] = num;
 	}
 	bubblesort(arr, n);
 	cout << ""Array after sorting is:"" << endl;
 	for (int i = 0; i < n; i++)
 	{
 		//For loop for printing out the array after sorting
 		cout << arr[i] << "" "";
 	}
 }
 void bubblesort(int arr[], int n)
 {
 	int temp;
 	for (int i = 0; i < n - 1; i++)
 	{
 		bool sorted = true;	// declaring a sorted variable which will check if array is already sorted or not
 		for (int j = 0; j < n - 1 - i; j++)
 		{
 			//Inner for loop
 			if (arr[j] > arr[j + 1])
 			{
 				temp = arr[j + 1];	//Swapping the elements, temp is used to store the temporary variable
 				arr[j + 1] = arr[j];
 				arr[j] = temp;
 				sorted = false;	// sorted value will be updated to false if there is swapping of elements occured 
 			}
 		}
 		if (sorted)
 		{
 			break;
 		}
 	}
 }
 /*
 Sample Output
 Enter the number of elements of the array: 5
 Enter the elements of the array to be sorted:6 5 2 3 1
 Array after sorting is:
 1 2 3 5 6
 
 Time complexities:
 Worst Case:O(n2)
 Best Case:O(n)    
 Average Case:O(n2)  
 
 Space Complexity: Auxilary Space:O(2) because of variable temp and sorted.  
 */
 
",C-Plus-Plus
"""""""
 The basic idea is to check fewer elements,
 by jumping ahead by fixed steps.
 NOTE:-Works only sorted arrays.
 Time Complexity : O(n)
 Auxiliary Space : O(1)
 SAMPLE INPUT line 1   1 2 3 4 5 6 7 8 9 10
 SAMPLE INPUT line 2   5
 SAMPLE OUTPUT     4
 """"""
 import math
 
 
 # main function
 def jump_search(arr, search):
     """"""Takes in a sorted array arr and a value to search for""""""
     interval = int(math.sqrt(len(arr)))
     for i in range(0, len(arr), interval):
         if arr[i] < search:
             low = i
         elif arr[i] == search:
             return i
         else:
             break
     l_index = [e for e, i in enumerate(arr[low:low+interval]) if i == search]
     if l_index[0]:
         return low + l_index[0]
     return ""Not Found""
 
 
 # driver code
 if __name__ == ""__main__"":
     ary = list(map(int, input(""ENTER A SORTED ARRAY"").split()))
     val = int(input(""ENETER THE VALUE TO SEARCH""))
     ans = jump_search(ary, val)
     print(ans)
",Python
"/* 
 Jay's neighbour has a garden in which there are N flowers and each flower has a beauty associated with it i.e. ith flower
  has B[i] beauty. Jay wants to pluck exactly K flowers from his neighbour's garden such that the sum of beauties of all flowers
  he plucked is maximum but to not get caught he can't pluck more than one flower in a row, more formally he can't pluck two 
 flowers if they are adjacent. Your task is to find maximum sum of beauty of all flowers Jay can get.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 #define ll long long int
 
 long long maxBeauty(int n, int k, vector<int> &B){
         ll i,j,dp[k+1][n+1];
         memset(dp,0,sizeof(dp));
         for(i=1;i<=k;i++)
         {
             for(j=2*i-1;j<=n;j++)
             {
                 dp[i][j]=B[j-1];
                 if(j-2>=0)
                 {
                     dp[i][j]+=dp[i-1][j-2];
                 }
                 dp[i][j]=max(dp[i][j],dp[i][j-1]);
             }
         }
         return dp[k][n];
     }
 
 
 int main(){
     
         int totalFlowers, k;
         cout << ""Enter total number of flowers and maximum flowers to be plucked "";
         cin >> totalFlowers >> k;                          // size of array and max flowers required
         vector<int> Beauty(totalFlowers);
         cout<< "" Enter beauty of each flower : "" ;
         for(int i = 0; i < totalFlowers; i++){
             cin >> Beauty[i];                                    // input array
         }
         long long answer =maxBeauty(totalFlowers , k , Beauty);
         cout << "" maximum sum of beauty by k flowers : "" << answer << endl;
     
 }    
     
 /*
 
 Input:
 Enter total number of flowers and maximum flowers to be plucked : 3  2
 Enter beauty of each flower : 1  1000000  1
 
 Output: 
 maximum sum of beauty by k flowers : 2
 
 Time Complexity: O(totalFlowers*K)
 Auxiliary Space: O(totalFlowers*K)
 
 */
",C-Plus-Plus
"#Bead sort (a.k.a Abacus sort, or Gravity sort) is a sorting algorithm 
 # that can sort a list of positive integers .
 # We can sort negative numbers too by adding a constant to all the integers and subracting it later 
 #Bead sort is a natural algorithm 
 #It uses (imitates) gravity to sort an input list
 
 def bead_sort(a):
     minimum, maximum = min(a), max(a)
     n = len(a)
 
     # Initialize a temporary array filled with minimum
     temp = [minimum] * n
     for i in range(maximum-1, minimum-1, -1):
         k = 0
         for j in range(n):
             if a[j] > i:
                 temp[k] += 1
                 k += 1
 
     # Copy temp array back into original array
     # replacing the array into sorted order
     # temp array is reverse sorted, so copy backwards for ascending order
     for i in range(n):
         a[i] = temp[n-i-1]
 
     return a
 
 if __name__ == ""__main__"":
     a=[]
     print(bead_sort(a))",Python
"import java.util.*;
 public class Main
 {  
    // Recursive Approach
   static int ternarySearchRecursive (int arr[], int f, int left, int right)
   {
     if (left <= right)
       {
 	int mid1 = left + (right - left) / 3;
 	int mid2 = right - (right - left) / 3;
 	if (arr[mid1] == f)
 	  return mid1 + 1;
 	else if (arr[mid2] == f)
 	  return mid2 + 1;
 	else if (f < arr[mid1])
 	    return ternarySearchRecursive (arr, f, left, mid1 - 1);
 	else if (f > arr[mid2])
 	    return ternarySearchRecursive (arr, f, mid2 + 1, right);
 	else
 
 	    return ternarySearchRecursive (arr, f, mid1 + 1, mid2 - 1);
       }
     return -1;
   }
     // Iterative Approach
  static int ternarySearch(int arr[], int f, int left, int right)
     {  int found = -1;
         while(left <= right)
         {
           int mid1 = left + (right - left) / 3;
 	int mid2 = right - (right - left) / 3;
             if(arr[mid1] == f)
                 return mid1 + 1;
             else if(arr[mid2] == f)
                 return mid2 + 1;
             else if(f < arr[mid1])
              right = mid1 - 1;
             else if(f > arr[mid2])
                left = mid2 + 1;
             else 
               {
                   left = mid2 + 1;
                   right = mid2 - 1;
               }
             
         } 
         return found;
        
     }
     
 
   public static void main (String[]args)
   {
     Scanner sc = new Scanner (System.in);
     int i, n, left, right, f = -1, element;
     System.out.println (""Enter length of array"");
     n = sc.nextInt ();
     System.out.println (""Enter  array elements"");
     int arr[] = new int[n];
     for (i = 0; i < n; i++)
       arr[i] = sc.nextInt ();
     System.out.println (""Enter element to be searched"");
     element = sc.nextInt ();
 
     Arrays.sort (arr);
     left = 0;
     right = n - 1;
 
     f = ternarySearch(arr, element, left, right);
     if (f != -1)
       System.out.println (""Element found at "" + (f));
     else
     ",Java
"//                      SPARSE MATRIX
 
 //          Java program for Sparse Matrix Representation using Array
 
 /*
     *A matrix can be defined with a 2-dimensional array.
     *Any array with 'm' columns and 'n' rows represent a m X n matrix. 
     *There may be a situation in which a matrix contains more number of ZERO values
     than NON-ZERO values. 
     *Such matrix is known as sparse matrix.
 
     *Triplet Representation (Array Representation)
     *Only non-zero values along with their row and column index values are considered
     *The 0th row stores the total number of rows, total number of columns 
     and the total number of non-zero values in the sparse matrix.
     *The subsequent rows are used for storing non zero values and indices of row and column
     of that non zero element
 */
 
 import java.util.*;
 
 public class SparseMatrices {
     // Varibale Declaration
     static int rows;
     static int columns;
     // Matrix Variable to store the input from the user
     static int inputMatrix[][] = new int[20][20];
     static int sparseMatrix[][] = new int[20][3];
     static int i;
     static int j;
     static int k;
     static int count = 0;
 
     // Function to read the input matrix from the user
     public static void initializeMatrix() {
         // Creating Scanner Object to read input from user
         Scanner s = new Scanner(System.in);
 
         System.out.println(""Enter the number of rows of the matrix"");
         // Reading the number of rows of the matrix from the user
         rows = s.nextInt();
 
         System.out.println(""Enter the number of columns of the matrix"");
         // Reading the number of columns of the matrix from the user
         columns = s.nextInt();
 
         System.out.println(""Enter the elements of the matrix"");
         for (i = 0; i < rows; i++) {
             for (j = 0; j < columns; j++) { // Reading the elements of the matrix from the user
                 inputMatrix[i][j] = s.nextInt();
 ",Java
"/* This program prints first n terms of the golomb sequence. n is the
 number taken as input from the user. Golomb sequence is a non-decreasing
 sequence of integers where the nth term of the sequence is equal to the
 number of times n appears in the sequence. We use dynamic programming
 approach to form the sequence.
 
 The nth term of the golomb sequence is given by the formula:
 
 Golomb(1) = 1 (Base case)
 Golomb(n + 1) = 1 + Golomb(n + 1 - Golomb(Golomb(n))), for n > 1
 */
 
 package main
 
 import (
 	""fmt""
 	""os""
 )
 
 // This function prints the golomb sequence
 func Print(array []int, number int) {
 
 	// If the number given as input is 1
 	if(number == 1) {
 		fmt.Print(""\nFirst term of the Golomb sequence is: "")
 	} else {
 		// Number given as input is greater than 1
 		fmt.Print(""\nFirst "", number, "" terms of the Golomb sequence are: "")
 	}
 
 	// Iterate till the length of the array
 	for i := 1; i < len(array); i++ {
 		// And print the numbers
 		fmt.Print(array[i], "" "")
 	}
 	fmt.Print(""\n"")
 }
 
 // This function forms the golomb sequence
 func golomb_seq(number int) {
 
 	/* Initialize an array to store the number
 	in a bottom-up manner.*/
 	array := make([]int, number + 1)
 
 	// Base cases/seeds
 	array[0] = 0
 	array[1] = 1
 
 	// Iterate from 2 to the number
 	for i := 1; i < number; i++ {
 		/* Get the number at that position using the formula
 		and add it to the array.*/
 		array[i + 1] = 1 + array[i + 1 - array[array[i]]]
 	}
 	// Call the print function to print the golomb sequence
 	Print(array, number)
 }
 
 func main() {
 
 	// Take number as input from the user
 	fmt.Print(""Enter a number: "")
 	var number int
 	fmt.Scan(&number)
 
 	// If the number is not positive, exit
 	if(number <= 0) {
 		fmt.Print(""\nPlease enter a positive number.\n"")
 		os.Exit(0)
 	}
 
 	// Call the function to print the sequence
 	golomb_seq(number)
 }
 
 /*
 
 Sample I/O:
 
 1)
 Enter a number: 16
 
 First 16 terms of the Golomb sequence are: 1 2 2 3 3 4 4",Go
"/*
 Given a set of n integers, divide the set in two subsets of n/2 sizes each such that the difference of the sum of two subsets is as minimum as possible. 
 If n is even, then sizes of two subsets must be strictly n/2 and 
 if n is odd, then size of one subset must be (n-1)/2 and size of other subset must be (n+1)/2.
 
  A C++ PROGRAM TO FIND TUG OF WATER USING BACKTRACKING
 */
 
 #include<iostream>
 #include <bits/stdc++.h>
 using namespace std;
 
 void traverse(int* arr, int i, int n, int no_of_selected, int sum, int& diff, bool* take, vector<int>& result, vector<int> current, int current_sum)
 {
     //if the current position is greater than or equals to n
     if (i >= n)
         return;
     /* if the value of difference is greater than
        Sum/2-current sum of the elements of Subset no.1 */
     
 	if ((diff > abs(sum / 2 - current_sum)) && (no_of_selected == (n + 1) / 2 || no_of_selected == (n - 1) / 2)) 
 	{
         diff = abs(sum / 2 - current_sum);
         //store the subset no. 1
         result = current;
     }
     //taking the elemets after the current element one by one
     for (int j = i; j < n; j++) 
 	{
         take[j] = true;
         current.push_back(arr[j]);
         traverse(arr, j + 1, n, no_of_selected + 1, sum, diff, take, result, current, current_sum + arr[j]);
         current.pop_back();
         take[j] = false;
     }
 }
 void find(int* arr, int n)
 {
     //array to distinguished the elements those are in subset no. 1
     bool take[n];
     int sum = 0;
     for (int i = 0; i < n; i++) 
 	{
         sum += arr[i];
         take[i] = false;
     }
     int diff = INT_MAX;
     int no_of_selected = 0;
     vector<int> result;
     vector<int> current;
     int current_sum = 0;
     int i = 0;
     traverse(arr, i, n, no_of_selected, sum, diff, take, result, current, current_sum);
     set<int> s;
     //elements those are in subset no.1
     cout << ""Set1 : { "";
     for (int j = 0; j < result.size(); j++) 
 	{
         cou",C-Plus-Plus
"/*
 Perfect number is a positive integer which is equal to the sum of its proper positive divisors.
 For example: 6 is the first perfect number
 Proper divisors of 6 are 1, 2, 3
 Sum of its proper divisors = 1 + 2 + 3 = 6.
 Hence 6 is a perfect number.
 */
 
 const prompt = require(""prompt-sync"")({ sigint: true });
 let n = +prompt(""Enter a number to check whether it is a perfect number or not: "");
 let sum = 0;
 
 for (let i = 1; i < n; i++) 
 {
     if (n % i == 0) 
         sum += i;
 }
 
 if (sum == n) 
     console.log(`${n} is a perfect number.`);
 else 
     console.log(`${n} is not a perfect number.`);
 
 /*
 
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 node JavaScript/math/Perfect_Number.js
 
 sample 1: Enter a number to check whether it is a perfect number or not: 6
 Output: 6 is a perfect number.
 
 sample 2: Enter a number to check whether it is a perfect number or not: 7
 output: 7 is not a perfect number.
 
 */
",JavaScript
"
 /* Program to reverse a string */
 
 import java.io.*;
 import java.util.*;
  
 // Main class
 
 class Program {
     public static void main(String[] args)
     {
         Scanner sc = new Scanner(System.in);
 
         // Accepting input from user
 
         System.out.println(""Enter string"");
         String str = sc.nextLine();
 
         // revoking the function reverse
 
         reverse(str);
         
     }
 
     // Method for reversing the string
 
     static void reverse(String s){
 
         // Reversing the string by extracting each element from the end of the string and storing in a variable result
 
         String result = """";
         for (int i = s.length() - 1; i >= 0; i--)
             result += s.charAt(i);
 
         // Printing the reversed string
 
         System.out.println(result);
        
     }
 
 }
 
 /* Time Complexity is O(n)
    Space Complexity is O(n)
    
    Input :
    Hello World
    
    Output :
    dlroW olleH
 */
",Java
"/*Given the head pointer to a linked list of length n and an integer k, we have to reverse every alternate k nodes in the linked list.
 
 Approach:
 1.Reverse the first k nodes
 2.Link the next of head of the modified list to the (k+1)th node 
 3.Traverse the next k nodes to skip their reversal
 4.Since 2k nodes are already processed,recursively call the function for the rest n-2k nodes
 5.Return the new head of the list
 
 */
 
 import java.util.*;
 public class Reverse_alternate_k_Nodes {
 
     //creating the head of the list
     static Node head;
 
     //class which defines the structure of each node in the list
     class Node {
         int data;
         Node next;
 
         // Constructor to initialize the data and next pointer
         Node(int data) {
             this.data = data;
             this.next = null;
         }
     }
 
     //Function to create the linked list with the elements given as input
     public void createList(int newData) {
 
         Node new_Node = new Node(newData);
         Node temp = head;
         if (head == null) {
             head = new_Node;
         } else {
             while (temp.next != null) {
                 temp = temp.next;
             }
             temp.next = new_Node;
         }
     }
 
     //Function to display the linked list
     public void displayList(Node A) {
 
         Node temp = A;
 
         while (temp != null) {
             System.out.print(temp.data + "" "");
             temp = temp.next;
         }
     }
 
     //Function which returns the head node of the result list
     public Node reverseAlternately(Node A, int k) {
         if (A == null || A.next == null)
             return A;
         Node head = null;
         Node current = A;
         Node forward = null;
         Node backward = null;
 
         //Reversing first k nodes of the current list
         for (int i = 0; i < k; i++) {
             forward = current.next;
             current.next = backward;
             backw",Java
"import java.util.ArrayList;
 import java.util.stream.IntStream;
 
 /**
  * The Sieve of Atkin is a modern algorithm for finding all prime
  * numbers up to a specified integer. Compared with the ancient
  * sieve of Eratosthenes, which marks off multiples of primes, the
  * sieve of Atkin does some preliminary work and then marks off
  * multiples of squares of primes, thus achieving a better theoretical
  * asymptotic complexity. It was created in 2003 by A. O. L. Atkin
  * and Daniel J. Bernstein.
  *
  * Google it if you don't know about it.
  *
  * @author Ricardo Prins
  * @since 3-7-2020
  */
 public class sieveOfAtkin {
 
     public static ArrayList<Integer> sieve(int lowerLimit, int upperLimit) {
         ArrayList<Integer> result = new ArrayList<>();
 
         if (upperLimit > 2) {
             result.add(2);
         };
         if (upperLimit > 3) {
             result.add(3);
         };
         boolean[] sieve = new boolean[upperLimit];
 
 
 
         IntStream.range(0, upperLimit)
                 .forEach(i -> sieve[i] = false);
 
         for (int x = 1; x * x < upperLimit; x++) {
             for (int y = 1; y * y < upperLimit; y++) {
                 int n = (4 * x * x) + (y * y);
                 if (n <= upperLimit && (n % 12 == 1 || n % 12 == 5)) sieve[n] ^= true;
                 n = (3 * x * x) + (y * y);
                 if (n <= upperLimit && n % 12 == 7) sieve[n] ^= true;
                 n = (3 * x * x) - (y * y);
                 if (x > y && n <= upperLimit && n % 12 == 11) sieve[n] ^= true;
             }
         }
         IntStream.iterate(5, r -> r * r < upperLimit, r -> r + 1)
                 .filter(r -> sieve[r])
                 .flatMap(r -> IntStream.iterate(r * r, i -> i < upperLimit, i -> i + r * r))
                 .forEach(i -> sieve[i] = false);
 
         for (int a = lowerLimit; a < upperLimit; a++) {
             if (sieve[a]) {
                 result.add(a);
             }
 
         }
        return result;
   ",Java
"'''
 Bulb switcher problem
 
 There are n bulbs that are initially off.
 You first turn on all the bulbs,then you turn off every second bulb.
 On the third round,toggle every third bulb (turn on if it's off or vice-versa)
 For the ith round, you toggle every i bulb.
 For the nth round, you only toggle the last bulb.
 Return the number of bulbs that are on after n rounds.
 
 Approach : By observation, a bulb is ON if it is toggled odd number of times
 only when `i` has perfect square root, its number of divisors is odd.
 
 Problem link: https://leetcode.com/problems/bulb-switcher/
 
 Time Complexity:  O(N)
 Space Complexity: O(1)
 '''
 
 
 def bulbSwitcher(n):
     bulb = 0
     while bulb * bulb <= n:
         bulb += 1
     return bulb - 1
 
 
 N = int(input())
 print(bulbSwitcher(N))
 
 '''
 Input: 5
 output: 2
 '''
",Python
"/*
   The Playfair cipher( Playfair square ) encrypts pairs of letters (digraphs),
   instead of single letters as in the simple substitution cipher. The Playfair
   is thus significantly harder to break since the frequency analysis used for 
   simple substitution ciphers does not work with it.
 */
 
 #include<stdio.h>
 #include<stdlib.h>
 #include<string.h>
 
 //Define size for input and key
 #define SIZE 100
 
 //This function will form the 5x5 key Matrix    
 void keyTable(char key[],int size2,char keyMatrix[5][5]){
       
      int i,j;
      int c = 0;
      char alph[26] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm','n', 'o','p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
      int index[26];
      
      //initializing the array to 0 as it stores garbage values
      for(int z=0;z<26;z++){
          index[z] = 0;
      }
 
      int hash[size2]; 
      //marking the alphabets in key
      for(i=0;i<size2;i++){
          if(key[i] != 'j'){
             for(j=0;j<26;j++){
                 if(key[i] == alph[j]){
                    index[j] = 2;
                    hash[c] = j;
                    c++;
                 }   
             } 
          }   
      } 
      
      //marking alphabetic j
      index[9] = 1;
      i = 0;
      j = 0;
 
      //adding the marked alphabets  
      for(int k=0;k<size2;k++){
          
          if(index[hash[k]] == 2){
             index[hash[k]] -= 1;
             keyMatrix[i][j] = key[k];
             j++;
             if(j==5){
               i++;
               j=0;
             } 
          }         
      }
      
      //adding the remaining alphabets
      for(int k=0;k<26;k++){
          
          if(index[k] == 0){
             keyMatrix[i][j] = alph[k];
             j++;
             if(j==5){
                i++;
                j=0;
             }
          }
      }
 
 }    
 
 /*this function searches for the characters of the digraph in key matrix 
 generated and gives thei",C
"/* This program written in C checks if a number is a perfect
 number. A perfect number is a number which is equal to the sum
 of its divisors (excluding the number itself).*/
 
 #include <stdio.h>
 #include <stdlib.h>
 
 // This function checks if a number is a perfect number
 int is_perfect(int number) {
 
 	// This variable stores the sum of divisors of number
 	int sum_of_div = 0;
 	// Iterate from 1 till the number
 	for(int i = 1; i < number; i++) {
 		if(number % i == 0) {
 			// Add divisors
 			sum_of_div += i;
 		}
 	}
 	// If the sum of divisors is equal to the number
 	if(sum_of_div == number) {
 		// Return 1
 		return 1;
 	}
 	// Else return -1
 	return -1;
 }
 
 int main() {
 
 	// Take number as input from the user
 	int number;
 	printf(""Enter a number: "");
 	scanf(""%d"", &number);
 
 	// If the number is non-positive, exit
 	if(number <= 0) {
 		printf(""\nPlease enter a positive number.\n"");
 		exit(0);
 	}
 
 	// Call the function
 	int result = is_perfect(number);
 
 	// If the result is 1, the number is a perfect number
 	if(result == 1) {
 		printf(""\nThe number %d is a perfect number.\n"", number);
 		exit(0);
 	}
 	// Else it is not
 	else {
 		printf(""\nThe number %d is not a perfect number.\n"", number);
 		exit(0);
 	}
 }
 
 /*
 Sample I/O:
 
 1)
 Enter a number: 28
 
 The number 28 is a perfect number.
 
 2)
 Enter a number: -23
 
 Please enter a positive number.
 
 */
",C
"/*
  * The Problem is deciding whether a given multiset S of positive integers can be partitioned
    into two subsets S1 and S2 such that the sum of the numbers in S1 equals the sum of the numbers in S2.
  * Complexity O(N^2)
  */
 using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
 
 namespace NeoAlgo
 {
     class Program
     {        
         public static bool NumberPartitiong(int[] numbers, int N)
         {       
             int Sum = 0;
             bool flag = false;       
             int[,] numbers2 = new int[N + 1, N + 1];
             /*
             * Calculate the sum of all elements in the array
             * Saving every elemebt in first row and column in the new matrix
             */
             for (int i = 1; i <= N; i++)
             {
                 Sum += numbers[i - 1];              
                 numbers2[i, 0] = numbers[i - 1];
                 numbers2[0, i] = numbers[i - 1];
             }
             int Sum2 = Sum / 2;
             int Subset = 0;
             for (int i = 1; i <= N; i++)
             {
                 for (int j = i + 1; j <= N; j++)
                 {
                     /*
                      * Adding numbers to matrix that equals to sum / 2 or if (sum / 2) + 1 in case sum is odd 
                      */
                     if (Sum % 2 != 0 && (numbers2[i, j - 1] + numbers2[0, j] > Sum2 || numbers2[i, j - 1] + numbers2[0, j] > Sum2 + 1) || j == 1)
                         numbers2[i, j] = numbers2[i, 0] + numbers2[0, j];
                     else if (Sum % 2 == 0 && numbers2[i, j - 1] + numbers2[0, j] > Sum2 || j == 1)
                         numbers2[i, j] = numbers2[i, 0] + numbers2[0, j];
                     else
                         numbers2[i, j] = numbers2[i, j - 1] + numbers2[0, j];
 
                     /*
                      * if Element in matrix = sum / 2 so Add 1 to subset
                      * if subset",C-Sharp
"/*
 Given a sorted and rotated array.
 The array is rotated between 1 and n times[ n = array size]
 find the minimum element of the input array.
 array may contain duplicate elements.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int get_minimum_element(int ar[], int N)
 {
     int first = 0, last = N - 1;
     int minelement = -1;
     while(first < last)
     {
         //if ar[first] > ar[last] then we will increment first and last remains same
         if(ar[first] > ar[last])
         {
             first++;
             minelement = ar[last];
 
         }
         //if ar[first] <=  ar[last] then we will decrement last and first remains same
         if(ar[first] <= ar[last])
         {
             last--;
             minelement = ar[first];
 
         }
     }
     return minelement;
 }
 int main()
 {
     cout << ""Enter the size of the array : \n"";
     int N;
     cin >> N;
     int ar[N + 1];
     cout << ""Enter array elements :\n"";
     for (int i = 0; i < N; i++)
     {
 	    cin >> ar[i];
     }
     int minimum_element = get_minimum_element(ar, N);
     cout << ""Minimum Element of the array is: \n"";
     cout << minimum_element << endl;
 
 }
 
 /*
 Standard Input and Output
 
 Enter the size of the array :
 12
 Enter array elements :
 465 7878 3535 68 3435 89897 466 878 44 7879 3 67868
 
 Minimum Element of the array is:
 3
 
 
 Time Complexity : O( N )
 Space Complexity : O(1)
 
 */
",C-Plus-Plus
"    /*
      *   An arrow function with 1 parameter and returns a value.
      *   @param {Array} arrayOfCandidates contains a list of candidates
      *   @return {number} majority candidate value selected by the algorithm
      *   
      *   This function determines the candidate who has the 
      *   the majority number of votes, this algorithm was proposed by Boyer Moore's. 
      */
     const selectCandidate = (arrayOfCandidates) => {
 
         var majorityVotes = 1; //contains the vote number of the candidate
         var majorityCandidate = arrayOfCandidates[0]; //contains current majority candidate
 
         for (var i = 1; i < arrayOfCandidates.length; i++) //Iterates through the list of candidates
         {
 
             /*
              * checks whether the current candidate value is 
              * same as of it's preceding one
              */
             if (majorityCandidate == arrayOfCandidates[i]) {
                 majorityVotes++;
             } else {
                 majorityVotes--;
             }
 
             /*
              * If majorityVotes deduct to 0 then a new candidate 
              * is assigned and the value of majorityVotes reset to 1
              */
             if (majorityVotes <= 0) {
                 majorityVotes = 1; //Resetting value of majorityVotes
                 majorityCandidate = arrayOfCandidates[i]; //Assigning new candidate
             }
         }
         return majorityCandidate; //Returns MajorityCandidate selected by the algorithm
     }
 
     /*
      *  An arrow function with 2 parameters and returns a value
      *  @param {Array} arrayOfCandidates contains a list of candidates
      *  @param {number} selectedCandidate the selected candidate by the Boyer Moore's Algorithm
      *  @return {boolean} verifies and returns that the given candidate is Majority Candidate or not
      * 
      * This function verifies that the given candidate selected is a valid candidate 
      * and satisfies the",JavaScript
"// EXECUTION OF INSERTION SORT IN C++
 
 /*First we  will  compare first element in the list with its adjacent element.
 
 And at every comparison if the element can be inserted at a particular position, 
 then it is inserted by shifting the other elements one position to the right.
 
 The above steps are repeated until all the elements in the list are in their 
 appropriate position.i.e. list is in sorted order.*/
 
 #include <iostream>
 using namespace std;
 
 // Function to print array.
 void display(int arr[], int size) { 
     int i;
     for (i=0; i < size; i++)
     cout<< arr[i]<<""\t"";
     cout<<""\n"";
 }
 
 // swapping elements in the array
 void swap(int arr[], int i , int j) {
     int temp = arr[i];
     arr[i] = arr[j];
     arr[j] = temp;
 }
 
 // Main function to run the program
 int main()
 {
     int size;
     cout << ""Enter size of array:"" << endl;
     cin >> size;
     int array[size];
     cout << ""Enter array elements:"" << endl;
     for (int i = 0; i < size; i++) {
         cin >> array[i];
     }
 
     int i, j, k;
     for (i = 1; i < size; i++) 
     {  
         // target = array[i];  
         // j = i - 1;  
         j = i-1;
         k = i;
         /* Here the elements in b/w arrary[0 to i-1]
         which are greater than target are moved
         ahead by 1 position each*/
         while (j >= 0 && array[k] < array[j]) 
         {  
             swap(array, k, j);
             j--;
             k--;
         }
     }
     cout<<""After Insertion sort: \n"";
     display(array, size);
     return 0;
 }
 
 /**
 Enter the size of list:
 6
 Enter the numbers:
 5
 0
 2
 1
 4
 3
 Sorted list:
 0
 1
 2
 3
 4
 5
 
 Time Complexity: O(n*2)
 Space Complexity: O(1)
  */
",C-Plus-Plus
"/*The Affine Cipher is a type of monoalphabetic substitution cipher.
 Here each letter in a message is first converted to a number and then
 encrypted using a simple mathematical function. Then the numbers are
 converted back to ASCII.*/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // Key values declared as global variables
 int a;
 int b;
 int m = 26;
 
 // This is the encryption function
 string encryption(string message) {
 
 	string cipher;
 
 	/* Encrypted Message(x) = ( a * x + b ) mod m
 	 modulus m: size of the alphabet, here 26 a and
          b: key of the cipher. a and m should be coprime.*/
 	
 	for (int i = 0; i < message.size(); ++i) {
 
 		// Spaces should not be encrypted
 		if (message[i] != ' ') {
 			// to make in range of ASCII ""A"" is added
 			cipher += (char)((a * (message[i] - 'A') + b) % 26 + 'A');
 		}
 		else {
 			cipher += message[i];
 		}
 	}
 
 	// Return the ciphertext
 	return cipher;
 }
 
 // This is the decryption function
 string decryption(string cipher) {
 
 	string message;
 	int a_inv = 0;
 
 	for (int i = 0; i < 26; ++i) {
 		if ((a * i) % 26 == 1) {
 			a_inv = i;
 			break;
 		}
 	}
 
 	/* Decrypted Message(x) = a_inv ( x - b ) mod m
 	a_inv : modular multiplicative inverse of a modulo m
 	1 = (a * a_inv) mod m .*/
 
 	for (int i = 0; i < cipher.size(); ++i) {
 		// Spaces should not be encrpyted
 		if (cipher[i] != ' ') {
 			// to make it in range of ASCII ""A"" is added
 			message += (char)(a_inv * (cipher[i] + 'A' - b) % 26 + 'A');
 		}
 		else {
 			message += cipher[i];
 		}
 	}
 	
 	// Return the underlying plaintext
 	return message;
 }
 
 int main() {
 
 	int choice;
 
 	cout << ""----------Affine Cipher----------\n\n"";
 
 	cout << ""1. Encryption"" << endl;
 	cout << ""2. Decryption"" << endl;
 	cout << ""3. Exit"" << endl;
 
 	cout << ""\nEnter your choice: "";
 	cin >> choice;
 
 	// Encryption
 	if(choice == 1) {
 		cout << ""\nEnter the key 'a': "";
 		cin >> a;
 		cout << ""Enter the key 'b': "";
 		cin >> b;
 		str",C-Plus-Plus
"// C++ program to check if a number is a palindrome or not
 #include <bits/stdc++.h>
 using namespace std;
 
 int main()
 {
     int num, temp, rev = 0;
     cout << ""Enter the number:  "";
     cin >> num;
     temp = num;
     /*To check if a number is palindrome, we reverse the number
     and then compare it with the given number */
     while (temp)
     {
         int rem = temp % 10;
         rev = rev * 10 + rem;
         temp = temp / 10;
     }
     if (rev == num)
     {
         cout << ""The given number is a palindrome number"";
     }
     else
     {
         cout << ""The given number is not a palindrome number"";
     }
     return 0;
 }
 
 /*
 Time Complexity: O(log(num)), where 'num' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number:  14321
 The given number is not a palindrome number
 
 SAMPLE 2
 
 Enter the number:  43234
 The given number is a palindrome number
 
 */
",C-Plus-Plus
"/*
 The Affine cipher is a type of monoalphabetic substitution cipher. Here each of the letter in the message is mapped to a number,
 then encrypted using a mathematical function. The numbers are then converted back to letters to form the ciphertext
 */
 
 import 'dart:io';
 
 /* Encrypted Message(x) = ( a * x + b ) mod m
 here a and b are the keys provided by user at the time of encryption */
 String encrypt(String plain, int key_a, int key_b) {
   int length = plain.length;
   List<int> encrypt = [];
 
   //Iterate through whole string and replace letters
   for(int index = 0; index < length; index++){
     int char = plain[index].codeUnitAt(0);
 
     // blank space is not encrypted
     if(char != 32){ 
       encrypt.add((key_a * (char - 65) + key_b)% 26 + 65);
     }
     else {
        encrypt.add(char);
     }
   }
   String encrypted_string = String.fromCharCodes(encrypt);
   return encrypted_string;
 }
 
 /* Decrypted Message(x) = a_inv ( x - b ) mod m
 a_inv : modular multiplicative inverse of a modulo m
 1 = (a * a_inv) mod m */
 String decrypt(String plain, int key_a, int key_b) {
   int length = plain.length;
   List<int> decrypt = [];
 
   int a_inv = 0;
 
   for (int index = 0; index < 26; ++index) {
 		if ((key_a * index) % 26 == 1) {
 			a_inv = index;
 			break;
 		}
 	}
 
   //Iterate through whole string and replace letters
   for(int index = 0; index < length; index++){
     int char = plain[index].codeUnitAt(0);
 
     // blank space is not decrypted
     if(char != 32){
       decrypt.add((a_inv* (char + 65 - key_b))% 26 + 65);
     }
     else {
        decrypt.add(char);
     }
   }
   String decrypted_string = String.fromCharCodes(decrypt);
   return decrypted_string;
 }
 
 
 void main() {
     print(""Enter 1 to ENCRYPT and 2 to DECRYPT : "");
     int choice = int.parse(stdin.readLineSync()!);
     
     if(choice == 1){
       print('Enter the key A :');
       int key_a = int.parse(stdin.readLineSync()!);
 
       print('Enter the key B ",Dart
"// C++ program to implement Maximum Sum Increasing Subsequence
 /*
 In this problem, given an array we have to find the maximum sum an increasing subsequence of that array can make.
 This problem is a slight modification to the Longest Increasing subsequence problem.
 The problem can be solved using Dynamic Programming
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 int max_sum_increasing_subsequence(int arr[], int n)
 {
     int dp[n], max_sum = 0;
 
     /* Initialize the dp array with the array values, as the maximum sum 
        at each point is atleast as the value at that point         */
     for (int i = 0; i < n; i++)
         dp[i] = arr[i];
 
     // Now Lets Fill the dp array in Bottom-Up manner
     /* Compare Each i'th element to its previous elements from 0 to i-1, 
        If arr[i] > arr[j], then it qualifies for increasing subsequence and
        If dp[i] < dp[j] + arr[i], then that subsequence sum qualifies for being the maximum one */
     for (int i = 1; i < n; i++)
         for (int j = 0; j < i; j++)
             if (arr[i] > arr[j] && dp[i] < dp[j] + arr[i])
                 dp[i] = dp[j] + arr[i];
 
     //Now Find the maximum element in the 'dp' array
     max_sum = *max_element(arr, arr + n);
 
     return max_sum;
 }
 
 int main()
 {
     int n, max_sum;
     cout << ""\nWhat is the length of the array? "";
     cin >> n;
     int arr[n];
     cout << ""Enter the numbers: "";
     for (int i = 0; i < n; i++)
     {
         cin >> arr[i];
     }
     max_sum = max_sum_increasing_subsequence(arr, n);
 
     cout << ""The maximum sum of an increasing subsequence of the given array is "" << max_sum;
     return 0;
 }
 
 /*
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 10
 Enter the numbers: 23 14 5 84 24 222 321 43 123 432 
 The maximum sum of an increasing subsequence of the given array is 1082
 
 SAMPLE 2
 
 What",C-Plus-Plus
"// Implementation of MergeSort a comparison-based sorting algorithm. It works on the principle of Divide and Conquer.
 
 using System;
 
 namespace MergeSortAlgorithm
 {
     class Merge_Sort
     {
         //The merge step to sort the elements
         private static void Merge(int[] arr, int[] temp, int leftStart, int mid, int rightEnd)
         {
             int left = leftStart, right = mid + 1, index = left;
             //Compare Elments from arr portion and sort them in temproray array temp
             while (left < mid + 1 && right <= rightEnd)
             {
                 if (arr[right] < arr[left])
                 {
                     temp[index] = arr[right++];
                 }
                 else
                 {
                     temp[index] = arr[left++];
                 }
                 index++;
             }
             // if the arr porion sorted but i didn't reach the last element place the rest in temp 
             for (; left <= mid; left++)
                 temp[index++] = arr[left];
             // if the arr porion sorted but j didn't reach the last element place the rest in temp 
             for (; right <= rightEnd; right++)
                 temp[index++] = arr[right];
             //Place the sorted elements from temp into arr
             for (left = leftStart; left <= rightEnd; left++)
                 arr[left] = temp[left];
         }
         // recursive part in merge sort to break the array into smaller portions
         private static void MergeSort(int[] arr, int[] temp, int leftStart, int rightEnd)
         {
             if (leftStart < rightEnd)
             {
                 int mid = leftStart + (rightEnd - leftStart) / 2;
                 MergeSort(arr, temp, leftStart, mid);
                 MergeSort(arr, temp, mid + 1, rightEnd);
                 Merge(arr, temp, leftStart, mid, rightEnd);
             }
 
         }
         //Limit the number of parameters
         public static void MergeSor",C-Sharp
"/* 
 Finding Modular multiplicative inverse by using DART.
 
 Given two integers n and m, find modular multiplicative inverse of n 
 under modulo m.
 The modular multiplicative inverse is an integer i such that. 
 
 n i  1 (mod m)
 */
 
 import 'dart:io';
 
 int modulo_inverse(int n, int m) {
   int mod = m;
   for (int i = 1; i < m; i++) {
     if (((n % m) * (i % m)) % m == 1) {
       mod = i;
       break;
     }
   }
   return mod;
 }
 
 void main() {
   // taking input from user
   var n, m;
   print('Enter the element: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   print('Enter the modulo: ');
   m = stdin.readLineSync();
   m = int.parse(m);
 
   int mod_inv;
   print(""\nModular multiplicative inverse of $n under modulo $m is: "");
   mod_inv = modulo_inverse(n, m);
   print(mod_inv);
 }
 
 /*
 TIME COMPLEXITY: O(n).
 SPACE COMPLEXITY: O(1).
 
 SAMPLE INPUT/OUTPUT:
 Enter the element: 
 11
 Enter the modulo: 
 28
 
 Modular multiplicative inverse of 11 under modulo 28 is:
 23
 */
",Dart
"
 /* Below code is an implementation of binary search in Golang using
 recursive method. An array is taken as input from the user, followed
 by the element the user wants to search in the array. The search function
 is called. If the element is present in the array, then print the index
 of the element in the array.
 NOTE : For binary search to work, the input array must be SORTED*/
 
 package main
 
 import (
 	""fmt""
 )
 
 // This function recursively searches for element in array
 func search(array []int, left, right, element int) int {
 
 	// If left pointer exceeds the right pointer
 	if(left > right) {
 		return -1
 	} else {
 		// Find the middle index
 		var middle int = left + (right - left) / 2;
 		// If element is found return index
 		if(array[middle] == element) {
 			return middle
 		} else if(array[middle] > element) {
 			/* If middle element is greater than the given
 			element to search, then, recursively search in
 			the left half of the array.*/
 			return search(array, left, middle - 1, element)
 		} else if(array[middle] < element) {
 			/* If middle element is less than the given
 			element to search, then, recursively search
 			in the right half of the array.*/
 			return search(array, middle + 1, right, element);
 		}
 	}
 	// If not found, return -1
 	return -1
 }
 
 func main() {
 
 	// Take length of array as input from the user
 	fmt.Print(""Enter the length of the array: "")
 	var n int
 	fmt.Scan(&n)
 
 	// Take elements of array as input from the user
 	fmt.Print(""Enter "", n, "" elements followed by spaces: "")
 	array := make([]int, n)
 	for i := 0; i < n; i++ {
 		fmt.Scan(&array[i])
 	}
 
 	// Take element to search as input from the user
 	fmt.Print(""Enter the element you want to search: "")
 	var element int
 	fmt.Scan(&element)
 
 	// Call search function to find the index
 	var index int = search(array, 0, n - 1, element)
 
 	/* If index is -1, the element is not present
 	Else print index of element in the array*/
 	if(index == ",Go
"/*
 Coin Change Problem Maximum Number of ways
 This problem is solved using dp.
 Given a value n which is total sum and m is size of coins array, 
 and we have infinite supply of each of S = { S1, S2, .. , Sm} valued coins,
 In this problem we have to count whether the values of subset of array is equal to sum or not.
 if equal then we will increase count by 1 else we will return 0.
 */
 #include<bits/stdc++.h>
 using namespace std;
 
 // This function is for checking whther the subset of array sum is equal to value or not
 long long int count( int S[], int m, int n )
     {
       // We will create matrix t of size (n+1)*(sum+1)
        long long int t[m+1][n+1];
 
     /* if j is 0 i.e. sum is 0 and i i.e. arr has whatever values it will always return true
     because if sum is 0 then we don't need to find if subset of array is equal to sum or not */
        for(int i=0;i<m+1;i++){
            t[i][0] = 1;
        }
 
     /* But if i is 0 i.e array has no value and sum has some value then we can nver make 
     subset of array value equal to sum so it will always give false */
        for(int i=1;i<n+1;i++){
            t[0][i] = 0;
        }
        
        for(int i=1;i<m+1;i++){
            for(int j=1;j<n+1;j++){
                // if subset sum value less than sum then we will proceed further and we add value to it
                if(S[i-1] <= j){
                    t[i][j] = t[i-1][j] + t[i][j-S[i-1]];
                }
                // if subset sum value grater than sum then we will proceed further
                else{
                    t[i][j] = t[i-1][j];
                }
            }
        }
        
        return t[m][n];
 }
 
 
 // Driver Code 
 int main()
 {
     /* n is sum to which we have to make arr sum equal
     m is size of array */
     int n,m;
     cout << ""Enter the value of n and m: \n"";
     cin>>n>>m;
     int arr[m];
     cout << ""Enter the value of array: \n"";
     for(int i=0;i<m;i++){
 	cin>>arr[i];
     }
    
     /",C-Plus-Plus
"import java.util.*;
 import java.lang.*;
 import java.io.*;
 
 class ZigZag {
     public String convert(String s, int numRows) {
         
         if (numRows == 1 || numRows >= s.length()) return s; 
         
         ArrayList<String> arrLL = new ArrayList<>();
         
         for (int i = 0; i < Math.min(numRows, s.length()); i++)
             arrLL.add("""");
         
         int counter = 0;
         boolean b = false;
         int size = Math.min(numRows, s.length());
         for (char c : s.toCharArray()){
             String str = Character.toString(c);
             String initial = """";
            
             if (counter < arrLL.size() || arrLL.get(counter) != """") {
                 initial = arrLL.get(counter);
                 arrLL.add(counter, initial + str);
                 arrLL.remove(counter+1);
                 
             }
             if (counter == 0 || counter + 1 == numRows) b = !b;   
             counter += b ? 1 : -1;     // adding -1 in b if b is false 
                                       // adding 1 in b if b is true
         }
         
         String ans = """";
         for (int i =0; i< arrLL.size(); i++){
             ans += arrLL.get(i);
         }
         
         
         return ans;
     }
 }
 
 /*
 TIME COMPLEXITY: 0(N) where n is size of string
 SPACE COMPLEXITY:0(N) where n is size of string
 TEST CASE
 
 INPUT
 ""PAYPALISHIRING""
 
 OUTPUT
 ""PAHNAPLSIIGYIR""
 
 INPUT
 ""PAYPALISHIRING""
 4
 
 OUTPUT
 ""PINALSIGYAHRPI""
 
 */
 
",Java
"/**
 We are given an array in which all the elements are 
 present twice except one element. The program will 
 find out that unique element.
  */
 
 import java.util.Scanner;
 
 public class UniqueNumberBitmasking {
 
     public static void main(String[] args) {
 		
 		Scanner sc=new Scanner (System.in);
 
               System.out.print (""Enter size of array - "");
 		int n=sc.nextInt();
 
 		int[] ar=new int[n];
               System.out.print (""Enter elements in array - "");
 		for (int i=0; i<n; i++) {
 			ar[i]=sc.nextInt();
 		}
 	      
 	        /*
 	        We know that xor of two similar numbers is 0 and xor of any 
 	        number with 0 is number itself. Ex: 1^1=0, 0^1=1.
 	        We use this concept here by taking xor of all the elements of 
 	        the array. Since we know that all elements are present twice
 	        except one, so the xor of all elements that are repeated
 	        will become 0 and when the unique number comes
 	        xor of 0 and that number will result in that number itself.
 	        */
 
 		int xor=0;
 		for (int i=0; i<n; i++) {
 			xor=xor^ar[i];
 		}
 
 		System.out.println (""Unique element in array - ""+xor);
 	}
 }
 
 /**
 Time Complexity : O(N)
 Space Complexity : O(N)
 
 Input :
 
 Enter size of array - 7
 
 Output : 
 
 Enter elements in array - 3 8 2 5 3 2 5
 Unique element in array - 8
 
 */
 
",Java
"/** 
 Radix sort is based on counting sort
 This sort is used for non-negative elements
 Assuming the range is fixed, as int capacity
 is limited in any language, this sort takes
 
 MAX_INT contains 10 decimal values
 If range is not fixed, this sort takes O(kn) time
 where k is #decimal places in the number
 This works because of the nature of counting sort
 Counting sort is a stable sort
 **/
 
 public class RadixSort {
     // required variables
 	private static int M = 10, K = 10;
 	private static void counting_sort(int[] arr, int  n, int p) {
 		int element = (int)Math.pow(10, p), i;
 		int divs = element / 10;
 		// counting array
 		int[] count = new int[M];
 		for(i = 0; i < M; i++)
 			count[i] = 0;
 		for(i = 0; i < n; i++)
 			count[(arr[i] % element) / divs] ++;
 		for(i = 1; i < M; i++)
 			count[i] += count[i-1];
 		int[] op = new int[n];
 		for(i = n-1; i >= 0; i--) {
 		    op[count[(arr[i] % element) / divs] - 1] = arr[i];
 		    count[(arr[i] % element) / divs] --;
 		}
 		// copying the array back
 		for(i = 0; i < n; i++)
 			arr[i] = op[i];
 	}
 
 	private static void radix_sort(int[] arr, int n) {
 		// apply counting sort for all decimal places
 		for(int i = 1; i <= K; i++)
 			counting_sort(arr, n, i);
 	}
 
 	public static void main(String[] args) {
 		int n, i;
 		Scanner sc= new Scanner(System.in);
 		n = sc.nextInt();
 		int[] arr = new int[n];
 		// taking ip
 		for(i = 0; i < n; i++)
 			arr[i] = sc.nextInt();
 		// perform the sort
 		radix_sort(arr, n);
 		for(i = 0; i < n; i++)
 			System.out.print(arr[i] + "" "");
 		System.out.println();
 	}
 }
 
 /**
 Input : 
 8
 175 45 75 90 802 24 2 66
 Output :
 2 24 45 66 75 90 175 802
 
 Time complexity : O(n)
 Space complexity : O(n)
 **/
",Java
"/*
 Given total number of nodes in an undirected graph
 numbered from 1 to n [ number of nodes] and total number of edges in the graph.
 Calculate the total number of connected components in the graph.
 */
 
 #include <stdio.h>
 
 int adj[10009][1009];
 int visited[10009];
 
 // this dfs function will visit the nodes
 void dfs(int node, int nodes)
 {
     /* for each node we will put  visited[node] = 1
     means that node is visited
     and then recursively will visit the
     adjacency matrix */
     visited[node] = 1;
     for(int i = 1; i <= nodes; i++)
     {
         if(adj[node][i] != 0 && visited[i] == 0)
         {
             dfs(i , nodes);
         }
     }
 }
 
 // this get_connected_components will count the number of connected components
 int get_connected_components(int nodes)
 {
     int connected_components = 0;
     for(int i = 1; i <= nodes; i++)
     {
         /* if the current visited[i] is zero , that means
         that node is not visited.
         so, we will make a dfs call
         and increment the connected_components
          */
         if(visited[i] == 0)
         {
             dfs(i, nodes);
             connected_components++;
         }
     }
     return connected_components;
 }
 
 int main()
 {
     printf( ""Enter the nodes of the graph :\n"");
     int nodes;
     scanf(""%d"",&nodes);
     printf( ""Enter the adjacency matrix :\n"");
     for(int i = 1; i <= nodes; i++)
     {
         for(int j = 1; j <= nodes; j++)
         {
             scanf(""%d"", &adj[i][j]);
         }
     }
     int connected_components = get_connected_components(nodes);
 
     printf(""Number of Connected Components in this graph is: \n"");
     printf(""%d \n"", connected_components);
 }
 
 /*
 Standard Input and Output
 
 Enter the nodes of the graph :
 8
 Enter the adjacency matrix :
 0 1 1 0 1 0 1 1
 0 1 1 0 1 0 1 1
 1 1 1 0 0 1 0 1
 0 0 0 1 1 0 1 1
 0 1 1 0 0 1 1 1
 1 1 0 0 1 1 1 1
 1 0 1 0 0 1 1 0
 1 0 1 0 1 0 1 0
 
 Number of Connected Components ",C
"/*
 Introduction 
 Given a vector of values , Build a Balanced BST with them
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 /* Function to create a node with 'value' as the data stored in it. 
  Both the children of this new Node are initially null. */
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to insert a node with given value to the root
 struct Node* insert(struct Node* root,int element) 
 {
     /*If the root is NULL , create a node with given element and assign it to root
     else if the root itself is the node with given data , return 
     else recursively insert it in one of the subtrees accordingly */
     if(root==NULL)
         root = newNode(element);
     else if(root->key < element)
         root->right = insert(root->right,element);
     else if(root->key > element)
         root->left = insert(root->left,element);
     
     return root;
 }
 
 // Function to print Tree in  level order
 void LevelOrderTraversal(struct Node* root)
 {
     // If root is NULL , return 
     if (root == NULL)
         return ;
 
     // Create an queue
     queue<struct Node*> q;
     //Enqueue the root node 
     q.push(root);
  
     while (!q.empty()) 
     {
         cout<<q.front()->key<<"" "";
         //Enqueue node's children , if they exist
         if(q.front()->left)
             q.push(q.front()->left);
         if(q.front()->right)
             q.push(q.front()->right);
         q.pop();
     }
     return ;
 }
 
 //Utility function to remove duplicates from a vector of sorted values
 vector<int> RemoveDuplicates(vector<int>values)
 {
    //declare a new vector
    vector<int>newVector;
 
    for(int i=0;i<values.size();i++)
    {",C-Plus-Plus
"# Julia program to Find the Sum of Digits of a Number 
 
 # Extracting Each digits
 function sum_of_digits(num)
     sum = 0
     while(num != 0)
         sum = sum + (num % 10)
         num = num  10
     end
     return sum
 end
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 sum = sum_of_digits(abs(num))
 println(""The sum of digits of the given number is $sum."")
 
 """"""
 Time Complexity: O(log(num)), where 'num' is the length of the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: -12
 The sum of digits of the given number is 3.
 
 SAMPLE 2
 Enter the number: 43258
 The sum of digits of the given number is 22.
 
 """"""
",Julia
"/*
 
 Stock Span Problem
 ===================
 You are given the price of a stock for N consecutive days and are required to find the span
 of stock's price on ith day. The span of a stock's price on a given day i, is the maximum
 consecutive days before the (i+1)th day, for which the stock's price is less than equal to that on
 the ith day.
 
 */
 
 import java.util.*;
 
 public class StockSpan {
 	public static void main(String args[]) {
 		// Input number of days
 		Scanner sc = new Scanner(System.in);
 		int n = sc.nextInt();
 		int[] price = new int[n];
 		int[] span = new int[n];
 
 		// Input price for n days
 		for (int i = 0; i < n; i++)
 			price[i] = sc.nextInt();
 
 		// Stack for keeping track of span of largest element till now
 		Stack<Integer> s = new Stack<Integer>();
 		// Push first element in the stack
 		s.push(0);
 		// Span for first day will always be 1
 		span[0] = 1;
 
 		// Looping through rest of the days
 		for (int i = 1; i < n; i++) {
 
 			// While we have elements in the stack and currPrice is greater than equal to topPrice
 			// keeping popping out elements and update the currSpan
 			while (s.empty() == false && price[s.peek()] <= price[i])
 				// Pop out the topmost element as its price was less than currPrice
 				s.pop();
 
 			// Calculate the span for the current day
 			span[i] = (s.empty()) ? i + 1 : i - s.peek();
 			// Push curr element into the stack
 			s.push(i);
 		}
 
 		// Print ans
 		for (int i = 0; i < n; i++)
 			System.out.print(span[i] + "" "");
 		System.out.println();
 	}
 }
 
 
 /*
 
 Input :
 5
 30 35 40 38 35
 Output :
 1 2 3 1 1
 
 Application: Stack data structure
 Time Complexity: O(n)
 Space Complexity: O(n)
 
 */
 
 
",Java
"/*
 This is the solution to build an expression tree from a given postfix expression.
 The corresponding infix expression is obtained by inorder traversal of the built expression tree.
 
 Constraints:
 1)Operands in the expression should lie in (0,10^5) or (A,Z) or (a,z)
 2)Operators in the expression - {+,-,*,/,%,^}
 
 Approach:
 1)Traverse through all the elements in the expression and check if it is an operator or operand.
 2)If it is an operand, push it into the stack.
 3)It it is an operator,pop the top 2 elements and make them the right and left child respectively of the current node.
   Push this node on the stack.
 4)After the expression is traversed,only one element is left in the stack.
 This is the root of the required expression tree.
 */
 
 
 import java.util.*;
 public class Build_Expression_Tree {
 
     //Class which defines the structure of each node in the binary tree
     static class Node {
         String data;
         Node left, right;
         Node(String data) {
             this.data = data;
             this.left = null;
             this.right = null;
         }
     }
 
     //Function to check if the element passed is an operator
     static boolean isOperator(String ch) {
         if (ch.equals(""+"") || ch.equals(""-"") || ch.equals(""*"") || ch.equals(""/"") || ch.equals(""%"") || ch.equals(""^""))
             return true;
         else
             return false;
     }
 
 
     //Function which builds the expression tree and returns the root node of the tree
     static Node buildTree(ArrayList < String > exp) {
         Node root;
         Node temp1;
         Node temp2;
         Stack < Node > s = new Stack < > ();
         for (int i = 0; i < exp.size(); i++) {
             //If the element is an operand,push it on the stack
             if (!isOperator(exp.get(i))) {
                 root = new Node(exp.get(i));
                 s.push(root);
             }
             //If the character is an operator,pop the top two nodes and make t",Java
"/* Given two sorted arrays nums1 and nums2 of size m and n
 respectively, return the median of the two sorted arrays */
 #include<stdio.h>
 #include<stdlib.h>
 
 double findMedianSortedArrays(int * arr1, int n, int * arr2, int m);
 int main() {
   int n, m;
   // accepting the sizes
   printf(""Enter sizes of both arrays: "");
   scanf(""%d %d"", & n, & m);
   int * arr1 = (int *) malloc(sizeof(int) * n);
   int * arr2 = (int *) malloc(sizeof(int) * m);
   // accepting the array elements
   printf(""Enter elements of first array: "");
 
   for (int i = 0; i < n; i++) {
     scanf(""%d "", arr1 + i);
   }
   printf(""Enter elements of second array: "");
   
   for (int i = 0; i < m; i++) {
     scanf(""%d "", arr2 + i);
   }
   // print the median
   printf(""Median of two arrays is %f"",
          findMedianSortedArrays(arr1, n, arr2, m));
   return 0;
 }
 
 // function to find the median of two arrays
 double findMedianSortedArrays(int * arr1, int n, int * arr2, int m) {
   // create a new array to store the two arrays
   int arr3Size = n + m;
   int * arr3 = (int *) malloc(sizeof(int) * arr3Size);
   int j = 0, k = 0;
   // if arraysize is 0 then return 0
   if (arr3Size == 0)
     return 0;
   // if any arraysize is 0 then store the other array in arr3
   else if (n == 0) {
     for (int i = 0; i < m; i++) {
       arr3[i] = arr2[i];
     }
   } else if (m == 0) {
     for (int i = 0; i < n; i++) {
       arr3[i] = arr1[i];
     }
   } else {
     // now store the two arrays in the new created array
     for (int i = 0; i < arr3Size; i++) {
       if (k == m && j < n) {
         arr3[i] = arr1[j];
         j++;
       } else if (j == n && k < m) {
         arr3[i] = arr2[k];
         k++;
       } else if (arr2[k] < arr1[j]) {
         arr3[i] = arr2[k];
         k++;
       } else if (arr1[j] <= arr2[k]) {
         arr3[i] = arr1[j];
         j++;
       }
     }
   }
   
   if (arr3Size == 1)
     return arr3[0];
   // if array size is even then return mid element
   else if",C
"    /*This is a java code for removing duplicate words from sentence.
     remove instances of words that are repeated more than once,
     but retain the first occurrence of any case-insensitive repeated word
     For example, Sam went went to to to his school, will become Sam went to his school.
     For example, Hello hello Ab aB, will change to Hello Ab.
     */
     import java.lang.String;
     import java.util.Scanner;
     import java.util.regex.Matcher;
     import java.util.regex.Pattern;
 
     public class Duplicate_word
     {
     public Duplicate_word(String input, Pattern p)
     {
         Matcher m = p.matcher(input);
         // Check for subsequences of input that match the compiled pattern
         while (m.find())
         {
              input = input.replaceAll(m.group(), m.group(1));
         }
         // Prints the modified sentence.
         System.out.println(input);
     }
     public static void main(String[] args)
     {
           String regex = ""\\b(\\w+)(?:\\W+\\1\\b)+"";
           Pattern p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
           Scanner in = new Scanner(System.in);
           System.out.println(""Please enter how many sentences you want correct : "")
           int numSentences = Integer.parseInt(in.nextLine());
           System.out.println(""Please enter your sentence..."")
           while (numSentences-- > 0)
           {
               String input = in.nextLine();
               Duplicate_word s = new Duplicate_word(input, p);
           }
           in.close();
     }
     }
     /*
     Time complexity is O(n)
     Space complexity is O(1)
 
     Input :
     Please enter how many sentences you want correct :
     5
     Please enter your sentence...
     Goodbye bye bye world world world.
     Sam went went to to to his business.
     Reya is is the the best player in eye eye game.
     in inthe.
     Hello hello Ab aB
 
     Output:
     Goodbye bye world
     Sam went to his business
     Reya is the",Java
"/*
 Repeating and missing number
 
 Given an unsorted array of positive integers. The elements are in the range 1 to n where n is the size of array,
 there is one number which is repeated and another number which is missing. Find these numbers and print them.
 The approach used is that checking if the current element is in its desired position or not. It is, then simply iterate
 for next, else put it in its desired position by comparing with its index number and swap it accordingly.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void print_number(int input[], int n){
     int j = 0;
     while(j < n){
         //if below condition is true then the number is either in its desired position or is repeated
         if(input[j] == j+1 || input[j] == input[input[j]-1]){
             j++;
         }
         else{
             //else putting the elements in its desired position by swaping them with the index number - 1
             swap(input[j], input[input[j]-1]);
         }
     }
     
     //after arranging the number in the sequence, printing the repeated and missing number
     for(int i = 0; i < n; i++){
         if(input[i] != i+1){
             cout << ""\nRepeated number: "" << input[i] << endl;
             cout << ""Missing number: "" << i+1 << endl;
         }
     }
 }
 
 int main() {
     cout << ""Enter the size of array: "";
     int n;
     cin >> n;
     cout << ""\n Enter the elements of array: "";
     int input[n];
     for(int i = 0; i < n; i++)
         cin >> input[i];
 
     //calling the function for repeated and missing number
      print_number(input, n);
 	
 	return 0;
 }
 
 /*
 Test Case :
 Input - 
 Enter the size of array: 7
 Enter the elements of array: 4 2 3 6 1 1 7
 Output - 
 Repeated number: 1
 Missing number: 5
 
 Time Complexity: O(n), n is size of array - for traversing the array
 Space Complexity: O(1), since no extra space is used
 */
 
",C-Plus-Plus
"//C++ Program to generate Pythagorean Triples within a user-given limit
 #include <bits/stdc++.h>
 using namespace std;
 
 //Function for computing Pythagorean Triples
 void GetTriples(int& l)
 {
 	//Starting values of m=2, n=1 are mapped to a=3, b=4, c=5, which is the smallest Pythagorean triple
 	int a = 0, b = 0, c = 0, m = 2, n = 1;
 
 	while (c < l)
 	{
 		//For every m, evaluate a,b,c for all values of n from 1 to m-1
 		n = 1;	
 		while (n < m)
 		{
 			//Evaluating a, b, c using relation between a,b,c and m,n
 			a = (int)(pow(m, 2)) - (int)(pow(n, 2));
 			b = 2 *m * n;
 			c = (int)(pow(m, 2)) + (int)(pow(n, 2));
 
 			//Checking for limit being exceeded
 			if (c > l)	
 				break;
 
 			//Display computed Triple
 			cout << a << "" "" << b << "" "" << c << ""\n"";
 			n++;
 		}
 
 		m++;
 	}
 }
 
 //Driver function
 int main()
 {
 	int l;
 	//Prompts user for input
 	cout << ""Enter limit (>4) :"";
 	cin >> l;
 	GetTriples(l);
 	return 0;
 }
 
 /*
 Sample I/O:
 Enter limit: 30
 3 4 5
 8 6 10
 5 12 13
 15 8 17
 12 16 20
 7 24 25
 24 10 26
 21 20 29
 
 Time Complexity - O(k)[k = number of triples generated]
 Space Complexity - O(1)
 
 References: https://youtu.be/n6vL2KiWrD4
 */",C-Plus-Plus
"""""""Julia program to Find Noble Integer in an array.
 Given an array arr, an integer ele is said to be noble integer if
 the number of integers greater than ele is equal to ele.
 If such an element is not found Return -1. 
 """"""
 
 function search_noble_integer(arr, n)
     # Traverse the entire array
     for i in 1:(n-1)
         if (arr[i] == arr[i+1])
             continue
         end
         #  If arr[i] equals the number of elements after arr[i], it is a noble Integer
         if(arr[i] == (n - i))
             return arr[i]
         end
     end
     if(arr[n] == 0)
         return arr[n]
     end
     return -1
 end
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""Array is Empty!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())] 
 # Sort the array in ascending order
 arr = sort(arr)
 res = search_noble_integer(arr, n)
 if (res == -1)
     print(""A Noble Integer is not present in the array."")
 else
     print(""A Noble Integer $res is  present in the array."")
 end
 
 
 """"""
 Time Complexity - O(n * log(n)), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 How many numbers are present in the array? 5
 Enter the numbers: 12 34 3 1 99
 A Noble Integer 3 is  present in the array.
 
 SAMPLE II
 
 How many numbers are present in the array? 5 
 Enter the numbers: 5 4 3 2 1
 A Noble Integer is not present in the array.
 
 """"""
",Julia
"import java.util.Scanner;
 
 public class PainterPartition {
 
     public static void main(String[] args) {
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter the array size, number of painters and amount of time:"");
         int size = scanner.nextInt();
         int numOfPainters = scanner.nextInt();
         int time = scanner.nextInt();
         int[] boards = new int[size];
         System.out.println(""Enter board sizes:"");
         for (int i = 0; i < size; i++) {
             boards[i] = scanner.nextInt();
         }
         scanner.close();
 
         System.out.println(""Total time taken:"" + partition(boards, size, numOfPainters) * time);
     }
 
     private static int partition(int[] boards, int size, int numOfPainters) {
 
         // base cases
         if (numOfPainters == 1) {
             return totalLength(boards, 0, size - 1);
         }
         if (size == 1) {
             return boards[0];
         }
 
         int best = Integer.MAX_VALUE;
 
         // find minimum of all possible maximum sums of partitions of the array
         for (int i = 1; i <= size; i++) {
             best = Math.min(best, Math.max(partition(boards, i, numOfPainters - 1),
                     totalLength(boards, i, size - 1)));
         }
 
         return best;
     }
 
     private static int totalLength(int[] boards, int from, int to) {
         int total = 0;
         for (int i = from; i <= to; i++) {
             total += boards[i];
         }
         return total;
     }
 }
 /*
 * Sample input/output:
 * Enter the array size, number of painters and amount of time:
 * 2 2 5
 * Enter board sizes:
 * 1 10
 * Total time taken:50
 * Enter the array size, number of painters and amount of time:
 * 6 3 1
 * Enter board sizes:
 * 10 20 30 40 50 60
 * Total time taken:90
 *
 * Time complexity: O(2^n)
 */
",Java
"/* PROBLEM LINK: https://www.codechef.com/MARCH21C/problems/SPACEARR
 
 **The rules of the game are as follows:
 *Initially, a sequence a1,a2,,aN is given.
 *The players alternate turns.
 *In each turn, the current player must choose
 *an index i and increment ai, i.e. change ai to ai+1.
 *Afterwards, if there is no permutation p1,p2,,pN of the
 *integers 1 through N such that ai=pi holds for each valid
 *i,the current player loses.
 *Otherwise, the game continues with the next turn.
 */
 
 // Code
 #include<bits/stdc++.h>
 using namespace std;
 //Function Code to Find Result of Game
 int Game(int arr[],int n)
 {
 	int sum = 0, c = 0;
         for (int i = 0; i < n; i++) {
 	//Cheking if index is graeter or less than element of array  at that position
 	    if (arr[i] > (i + 1))
 	    { 
         // true, increase value of c  i.e. count
 		c = 1;                   
 		break;
 	     }
 	//if not,take the sum of difference of index and array at that index.
 	    sum += abs(arr[i] - (i + 1));    
 	}
 	//c is 1 i.e. arrayy is greater than element of array
 	if (c == 1) 
 	{
 	//second player wins.
 	    cout << ""Second"" << endl;       
 	}
 	else {
 	    // if sum is even.
 	  if (sum % 2 == 0)    
 	   // second is winner.
 	    cout << ""Second"" << endl;  
 	  else
           // otherwise first will win.
 	    cout << ""First"" << endl;  
 		}
 }
 //Driver Code
 int main() 
 {
 	//No of test Cases.
 	int t;  
 	cin >> t;
 	while (t--) {
 		 // No of elements in array
 		int n;     
 		cin >> n;
 		int arr[n];
 		 // i as Index of Array
 		for (int i = 0; i < n; i++)           
 			cin >> arr[i];		
                  //Sorting the Array
 		sort(arr, arr + n);    
 		//Finding who will win 
 		Game(arr,n);
 	}
 	return 0;
 }
 /*
 Example Input
 4
 4
 1 2 3 3
 4
 1 1 3 3
 5
 1 2 2 1 5
 3
 2 2 3
 Example Output
 First
 Second
 Second
 Second
 
 Time complexity: 0.06 sec using above algo, ""MAX time complexity can be 1 sec ""
 Memory used: 6.5 MB uisng above algo, MAx spa",C-Plus-Plus
"/******************************************************************************
 Author: @Suvraneel Bhuin
 
 Inorder Traversal of a Binary Tree
 
 Postorder Traversal of a Binary Tree
 Definition: Process all nodes of a tree by processing the root, then recursively processing all subtrees
 Post-order traversal is one of the multiple methods to traverse a tree. It is mainly used for tree deletion.
 Algorithm of Postorder(tree) Traversal 
 1. Traverse the left subtree, i.e., call Postorder(left-subtree)
 2. Traverse the right subtree, i.e., call Postorder(right-subtree)
 3. Visit the root.
 *******************************************************************************/
 #include <stdio.h>
 #include <stdlib.h>
 
 struct node
 {
 int key;
 struct node *lt;
 struct node *rt;
 }*root = NULL, *temp = NULL;
 //root & temp are made global so that we dont need to pass those again & again
 
 // Function to search the appropriate position to insert the new node
 void search(struct node *t)
 {
     if ((temp->key > t->key) && (t->rt != NULL))            //key > root node move down more right
         search(t->rt);
     else if ((temp->key > t->key) && (t->rt == NULL))       //if right node NULL, insert key
         t->rt = temp;
     else if ((temp->key < t->key) && (t->lt != NULL))       //key < root node move down more left */
         search(t->lt);
     else if ((temp->key < t->key) && (t->lt == NULL))       //if left node NULL, insert key
         t->lt = temp;
 }
 
 /* To insert a node in the tree */
 void insert()
 {
     int data;
     printf(""Enter data of node to be inserted : "");
     scanf(""%d"", &data);
     temp = (struct node *)malloc(1*sizeof(struct node));
     temp->key = data;
     temp->lt = temp->rt = NULL;             //initialise lt & rt child as null
 
     if (root == NULL) 
     root = temp;
     else    
     search(root);    
 }
 
 /* To find the postorder (LRV) traversal */
 void postorder(struct node *t)
 {
     if (root == NULL)
     {
         pr",C
"/* RABIN KARP ALGO in c issue - 2943
 Rabin-Karp is  pattern searching algorithm to find the pattern in a more efficient way, 
 finds the hash value. When the hash value is matched, then only it tries to check each character */
 #include <stdio.h>
 #include<string.h>
 void hash(char word[], char format[], int max, int len1 ,int pos, int num, int  initial){
  /* C hash value calculation for pattern and text*/
   for (int index = 0; index < len1; index++) {
     initial = (num *  initial +format[index]) % max;
 /* getting initial updated with hash value*/
     pos = (num * pos + word[index]) % max;
 /* getting pos updated with hash value*/
   }
 }
 /* checking whether the pattern is present or not*/
 int checking(char word[], char format[], int len2 , int len1 ,int pos, int  initial){
     int Index;
   for ( int index = 0; index <= len2 - len1; index++) {
  /* we check both size and intial positions */
     if (pos ==  initial) {
       for (Index = 0; Index < len1; Index++) {
         if (format[index + Index] != word[Index])
           break;
       }
  /* checking the len1 and the Indexes are equal or not */
       if (Index == len1)
         printf( ""PATTERN IS AT POSITION %d"", index + 1 );
 /*printing the position of word present in format text*/
     }
   }
 }
 int main() {
    char format[1000];
    printf(""enter the string format "");
    /* giving input text in string format */
    gets(format);
     char word[1000];
     printf(""give pattern "");
     /*giving the pattern for checking word in text*/
     gets(word);
   int max = 100,index=0,Index=0;
  /* getting the length stored in len1 for word*/ 
   int len1 = strlen(word);
 /*getting the length stored in len2 for format string*/  
   int len2 = strlen(format);
   int pos= 0, initial = 0, valuehash = 1, num=10;
   for (index = 0; index < len1- 1; index++){
     valuehash = (valuehash * num) % max;
   }
     hash(word, format, max , len1,pos, num, initial );
     checking(word, format, len2, len1, pos,  ini",C
"""""""
 BogoSort is also known as permutation sort, and/or stupid sort.
 Imagine throwing a pile of cards, and then search for 2 pre-determined cards.
 You pick 2 cards, match them if they are the ones you need, if not, you throw them back in the pile.
 Pick 2 cards again, match them till you get the required pair. Yes it is stupid, slow and depends upon Luck.
 
 The algorithm successively generates permutations of its input until it finds one that is sorted.
 """"""
 import time
 import random
 
 n = int(input(""Please Enter the number of Elements you want in Array: ""))
 # takes the whole line of n numbers
 arr = input(
     ""Enter the elements separated by a WhiteSpace, for e.g. <1 2 3 4 5>: "")
 final_array = list(map(int, arr.split(' ')))
 
 
 def is_sorted(data) -> bool:
     """"""
     Determine the Array is sorted or not.
     Returns: bool
     """"""
     return all(data[i] <= data[i + 1] for i in range(len(data) - 1))
 
 
 def bogo_sort(final):
     """"""
     Takes an array and applies Bogo Sorting algorithm it.
     """"""
     count = 0
     while not is_sorted(final):
         random.shuffle(final)
         print(""Shuffling the array randomly."")
         print(final)
         time.sleep(2)
         count += 1
     print(""\nObtained the sorted list (after {} round):"".format(count - 1))
     print(final)
 
 
 bogo_sort(final_array)
 
 
 """"""
 Test Case 1:
 
 Please Enter the number of Elements you want in Array: 4
 Enter the elements separated by a WhiteSpace, for e.g. <1 2 3 4 5>: 2 1 4 3
 Shuffling the array randomly.
 [3, 2, 4, 1]
 Shuffling the array randomly.
 [2, 1, 4, 3]
 Shuffling the array randomly.
 [1, 4, 3, 2]
 Shuffling the array randomly.
 [3, 2, 4, 1]
 Shuffling the array randomly.
 [2, 1, 3, 4]
 Shuffling the array randomly.
 [1, 4, 2, 3]
 Shuffling the array randomly.
 [2, 3, 1, 4]
 Shuffling the array randomly.
 [3, 4, 1, 2]
 Shuffling the array randomly.
 [1, 2, 3, 4]
 
 Obtained the sorted list (after 8 round):
 [1, 2, 3, 4]
 
 Process finished with exi",Python
"// C Program to find Binary Exponent Iteratively and Recursively.
 
 #include <stdio.h>
 
 // Iterative function to calculate exponent.
 
 int binExpo_iterate(int a, int b)
 {
     int res = 1;
     while (b > 0)
     {
         if (b % 2)
         {
             res = res * a;
         }
         a = a * a;
         b /= 2;
     }
     return res;
 }
 
 // Recursive function to calculate exponent.
 
 int binExpo_recurse(int a, int b)
 {
     if (b == 0)
     {
         return 1;
     }
     int res = binExpo_recurse(a, b / 2);
     if (b % 2)
     {
         return res * res * a;
     }
     else
     {
         return res * res;
     }
 }
 
 // Main function
 
 int main()
 {
     int a, b;
 
     scanf(""%d%d"", &a, &b);
 
     if (a == 0 && b == 0)
     {
         printf(""Math Error"");
     }
     else if (b < 0)
     {
         printf(""Exponent must be Positive"");
     }
     else
     {
         int resIterate = binExpo_iterate(a, b);
         int resRecurse = binExpo_recurse(a, b);
 
         printf(""%d"", resIterate);
         printf(""%d"", resRecurse);
     }
 }
",C
"/* 
 Code Description:
 A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations.
 Through this C program ,we pairwise swap elements in a given linked list.
 Following is the implementation of the same that swaps adjacent nodes pairwise and changes links instead of swapping data. 
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 /* Defining a Node */
 struct Node {
 	int data;
 	struct Node* next;
 };
 
 /* Declaration of Function to swap nodes at addresses a and b */
 void swap(int* a, int* b);
 
 /* Header points to first node and Last points to last one */
 struct Node *header,*last;
 
 /* Function to pairwise swap elements of a linked list */
 void pairWiseSwap()
 {
 	struct Node* temp = header;
 
 	/* Traverse further only if there are at-least two nodes available */
 	while (temp != NULL && temp->next != NULL) 
 	{
 		/* Swap the data of node with its next node's data */
 		swap(&temp->data, &temp->next->data);
 
 		/* Update temp by 2 for the next pair */
 		temp = temp->next->next;
 	}
 }
 
 /* Function for Swapping */
 void swap(int* a, int* b)
 {
 	int temp;
 	temp = *a;
 	*a = *b;
 	*b = temp;
 }
 
 /* Function to create a Linked List */
 void create()
 {
 	struct Node *temp=(struct Node*)malloc(sizeof(struct Node));
   	
  	printf(""Enter value of node : "");
  	
   	scanf(""%d"",&temp->data);
   	temp->next=NULL;
   	
     if (header==NULL)
   	{
     	header=temp;
     	last=temp;
     	return;
   	}
   	else
   	{
     	last->next=temp;
     	last=temp;
     	return;
   	}
 }
 
 /* Function to print nodes in a given linked list */
 void show()
 {
   	struct Node *temp=header;
   	while(temp!=NULL)
   	{
 		printf(""-->%d"",temp->data);
     	temp=temp->next;
   	}
 }
 
 /* Driver Function */
 void main()
 {
 	int i,num;
 	
 	printf(""Enter the number of nodes: "");
 	scanf(""%d"",&num);
 	
 	for(i=1;i<=num;i++)
 	create();
 	
 	printf(""\nLinked List is\n"");
 	show();
 	
 	printf(""\nLinked list after calling ",C
"/* WIGGLE SORT
    This program accepts an array of unsorted numbers and
    sorts the array such that arr[0]<arr[1]>arr[2]<arr[3]...
 
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void wiggle_sort(int n, vector<int> arr)
 {
     int left, right;
     //A new vector res is initialized to store sorted array
     vector<int> res(arr);
     //res is sorted with the built-in sort() function.
     sort(res.begin(), res.end());
 
     /*res is partitioned into two such that left sub-array 
       contains elements less than the elements in right sub-array*/
 
     // left points to the end of left sub-array 
     left = (n - 1) / 2;
     // right points to the end of right sub-array
     right = n - 1;
     
     //Elements in the left sub-array  are added to the even indices of vector res
     for (int k = 0; k < n; k += 2)
         // left is decremented
         arr[k] = res[left--];
 
     //Elements in the right sub-array are added to the odd indices of vector x
     for (int k = 1; k < n; k += 2)
         // right is decremented
         arr[k] = res[right--];
 
     cout << ""["";
     for (int i = 0; i < n; i++)
     { //for printing the wiggle sorted array
         cout << arr[i];
         if (i != n - 1)
             cout << "", "";
     }
     cout << ""]""
          << ""\n"";
 }
 
 int main()
 {
     int element, i, no_of_elements;
     cin >> no_of_elements;
     vector<int> arr;
     for (int i = 0; i < no_of_elements; i++)
     { //The given array is stored in a vector arr
         cin >> element;
         arr.push_back(element);
     }
     //to wiggle sort arr
     wiggle_sort(no_of_elements, arr);
     return 0;
 }
 
 /*1. Sample input:
      6
      1 3 2 2 3 1
      Sample output:
      [2,3,1,3,1,2]
 
   2. Sample input:
      10
      1 4 6 2 3 7 9 2 1 0
      [2, 9, 2, 7, 1, 6, 1, 4, 0, 3]
 */
 
 /*
    Time Complexity : O(nlogn)   (Sorting takes O(n logn) and traversal takes O(n))
    Space Complexity : O(n)   (New array to store the wiggle sor",C-Plus-Plus
"/*INSERTION SORT
 The array is virtually split into a sorted and an unsorted part. 
 Values from the unsorted part are picked and placed at the correct position in the sorted part.
 */
 #include <stdio.h>
 
 void insertion_sort(int[], int);
 int main()
 {
 	int arraySize, index, temp, key;
 	printf(""Enter the size of the array:"");
 	scanf(""%d"", &arraySize);
 	int arr[arraySize];	// declaring array by - 'arr'
 	printf(""Enter the elements to sort:"");
 	for (index = 0; index < arraySize; index++)
 	{
 		scanf(""%d"", &arr[index]);
 	}
 
 	insertion_sort(arr, arraySize);
 	printf(""Sorted Array:"");
 	for (index = 0; index < arraySize; index++)
 	{
 		printf(""%d "", arr[index]);
 	}
 
 	return 0;
 }
 
 // Function to sort the array using insertion sort method
 void insertion_sort(int arr[], int arraySize)
 {
 	int index, key, temp;
 	for (index = 1; index < arraySize; index++)
 	{
 		key = arr[index];	// the key stores the value at the index position
 		temp = index - 1;
 		while (temp >= 0 && arr[temp] > key)
 		{
 			arr[temp + 1] = arr[temp];
 			temp--;
 		}
 
 		arr[temp + 1] = key;
 	}
 }
 
 /*
 Sample Output
 Enter the size of the array:6
 Enter the elements to sort:17 8 9 0 2
 Sorted Arrray:0 2 8 9 17
 
 Complexities
 Time Complexity:O(n^2)
 Space Complexity:O(1)
 */
 
",C
"/**
 Given an array, fing the next lexicographical largest permutation
 **/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 vector<int> nextPermutation(vector<int> &A) {
     int k = A.size()-1;
     while(A[k-1] >= A[k] && k > 0)
         k--;
     if(k == 0)
         reverse(A.begin(), A.end());
     else {
         int t = A[k-1];
         int m = k;
         for(int i=k+1; i<A.size(); i++)
             if(A[i] > t && A[i] < A[k])
                 m = i;
         A[k-1] = A[m];
         A[m] = t;
         sort(A.begin()+k, A.end());
     }
     return A;
 }
 
 int main() {
     int n;
     cin >> n;
     vector<int> arr(n);
     for(int i = 0; i < n; i++)
         cin >> arr[i];
     nextPermutation(arr);
     cout << ""The next permutation of the array is : \n"";
     for(int i = 0; i < n; i++)
         cout << arr[i] << ' ';
     cout << '\n';
     return 0;
 }
 
 /**
 
 Input :
 6
 5 3 4 9 7 6
 Output :
 6
 5 3 4 9 7 6
 
 Time Complexity : O(nlogn)
 Space Complexity : O(n)
 
 **/",C-Plus-Plus
"class Graph:
     def __init__(self, vertices):
         self.V = vertices
         self.graph = []
 
     def add_edge(self, u, v, w):
         self.graph.append([u, v, w])
 
     # Search function
 
     def find(self, parent, i):
         if parent[i] == i:
             return i
         return self.find(parent, parent[i])
 
     def apply_union(self, parent, rank, x, y):
         xroot = self.find(parent, x)
         yroot = self.find(parent, y)
         if rank[xroot] < rank[yroot]:
             parent[xroot] = yroot
         elif rank[xroot] > rank[yroot]:
             parent[yroot] = xroot
         else:
             parent[yroot] = xroot
             rank[xroot] += 1
 
     #  Applying Kruskal algorithm
     def kruskal_algo(self):
         result = []
         i, e = 0, 0
         self.graph = sorted(self.graph, key=lambda item: item[2])
         parent = []
         rank = []
         for node in range(self.V):
             parent.append(node)
             rank.append(0)
         while e < self.V - 1:
             u, v, w = self.graph[i]
             i = i + 1
             x = self.find(parent, u)
             y = self.find(parent, v)
             if x != y:
                 e = e + 1
                 result.append([u, v, w])
                 self.apply_union(parent, rank, x, y)
         print(""Edge  : Weight"")
         for u, v, weight in result:
             print(""%d - %d : %d"" % (u, v, weight))
 
 if __name__ == '__main__':
   g = Graph(6)
   for i in range(8):
       src = int(input(""Source : ""))
       dest = int(input(""Destination : ""))
       weight = int(input(""Weight : ""))
       g.add_edge(src,dest,weight)
   
   g.kruskal_algo()
 
 
 '''
 Sample Input :
 Source : 0
 Destination : 1
 Weight : 4 
 Source : 0 
 Destination : 2 
 Weight : 4 
 Source : 1 
 Destination : 2 
 Weight : 2 
 Source : 2 
 Destination : 3 
 Weight : 3 
 Source : 2 
 Destination : 5 
 Weight : 2 
 Source : 2 
 Destination : 4 
 Weight : 4 
 Source : 3 
 Destination : 4 
 We",Python
"/*
 Linear probing is a collision resolution technique in hash tables, data structures 
 for maintaining a collection of keyvalue pairs and looking up the value associated 
 with a given key.
 In linear probing, we linearly probe for next empty slot in the hashtable for inserting an element
 */
 import java.util.Scanner;
 class Code{
     static int SIZE = 10;
     //hash function
     static int hashf(int val)
     {
         return val % SIZE;
     }
     //Linear Probing function inserts an element in the hashtable by linear probing
     static void LinearProbing(int ht[], int val)
     {
         int index = hashf(val);
         if (ht[index] == 0)
         {
             ht[index] = val;
         }
         else
         {
             int i = index;
             i = (i + 1) % SIZE;
             while (ht[index] != 0 && i != index)
             {
                 i = (i + 1) % SIZE;
             }
             if (ht[index] == 0)
             {
                 ht[index] = val;
             }
         }
     }
 
     //doesExists function searches the hashtable using Linear probing
     static int doesExist(int ht[], int val)
     {
         int index = hashf(val);
         if (ht[index] == val)
         {
             return 1;
         }
         int i = index;
         i = (i + 1) % SIZE;
         while (ht[index] != 0 && index != i)
         {
             if (ht[index] == val)
             {
                 return 1;
             }
             i = (i + 1) % SIZE;
         }
         return 0;
         //return 1 if exists and 0 if not
     }
 
     static void print(int ht[])
     {
         for (int i = 0; i < SIZE; i++)
         {
             System.out.println(i+"" ""+ht[i]);
         }
     }
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         int ht[] = new int[SIZE];
         for (int i = 0; i < SIZE; i++){
             ht[i] = 0;
         }
         int opt, val, exists;
         do
         {
 ",Java
"/* given a singly linked list of integers along with two integers, 'i,' and 'j.' 
 Swap the nodes that are present at the 'i-th' and 'j-th' positions.
 the nodes themselves must be swapped and not the datas.
 */
 
 #include <iostream>
 using namespace std;
 
 class Node {
   public:
     int data;
   Node * next;
   Node(int data) {
     this -> data = data;
     this -> next = NULL;
   }
 };
 
 // function to take input for linked list
 
 Node * takeinput() {
   int data;
   cin >> data;
   Node * head = NULL, * tail = NULL;
   while (data != -1) {
     Node * newnode = new Node(data);
     if (head == NULL) {
       head = newnode;
       tail = newnode;
     } else {
       tail -> next = newnode;
       tail = newnode;
     }
     cin >> data;
   }
   return head;
 }
 
 // funtion to print the linked list
 
 void print(Node * head) {
   Node * temp = head;
   while (temp != NULL) {
     cout << temp -> data << "" "";
     temp = temp -> next;
   }
   cout << endl;
 }
 
 // funtion to swap the nodes of linked list
 
 Node * swapNodes(Node * head, int i, int j) {
   int pos = 0;
   Node * tail = head;
   Node * prevFirst = NULL;
   Node * prevSecond = NULL;
   int first = (i < j) ? i : j;
   int second = (i + j) - first;
   while (tail != NULL) {
     if (pos == first - 1)
       prevFirst = tail;
 
     if (pos == second - 1)
       prevSecond = tail;
 
     tail = tail -> next;
     pos++;
   }
   if (first == 0 && prevSecond != NULL && prevSecond -> next != NULL) {
 
     if (second != first + 1) {
       Node * temp1 = head;
       Node * temp2 = prevSecond -> next -> next;
 
       head = prevSecond -> next;
       prevSecond -> next -> next = temp1 -> next;
       prevSecond -> next = temp1;
       temp1 -> next = temp2;
 
       return head;
     } else {
       Node * temp = head;
       Node * temp2 = head -> next -> next;
 
       head = head -> next;
       head -> next = temp;
       temp -> next = temp2;
 
       return head;
     }
   }
   if (prevFirs",C-Plus-Plus
"/*
 
 A stack is a data structure that follows the Last in, First out principle (i.e. the last added elements are removed first).
 Generally, a stack is implemented using an array but a linked list approach can be used. Below is the implementation of a stack using a linked list ( Singly Linked List ).
 
 In this program, the user can provide a choice to perform operations on a stack. It is created using an ES6 class syntax. 
 prompt & colors are node packages for taking user input and displaying text in different colors respectively. 
 
 */
 
 const prompt = require(""prompt-sync"")({ sigint: true });
 const colors = require(""colors"");
 
 // Setting the Color schema
 colors.setTheme({
   display: ""green"",
   insert: ""white"",
   delete: ""red"",
   leave: ""yellow"",
   end: ""rainbow"",
   wrong: ""america"",
 });
 
 // Creating the node class to create nodes
 class Node {
   constructor(value, next = null) {
     this.value = value;
     this.next = next;
   }
 }
 
 // Creating a Stack class to perform operations
 class Stack {
   constructor() {
     this.top = null;
     this.bottom = null;
     this.length = 0;
   }
 
   // Push element into the stack
   push(value) {
     const newNode = new Node(value);
     if (this.length === 0) {
       this.top = newNode;
       this.bottom = newNode;
       this.length++;
 
       return this;
     }
 
     const holdingPointer = this.top;
     this.top = newNode;
     this.top.next = holdingPointer;
     this.length++;
     return this;
   }
 
   // Get topmost element of stack
   peek() {
     if (this.length === 0) return console.log(""Nothing to look for"");
     return console.log(this.top.value);
   }
 
   // Check whether the stack is empty or not
   isEmpty() {
     if (this.length === 0) return console.log(""Yes, it's Empty here"");
     return console.log(""There is something inside, not void for sure"");
   }
 
   // Pop element form the stack
   pop() {
     if (!this.top) return console.log(""Nothing to pop"");
     let pop",JavaScript
"/*
 A number is said to be a Harshad Number if it is divisible by the sum of its digits.
 For example: The number 84 is divisible by the sum (12) of its digits (8, 4).
 */
 
 import 'dart:io';
 
 // Check if a number is a Harshad number
 bool isHarshad(int number) {
   int sum = 0;
   int copy = number;
 
   // Seperate individual digits and add to sum
   while (number > 0) {
     int digit = number % 10;
     number ~/= 10;
     sum += digit;
   }
 
   // Check if number is divisible by sum
   if (copy % sum == 0) {
     return true;
   }
   return false;
 }
 
 // Main Function, with driver code
 void main() {
   print(""Enter a number:"");
   int input = int.parse(stdin.readLineSync()!);
 
   // Call isHarshad function
   if (isHarshad(input)) {
     print(""$input is a Harshad Number"");
   } else {
     print(""$input is not a Harshad Number"");
   }
 }
 /**
 Time Complexity: O(log(n))
 Space Complexity: O(1)
 
 Sample Input/Output
 Enter a number:
 18
 18 is a Harshad Number
 
 Enter a number:
 123
 Sum of digits in 123 is 6
 */
 
",Dart
"/* This program prints post order traversal of a tree. In post order,
 the traversal is done as : (left, right, root). */
 
 package main
 
 import (
 	""fmt""
 )
 
 // Structure of a node in the tree
 type Node struct {
 	/* Every node has a data, pointer to its
 	left child and also right child.*/
 	data int
 	left *Node
 	right *Node
 }
 
 
 
 /* This function prints thre post order traversal of
 the tree recursively.*/
 func post_order(root *Node) {
 
 	// If we reach the end, return
 	if(root == nil) {
 		return
 	}
 	// Call the function for left half
 	post_order(root.left)
 	// Then, call for the right half
 	post_order(root.right)
 
 	// Print the data
 	fmt.Print(root.data, "" "")
 }
 
 // This function creates a new node
 func new_node(value int) *Node {
 	// It takes data to be stored as parameter
 	return &Node{value, nil, nil}
 }
 
 // This function forms the tree using the user input
 func form_tree(array []int) *Node {
 
 	/* The user input is considered as level
 	order traversal of the tree. This function
 	returns pointer to the root of the tree.*/
 
 	// This array contains all nodes in the tree
 	a := make([]*Node , len(array))
 	for i := 0; i < len(array); i++ {
 		a[i] = new_node(array[i])
 	}
 
 	// Below are some base cases for 1, 2, 3, 4 nodes
 
 	// If there is only one node return the node
 	if(len(array) == 1) {
 		return a[0]
 	}
 
 	// If there are two nodes
 	a[0].left = a[1]
 	if(len(array) == 2) {
 		// Point the second node to first and return
 		return a[0]
 	}
 
 	// If there are three nodes
 	a[0].right = a[2]
 	if(len(array) == 3) {
 		// Make a binary tree and return root node
 		return a[0]
 	}
 
 	// If there are four nodes
 	if(len(array) == 4) {
 		a[1].left = a[3]
 		return a[0]
 	}
 
 	// If there are more than four nodes
 	for i := 1; i < len(array); i++ {
 
 		// Point  each node to its left and right child
 		a[i].left = a[2*i + 1]
 		a[i].right = a[2*i + 2]
 
 		// If we reach the end, return root node
 		if(2*i + 2 == l",Go
"""""""
 In mathematics, matrix addition is the operation of adding two matrices by adding 
 the corresponding entries together.This program takes two matrices of order r*c and 
 stores it in two-dimensional array. Then, the program adds these two matrices and 
 displays it on the screen.
 """"""
 
 Row_1 = int(input(""Enter the number of rows for first matrix : ""))
 Col_1 = int(input(""Enter the number of columns for first matrix : ""))
 
 matrix_1 = []
 print(""Enter the entries rowwise:"")
 for i in range(Row_1):
     matrix_1.append([int(x) for x in input().split("" "")])
 
 Row_2 = int(input(""Enter the number of rows for second matrix : ""))
 Col_2 = int(input(""Enter the number of columns for second matrix : ""))
 
 matrix_2 = []
 print(""Enter the entries rowwise:"")
 for i in range(Row_2):
     matrix_2.append([int(x) for x in input().split("" "")])
 
 result = [[0 for i in range(Col_2)] for j in range(Row_1)]
 # Adding both matrices and storing in result
 for i in range(Row_1):
     for j in range(Col_2):
         result[i][j] = matrix_1[i][j] + matrix_2[i][j]
 
 print(""The result of the matrix Addition is"")
 for i in range(Row_1):
     for j in range(Col_2):
         print(result[i][j], end="" "")
     print()
 
 """"""
 Sample I/O :
 
 Enter the number of rows for first matrix : 3
 Enter the number of columns for first matrix : 3
 Enter the entries rowwise:
 1 2 3
 4 5 6
 7 8 9
 Enter the number of rows for second matrix : 3
 Enter the number of columns for second matrix : 3
 Enter the entries rowwise:
 1 2 3
 4 5 6
 7 8 9
 The result of the matrix Addition is
 2 4 6
 8 10 12
 14 16 18
 
 Time complexity : O(n^2)
 Space complexity : O(n^2)
 """"""
",Python
"/*Kadane's Algorithm implementation
 We use Kadane's algorithm when we need to find Maximum Array Sum .
 The subarrays consist of both positive and negative numbers. Also it can be
 modified to solve the variations as well */
 # include <bits/stdc++.h>
 using namespace std;
 
 int kadane_1(int arr[], int arr_len)
 {
 	int max_sum = INT_MIN;
 	int curr_sum = 0;
 
 	for (int ind = 0; ind < arr_len; ind++)
 	{
 		// take sum of all the elements in the array
 		curr_sum += arr[ind];
 		//for maximum sum subarray when we comes across negative numbers the sum
 		// made 0 as it reduces the sum
 		if (curr_sum < 0)
 			curr_sum = 0;
 		max_sum = max(curr_sum, max_sum);
 	}
 	return max_sum ;
 }
 // we can also implement kadane's algorithm by storing current maximum sum and
 // taking maximum of current sum + a[i] and a[i] in place of reducing negative sum to 0
 int kadane_2(int arr[], int arr_len)
 {
 	int curr_sum_arr[arr_len];
 	curr_sum_arr[0] = arr[0];
 	for (int ind = 1; ind < arr_len; ind++) {
 		curr_sum_arr[ind] = max(arr[ind], (curr_sum_arr[ind - 1] + arr[ind]));
 	}
 	int ans = INT_MIN;
 	for (int ind = 0; ind < arr_len; ind++)
 	{
 		ans = max(ans, curr_sum_arr[ind]);
 	}
 	return ans;
 }
 int main()
 {
 	int arr_len; // length of array
 	cin >> arr_len;
 	int arr[arr_len];
 	for (int ind = 0; ind < arr_len; ind++)
 		cin >> arr[ind];
 	cout << kadane_1(arr, arr_len);
 	cout << '\n';
 	cout << kadane_2(arr, arr_len);
 	cout << '\n';
 
 	return 0;
 }
",C-Plus-Plus
"/*
   Code Implementation of Diameter of Binary Tree(Recursive Approach)
   
   Definition:-The diameter of a binary tree (sometimes called the width) is the number of nodes
   on the longest path between two end nodes.
 
    Approach of solving:-Diameter of a tree can be calculated by utilizing the property that
    the diameter of a tree is nothing but maximum value of (left_height + right_height + 1) for each node.
    So we need to calculate this value (left_height + right_height + 1) for each node and update the result. 
    
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //User-define Tree structure
 struct  Tree {
     int data;
     Tree* left, *right;
 };
 
 struct Tree* CreateNode(int data)
 {
     struct Tree* node = new Tree;
     node->data = data;
     node->left = NULL;
     node->right = NULL;
  
     return (node);
 }
 
 int height(struct Tree* node)
 {
      //  case 1:- when Tree is empty
     if (node == NULL)
     {
          return 0;
     }
     //Case 2:- height would be 1+max(height of left tree,height of right tree)
     return 1 + max(height(node->left), height(node->right));
 }
 
 int Diameter(struct Tree* node)
 {
     //  case 1:- when Tree is empty
     if (node == NULL)
     {
         return 0;  
     }      
     //  Finding the  diameter of left and right sub-trees
     int leftdiameter = Diameter(node->left);
     int rightdiameter = Diameter(node->right);
   
     // Finding the height of left and right sub-trees
     int leftheight = height(node->left);
     int rightheight = height(node->right);
     /* 
       Result is nothing but the maximum of diameter of left,right  subtrees and 
       height of left subtree + height of right subtree + 1;
     */
     return max(leftheight + rightdiameter + 1, max(leftdiameter, rightdiameter));
 }
 
 int main()
 {  
     //Creating a random binary tree 
     struct Tree* root = CreateNode(1);
     root->left = CreateNode(4);
     root->right = CreateNode(9);
     root->left->lef",C-Plus-Plus
"""""""
 Purpose: Given a binary matrix of N*M order where 0 is the wall and 1 is the way.
         Find the shortest distance from a source cell to a destination cell,
         traversing through limited cells only. Also, you can move only
         up, down, left and right. If found then print the distance and
         path in separate lines, else return -1.
 
 """"""
 from heapq import heappop, heappush
 
 
 def Dijkstra(maze, src, des, way=1):
 
     # Dimention of the maze
     n = len(maze)
     m = len(maze[0])
 
     # To keep a track of visited nodes, also mark source as visited
     visited = [[False] * m for i in range(n)]
     distance = [[float('inf')] * m for i in range(n)]
 
     # All possible moves from a cell
     moves = {(1, 0): 'D', (-1, 0): 'U', (0, 1): 'R', (0, -1): 'L'}
 
     x, y = src
     distance[x][y] = maze[0][0]
     visited[x][y] = True
 
     cur_pos = [(x, y)]
     parent = {}
 
     while True:
         boo = False
         hp = []
         for i in cur_pos:
             x, y = i
 
             # If the node is destination, calculate the path and return
             if (x, y) == des:
                 path = ''
                 dis = distance[x][y]
                 cur = (x, y)
 
                 # Calculate the path by backtracking with the parent dict
                 while cur != src:
                     prev_move = parent[cur]
                     m = (cur[0] - prev_move[0], cur[1] - prev_move[1])
                     path += moves[m]
                     cur = prev_move
 
                 # Return the distance and path
                 return dis, path[::-1]
 
             for j in moves.keys():
                 r = x + j[0]
                 c = y + j[1]
 
                 # If the next node inside the maze , has a way and not yet visited
                 # then mark it visited and push it in the queue
                 if 0 <= r < n and 0 <= c < m and maze[r][c] == way and not visited[r][c]:
                     visited[r][c] = True
",Python
"/*Below is an implementation of Burrows Wheeler Transform in C. It restructures
 the given plaintext to forms the ciphertext. It first forms all possible cyclic
 rotations of the plaintext, and then sorts the rotations lexicographically. Then,
 ciphertext is formed by taking the last character of each rotation sorted in
 lexicographical order. This code is implemented keeping in mind that characters
 in the plaintext are all unique.*/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 // Define maximum length of plaintext, ciphertext
 #define MAXLENGTH 100
 
 // Define size of plaintext
 #define size 6
 
 // This function generates all cyclic rotations of given plaintext
 void generate(char* plaintext, char combinations[][size]) {
 
 	int index = 0;
 	for(int i = 0; i < size; i++) {
 		for(int j = 0; j < size; j++) {
 			// Mod is used to wrap around the index
 			combinations[i][j] = plaintext[(index + j) % size];
 		}
 		index += 1;
 	}
 }
 
 // This function sorts the above rotations lexicographically.
 void sort(char* plaintext, char combinations[][size], int arr[size]) {
 
 	// Calling the generate function to generate all rotations
 	generate(&plaintext[0], combinations);
 
 	int count = 0;
 	int k = 0;
 
 	while(k < size) {
 
 		// Iterate through the first column
 		for(int i = 0; i < 1; i++) {
 			/* Char { is lexicograqphically greater than
 			[A-Z] and [a-z]. So, we use it here as a maximum.*/
 			char min = '{';
 			int index;
 
 			// Iterate though first element of each row
 			for(int j = 0; j < size; j++) {
 				if(combinations[j][i] < min) {
 					// Find the minimum
 					min = combinations[j][i];
 					// Store its index
 					index = j;
 				}
 			}
 			// Add the index to the array
 			arr[count++] = index;
 			// Replace the minimum with {
 			combinations[index][i] = '{';
 		}
 		k++;
 	}
 }
 
 // This is the encrpytion function
 char* encrypt(char* plaintext, char combinations[][size]) {
 
 	int arr[size];
 
 	// Calling the ",C
"#= Given a number N check if it is a power of 2 in O(1). We will be 
 using bitwise operator to get the calculation.=#
 
 ## Function
 
 function isPowerOfTwo(n)
     return (n & (n - 1) == 0)
 end
 
 ## Input
 
 println(""Enter the number : "")
 n = readline()
 n = parse(Int64, n)
 
 ## Calling the function
 
 if (isPowerOfTwo(n))
     println(""Its a power of 2"")
 else
     println(""Its not a power of 2"")
 end
 
 #=
 Sample Test Case
 Input: 
     Enter a number : 4294967296
 Output:
     Its a power of 2
 Time complexity: O( 1 ) 
 =#
",Julia
"''' This program written in Python checks if a number is a perfect
 number. A perfect number is a number which is equal to the sum of
 its divisors (excluding the number itself).'''
 
 # This function checks if a number is a perfect number
 def is_perfect(n):
 
     # This variable stores the sum of divisors of number
     sum_of_divisors = 0
     # Iterate from 1 till the number
     for i in range(1, n):
         if(n % i == 0):
             # Add divisors
             sum_of_divisors += i
 
     # If the sum of divisors is equal to the number
     if(sum_of_divisors == n):
         return 1
 
     # Else return -1
     return -1
 
 if __name__ == '__main__':
 
     # Take number as input from the user
     number = int(input(""Enter a number to check if it's a perfect number: ""))
 
     # If the number is non-positive, exit
     if(number <= 0):
         print(""\nPlease enter a positive number."")
     else:
         # Call the function
         result = is_perfect(number)
 
         # If the result is 1, the number is a perfect number
         if(result != -1):
             print(""\nThe number "" + str(number) + "" is a perfect number."")
         else:
             # Else it is not
             print(""\nThe number "" + str(number) + "" is not a perfect number."")
 
 '''
 Sample I/O:
 
 1)
 Enter a number to check if it's a perfect number: 28
 
 The number 28 is a perfect number.
 
 2)
 Enter a number to check if it's a perfect number: -16
 
 Please enter a positive number.
 
 Time Complexity - O(n)
 Space Complexity - O(1)
 
 '''
 
",Python
"import java.util.List;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.ListIterator;
 import java.util.Scanner;
 
 /**
  * <h1>Columnar</h1>
  * <p>
  * Columnar class acts as a custom Data Structure which consits of a List of Characters.
  * </p>
  */
 class Columnar
 {
     List<Character> characterList;
 }
 
 /**
  * <h1>Simple Columnar Transposition Cipher With Multiple Rounds</h1>
  * <p>
  * To Implement Simple Columnar Transposition Cipher With Multiple Rounds
  * </p>
  * <b>Description</b>
  * <p>
  * class SimpleColumnarTranspositionWithMultipleRoundsCipher is used to encrypt plainText to cipherText using Columnar
  * Transposition and decrypt cipherText to plainText using the respective algorithm, Simple Columnar Transposition is a
  * variation of Transposition technique just like Rail Fence Cipher
  * </p>
  * <b>Requirements</b>
  * <p>
  * A string plain text and a string key are required for encryption and for decryption the cipher text which is
  * calculated from the given key and the key itself.
  * </p>
  */
 public class SimpleColumnarTranspositionWithMultipleRoundsCipher
 {
     /**
      * <p>
      * This is a private method used to validate the key provided by the user.
      * </p>
      * <b>Validation Scheme</b>
      * <p>
      * There must be NO occurance of repetative characters in a string, occurance of repetative characters can lead to
      * malfunctioning of the code and algorithm leading to mismatched output.
      * </p>
      * <p>
      * Thou same letters with different cases(UpperCase and LowerCase) can be accepted.
      * </p>
      * <p>
      * Example: AaZ can be a valid key, but AAZ will not be considered as a valid key.
      * </p>
      * 
      * @param key This is a String parameter to validateKey method, this signifies key which is passed to perform encryption
      *            and decryption.
      * 
      * @return Boolean Tells whether the key entred is a valid key or not
      */
 ",Java
"/*C program to find Minimum Element in a Stack in Constant Time i.e O(1).
     Maintain an additional stack that will keep track of the minimum element
     of the Original Stack.
 
     Every push to the primary STACK, compare the current value
     with the TOS of the temporary Stack and IF the current value is less
     than the TOS push the current value to the temporary STACK,such that
     the minimum element is always at the top of the STACK
 
 */
 
 #include <stdio.h>
 #include <malloc.h>
 
 typedef struct Node {
   int value;
   struct Node *next;
 } Node;
 
 /* Stack1 pointer points to the original stack and stack2 pointer
    points to the temporary stack which will hold the minimum values
 */
 Node *stack1 = NULL, *stack2 = NULL;
 
 // check whether stack is empty or not
 int isEmpty(Node *head) {
   // When stack-1 is empty return true
   if (head == NULL) {
     return 1;
   }
   return 0;
 }
 
 // Dynamically generate the node
 Node *gen_node(int val) {
   Node *newnode;
   newnode = (Node *)malloc(sizeof(Node));
   if (newnode == NULL) {
     printf(""\nMemory was not allocated"");
     return 0;
   } else {
     newnode->value = val;
     newnode->next = NULL;
     return newnode;
   }
 }
 
 // Returns the top of the temporary stack
 int peek() {
   int topVal;
   if (stack2 != NULL) {
     topVal = stack2->value;
   }
   return topVal;
 }
 
 // Push the element at the top of the stack
 void push() {
   int val;
   Node *newNode, *temp;
   scanf(""%d"", &val);
   newNode = gen_node(val);
 
   if (stack1 == NULL) {
     stack1 = newNode;
     stack2 = newNode;
     stack1->next = stack2->next = NULL;
   } else {
     /* IF passed value is less than TOS of the temporary stack i.e stack2
         push the value,such that minimum element is always at the TOS of stack2
     */
     if (val <= peek()) {
       temp = stack2;
       stack2 = newNode;
       stack2->next = temp;
     }
 
     // Push data to original stack i.e stack1
     temp = stack1;
     st",C
"/*
 PROBLEM STATEMENT:
 Given a floor of size 2Xn and tiles of size 2X1. We've to find the number number of ways in which the floor can be tiled using tiles of size 2X1. 
 A tile can be either placed horizontally or vertically.
 */
 
 #include<stdio.h>
 
 int NoOfWays(int n){
 	int tiles[n+1];
 	for(int i = 0; i <= n; i++){
 		//Base cases
 		if(i == 0)
 			tiles[i] = 0;
 		else if(i == 1)
 			tiles[i] = 1;
 		//Adding the solutions that we get by placing first tile vertically and by placing first tile horizontally 
 		else
 			tiles[i] = tiles[i-1] + tiles[i-2];
 	}
 	//returning the ways in which floor of size 2Xn can be tiled
 	return tiles[n];
 }
 
 //Driver function
 int main(){
 	int n;
 	printf(""Enter value of n: "");
 	scanf(""%d"",&n);
 	printf(""Total no. of ways in which floor of size 2X%d can be tiled are: %d"", n, NoOfWays(n));
 	return 0;
 }
 
 /*
 TEST CASE:
 Input: 4
 Output: 3
 
 TIME COMPLEXITY: O(n), due to the single for loop used
 SPACE COMPLEXITY: O(n), due to the additional dp array created
 where 'n' denotes the breadth of the floor as entered by the user
 */
",C
"/*
    This is a simple programe in go language to search for a given element in
    an array/list given. First we find a range we need to search for and then 
    we do a binary search on the that range to arrive at our element. If we find
    the element we return the index position else we give a message missing.
 
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 // Global variables
 var number int
 var array[100] int
 var x int
 
 // function to print the index and message
 func printfunction(checker int) {
 
     if(checker == -1){
        fmt.Print(""The entered element is not found"");
     }else {
        fmt.Print(""The entered element is at the index position : "",checker)
     }
 }
 
 //this function returns the minimum of given 2 numbers
 func min(x,y int) int{
 
    if(x<y){
      return x
    }else{
      return y
    }
 }
 
 // We do binary search using this function
 func binarysearch(l,r int) int{
 
    if(r<l){
       return -1
 
    }else if(r>=l) {
 
    mid := (l+r)/2
 
    if(array[mid] == x) {
       return mid
    }
 
    if(array[mid] > x) {
       return binarysearch(l,mid-1)
    }
 
    return binarysearch(mid+1, r)
 
    }
    return -1
 }
 
 // This function helps us to find the range we search for
 func exponentialsearch() int{
 
    if(array[0] == x) {
         return 0
    }
 
    i := 1;
    for(i<number && array[i]<=x) {
         i = i*2
    }
 
    minimum := min(i, number-1)
 
    return binarysearch(i/2,minimum)
 }
 
 // driver function
 func main() {
 
    var n int
    fmt.Print(""Enter the number of elements :"")
    fmt.Scan(&number)
 
    fmt.Print(""Enter the elements of the array in sorted manner :"")
    for i:=0;i<number;i++ {
        fmt.Scan(&n)
        array[i] = n
    }
 
    fmt.Print(""Enter the element you want to search for :"")
    fmt.Scan(&x)
 
    checker := exponentialsearch()
    printfunction(checker)
 }
 
 /*
    Sample I/O :
 
    Enter the number of elements :5
    Enter the elements of the array in sorted mann",Go
"/*
 Catalan numbers is a number sequence, which is found useful in a number of
 combinatorial problems, often involving recursively-defined objects.
 */
 
 #include <iostream>
 using namespace std;
 
 // To find nth catalan number using recursive function
 unsigned long int catalan(unsigned int n)
 {
 
   if (n <= 1)
     return 1;
   unsigned long int res = 0;
   for (int i = 0; i < n; i++)
     res = res + catalan(i) * catalan(n - i - 1);
 
   return res;
 }
 
 int main()
 {
   cout << ""Enter the Number:"" << endl;
   int n;
   cin >> n;
   for (int i = 0; i < n; i++)
   {
     cout << catalan(i) << "" "";
   }
   cout << endl;
   return 0;
 }
 
 /*
 Input:
 Enter the Number:
 15
 Ouput:
 1 1 2 5 14 42 132 429 1430 4862 16796 58786 208012 742900 2674440
 
 Time Complexity: O(2^n)
 Space Complexity: O(1)
 */",C-Plus-Plus
"/* Below program checks if a number is a mystery number. 
 Mystery number - A number that can be represented by sum
 of two numbers, such that the two numbers are reverse of
 each other.*/
 
 import java.util.*;
 import java.lang.*;
 
 public class MysteryNumber {
 
 	/* This function takes a number as a input and
 	returns	a number with the digits reversed*/
 	static int reverse(int number) {
 
 		int rev = 0;
 		while(number != 0) {
 			rev *= 10;
 			rev += number % 10;
 			number = number / 10;
 		}
 		return rev;
 	}
 
 	// This function checks if the number is a mystery number
 	static int isMystery(int number) {
 
 		// We iterate till the middle of the number
 		for(int i = 1; i <= number / 2; i++) {
 
 			// Find reverse of current iteration value
 			int rev = reverse(i);
 			// Check the sum of number with its reverse
 			if(i + rev == number) {
 				// If its is equal to the given number we return and print
 				System.out.println(""\nThe two digits are: "" + i + "" "" + rev);
 				return 1;
 			}
 		}
 		// Else return -1
 		return -1;
 	}
 
 	public static void main(String args[]) {
 
 		// Taking number as input from the user
 		Scanner scan = new Scanner(System.in);
 		System.out.print(""Enter the number: "");
 		int number = scan.nextInt();
 		scan.close();
 
 		// Calling the mystery function
 		int result = isMystery(number);
 
 		// If the result is 1, the number is a mystery number
 		if(result == 1) {
 			System.out.println(""The given number "" + number + "" is a Mystery number."");
 		}
 
 		// Else it is not a mystery number
 		else {
 			System.out.println(""\nThe given number "" + number + "" is not a Mystery number."");
 		}
 	}
 }
 
 /*
 Sample I/O:
 
 1)
 Enter the number: 343
 
 The two digits are: 122 221
 The given number 343 is a Mystery number.
 
 2)
 Enter the number: 3214
 
 The given number 3214 is not a Mystery number.
 
 */
",Java
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# NASA ASTEROIDS CLASSIFICATION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [Asteroid Details](https://www.kaggle.com/shrutimehta/nasa-asteroids-classification)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import numpy as np\n"",
     ""from sklearn import preprocessing  \n"",
     ""from statsmodels.stats.outliers_influence import variance_inflation_factor\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.naive_bayes import GaussianNB\n"",
     ""import matplotlib.pyplot as plt\n"",
     ""from scipy import stats\n"",
     ""import seaborn as sns\n"",
     ""from sklearn.metrics import confusion_matrix""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting our Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n"",
        ""<table border=\""1\"" class=\""dataframe\"">\n"",
        ""  <thead>\n"",
        ""    <tr style=\""text-align: right;\"">\n"",
        ""      <th></th>\n"",
        ""      <th>Neo Reference ID</th>\n"",
        ""      <th>Name</th>\n"",
        ""      <th>Absolute Magnitude</th>\n"",
        ""      <",Python
"/*
 You have to paint N boards of length {A0, A1, A2, A3  AN-1}. There are K 
 painters available and you are also given how much time a painter takes to
  paint 1 unit of board. You have to get this job done as soon as possible
  under the constraints that any painter will only paint contiguous sections
   of board. Return the ans % 10000003
 
 Input Format
 First line contains three space seperated integers N,K and T ,where
 N = Size of array,
 K = No of painters available ,
 T = Time taken to print each board by one painter
 Next line contains N space seperated positive integers denoting size of N boards.
 
 Constraints
 1<=N<=100000
 1<=K<=100000
 1<=T<=1000000
 1<=Li<=100000
 
 Output Format
 Return minimum time required to paint all boards % 10000003.
 
 Sample Input
 2 2 5
 1 10
 Sample Output
 50
 Explanation
 The first painter can paint the first board in 5 units of time and the second painter 
 will take 50 units of time to paint the second board. Since both can paint simultaneously,
  the total time required to paint both the boards is 50.
 */
 
 #include<iostream>
 #include <bits/stdc++.h>
 using namespace std;
 
 bool painters(int* arr,long long int maxtime,int n,int k)
 {
 	long long int time=0;
 	int p_used=1;
 	for(int i=0;i<n;i++)
 	{
 		time += arr[i];
 		if(time > maxtime)
 		{
 			time=arr[i];
 			p_used++;
 			if(p_used>k)
 			{
 				return false;
 			}
 		}
 	}
 	return true;
 }
 
 long int minimum_time(int* arr,int n ,int k,int t,long long int sum)
 {
 	long long int start = *max_element(arr, arr + n);
 	long long int end   = sum;
 	long long int ans;
 	while(start<=end)
 	{
 		long long mid = (start+end)/2;
 		if(painters(arr,mid,n,k))
 		{
 			ans=mid;
 			end=mid-1;
 		}
 		else
                 {
                         start=mid+1;
                 }
         }
         return (ans*t)%10000003;
 }
 
 int main()
 {
 	int n,k,t;
 	long long int sum=0;
 	cin>>n>>k>>t;
 	int* arr=new int[n];
 	for(int i=0;i<n;i++)
         {
 	       	cin",C-Plus-Plus
"/*Problem: Given array of strings, find the longest common prefix present in all the strings.
 Print the longest common prefix. If no common prefix is present, then print empty string ("""").
 
 Approach: Comparing characters of the same column in all the strings. If the character does not much
 or the string ends at that column, algorithm will retun lcp till that point.
 
 Time complexity:O(S) where S is the number of all the characters in all strings.
 Space complexity: O(1)
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 string solve(int n, string *strs)
 {
     string lcp = """";
     char cur_car;
     int j = 0;
     if (n == 0)
     {
         return """";
     }
     while (1)
     {
         if (strs[0] == """")
         {
             return """";
         }
         if (strs[0][j] == '\0')
         {
             return lcp;
         }
         else
         {
             cur_car = strs[0][j];
         }
         for (int i = 1; i < n; i++)
         {
             if (strs[i] == """")
             {
                 return """";
             }
             if (strs[i][j] == '\0' || strs[i][j] != cur_car)
             {
                 return lcp;
             }
         }
         lcp += cur_car;
         j++;
     }
     return lcp;
 }
 
 int main()
 {
     //input
     //number of strings in array
     cout << ""Enter number of strings:"" << endl;
     int n;
     cin >> n;
     string *strs = new string[n];
     //enter strings
     cout << ""Enter the strings:"" << endl;
     for (int i = 0; i < n; i++)
     {
         cin >> strs[i];
     }
 
     string lcp = solve(n, strs);
     if (lcp == """")
     {
         cout << ""No common prefix"";
     }
     else
     {
         cout << ""Longest Common Prefix is: "" << lcp;
     }
 }
 
 /*
 Sample input:
 ""apple"", ""appology"", ""apps""
 
 Sample output:
 ""app""
 */",C-Plus-Plus
"/*
 Euler's totient function, also known as phi-function (n), counts the
 numberof integers between 1 and n inclusive, which are coprime to n.
 */
 #include <stdio.h>
 
 void Euler_Totient(int, int[]);
 int main()
 {
 	int n, phi[100];
 	printf(""Enter an integer: "");
 	scanf(""%d"", &n);
 	Euler_Totient(n, phi);
 	printf(""\nThe euler totient function for all integers from 1 to %d is:\n"", n);
 	for (int i = 1; i <= n; ++i)
 	{
 		printf(""%d: %d\n"", i, phi[i]);
 	}
 
 	return 0;
 }
 
 // Function whuch counts number of integers between 1 to n which are co-prime to n
 void Euler_Totient(int n, int phi[])
 {
 	int temp = n;
 	//This gives euler totient function for N
 	// Time Complexity: O(N*root(N))
 	int ans = n;
 	for (int i = 2; i <= n; ++i)
 	{
 		if (n % i == 0)
 		{
 			ans = ans - ans / i;
 			while (n % i == 0)
 				n /= i;
 		}
 	}
 
 	if (n > 1)
 	{
 		ans = ans - ans / n;
 	}
 
 	n = temp;
 	printf(""\nThe euler totient function for %d is: %d"", n, ans);
 
 	//This gives euler totient function from 1 to N
 	// Time Complexity: O(N loglogN) - same as Sieve of Eratosthenes
 	for (int i = 0; i <= n; ++i)
 	{
 		phi[i] = i;
 	}
 
 	for (int i = 2; i <= n; ++i)
 	{
 		if (phi[i] == i)
 		{
 			for (int j = i; j <= n; j += i)
 			{
 				phi[j] = phi[j] - phi[j] / i;
 			}
 		}
 	}
 }
 
 /*
 Time Complexity: O(N loglogN)
 
 OUTPUT
 Enter an integer: 10
 The euler totient function for 10 is: 4
 The euler totient function for all integers from 1 to 10 is:
 1: 1
 2: 1
 3: 2
 4: 2
 5: 4
 6: 2
 7: 6
 8: 4
 9: 6
 10: 4
 
 -----
 (1,3,7,9) are coprime to 10
 */
 
",C
"/*
 Given a sequence of matrices, find the most efficient way to multiple these matrices together. 
 We have to find the way which costs minimum.
 Let's asssume two matrices are there of order 10X30 and 30X20 so cost of multiplication of them will be 10*30*20 ,
 we will take the common order element only once .
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 int t[1001][1001];
 int solve(int arr[], int i, int j) {
   /*
    If there is no element in the array then we don't have any matrix .
    If there is only one element in the array then we can't find the order of the matrix as order of matrix at ith index is arr[i-1]*arr[i].
    */
   if (i >= j) {
     return 0;
   }
 
   memset(t, -1, sizeof(t));
   if (t[i][j] != -1) {
     return t[i][j];
   }
 
   int ans = INT_MAX;
   /* moving from first matrix which will be at index 1 and its order will be arr[0]*arr[1]
     to last matrix which will be at index n-2 and its order will be arr[n-3]*arr[n-2] . */
   for (int k = i; k < j; k++) {
     /* splitting the problem into two parts and finding answers of both parts and adding cost of multiplying both answers in temp */
     int temp = solve(arr, i, k) +
       solve(arr, k + 1, j) + arr[i - 1] * arr[k] * arr[j];
     // getting minimum of all costs.
     ans = min(ans, temp);
   }
 
   return t[i][j] = ans;
 }
 
 int matrixMultiplication(int N, int arr[]) {
   int i = 1, j = N - 1;
 
   return solve(arr, i, j);
 }
 
 int main() {
   int N;
   cout << ""Size of array -"" << endl;
   cin >> N;
   int arr[N + 1];
   cout << ""Input Array -"" << endl;
   for (int i = 0; i < N; i++) {
     cin >> arr[i];
   }
   cout << ""Minimum costs -"" << endl;
   cout << matrixMultiplication(N, arr);
 }
 /*
 
 Input: 
 Size of array -                                                                                                                                 
 4                                                                                                                    ",C-Plus-Plus
"/**
 N-Queens problem is a famous problem
 The paradigm used to solve the problem is backtracking
 The problem is to find a way to place n queens on nXn board
 such that no queen can kill the other
 **/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 #define N 20
     
 void solve(bool board[N][N], bool cols[N], bool ndiag[2*N-1], bool rdiag[2*N-1], int row, string asf, int n) {
     
     if(row == n) {
         cout << asf << '.' << '\n';
         return;
     }
     
     for(int col=0; col<n; col++) {
         if(cols[col] == false && ndiag[row+col] == false && 
             rdiag[row-col+n-1] == false) {
                 // place the queen
                 cols[col] = true;
                 ndiag[row+col] = true;
                 rdiag[row-col+n-1] = true;
                 board[row][col] = true;
                 solve(board, cols, ndiag, rdiag, row+1, asf+to_string(row)+""-""+to_string(col)+"", "", n);
                 // backtrack
                 cols[col] = false;
                 ndiag[row+col] = false;
                 rdiag[row-col+n-1] = false;
                 board[row][col] = false;
             }
     }
 }
 
 int main() {
 	int n;
 	cin >> n;
 
 	bool board[N][N];
     bool cols[N];
     bool ndiag[2*N-1], rdiag[2*N-1];
 
 	// initialize
 	for(int i = 0; i < n; i++)
 		for(int j = 0; j < n; j++)
 			board[i][j] = false;
 
     // initialize that no column has a queen
 	for(int i = 0; i < n; i++)
 		cols[i] = false;
 
 	for(int i = 0; i < 2*n-1; i++) {
 		ndiag[i] = false;
 		rdiag[i] = false;
 	}
 
 	solve(board, cols, ndiag, rdiag, 0, """", n);
 }
 
 /**
 Input :
 4
 Output :
 0-1, 1-3, 2-0, 3-2, .
 0-2, 1-0, 2-3, 3-1, .
 Space Complexity : O(n^2)
 Time Complexity : upperbounded by O(n^n)
 **/",C-Plus-Plus
"'''
 A pronic number is a number which is the product of two consecutive integers.
 Such as 2=2*1 (2 and 1 are consecutive numbers)
         12=4*3
              
 This program will print the pronic numbers in the given range. '''
 
 import math
 
 '''Function to check whether number is pronic or not
    A number is pronic if the root of equation i^2+i-num=0 is real and integer.'''
 
 def is_pronic(n):
     dis = 1 + 4 * n
     if dis <= 0:
         return 0
     else:
         root = int(math.sqrt(dis))
         if root * root == dis and dis % 2 == 1:
             return 1
         else:
             return 0
 
 if __name__ == '__main__':
 
     ran_ge = list(input(""Enter range to print all the PRONIC NUMBERS: "").split())
 
     #Printing pronic numbers in given range
     print(""PRONIC NUMBERS from ""+ ran_ge[0] +"" to ""+ran_ge[1]+"" are:"")
     for i in range(int(ran_ge[0]),int(ran_ge[1])+1):
         if is_pronic(i):
             print(i,end="" "")
 
 '''
 Sample Input/Output:
 
 Input:
 Enter range to print all the PRONIC NUMBERS: 1 1000
 
 Output:
 PRONIC NUMBERS from 1 to 1000 are:
 2 6 12 20 30 42 56 72 90 110 132 156 182 210 240 272 306 342 380 420 462 506 552 600 650 702 756 812 870 930 992
 
 Time Complexity:O(n)  where n is total numbers in range
 Time Complexity of is_pronic()=O(1) 
 Space Complexity:O(1)
 
 '''
",Python
"/*
 C program to find the N'th Lucas Number.
 Lucas Numbers is a sequence similar to Fibonacci numbers and is defined 
 as the sum of its two immediately previous terms.
 The first and second numbers in Lucas sequence are 2 and 1 respectively.
 */
 #include <stdio.h>
 
 int lucas_num(int n)
 {
     int l1 = 2, l2 = 1;
     if (n == 0)
         return l1;
 
     for (int i = 2; i <= n; i++)
     {
         int next = l1 + l2;
         l1 = l2;
         l2 = next;
     }
     return l2;
 }
 
 int main()
 {
     int n;
     printf(""Enter the value of n(where you need the nth lucas number): "");
     scanf(""%d"", &n);
     if (n < 0)
     {
         printf(""Invalid Value of n !!!"");
         return 0;
     }
     int res = lucas_num(n);
     printf(""The %d'th Lucas Number is %d."", n, res);
     return 0;
 }
 
 /*
 Time Complexity - O(n), where `n` is the given number.
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the value of n(where you need the nth lucas number): 25
 The 25'th Lucas Number is 167761.
 */
",C
"/Given a Binary Tree. Find the Zig-Zag Level Order Traversal of the Binary Tree.
 
 import java.util.*;
 import java.util.HashMap;
 import java.io.*;
 
 class Node{
     int data;
     Node left,right;
     Node(int data){
         this.data = data;
         left=null;
         right=null;
     }
 }
 
 //Main Class
 public class Main {
     static Node buildTree(String str){
         if(str.length()==0 || str.charAt(0)=='N'){
             return null;
         }
         String ip[] = str.split("" "");
         // Create the root of the tree
         Node root = new Node(Integer.parseInt(ip[0]));
         // Push the root to the queue
         Queue<Node> queue = new LinkedList<>(); 
         queue.add(root);
         // Starting from the second element
         int i = 1;
         while(queue.size()>0 && i < ip.length) {
             // Get and remove the front of the queue
             Node currNode = queue.peek();
             queue.remove();
             // Get the current node's value from the string
             String currVal = ip[i];
             // If the left child is not null
             if(!currVal.equals(""N"")) {
                 // Create the left child for the current node
                 currNode.left = new Node(Integer.parseInt(currVal));
                 // Push it to the queue
                 queue.add(currNode.left);
             
             // For the right child
             i++;
             if(i >= ip.length)
                 break;    
             currVal = ip[i];
             // If the right child is not null
             if(!currVal.equals(""N"")) {
                 // Create the right child for the current node
                 currNode.right = new Node(Integer.parseInt(currVal));
                 // Push it to the queue
                 queue.add(currNode.right);
             }
             i++;
         }
         return root;
     }
 	public static void inorder(Node root) {
 	    if(root==null)
 	    return;
 	    inorder(root.left);
",Java
"#Optimized Bubble Sort
 """"""
 Add a small optimization for Bubble Sort algorithm, so that is stops looping on the given \
 list if it is sorted.
 """"""
 
 def optimized_BS(L):
     length = len(L)
     for i in range(length):
         #sorted flag
         sorted = 0 
         for j in range(length-i-1):
             #Reverse the operator for descending order
             if L[j] > L[j+1]: 
                 L[j], L[j+1] = L[j+1], L[j]
                 sorted = 1
                 
         #If no swaps happened for a complete pass
         #Then the array is sorted
         if sorted == 0:
             break        
     return L
 
 
 #Start checkpoint
 if __name__ == ""__main__"":
     #Convert to a list so len() function can work on it
     L = list(map(int, input(""Enter list > "").split()))
     
     print(""List after sorting: {} "".format(optimized_BS(L)))
 
 """"""
 
 I/O example:
 =============
 Input:
 Enter list > 65 89 1 4 5 6 87
 
 Output:
 List after sorting: [1, 4, 5, 6, 65, 87, 89]
 
 Time Complexity:
 =================
 Best case Time Complexity: O(n)
 Explain: When the array is already sorted
 
 Worst case Time Complexity: O(n^2)
 Explain: Will occur when the array is sorted in the opposite order of the alrogrithm
   If the algorithm is configured to sort in ascending order and the provided list is in descending order \
   and vice versa.
 """"""
",Python
"import java.util.Scanner;
 
 public class SudokuSolver {
 
     public static void main(String[] args) {
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter elements of unsolved sudoku. Type 0 for empty cells:"");
         int[][] sudokuArr = new int[9][9];
         for (int i = 0; i < 9; i++) {
             for (int j = 0; j < 9; j++) {
                 sudokuArr[i][j] = scanner.nextInt();
             }
         }
         scanner.close();
 
         if (solveSudoku(sudokuArr)) {
             System.out.println(""Solved sudoku:"");
             for (int i = 0; i < 9; i++) {
                 for (int j = 0; j < 9; j++) {
                     System.out.print(sudokuArr[i][j]+ "", "");
                 }
                 System.out.println();
             }
         } else {
             System.out.println(""Unsolvable"");
         }
     }
 
     private static boolean solveSudoku(int[][] sudokuArr) {
         int row = -1, col = -1;
         boolean isEmpty = true;
 
         for (int i = 0; i < 9; i++) {
             for (int j = 0; j < 9; j++) {
                 if (sudokuArr[i][j] == 0) {
                     row = i;
                     col = j;
 
                     // we still have some remaining
                     // missing values in Sudoku
                     isEmpty = false;
                     break;
                 }
             }
             if (!isEmpty) {
                 break;
             }
         }
 
         if (isEmpty) {
             return true;
         }
 
         for (int i = 1; i <= 9; i++) {
             if (isSafe(sudokuArr, row, col, i)) {
                 sudokuArr[row][col] = i;
                 if (solveSudoku(sudokuArr)) {
                     return true;
                 }
                 else {
                     sudokuArr[row][col] = 0;
                 }
             }
         }
 
         return false;
     }
 
     private static boolean isSafe(int[][] sudokuArr, int row, int col, i",Java
"/*
 *   Author: Shishir Bhandari
 *   Date: 28/10/2020
 */
 
 // Search an element in an array using Ternary Search algorithm (iterative)
 // Prerequisite: Sorted array should be passed
 function ternary_search_iterative(leftIndex, rightIndex, key, array) {
     // If left index is greater than right index then the key cannot be searched. 
     while(rightIndex >= leftIndex) {
 
         // Find two mid values
         let mid1 = leftIndex + ((rightIndex - leftIndex) / 3);
         let mid2 = rightIndex - ((rightIndex - leftIndex) / 3);
 
         // If the key is in one of the mid values, return its index
         if(key == array[mid1])
             return mid1;
         else if(key == array[mid2])
             return mid2;
 
         // Check which part of the array the key is present
         // and update the leftIndex and rightIndex values accordingly
         if(key < array[mid1]) {
             rightIndex = mid1 - 1;  // key lies in the region between leftIndex and mid1
         }
         else if(key > array[mid2]) {
             leftIndex = mid2 + 1;   // key lies in the region between mid2 and rightIndex
         }
         else {
             leftIndex = mid1 + 1;
             rightIndex = mid2 - 1;
         }
     }
 
     // The key does not exist
     return -1;
 }
 
 // Search an element in an array using Ternary Search algorithm (recursive)
 // Prerequisite: Sorted array should be passed
 function ternary_search_recursive(leftIndex, rightIndex, key, array) {
     if(rightIndex >= leftIndex) {
         // Find the two mid values
         let mid1 = leftIndex + ((rightIndex - leftIndex) / 3);
         let mid2 = rightIndex - ((rightIndex - leftIndex) / 3);
 
         // If the key is in one of the mid values, return its index
         if(key == array[mid1])
             return mid1;
         else if(key == array[mid2])
             return mid2;
 
         // Check which part of the array the key is present
         // and recall the function using upda",JavaScript
"// Armstrong Number
 using System;
 public class Armstrong // Class Declaration
 {
   public static void Main(string[] args) {
     int number, r, sum = 0, temp;
     Console.Write(""Enter the Number to check whether it is an Armstrong Number or Not = "");
     number = int.Parse(Console.ReadLine()); // Getting Number From User    
     temp = number;
     while (number > 0) {
       r = number % 10;
       sum = sum + (r * r * r);
       number = number / 10;
     }
     // Checking if the number is Armstrong number or not
     if (temp == sum) Console.Write(""{0} Is an Armstrong Number."", temp);
     else Console.Write(""{0} Is Not an Armstrong Number."", temp);
 
   }
 }
 
 /*
 Input:
 Enter the Number to check whether it is an Armstrong Number or Not = 153
 Output:
 153 Is an Armstrong Number.
 
 Input:
 Enter the Number to check whether it is an Armstrong Number or Not = 788
 Output:
 788 Is Not an Armstrong Number.
 
 Time Complexity: O(log(n))
 Space Complexity: O(1)
 */
",C-Sharp
"'''
 Ugly numbers are numbers whose only prime factors are 2, 3 or 5. 
 The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15,  shows the first 11 ugly numbers. 
 By convention, 1 is included. Write a program to find Nth Ugly Number.
 
 Example 1:
 Input:
 N = 10
 Output: 12
 Explanation: 10th ugly number is 12.
 
 Example 2:
 Input:
 N = 4
 Output: 4
 Explanation: 4th ugly number is 4.
 '''
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int main()
 {
 	//code
 	int t;
 	cin>>t;
 	
 	long long arr[10000];
 	int c2 = 0, c3 = 0, c5 = 0;
 	arr[0] = 1;
 	
 	for(int i=1; i<10000; i++)
 	{
 	    arr[i] = min(arr[c2]*2, min(arr[c3]*3, arr[c5]*5));
 	    
 	    if(arr[i] % 2 == 0)
 	        c2++;
 	    if(arr[i] % 3 == 0)
 	        c3++;
 	    if(arr[i] % 5 == 0)
 	        c5++;
 	}
 	
 	while(t>0)
 	{
 	    int n;
 	    cin>>n;
 	    cout<<arr[n-1]<<endl;
 	    t--;
 	}
 	return 0;
 }",C-Plus-Plus
"// C++ program to find the number of bits to be flipped to convert one number to another
 #include <bits/stdc++.h>
 using namespace std;
 
 /*
 Inorder to compare the individual bits of given the numbers, we can compute the number of
 set bits in thier XOR, as we know that XOR operation yields set bits, only when two same
 bits are XORed.
 */
 int get_num_flips(int n1, int n2) {
     int count = 0, n = n1 ^ n2;
 
     // Loop till 'n' becomes zero
     while (n) {
         // If the lsb is set, increase the count by 1
         if (n & 1)
             count++;
         // Shift the bits to right by 1.
         n = n >> 1;
     }
 
     return count;
 }
 
 int main() {
     int n1, n2;
     cout << ""\nEnter the two numbers: "";
     cin >> n1 >> n2;
 
     cout << ""Number of flips required to inter-convert the given numbers is "";
     cout << get_num_flips(n1, n2);
     return 0;
 }
 
 /*
 
 Time Complexity: O(log(n)), where n is the greater of the input number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the two numbers: 12 24
 Number of flips required to inter-convert the given numbers is 2
 
 */
",C-Plus-Plus
"/**
 Algorithm to sort arrays when numbers are distributed over a range. In this
 algorithm we divde the whole array into buckets and then sort the smaller buckets
 to get the sorted array.
  */
 import 'dart:io';
 import 'dart:math';
 
 // function that implements bucket sort
 List bucketSort(List arr, int bucketNum) {
   // get max value in array to find upper limit of bucket
   num maxVal = arr[0];
   for (int i = 0; i < arr.length; i++) {
     maxVal = max(maxVal, arr[i]);
   }
   maxVal++;
 
   // making bucket list and adding buckets to it
   List bucketList = new List.empty(growable: true);
   for (int i = 0; i < bucketNum; i++) {
     bucketList.add(new List.empty(growable: true));
   }
 
   // dividing numbers in different buckets
   for (int i = 0; i < arr.length; i++) {
     int bucketIndex = ((arr[i] * bucketNum) ~/ maxVal) as int;
     bucketList[bucketIndex].add(arr[i]);
   }
 
   // sorting each bucket one-by-one
   for (int i = 0; i < bucketNum; i++) {
     bucketList[i].sort();
   }
 
   // joining buckets
   int pos = 0;
   for (int i = 0; i < bucketNum; i++) {
     for (int j = 0; j < bucketList[i].length; j++) {
       arr[pos] = bucketList[i][j];
       pos += 1;
     }
   }
 
   return arr;
 }
 
 // main function, entry point of the program
 void main() {
   print(""Enter the size of list:"");
   int size = int.parse(stdin.readLineSync()!);
   List arr = [];
   print(""Enter the numbers:"");
   for (int i = 0; i < size; i++) {
     arr.add(int.parse(stdin.readLineSync()!));
   }
   print(""Enter number of buckets:"");
   int buckets = int.parse(stdin.readLineSync()!);
   // sorting
   arr = bucketSort(arr, buckets);
   print(""Sorted list:"");
   for (int i = 0; i < size; i++) {
     print(arr[i]);
   }
 }
 
 /**
 Enter the size of list:
 6
 Enter the numbers:
 5
 0
 2
 1
 4
 3
 Enter number of buckets:
 5
 Sorted list:
 0
 1
 2
 3
 4
 5
 
 Time Complexity: O(n+k)
 Space Complexity: O(n+k)
  */
",Dart
"# creating the Node class to frame a single node
 class Node:
     def __init__(self,data):
         self.data = data
         self.next = None
 
 # creating a Linked List class to get all the helper functionalities inside
 class LinkedList:
     def __init__(self):
         self.head = None
         self.tail = None
 
     def append(self,data):
         if self.tail is None:
             self.head = Node(data)
             self.tail = self.head
 
         else:
             self.tail.next = Node(data)
             self.tail = self.tail.next
 
     def printLL(self):
         temp = self.head
         while(temp):
             print(temp.data, end ="" "")
             temp = temp.next
 
 # creating a solution class to implement more methods on the Linked List
 class solution:
 
     def length(self,head):
         temp = head
         count = 0
         while(temp):
             temp = temp.next
             count += 1
         return count
 
     # the recursive approach to reverse the Linked List
     def reverse_linked_recursive(self,head):
         
         # if head or it's next pointer are null
         if(head == None or head.next == None):
             return head
         
         # getting small output using recursion
         small_head = self.reverse_linked_recursive(head.next)
         head.next = None
         
         # Traversing to the end node
         temp = small_head
         while(temp.next != None):
             temp = temp.next
         
         # Putting the head pointer at the next of end node
         temp.next = head
         head = small_head
         return head
     
     # the iterative approach to reverse the linked list
     def reverse_linked_iterative(self,head):
         
         # if head or it's next pointer are null
         if(head == None or head.next == None):
             return head
         
         
         # getting three pointers,
         
         # prev = to store the previous pointer
         # temp = auxili",Python
"/*
 Egg Dropping Puzzle
 
 Imagine there is a building of N floors and you have K eggs.
 How many minimum number of attempts it would take to find the minimum floor (or first floor) F (0 <= f <= N) 
     where any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break. 
 
 Each move, you may take an unbroken egg and drop it from any floor f (where 1 <= f <= N). 
 If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.
 
 
 Input: Number of floors, number of eggs
 Output: An integer denoting the number of minimum moves it would take.
 
 Thoughts: 
 When we drop an egg from a floor f, there can be two cases:
 1. The egg breaks 
     We only need to check for floors below f with the remaining eggs. So the problem reduces to (K - 1) eggs with (f - 1) floors
 2. The egg doesnt break. 
     We only need to check for floors above f with the remaining eggs. So the problem reduces to (K) eggs and (N - f) floors.
 
 So, if we write the above 2 cases in a recursive relation, it will be as below:
 
     min(1 + findFloorHelper(K - 1, f - 1), findFloorHelper(K, N - f))
 
 But, the above approach has a time complexity of O(K * N * N) and there exists much optimal solutions than the above.
 
 Approach:
 Let's think of the problem in a different way.
 We have K eggs and M attempts to determine the 'critical floor' in a N floors building findFloor(K, M).
 We use 1 egg and 1 attempt to check if the current floor we are at is indeed 'critical'.
 
 Now, if the egg breaks, we can use (K - 1) eggs and (M - 1) attempts to find the floor with findFloor(K - 1, M - 1).
 if the egg doesn't break, we can use (K) eggs and (M - 1) attempts to find the floor with findFloor(K, M - 1).
 
 So, the relation becomes this:
     findFloor(K, M) = 1 + findFloor(K - 1, M - 1) + findFloor(K, M - 1)
 
 We are not taking the maximum above because we try with one egg first. If it is broken, the targe",Java
"/*
 Given total number of nodes in an undirected graph
 numbered from 1 to n [ number of nodes] and total number of edges in the graph.
 Calculate the total number of connected components in the graph.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 vector < int > adj[10009];
 int visited[10009];
 
 // this dfs function will visit the nodes
 void dfs(int node)
 {
     /* for each node we will put  visited[node] = 1
     means that node is visited
     and then recursively will visit the
     adjacency vector
      */
     visited[node] = 1;
     for(auto child : adj[node])
     {
         if(visited[child] == 0)
         {
             dfs(child);
         }
     }
 }
 
 // this get_connected_components will count the number of connected components
 int get_connected_components(int nodes)
 {
     int connected_components = 0;
     for(int i = 1; i <= nodes; i++)
     {
         /* if the current visited[i] is zero , that means
         that node is not visited.
         so, we will make a dfs call
         and increment the connected_components
          */
         if(visited[i] == 0)
         {
             dfs(i);
             connected_components++;
         }
 
     }
     return connected_components;
 }
 
 int main()
 {
     cout << ""Enter the nodes and edges of the graph :\n"";
     int nodes, edges;
     cin >> nodes >> edges;
     cout << ""Enter the start and end points that have edges \n"";
     for(int i = 1; i <= edges; i++)
     {
         int point1, point2;
         cin >> point1 >> point2;
         adj[point1].push_back(point2);
         adj[point2].push_back(point1);
 
     }
     int connected_components = get_connected_components(nodes);
 
     cout << ""Number of Connected Components in this graph is: \n"";
     cout << connected_components << endl;
 }
 
 /*
 Standard Input and Output
 
 Enter the nodes and edges of the graph :
 8 5
 Enter the start and end points that have edges
 1 2
 2 3
 2 4
 3 5
 6 7
 
 Number of Connected Components in th",C-Plus-Plus
"# InOrder tree traversal using python3 (Iterative)
 
 
 class node:
     def __init__(self, data):
         self.data = data
         self.left = None
         self.right = None
 
 
 class Tree:
     def __init__(self):
         self.root = None
 
     # creation of tree.
     def createTree(self, NodesArray):
         queue = []
         self.root = node(int(NodesArray.pop(0)))
         queue.append(self.root)
         size = len(queue)
         while NodesArray:
             while size:
                 root = queue.pop(0)
                 if root:
                     data = NodesArray.pop(0)
                     if data == 'null':
                         root.left = None
                     else:
                         root.left = node(int(data))
                         queue.append(root.left)
                     data = NodesArray.pop(0)
                     if data == 'null':
                         root.right = None
                     else:
                         root.right = node(int(data))
                         queue.append(root.right)
                 size -= 1
             size = len(queue)
 
     # Iterative function to perform in-order traversal of the tree
     def inorderIterative(self, root):
         stack = []
         curr = root
         while stack or curr:
             # if current node is not null, push it to the stack
             if curr:
                 stack.append(curr)
                 curr = curr.left
             # else if current node is null, we pop an element from the stack,
             # print it and finally set current node to its right child
             else:
                 curr = stack.pop()
                 print(curr.data, end=' ')
                 curr = curr.right
 print(""Enter the input:- root.val root->left root->right(enter null if empty)"")
 NodesArray = list(input().split(' '))
 InOrdertree = Tree()
 InOrdertree.createTree(NodesArray)
 InOrdertree.inorderIterative(InOrdertree.root)
 
 
 '''
 Input-forma",Python
"/*  DOUBLE ENDED QUEUE
     Double ended queue or dequeue is a special type of queue 
     wherein elements can be inserted or deleted from both ends
     i.e front and rear
 */
 
 #include <stdio.h>
 //Declare dequeue with an array arr, front and rear as members
 typedef struct
 {
     int arr[10];
     int front, rear;
 } dequeue;
 dequeue dq;
 
 //to insert an element to the front of double ended queue
 void enqueue_front(int n)
 {
     //If dequeue is not full
     if ((dq.rear + 1) % 10 != dq.front)
     {
         //If dequeue is empty insert as first element
         if (dq.front == -1)
         {
             dq.front = 0;
             dq.rear = 0;
         }
         //decrement front in circular manner and insert
         else
             dq.front = (dq.front + 9) % 10;
         dq.arr[dq.front] = n;
     }
 }
 
 //to insert an element to the rear of double ended queue
 void enqueue_rear(int n)
 {
     if ((dq.rear + 1) % 10 != dq.front)
     {
         if (dq.rear == -1)
         {
             dq.front = 0;
             dq.rear = 0;
         }
         //increment rear in circular manner and insert
         else
             dq.rear = (dq.rear + 1) % 10;
         dq.arr[dq.rear] = n;
     }
 }
 
 //to delete an element and return it from the front of dequeue
 int delete_front()
 {
     int item;
     //If dequeue is empty
     if (dq.front == -1)
         return -1;
     else
     {
         item = dq.arr[dq.front];
         //if there is only one element
         if (dq.front == dq.rear)
         {
             dq.front = -1;
             dq.rear = -1;
         }
         else
             dq.front = (dq.front + 1) % 10;
     }
     return item;
 }
 
 //to delete an element and return it from the rear of dequeue
 int delete_rear()
 {
     int item;
     if (dq.rear == -1)
         return -1;
     else
     {
         item = dq.arr[dq.rear];
         if (dq.front == dq.rear)
         {
             dq.front = -1;
             dq.rear = -1;
         }
  ",C
"""""""
 Knapsack 0-1 problem using dp (0-1 means we either choose it or we don't, no fractions)
 Given weights and their corresponding values,
 We fill knapsack of capacity W to obtain maximum possible value in bottom-up manner.
 N: Number of (items)weight elements 
 W: Capacity of knapsack
 Time Complexity: O(N*W)(Looping through the matrix)
 Space Complexity: O(N*W)(Space taken by matrix - knapsack_table)
 """"""
 
 
 def knapsack(capacity, weights, values):
     # 'items' variable represents number of weight elements
     items = len(weights)
 
     # Initializing knapsack_table values as 0
     knapsack_table = [[0 for x in range(capacity + 1)]
                       for x in range(items + 1)]
 
     # Updating knapsack_table[][] in bottom up manner
     for i in range(items + 1):
 
         # Note that list is 0-based, so to get i_th item we do i-1
         for j in range(capacity + 1):
 
             # i=0 means no items available to put
             # j=0 means no capacity remains to be filled
             if i == 0 or j == 0:
                 knapsack_table[i][j] = 0
 
             # Weight of item is greater than current capacity, so we cannot use it
             # So knapsack value here is the best we can do without this item ie. with the (i-1)th item
             elif weights[i-1] > j:
                 knapsack_table[i][j] = knapsack_table[i-1][j]
 
             # Weight of item is less than current capacity, so we can use it to optimize knapsack
             else:
                 knapsack_table[i][j] = max(
                     # If i_th item is included,
                     # knapsack value is equal to it's value + best we can do(ie. value of knapsack_table):
                     # 1) without this item(with the previous one) and
                     # 2) capacity being current capacity(j) - weight of i_th item
                     values[i-1] + knapsack_table[i-1][j-weights[i-1]],
                     knapsack_table[i-1][j])  # i_th item is not included
 
 ",Python
"// Liner Search
 
 #include<iostream>
 using namespace std;
 
 int main()
 {
   int n,i,a;
   // initialize position variable as -1
   int pos=-1;      
   cout<<""Enter number of elements: "";
   cin>>n;
   cout<<""Enter the elements ""<<endl;
   int arr[n];
 
   for(i=0;i<n;i++)
   {
     cin>>arr[i];
   }
   cout<<""Enter element to search "";
   cin>>a;
 
   //loop from 0th to nth element of array
   for(i=0;i<n;i++)    
   {
     //check whether number is present
     if(arr[i]==a)       
     {
       //if found update pos to i i.e. position of the element
       pos = i;       
       cout<<""Found at ""<<pos;
       //terminate the for loop
       break;        
     }
   }
 
 // if pos=-1 then element is not found
   if(pos == -1)    
   {
     cout<<""Not Found"";
   }
   return 0;
 }
 
 /*
 Time complexity : O(N)
 Space complexity :O(1)
 */
 
 /*
 Test Case :
   Input :
   Enter number of elements: 
   4
   Enter the elements 
   1 2 4 5
   Enter element to search 
   9
 
   Output :
   Not Found
 */
 
",C-Plus-Plus
"/* 
 Shell Sort in Dart
 
 Shell sort is an algorithm that first sorts the elements far apart from 
 each other and successively reduces the interval between the elements to 
 be sorted. 
 */
 
 import 'dart:io';
 
 void ShellSort(var arr, int n) {
   // Setting the intervals as n/2, n/4, n/8, ...
   for (int interval = (n / 2).floor();
       interval > 0;
       interval = (interval / 2).floor()) {
     // traversing through the right side of the interval
     for (int i = interval; i < n; i++) {
       int temp = arr[i];
 
       int j;
 
       // Sorting the temp element by comparing it with left side of the interval
       for (j = i; j >= interval && arr[j - interval] > temp; j -= interval) {
         arr[j] = arr[j - interval];
       }
       arr[j] = temp;
     }
   }
 }
 
 void main() {
   var array = [];
 
   var n, ele;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
 
   ShellSort(array, n);
   print(array);
 }
 
 /*
 Time Complexity:
 1. Worst Case Complexity: O(n^2)
 2. Best Case Complexity: O(n*log n)
 3. Average Case Complexity: O(n*log n)
 
 Space Complexity: O(1) 
 
 Sample Input/Output:
 Input :
 Enter the number of Elements: 
 5
 Enter Element 1: 
 50
 Enter Element 2: 
 30
 Enter Element 3: 
 10
 Enter Element 4: 
 40
 Enter Element 5: 
 20
 Output:
 [10, 20, 30, 40, 50]
 
 */
",Dart
"/*
 First fit is the simplest of all the storage allocation strategies.
 Here the list of storages is searched and as soon as a free storage block of size >= N is found ,
 the pointer of that block is sent to the calling program after retaining the residue space.Thus, for example,
 for a block of size 5k , 2k memory will be sent to the caller . The below program is a simulation of the first fit strategy
 using array data structure.
 */
 
 class Block{
     constructor(){
         this.size = 0
         this.ID = 0
         this.fragment = 0
     }
 }
 
 
 
 class Process{
     constructor(){
         this.Num = 0
         this.size = 0
         this.block = null
     }
 }
 
 
 class Firstfit{
     initialiseBlocks(arr,sizes,n){
         for(let i=0;i<n;i++){
             arr[i].size = sizes[i]
             arr[i].fragment = sizes[i]
             arr[i].ID = i + 1
         }
     }
 
     printResult(arr2, numOfProcess){
         console.log(
         ""Process No            Process Size          Block ID          Block Size         Block Fragment""
         );
         for(let i=0;i<numOfProcess;i++){
             console.log(
                 arr2[i].Num
                 + ""                     ""
                 + arr2[i].size
                 + ""                     ""
                 + arr2[i].block.ID
                 + ""                     ""
                 + arr2[i].block.size
                 + ""                     ""
                 + arr2[i].block.fragment
             )
         }
 
     }
 
     firstfit(arr, sizes, n, arr2, numOfProcess){
         for(let i=0;i<numOfProcess;i++){
             for(let j=0;j<n;j++){
                 if(arr2[i].size <= arr[j].fragment){
                     arr[j].fragment -= arr2[i].size;
                     arr2[i].block = new Block();
                     arr2[i].block.size = arr[j].size;
                     arr2[i].block.ID = arr[j].ID;
                     arr2[i].block.fragment = arr[j].fragment;
                 ",JavaScript
"/*
 Given a list of strings.
 those strings occurs more than one time, return them as a vector of strings.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 vector < string > get_duplicate_string( vector < string > vec_string, int Number)
 {
     vector < string > duplicates;
     map < string , int > mp;
     for(int i = 0; i < vec_string.size(); i++)
     {
         /* if mp[vec_string[i]] == 0 means that
         that string is not present. right now it's occurrence
         is only 1
         */
         if(mp[vec_string[i]] == 0)
         {
             mp[vec_string[i]]++;
         }
         /* if mp[vec_string[i]] != 0 means that
         that string is already present. right now it's occurrence
         more than 1 , it's duplicate.
         */
         else if(mp[vec_string[i]] != 0)
         {
             duplicates.push_back(vec_string[i]);
         }
     }
     return duplicates;
 }
 
 int main()
 {
     cout << ""Enter the number of strings : \n"";
     int Number;
     cin >> Number;
     vector < string > vec_string;
     cout << ""Enter the strings :\n"";
     for(int i = 1; i <= Number; i++)
     {
         string s;
         cin >> s;
         vec_string.push_back(s);
     }
     vector < string > duplicate_string = get_duplicate_string(vec_string, Number);
     cout << ""Duplicate Strings are : "";
     for(auto i : duplicate_string)
     {
         cout << i << ' ';
     }
     cout << endl;
 }
 /*
 Standard Input and Output
 
 Enter the number of strings :
 6
 Enter the strings :
 tom
 lucius
 ginny
 harry
 ginny
 harry
 Duplicate Strings are : ginny harry
 
 Time Complexity : O(log N)
 Space Complexity : O(N)
 
 */
",C-Plus-Plus
"/*
 
 Fibonacci search technique is a method of searching a sprted array using a divide and conquer algorithm that narrows down possible location with the aid of Fibonacci numbers.
 Works similarliy to Binary Search i.e. on Sorted array
 Algorithm - Divide the array into two parts that have sizes that are consecutive Fibonacci numbers.
 Time Complexity - O(log n)
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 function fibonacciSearch(array, key) {
   let fib0 = 0;
   let fib1 = 1;
   let fibK = fib0 + fib1;
 
   // Get the smallest fibonaaci number greater than or equal to array length
   while (fibK < array.length) {
     fib0 = fib1;
     fib1 = fibK;
     fibK = fib0 + fib1;
   }
 
   let offSet = -1;
 
   // Start comparing the key
   while (fibK > 1) {
     // Get the valid array location
     let i = Math.min(offSet + fib0, array.length - 1);
 
     // if key is greater than the value, then cut the subarray - [offset, i]
     if (array[i] < key) {
       fibK = fib1;
       fib1 = fib0;
       fib0 = fibK - fib1;
       offSet = i;
     } else if (array[i] > key) {
       // if key is smaller than the value, then cut the subarray - [i + 1, array.length]
       fibK = fib0;
       fib1 = fib1 - fib0;
       fib0 = fibK - fib1;
     } else {
       return console.log(`Element ${array[i]} found at ${i + 1}`);
     }
   }
 
   // Last element case
   if (fib1 && array[offSet + 1] === key)
     return console.log(`Element ${array[offSet + 1]} found at ${offSet + 2}`);
 
   return console.log(""Element not found"");
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array elements
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter",JavaScript
"import 'dart:math';
 import 'dart:io';
 
 // checks if num is armstrong or not
 bool isArmstrong(int num) {
   bool isArmNum = false;
   int result = 0;
   int temp = num;
 
   // Count No Digits in numbers
   int numberOfDigits = temp.toString().length;
 
   while (temp > 0) {
     int remainder = temp % 10;
     result += pow(remainder, numberOfDigits).toInt();
     temp ~/= 10;
   }
 
   if (result == num) {
   isArmNum = true;
   }
   return isArmNum;
 }
 
 // Main Function, Entry Point of Program
 void main() {
   print(""Enter a number:"");
   int num = int.parse(stdin.readLineSync()!);
 
   // Call function to check number is Armstrong
   if (isArmstrong(num)) {
     print(""$num is an Armstrong Number"");
   } else {
     print(""$num is not an Armstrong Number"");
   }
 }
 /**
  * Sample input/output:
  * Enter Number: 
  * 153
  * 153 is an Armstrong Number
  * 
  * Enter Number: 
  * 224
  * 224 is not an Armstrong Number
  */
",Dart
"/*
 Given a list of words as strings,
 return the n-th most occurrence words(strings) .
 
 Words should follow the lexicographical order.
 means the lexicographical order is a generalization of the alphabetical order
 of the dictionaries to sequences of ordered symbols or, more generally,
 of elements of a totally ordered set.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // this print_words function will print the strings
 void print_words(vector < string > most_occur_string)
 {
     cout << ""Most occurrence words are: \n"";
     for(auto i : most_occur_string)
     {
         cout << i << ' ';
     }
     cout << endl;
     return;
 }
 
 //this get_most_occur_string function will give us the most occurrence strings
 vector < string > get_most_occur_string(vector < string > words, int number, int occurrence_number)
 {
     vector < string > get_words;
 
     // we will insert characters into the map
     map < string, int > occur_char;
     for(int i = 0; i < (int)words.size(); i++)
     {
         occur_char[words[i]]++;
     }
     /* multimap can contain duplicate keys. that's why we will use it.
     here multimap's key is the occurrence of each string.
     and multimap's value is that particular string.
     greater < int > will store them in descending order.
     */
     multimap < int , string, greater < int > > occur_char_2;
     for(auto i : occur_char)
     {
         occur_char_2.insert( { i.second , i.first } );
     }
     int count_occur = 0;
     for(auto i : occur_char_2)
     {
         /* if the count_occur is less than occurrence_number
         we will add the strings.
          */
         if(count_occur < occurrence_number)
         {
             get_words.push_back(i.second);
             count_occur++;
         }
         if(count_occur == occurrence_number)
         {
             break;
         }
 
     }
     return get_words;
 }
 
 int main()
 {
     cout << ""Enter the number of strings and occurrence number: "";
     int nu",C-Plus-Plus
"/*
 C program to check whether a number is kaprekar number or not
 Kaprekar number is a number whose square when divided into two parts and then added gives the original number
 Eg: 45 (45^2 = 2025 -->20+25 = 45)
 */
 
 #include<stdio.h>
 #include<math.h>
 #include<stdbool.h>
 
 bool kaprekar (int n);
 
 int main ()
 {
   int n;
   printf (""Enter the number to check:\n"");
   scanf (""%d"", &n);
   if (kaprekar (n) == true)
     {
       printf (""Kaprekar Number!"");
     }
   else
     {
       printf (""Not Kaprekar Number !"");
     }
   return 0;
 }
 
 bool kaprekar (int n)
 {
   if (n == 1)
     return true;
   int s = n * n;
   int t = 0;
   while (s)
     {
       t = t + 1;
       s = s / 10;
     }
   s = n * n;
   for (int c = 1; c < t; c++)
     {
       int f, x1, x2, sum;
       f = pow (10, c);
       if (f == n)
 	continue;
       x1 = s / f;
       x2 = s % f;
       sum = x1 + x2;
       if (sum == n)
 	return true;
     }
   return false;
 }
 
 /*
 SampleInput-Output1:
 Enter the number to check:
 297
 Kaprekar Number!
 
 SampleInput-Output2:
 Enter the number to check:
 12
 Not Kaprekar Number!
 
 Time Complexity: O(n)
 */
",C
"// C program to find to the longest common substring along with its length
 #include <stdio.h>
 
 // Helper function to find the maximum of two elements
 int max(int a, int b)
 {
     if (a > b)
         return a;
     else
         return b;
 }
 
 // Length of Longest Common substring
 void lcs(char s1[], int n, char s2[], int m)
 {
     /*
     Builds a 2D table in a bottom Up manner, storing info 
     regarding the length of longest common substring till that index.
     */
     int dp[n + 1][m + 1], ans = 0;
 
     for (int i = 0; i <= n; i++)
     {
         for (int j = 0; j <= m; j++)
         {
             // If one of the string size is zero, then the length of LCS is also zero
             if (i == 0 || j == 0)
                 dp[i][j] = 0;
             /* If the elements of both the strings match, then the value of LCS increments by one.
             Also Check if the value of lcs has reached the max till now.
             */
             else if (s1[i - 1] == s2[j - 1])
             {
                 dp[i][j] = dp[i - 1][j - 1] + 1;
                 ans = max(ans, dp[i][j]);
             }
             else
                 dp[i][j] = 0;
         }
     }
 
     int index = ans;
     char lcs[index+1];
     lcs[index] = '\0';
 
     int i = n, j = m;
     while (i > 0 && j > 0)
     {
         if (s1[i-1] == s2[j-1])
         {
             lcs[index-1] = s1[i-1];
             i--;
             j--;
             index--; 
         }
         else if (dp[i-1][j] > dp[i][j-1])
         {
             i--;
         }
         else
         {
             j--;
         }
         
     }
     printf(""The length of the longest common substring is: %d and the substring is %s."", ans, lcs);
 }
 
 int main()
 {
     int n, m;
     printf(""\nEnter the length of the first string? "");
     scanf(""%d"", &n);
     char s1[n];
     printf(""Enter the first string: "");
     scanf("" %s"", s1);
 
     printf(""\nEnter the length of the second string? "");
     scanf(""%d"", ",C
"package main
 
 import (
 	""fmt""
 	""time""
 )
 
 // merge(): a simple function which merge the two slices into one slice
 
 func merge(left []int, right []int) []int {
 	result := make([]int, len(left)+len(right))
 
 	leftArrayIndex, rightArrayIndex := 0, 0
 
 	for resultArrayIndex := 0; resultArrayIndex < len(result); resultArrayIndex++ {
 		if leftArrayIndex >= len(left) {
 			result[resultArrayIndex] = right[rightArrayIndex]
 			rightArrayIndex++
 			continue
 
 		} else if rightArrayIndex >= len(right) {
 			result[resultArrayIndex] = left[leftArrayIndex]
 			leftArrayIndex++
 			continue
 
 		}
 
 		if left[leftArrayIndex] < right[rightArrayIndex] {
 			result[resultArrayIndex] = left[leftArrayIndex]
 			leftArrayIndex++
 
 		} else {
 			result[resultArrayIndex] = right[rightArrayIndex]
 			rightArrayIndex++
 
 		}
 
 	}
 
 	return result
 }
 
 func mergeSort(arr []int) []int {
 	length := len(arr)
 	if length < 2 {
 		return arr
 	}
 	left := arr[0 : length/2]
 	right := arr[length/2:]
 
 	// making recursive call with mergeSort() function on both halves of slice
 	left = mergeSort(left)
 	right = mergeSort(right)
 
 	return merge(left, right)
 }
 
 func main() {
 	arr := []int{3, 5, 1, 6, 1, 7, 2, 4, 5, 1}
 
 	start := time.Now() // adding timestamp when excecution of mergesort start
 
 	arr = mergeSort(arr)
 
 	end := time.Now() // adding timestamp when excecution of mergesort finish
 
 	fmt.Println(""sorted array is"")
 	fmt.Println(arr)
 	fmt.Println(""time taken by algorithm is"")
 	fmt.Println(end.Sub(start))
 }
 
 /*
 	input/output sample
 
 	sorted array is
 	[1 1 1 2 3 4 5 5 6 7]
 	time taken by algorithm is
 	2.535s
 
 
 
 	Time Complexity: O(nLog(n)) in worst case
 	Space Complexity: O(n) in worst case
 
 */
",Go
"/*Implementation of Queue using linked list U can peerfom enqueue , dequeue and display elements of queue */
 
 #include<iostream>
 using namespace std;
 
 class Node {
   int data;
   Node *next;
 public:
   friend class queue;
 };
 
 
 class queue {
   Node *front , *rear;
 public:
   queue() {
     front = rear = NULL;
 
   }
   void enQueue(int x) {
 
     if (rear == NULL) {
       Node *temp = new Node();
       temp->data = x;
       temp->next = NULL;
       rear = temp;
       front = rear;
     }
     else {
       Node *temp = new Node();
       temp->data = x;
       temp->next = NULL;
       rear->next = temp;
       rear = temp;
     }
 
   }
   void deQueue() {
     // Node *temp = front;
     if (front == NULL)
     {
       return;
     }
     Node * temp = front;
     front = front->next;
 
     if (front == NULL) {
       rear = NULL;
     }
     cout << ""Deleted Elemeted is :"" << temp->data << endl;
     free(temp);
 
   }
   void displayQueue() {
     Node *temp = front;
     if ((front == NULL) || (rear == NULL)) {
       cout << ""Queue is empty!!"" << endl;
       return;
     }
     cout << ""Queue Elements are :"" << endl;
     while (temp != NULL) {
       cout << temp->data << "" "";
       temp = temp->next;
     }
     cout << endl;
   }
 
 };
 
 int main() {
   queue q;
   int ch;
   do {
     cout << ""Enter the option below :\n1.Enqueue an Element \n2.Dequeue an Element \n3.Display all elements of a queue\n4.Exit \n"";
     cin >> ch;
     switch (ch) {
     case 1:
       int k;
       cin >> k;
       q.enQueue(k);
       break;
     case 2:
       q.deQueue();
       break;
     case 3:
       q.displayQueue();
       break;
     }
   } while (ch != 4);
 }
",C-Plus-Plus
"#include <iostream>
 using namespace std;
 
 //space O(n)
 int fib(int n,int dp[]){
 	for(int i=2;i<=n;i++){
 		dp[i]=dp[i-1]+dp[i-2];
 	}
 	return dp[n];
 }
 
 //space O(1)
 int fib_Space_Opt(int n){
 	//base case
 	if(n == 0 || n == 1) return n;
 
 	int a = 0;
 	int b = 1;
 	int c;
 
 	for(int i=2;i<=n;i++){
 		c = a + b;
 		a = b;
 		b = c;
 	}
 	return c;
 }
 
 
 int main() {
  int n;
  cout<<""Enter number 'n' to find nth fibonacci number: "";
  cin>>n;
  int dp[n+1]={0};
  dp[1] = 1;
 
  cout<<""Output calculated with space complexity O(n): "";
  cout<<fib(n,dp)<<endl;
  cout<<""Output calculated with space complexity O(1): "";
  cout<<fib_Space_Opt(n)<<endl;
 
 return 0;
 }
 
 /*
 sample input output
 input: 10
 output: 55
 */
 
 /*
 Time O(n)
 */
",C-Plus-Plus
"/******************************************************************************
 Author - @Suvraneel 
         Suvraneel Bhuin
 * Implementation of a Polynomial Addition & multiplication using Linked Lists in Java *
 ******************************************************************************/
 
 import java.util.*;
 class LinkedList
 {
 	// Structure containing exponent and coefficient of variable 
 	static class Term { 
 		int coefficient;
 		int exponent;
 		//Link to next Term in singly LL
 		Term link; 
 	}
 
 	// Function add a new Term at the end of list 
 	static Term addTerm(Term head, int coefficient, int exponent) 
 	{
 		// Create a new Term 
 		Term nd = new Term(); 
 		nd.coefficient = coefficient; 
 		nd.exponent = exponent;
 		//Link pointing to null because this is leaf node as of yet
 		nd.link = null; 
 
 		// If linked list is empty
 		if (head == null) 
 			return nd;
 
 		// Initiate a pointer at the head to start traversal 
 		Term ptr = head;
 		// Traverse until leaf Term
 		while (ptr.link != null) 
 			ptr = ptr.link;
 		//return leaf term
 		ptr.link = nd; 
 		return head; 
 	} 
 
 	// Function to collapse the expanded form by merging duplicates in 1 term
 	static void collapse(Term head) 
 	{ 
 		Term polyA;
 		Term polyB;
 		polyA = head; 
 		//outer loop => for every term in poynomial,
 		while (polyA != null && polyA.link != null) { 
 			polyB = polyA;
 			//inner loop => iterate through the rest of the loop to find redundant elements
 			while (polyB.link != null) {
 				// If exponent of two elements are same
 				if (polyA.exponent == polyB.link.exponent) { 
 					// Collapse them onto the 1st occurance of that term (ie, term currently in outer loop)
 					polyA.coefficient += polyB.link.coefficient;
 					polyB.link = polyB.link.link;
 				}
 				// If exponent not same, check the other terms - inner loop
 				else polyB = polyB.link;
 			}
 			//check similarly for the next term as well - outer loop
 			polyA = polyA.link;
 		}",Java
"/*
   Jump Game :
       We need to find the minimum number of jumps to reach the end of the array starting from the first
       element of the array, jumps value would be (-1) if we are not able to reach the end of the array
 
   Example : array = {2,3,0,1,4,1,1,2,0,3,5}
             minimum jumps = 5  {2 to 3, 3 to 4, 4 to 2, 2 to 3, 3 to 5}
 
   Explanation : (Greedy Solution)
 
    1. We will check if array's length is equal to or less than 1 or not
           i.e  if array's length is equal to 1 then we have only one element in the
           array and it is already at the end and program will return 0
 
    2. Now, we will check if the first element of array is 0 or not,
           i.e if it is 0 then we can't make any jump and program will return -1
 
    3. Now, we will use the for loop from i = 1 till array's length when (i == array.length - 1)
       this is true then we have reached the end and we will return jumps
 
    4. (i + array[i]) is the number of steps we take from the current position and we will compare it with
       max_Jump_Reach and then we will use Math.max which will compare both and return the maximum and assigns
       it to the max_Jump_Reach again
 
    5. We have used checks-- so that we can iterate the for loop till the checks == 0 and find the maximum
       value for max_Jump_Reach and afterwards we will update checks by (max_Jump_Reach - i)
  */
 import java.util.Scanner;
 
 public class JumpGame {
 	// jumpGame method
 	public static int jumpGame(int array[]) {
 
 		//Initializing max_Jump_Reach, checks, jumps
 		int max_Jump_Reach = array[0];
 		int checks = array[0];
 		int jumps = 1;
 
 		// If array has only 1 element then it is already at last element so return 0
 		if (array.length <= 1) {
 			return 0;
 		}
 		// If first element is 0 then we can't jump to any other element in the array
 		if (array[0] == 0) {
 			return -1;
 		}
 		// Traverse array
 		for (int i = 1; i < array.length; i++) {
 
 			// Check if we reache",Java
"// Binary Search in Go
 // Requires array to be sorted
 // Return index of found element else return -1
 package main
 
 import (
 	""fmt""
 )
 
 func main() {
 	arr := []int{2, 4, 6, 8, 10, 12, 14, 16, 18, 20}
 	fmt.Printf(""Array: %v\n"", arr)
 	var find int
 	fmt.Printf(""Please enter element to be found: "")
 	fmt.Scan(&find)
 	result := search(arr, find)
 	fmt.Printf(""Result: %d"", result)
 }
 
 func search(list []int, item int) int {
 	low := 0
 	high := len(list) - 1
 	for low <= high {
 		middle := (low + high) / 2
 		if list[middle] == item {
 			return middle
 		} else if list[middle] < item {
 			low = middle + 1
 		} else {
 			high = middle - 1
 		}
 	}
 	return -1
 }
",Go
"/*Below is an implementation of keyword cipher in C++. It is a form of
 monoalphabetic substitution. A encryption is formed of alphabets from
 [a-z] such that the first part of encrption contains unique letters of
 the keyword and the rest are the remaining alphabets from [a-z]. That is,
 until the keyword is used up, whereupon the rest of the ciphertext letters
 are used in alphabetical order, excluding those already used in the key.*/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // This function generates the pad using the keyword
 string generate_pad(string key) {
 
 	int i = 0;
 	string pad = ""00000000000000000000000000"";
 	int count = 0;
 	
 	// Ignoring the spaces in the given keyword
 	while(i < key.length()) {	
 		if(key.at(i) == ' ') {
 			i = i + 1;
 			continue;
 		}
 
 		// Checking keyword alphabet-wise
 		int missing = 0;
 		for(int j = 0; j < key.length(); j++) {
 			if(key.at(i) != pad.at(j)) {
 				missing += 1;
 			}
 		}
 
 		// Adding the unique words of key to pad
 		if(missing == key.length()) {
 			pad.at(count) = key.at(i);
 			count += 1;
 		}
 		i = i + 1;
 	}
 	// Till here we get the first half of the pad
 
 	string alphabet = ""abcdefghijklmnopqrstuvwxyz"";
 
 	i = 0;
 	// This while loop forms the remaining pad
 	while(i < 26) {
 		int not_present = 0;
 		for(int j = 0; j < 26; j++) {
 			if(alphabet.at(i) != pad.at(j)) {
 				not_present += 1;
 			}
 		}
 		
 		/* Whatever alphabets from [a-z] are not present
 		in the pad till now, add them to the pad.*/
 		if(not_present == 26) {
 			pad.at(count) = alphabet.at(i);
 			count++;
 		}
 		i++;
 	}
 	// Return the length 26 pad
 	return pad;
 }
 
 // This is the encryption function
 string encrypt(string plaintext, string key) {
 	
 	// Generate the pad using the above function
 	string pad = generate_pad(key);
 	string alphabet = ""abcdefghijklmnopqrstuvwxyz"";
 
 	// Replace all sapces in plaintext with underscores
 	for(int i = 0; i < plaintext.length(); i++) {
 		if(plaintext.at(",C-Plus-Plus
"#Find Minimum number of jumps to reach end
 def min_jump(arr, n):
     if n <= 1: 
         return 0 #return zero values if the array less than one element
     
     #assigning the value 0    
     left = 0
     right = arr[0]
     count = 1
 
     while right < n-1:
         count += 1 #incresing the value 
         jump = max(i + arr[i] for i in range(left, right + 1)) #by this checking all the arr and finding min values 
         left, right = right, jump #swaping the values
     return count
 
 arr = list(map(int, input(""Enter the elements: "").split()))
 size = len(arr)
 print('Minimum number of jumps to reach',
       'end is', min_jump(arr, size))
 
 '''
 Time Complexity : O(n)
 Space Complexity : O(1)
 
 INPUT:
     Enter the elements: 1 3 5 8 9 2 6 7 6 8 9
 
 OUTPUT  
     Minimum number of jumps to reach end is 3
 
 Output: 3 (1-> 3 -> 8 -> 9)
 Explanation: Jump from 1st element 
 to 2nd element as there is only 1 step, 
 now there are three options 5, 8 or 9. 
 If 8 or 9 is chosen then the end node 9 
 can be reached. So 3 jumps are made.
 
 '''
 
",Python
"/*
   Rotten Oranges:
     We have to determine what is the minimum time required to rot all oranges. So basically we will use breadth first search using queue.
     We can go in four directions i.e. up, down, left and right. We traverse each node and if it is fresh or no oranges then we don't go to the
     breadth first search else we go and traverse through the matrix. 
     
     Hence we get the time by updating the level variable each time we put
     something in our queue that is the next iteration and hence we follow the same procedure starting from each rotten orange.
     The problem can also be found on geeksforgeeks for reference.
 
 */
 
 import java.util.*;
 import java.lang.*;
 import java.io.*;
 class BFS_RottenOranges
 {
     public static void main(String[] args) throws IOException
     {
         Scanner sc= new Scanner(System.in);
             System.out.println(""Enter the dimention of the matrix: "");
             int n = sc.nextInt();
             int m = sc.nextInt();
             int[][] grid = new int[n][m];
       
             System.out.println(""Enter values of the matrix which consists of 1 for fresh, 0 for no oranges, 2 for rotten oranges: "");
             for(int i = 0; i < n; i++){
                 for(int j = 0; j < m; j++){
                     grid[i][j] = sc.nextInt();
                 }
             }
             BFS_RottenOranges1 obj = new BFS_RottenOranges1();
             int ans = obj.orangesRotting(grid);
             System.out.println(""The time taken to rot all oranges is: "");
             System.out.println(ans);
 
         sc.close();
     }
 }// } Driver Code Ends
 
 
 class BFS_RottenOranges1
 {
     class Node{
         int i;
         int j;
         public Node(int i, int j){
             this.i=i;
             this.j=j;
         }
     }
     public int orangesRotting(int[][] grid)
     {
         int n= grid.length;
         int m= grid[0].length;
         
         Queue<Node> queue= new LinkedList<>();
       ",Java
"/*
 Counting sort is a sorting algorithm that sorts the elements of an array by counting 
 the number of occurrences of each unique element in the array. The count is stored in an 
 auxiliary array and the sorting is done by mapping the count as an index of the auxiliary array.
 
 Counting sort which takes negative numbers as well
 */
 
 using System;
 using System.Linq;
 class countingSort
 {
     static void countSort(int[] arr, int Length)
     {
         int max = arr.Max();
 	    int min = arr.Min();
 	    int range = max - min + 1;
 	
 	    //Create a new ""counting"" array 
         //which stores the count of each unique number
 	    int []count = new int[range];
 	
 	    //Create a new ""output"" array
 	    int []output = new int[Length];
 	
 	    //loop through array and increment each numbers corresponding index in the countArray  
 	    for (int i = 0; i < arr.Length; i++) {
 	       count[arr[i] - min]++;
 	    }
 	
 	    //start at second position and add each previous count to the next to get each integers final in the sorted array
 	    for (int i = 1; i < count.Length; i++) {
 	    
 	       //this step we get the index ending positions for numbers
 	       count[i] += count[i - 1];
 	    }
 	
 	    for (int i = arr.Length - 1; i >= 0; i--) {
 	       output[count[arr[i] - min] - 1] = arr[i];
 	       count[arr[i] - min]--;
 	    }
 	
 	    for (int i = 0; i < arr.Length; i++) {
 	       arr[i] = output[i];
 	    }
     }
   
 
     public static void Main(string[] args)
     {
 	    //Take array size input
         Console.Write(""Enter array size: "");
         int Length = Convert.ToInt32(Console.ReadLine());
         
         int[] array = new int[Length]; 
         
         //Take array elements input
         for(int i=0; i<Length; i++){
             Console.Write(""Element {0} : "", i);
             array[i] = Convert.ToInt32(Console.ReadLine());
         }
         
         
         //Print array before Count sort
         Console.Write(""\nThe ",C-Sharp
"'''
 Bilinear search is searching algorithm where it is search for a element
 from the both end. It is a improved version of linear search.
 '''
 
 
 def bilinear(x, arr):
     siz = len(arr)
     p = 0
     i = 0
     j = siz-1
 
     while i < j:
         if arr[i] != x and arr[j] != x:
             i += 1
             j -= 1
         else:
             p = 1
             break
     if p == 1:
         return True
     else:
         return False
 
 if __name__ == ""__main__"":
     print('enter the list:')
     l = list(map(int, input().split(' ')))
 
     ele = int(input(""enter the element to check:""))
 
     if bilinear(ele, l):
         print('element found')
     elif bilinear(ele, l) is False:
         print(""element not found"")
",Python
"import java.util.*;
 
 public class Search_insert_index {
 
     static int search(int[] nums, int target) {
         // using binary search since array is sorted.
         int start = 0;
         int end = nums.length - 1;
 
         while (start <= end) {
             int mid = (start + end) / 2;
 
             if (target > nums[mid]) {
                 start = mid + 1;
             } else if (target < nums[mid]) {
                 end = mid - 1;
             } else {
                 return mid;
             }
         }
 
         return start;
     }
 
     public static void main(String[] args) {
 
         Scanner sc = new Scanner(System.in);
         int len, target, index;
         System.out.println(""Enter the length of array"");
         len = sc.nextInt();
         int arr[] = new int[len];
         System.out.println(""Enter the array elements"");
         for (int i = 0; i < len; i++)
             arr[i] = sc.nextInt();
         System.out.println(""Enter the target value"");
         target = sc.nextInt();
         index = search(arr, len);
         System.out.println(""Index of the target element is "" + index);
     }
 }
 /*
  * output: Enter the length of array 4 Enter the array elements 1 2 5 6 Enter
  * the target value 3 Index of the target element is 2
  *
  * Time Complexity: O(log(n)) space complexity: O(n)
  */
",Java
"def sort012(arr,n):
     listofZero = []
     listofOne = []
     listofTwo = []
 
     for i in range(0,n):
         if arr[i] == 0:
             listofZero.append(0)
         elif arr[i] == 1:
             listofOne.append(1)
         else:
             listofTwo.append(2)
 
     Total = listofZero+listofOne+listofTwo
     return Total 
 
 
 
 
 arr = list(map(int,input(""Enter the Number:\n"").split()))
 n = len(arr)
 print(sort012(arr,n))
 
 '''
 Time Complexity is O(n)
 Space Complexity is O(1)
 
 Input: 
 Enter the Number:
 0 2 1 2 0
 
 Output:
 0 0 1 2 2
 Explanation:
 0s 1s and 2s are segregated 
 into ascending order.
 '''",Python
"/*
     Given a String, find the minimum number of characters that need to be deleted to make the 
     resultant String a Palindrome and also print these characters.
 */
 /*
     Basic Idea to solve this problem:- We find the Longest Common Subsequence of given string and its reverse. The resultant 
     sequence is now just matched with the original string and the missing characters will be the ones that need to be deleted
     from the original string to make it a palindrome.
 */
 
 import java.util.*;
 
 public class Make_string_palindrome_using_DP {
     //Function to calculate maximum out of 2 nos
     public static int maximum(int a, int b){
         return (a>=b) ? a : b;
     }
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the string:- "");
         
         String s1 = sc.nextLine();
 
         StringBuilder s = new StringBuilder();
         s.append(s1);
         s.reverse();
         String s2 = s.toString();
 
         longest_common_subsequence(s1, s2);
     }
 
     public static void longest_common_subsequence(String s1, String s2){
         //Cost Matrix for finding the Longest Common Subsequence for Original string and its reverse
         int cost[][];
         cost = new int[s1.length() + 1][s2.length()+1];
 
         //Recurrence Relation for LCS:- 
         // if str1[i-1] == str2[j-1] -> cost[i][j] = 1 + cost[i-1][j-1]
         // else -> max(cost[i-1][j], cost[i][j-1)
 
         for (int i = 0; i<=s1.length(); i++) {
             for (int j = 0; j<=s2.length(); j++) {
                 if(i == 0 || j == 0){
                     cost[i][j] = 0;
                 }
                 else if(s1.charAt(i-1) == s2.charAt(j-1)){
                     cost[i][j] = 1 + cost[i-1][j-1];
                 }
                 else {
                     cost[i][j] = maximum(cost[i-1][j], cost[i][j-1]);
                 }
             }
         }
 
         System.out.println(""\nL",Java
"/*
 
 A queue is a linear data structure that follows the First in, First out principle (i.e. the first added elements are removed first).
 Generally, a queue is implemented using Linked List but other approach can be used i.e using array ( which has high time complexity ) or using stack.
 Below is the implementation of a queue using a linked list ( Singly Linked List ).
 
 In this program, the user can provide a choice to perform operations on a Queue. It is created using an ES6 class syntax. 
 prompt & colors are node packages for taking user input and displaying text in different colors respectively. 
 
 */
 
 const prompt = require(""prompt-sync"")({ sigint: true });
 const colors = require(""colors"");
 
 // Setting the Color schema
 colors.setTheme({
   display: ""green"",
   insert: ""white"",
   delete: ""red"",
   leave: ""yellow"",
   end: ""rainbow"",
   wrong: ""america"",
 });
 
 // Creating the node class to create nodes
 class Node {
   constructor(value, next = null) {
     this.value = value;
     this.next = next;
   }
 }
 
 // Creating a Queue class to perform operations
 class Queue {
   constructor() {
     this.first = null;
     this.last = null;
     this.length = 0;
   }
 
   // Get the first element of Queue
   peek() {
     if (this.length === 0) return console.log(""Empty Queue"");
     return console.log(this.first.value);
   }
 
   // Insert an element in the Queue
   enqueue(value) {
     const newNode = new Node(value);
     if (this.length === 0) {
       this.first = newNode;
       this.last = newNode;
     } else {
       this.last.next = newNode;
       this.last = newNode;
     }
 
     this.length++;
     return this;
   }
 
   // Delete an element from the Queue
   dequeue() {
     if (!this.first) return console.log(""Queue is already empty"");
     if (this.first === this.last) {
       this.first = null;
       this.last = null;
     } else {
       this.first = this.first.next;
     }
 
     this.length--;
     return this;
   }
 
   // Ch",JavaScript
"/*Description-
     A bitonic subarray is a subarray in which elements are first increasing and then decreasing. User enters array elements/numbers and program returns length of largest bitonic subarray.
      For example, if user enters A[] = {12, 4, 78, 90, 45, 23}, the maximum length bitonic subarray is {4, 78, 90, 45, 23} which is of length 5.
 */
 
 #include<stdio.h>
 #include<stdlib.h>
  
 int bitonic(int *arr, int n)
 {
     int inc[n]; // Length of increasing subarray ending at all indexes
 
     int dec[n]; // Length of decreasing subarray starting at all indexes
     int i, max;
     
     // length of increasing sequence ending at first index is 1
     inc[0] = 1;
     
     // length of increasing sequence starting at first index is 1
     dec[n-1] = 1;
     
     // Step 1) Construct increasing sequence array
     for (i = 1; i < n; i++)
        inc[i] = (arr[i] >= arr[i-1])? inc[i-1] + 1: 1;
     
     // Step 2) Construct decreasing sequence array
     for (i = n-2; i >= 0; i--)
        dec[i] = (arr[i] >= arr[i+1])? dec[i+1] + 1: 1;
     
     // Step 3) Find the length of maximum length bitonic sequence
     max = inc[0] + dec[0] - 1;
     for (i = 1; i < n; i++)
         if (inc[i] + dec[i] - 1 > max)
             max = inc[i] + dec[i] - 1;
  
     return max;
 }
  
 int main()
 {
     int i,NoOfElements;
 	int *A;
 	printf(""How many elements? Enter the size: "");
 	scanf(""%d"",&NoOfElements);
     A=(int*)malloc(NoOfElements*sizeof(int));
     if(A==NULL){
 		printf(""ERROR: MEMORY ALLOCATION FAIL\n"");
 		return 1;
 	}
 	printf(""Enter %d elements"",NoOfElements);
 	for (i=0; i<NoOfElements; ++i){
 		scanf(""%d"",&A[i]);
 	}
     printf(""Array elements are:\n"");
 	for(i=0;i < NoOfElements;i++){
 		printf(""%d\n"",A[i]);
     }
     int n = sizeof(A)/sizeof(A[0]);
     printf(""Length of max length Bitnoic Subarray is %d"",
             bitonic(A, n));
     return 0;
 }
 /* Time COmplexity: O(n)
  Space Complexity: O(n)
 Test Case:
 Input:
 How many elements?",C
"/* if you are given two nodes of a tree , this program will calculate 
    the Lowest Common Ancestor(LCA) of those two nodes
    Definition of LCA : 
    Let T be a rooted tree. The lowest common ancestor between two nodes n1 and n2 is defined 
    as the shared ancestor of n1 and n2 that is located farthest from the root T. 
 */
 #include <bits/stdc++.h>
 using namespace std;
 vector<long long int> adj[100005];
 long long int height_of_node[100005];
 long long int parent_node[100005][18];
 
 void calculate_parent_and_height_node(long long int node, long long int first_parent, long long int current_height = 1)
 {
     height_of_node[node] = current_height;
     parent_node[node][0] = first_parent;
     for (int i = 1; i < 18; i++)
     {
         parent_node[node][i] = parent_node[parent_node[node][i - 1]][i - 1];
     }
     for (auto adjacent_node : adj[node])
     {
         if (adjacent_node != first_parent)
             calculate_parent_and_height_node(adjacent_node, node, current_height + 1);
     }
 }
 long long int LCA(int node1, int node2)
 {
 
     // considering that height of node1 is always the maximum
     if (height_of_node[node1] < height_of_node[node2])
         swap(node1, node2);
 
     long long int difference_in_level = height_of_node[node1] - height_of_node[node2];
     // we are bring node1 and node 2 in the same level using binary lifting technique
     long long int count = 0;
     while (difference_in_level)
     {
         if (difference_in_level & 1)
         {
             node1 = parent_node[node1][count];
         }
         count++;
         difference_in_level = difference_in_level >> 1;
     }
     // if after bringing both nodes at same level, node1=node2 , then that is only the lca .
     if (node1 == node2)
     {
         // we could return any of the node as both are same.
         return node1; 
     }
     //Applying binary lifing and trying to reach the fartherst unequal nodes
     for (int powers_of_two = 17; powers_of_two",C-Plus-Plus
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# ICE CREAM REVENUE PREDICTION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [Ice Cream Revenue](https://www.kaggle.com/vinicius150987/ice-cream-revenue)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import matplotlib.pyplot as plt\n"",
     ""import seaborn as sb\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.linear_model import LinearRegression\n"",
     ""from sklearn.metrics import r2_score""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting our Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n"",
        ""<table border=\""1\"" class=\""dataframe\"">\n"",
        ""  <thead>\n"",
        ""    <tr style=\""text-align: right;\"">\n"",
        ""      <th></th>\n"",
        ""      <th>Temperature</th>\n"",
        ""      <th>Revenue</th>\n"",
        ""    </tr>\n"",
        ""  </thead>\n"",
        ""  <tbody>\n"",
        ""    <tr>\n"",
        ""      <th>0</th>\n"",
        ""      <td>24.566884</td>\n"",
        ""      <td>534.799028</td>\n"",
        ""    </tr>\n"",
        ""    <tr>\n"",
        ""      <th>1</th>\",Python
"/*
 Find the subarray with the given sum:
 
 Given an unsorted array of nonnegative integers, 
 the given script shows the implementation to find 
 a continuous subarray which adds up to the desired sum. 
 
 */
 
 import 'dart:io';
 
 List findSubarray(var arr, int n, int total) {
   // Initializing a counter for the total sum so far
   var curr_sum = arr[0];
 
   // Setting initial index as 0
   int init = 0;
 
   for (int i = 1; i <= n; i++) {
     // increasing the initial index if the current sum becomes
     // greater than the total i.e., removing those elements below init
     while (curr_sum > total && init < i - 1) {
       curr_sum = curr_sum - arr[init];
       init += 1;
     }
 
     // Creating sub-array, if the sum is equal
     if (curr_sum == total) {
       var sub_arr = [];
       for (int j = init; j < i; j++) {
         sub_arr.add(arr[j]);
       }
       return sub_arr;
     }
 
     // Adding the given element to the current sum
     if (i < n) {
       curr_sum = curr_sum + arr[i];
     }
   }
 
   // In case of no subarray of the given sum
   return [];
 }
 
 main() {
   // Taking user input
   var array = [];
 
   var n, ele, total;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
 
   print('Enter the desired total: ');
   total = stdin.readLineSync();
   total = int.parse(total);
 
   // Calling function to obtain the required results
   List soln = findSubarray(array, n, total);
   print(""The subarray is as follows: $soln"");
 }
 
 /*
 Time Complexity:  O(n)
 Space Complexity: O(1)
 
 Sample I/O:
 Enter the number of Elements: 
 5
 Enter Element 1: 
 67
 Enter Element 2: 
 55
 Enter Element 3: 
 4
 Enter Element 4: 
 5
 Enter Element 5: 
 9
 Enter the desired total: 
 18
 The subarray is as follows: [4, 5, 9]
 
 */
",Dart
"/* This is a simple program in go language to check if a given number is neon number
    or not. A neon number is a number where the sum of digits of the square of the
    number should be equal to the initial number.
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 // variables declared globally
 var n int
 var r int
 var sum int
 var square int
 
 // This function calculates the sum of digits of a number
 func Sum(square int) {
 
    for square != 0{
 
       r = square%10
       sum += r
       square = square/10
 
    }
 
 }
 
 // This function checks if a number is a neon number or not
 func neon() {
 
    //calling sum function to calculate the sum
    Sum(square)
 
    if (sum == n){
       fmt.Print(""The given number is a neon number !"")
 
    }else{
 
       fmt.Print(""The given number is not a neon number !"")
    }
 
 }
 
 //driver function
 func main() {
 
   fmt.Print(""Enter the number here :"")
   fmt.Scanln(&n)
 
   square = n*n
 
   //calling the neon function
   neon()
 
 }
 
 /*
    Sample I/O :
 
    a) Is a neon number :
 
    Enter the number here :9
    The given number is a neon number ! 
 
    b) Is not a neon number :
 
    Enter the number here :12
    The given number is not a neon number !  
 */
 
",Go
"/*
 In this problem an array of
 binary strings S and two 
 integers M and N are given.
 Print the size of the largest
 subset of S such that there 
 are at most M 0's and N 1's
 in the subset.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 /*
 This function will return 
 the size of the largest 
 subset having at most max-
 Zero 0's and maxOne 1's.
 */
 
 int largestSubsetSize(vector<string>& S, int maxZero, int maxOne)
 {
     int size = S.size();
     int i, j, k;
     int DP[size + 1][maxZero + 1][maxOne + 1];
     for (i = 0; i <= size; i++) {
         for (j = 0; j <= maxZero; j++) {
             for (k = 0; k <= maxOne; k++) {
                 DP[i][j][k] = 0;
             }
         }
     }
 
     int ans = 0;
     for (i = 1; i <= size; i++) {
         int O = count(S[i - 1].begin(), S[i - 1].end(), '1');
         int Z = S[i - 1].length() - O;
         for (j = 0; j <= maxZero; j++) {
             for (k = 0; k <= maxOne; k++) {
                 DP[i][j][k] = DP[i - 1][j][k];
                 if ((j >= Z) && (k >= O))
                     DP[i][j][k] = max(DP[i][j][k], DP[i - 1][j - Z][k - O] + 1);
                 ans = max(ans, DP[i][j][k]);
             }
         }
     }
 
     return ans;
 }
 
 int main()
 {
     vector<string> S;
     string temp;
     int size, i, maxOne, maxZero;
     cout << ""Enter the size of the array"" << endl;
     cin >> size;
     for (i = 0; i < size; i++) {
         cin >> temp;
         S.push_back(temp);
     }
 
     cout << ""Enter the value of at most 0's and 1's"" << endl;
     cin >> maxOne >> maxZero;
     cout << largestSubsetSize(S, maxZero, maxOne) << endl;
     return 0;
 }
 
 /*
 Sample Input/Output: 
 Input:
 Enter the size of the array
 4
 S=[""10"",""0001"",""111001"",""1"",""0""]
 Enter the value of at most 0's and 1's
 3 5
 Output: 
 4
 
 Time Complexity:O(S*N*M)
 Space Complexity:O(S*N*M)
 where S is the size of Array,
 N is the no of '1' and M is
 the no of '0'.
 */
",C-Plus-Plus
"/*
  Created by Sarthak-9 on 30-12-2020.
  Count Sort Algorithm for Sorting an array of small integers quickly.
 
  Worst complexity: O(n+k)
  Average complexity: O(n+k)
  Space complexity: O(n+k)
  where n is the number of elements input in array and k is the range of input.
 */
 
 #include <iostream>
 
 using namespace std;
 
 int Min(long long int A[], long long int n) {
         long long int min = 100000;
 
         // finds the maximum element of the array
         for (long long int i = 0; i < n; i++) {
                 if (A[i] < min) {
                         min = A[i];
                 }
         }
         return min;
 }
 
 int Max(long long int A[], long long int n) {
         long long int max = A[0];
 
         // finds the maximum element of the array
         for (long long int i = 0; i < n; i++) {
                 if (A[i] > max) {
                         max = A[i];
                 }
         }
         return max;
 }
 
 void CountSort(long long int A[], long long int n) {
         long long int max = Max(A, n);
         long long int min = Min(A, n);
         int* count = new int [max- min + 1];
 
         // initializes the count array with all elements to zero
         for (long long int i = 0; i < n; i++) {
                 count[A[i]-min] = 0;
         }
 
         // updates the count array with frequencies of given numbers
         for (long long int i = 0; i < n; i++) {
                 count[A[i]-min]++;
         }
 
         int k = 0;
 
         for (int j = max; j >= min; j--)
         {
                 for (int i = 0; i < count[j - min]; i++)
                 {
                         A[k++] = j;
                 }
         }
 
         delete [] count;
 }
 
 int main() {
 
         long long int n;
         long long int A[100000];
         cout << ""Enter the size of array"" << endl;
         cin >> n;
         cout << ""Enter the elements"" << endl;
 
             // inputs numbers from the user in an array
         for (long long",C-Plus-Plus
"/*
     Finding the Shortest Path from Source node to the Destination node for a Multi-Staged Graph 
     using the DP approach
     Check out -> https://www.geeksforgeeks.org/multistage-graph-shortest-path/ to know more about
     Multi-Staged Graphs
 */
 
 import java.util.*;
 
 class Graph{
     //Method to create a graph using a Matrix of nodes(adjacency Matrix)
     public int[][] create_graph(int n){
         Scanner sc = new Scanner(System.in);
         int adjacency_matrix[][] = new int[n][n];
         for(int i = 0; i<n; i++){
             for(int j = 0; j<n; j++){
                 System.out.println(String.format(""Enter the weight of the edge %d%d"", i, j));
                 adjacency_matrix[i][j] = sc.nextInt();
             }
         }
         return adjacency_matrix; 
     }
 
     public void printGraph(int[][] graph, int n) 
 	{ 
 		for (int i = 0; i < n; i++) { 
 			System.out.println(""\nAdjacency list of vertex "" + i);  
 			for (int j = 0; j < n; j++) { 
                 if(graph[i][j] != 0){
                     System.out.print("" -> ""+ j); 
                 }
 			} 
 			System.out.println(); 
 		} 
 	}
 }
 
 public class Finding_shortest_path_for_multistaged_graph {
     public static void main(String[] args) {
         Scanner input = new Scanner(System.in);
         
         System.out.println(""Enter the no of Nodes of graph"");
         int n = input.nextInt();
 
         //Array containing Stage No of each node
         int staged_nodes_arr[] = new int[n];
 
         Graph g = new Graph();
         int graph[][] = g.create_graph(n);
         g.printGraph(graph, n);
 
         //Note:- Source and dest nodes are not in any stage so both will have value of stage no as 0.
         staged_nodes_arr[0] = 0;
         staged_nodes_arr[staged_nodes_arr.length - 1] = 0;
         for(int i = 1; i<staged_nodes_arr.length - 1; i++){
             System.out.println(String.format(""Enter Stage no for node %d"", i));
             staged_nodes_arr[i] = input.n",Java
"/*
 We are given two arrays a[] and b[].
 We have to find all possible sums a[i]+b[j], 
 and for each sum count how often it appears.
 Let the size of array a be n and array b be m.
 Sample Input: 
 3 2
 1 2 3
 4 5
 Sample Output:
 5 1
 6 2
 7 2
 8 1
 Large Data file: https://bit.ly/3l8Zo9q
 Output file: https://bit.ly/3jqnz2C 
 Constraints:
 1<=n<=1e5
 1<=m<=1e5
 0<=ai<=1e4
 0<=bi<=1e4
 Time Limit: 1 sec
 My Solution using Fast Fourier Transform:
 We construct for the arrays a and b two polynomials A and B. 
 The numbers of the array will act as the exponents in the polynomial (a[i]xa[i]); 
 and the coefficients of this term will by how often the number appears in the array.
 Then, by multiplying these two polynomials in O(nlogn) time, we get a polynomial C, 9
 where the exponents will tell us which sums can be obtained, 
 and the coefficients tell us how often
 Recorded Time for boundary limits:
 n=1e5
 m=1e5
 0<=ai,bi<=1e4
 Efficiency: O((n+m)log(n+m))
 Execution Time: 0.621 secs
 Language: C++17
 for more details on this algorithm goto
 https://cp-algorithms.com/algebra/fft.html
 */
 
 
 #include<bits/stdc++.h>
 using namespace std;
 
 using cd=complex<double>;
 //Range is the maximum limit of ai & bi together
 #define RANGE 1e4
 const double PI = acos(-1);
 
 //standard Fast Fourier Transform Algorithm
 void fft(vector <cd> &a, bool invert) 
 {
     int n = a.size();
     for (int i = 1, j = 0; i < n; i++) 
     {
         int bit = n>>1;
         for (; j & bit; bit>>=1)
             j ^= bit;
         j ^= bit;
         if (i < j) 
         	swap(a[i], a[j]);
     }
     for (int len = 2; len <= n; len<<=1) 
     {
         double ang=2*PI/len*(invert?-1:1);
         cd wlen(cos(ang),sin(ang));
         for(int i=0;i<n;i+=len) 
         {
             cd w(1);
             for (int j = 0; j < len/2; j++) 
             {
                 cd u = a[i + j], v = a[i + j + len/2] * w;
                 a[i + j] = u + v;
                 a[i + j + len/2] = u - v;
",C-Plus-Plus
"/*
 The best fit strategy will not allocate a block of size > N , as it is found in the first-fit method;
 instead it will continue searching to find a suitable block so that the block size is closer to the block size of request.
 The below program is an implementation of best fit algorithm using array data structure.
 */
 
 
 import java.util.Scanner;
 //Block class is used as the fixed memory blocks for allocation
 class Block {
     int size;
     int ID;
     int fragment;
 }
 // process class is used for allocating memory for the requesting processes
 class process {
     int Num;
     int size;
     Block block;
 }
 
 class Code {
     // initialiseBlocks function initializes all the blocks with sizes and id
     void initialiseBlocks(Block arr[], int sizes[], int n) {
         for (int i = 0; i < n; i++) {
             arr[i].size = sizes[i];
             arr[i].fragment = sizes[i];
             arr[i].ID = i + 1;
         }
     }
     // printResult function prints the result of the memory allocation strategy
     void printResult(process arr2[], int numOfprocess) {
         System.out.println(
             ""Process No            Process Size          Block ID          Block Size         Block Fragment\n"");
         for (int i = 0; i < numOfprocess; i++)
             System.out.println(arr2[i].Num + ""                     "" + arr2[i].size + ""                     ""
                                + arr2[i].block.ID + ""                     "" + arr2[i].block.size + ""                     ""
                                + arr2[i].block.fragment + ""\n"");
     }
     // bestfit function allocates memory to processes using bestfit allocation algorithm
     void bestfit(Block arr[], int sizes[], int n, process arr2[], int numOfprocess) {
         initialiseBlocks(arr, sizes, n);
         Block minBlock = new Block();
         for (int i = 0; i < numOfprocess; i++) {
             int min = Integer.MAX_VALUE;
             for (int j = 0; j < n; j++) {
               ",Java
"# Program to traverse given tree in pre-order, in-order and post-order fashion
 
 
 class TreeNode:
     def __init__(self, val):
         self.val = val
         self.left = None
         self.right = None
 
 
 class Tree:
     def __init__(self, root):
         self.root = TreeNode(root)
 
     def inorder_traversal(self, node, path):
         if node:
             path = self.inorder_traversal(node.left, path)
             path += str(node.val) + ' '
             path = self.inorder_traversal(node.right, path)
 
         return path
 
     def preorder_traversal(self, node, path):
         if node:
             path += str(node.val) + ' '
             path = self.preorder_traversal(node.left, path)
             path = self.preorder_traversal(node.right, path)
 
         return path
 
     def postorder_traversal(self, node, path):
         if node:
             path = self.postorder_traversal(node.left, path)
             path = self.postorder_traversal(node.right, path)
             path += str(node.val) + ' '
 
         return path
 
 # Creating a tree of the following structure:-
 
 #      1
 #    /   \
 #   2     3
 #  / \   / \
 # 4   5 6   7
 
 tree = Tree(1)
 
 tree.root.left = TreeNode(2)
 tree.root.right = TreeNode(3)
 
 tree.root.left.left = TreeNode(4)
 tree.root.left.right = TreeNode(5)
 tree.root.right.left = TreeNode(6)
 tree.root.right.right = TreeNode(7)
 
 # In-Order Traversal :- left -> root -> right
 
 print(tree.inorder_traversal(tree.root, ''))
 # Expected Output:- 4 2 5 1 6 3 7
 
 # Pre-Order Traversal :- root -> left -> right
 
 print(tree.preorder_traversal(tree.root, ''))
 # Expected Output:- 1 2 4 5 3 6 7
 
 # Post-Order Traversal :- left -> right -> root
 
 print(tree.postorder_traversal(tree.root, ''))
 # Expected Output:- 4 5 2 6 7 3 1
",Python
"/**
 Given a Matrix of dimensions n*n, the program will 
 print the matrix after rotating it with 90 degrees
 in both clockwise and anticlockwise directions.
 */
 
 import java.util.Scanner;
 
 public class MatrixRotation {
 
 	public static void main(String[] args) {
 
 		Scanner sc = new Scanner(System.in);
 		
 		System.out.print (""Enter size of square matrix - "");
 		int n = sc.nextInt();
 		
 		int[][] ar = new int[n][n];
 		System.out.println(""Enter elements -"");
 		for (int i = 0; i < n; i++) {
 			for (int j = 0; j < n; j++) {
 				ar[i][j] = sc.nextInt();
 			}
 		}
 		
 		System.out.println(""Original Matrix :"");
 		for (int i = 0; i < n; i++) {
 			for (int j = 0; j < n; j++) {
 				System.out.print(ar[i][j] + ""\t"");
 			}
 			System.out.println();
 		}
 		
 		System.out.println(""\nAnticlockwise Direction :"");
 		for (int i = 0; i < n; i++) {
 			for (int j = 0; j < n; j++) {
 				System.out.print(ar[j][n - 1 - i] + ""\t"");
 			}
 			System.out.println();
 		}
 		
 		System.out.println(""\nClockwise Direction :"");
 		for (int i = 0; i < n; i++) {
 			for (int j = 0; j < n; j++) {
 				System.out.print(ar[n-1-j][i] + ""\t"");
 			}
 			System.out.println();
 		}
 	}
 }
 
 /**
 Time Complexity : O(n*n)
 Space Complexity : O(n*n)
 
 Input :
 
 Enter size of square matrix - 4
 Enter elements -
 12 23 45 2
 54 34 89 75
 1 5 38 6
 28 67 11 9
 
 Output :
 
 Original Matrix :
 12	23	45	2	
 54	34	89	75	
 1	5	38	6	
 28	67	11	9	
 
 Anticlockwise Direction :
 2	75	6	9	
 45	89	38	11	
 23	34	5	67	
 12	54	1	28	
 
 Clockwise Direction :
 28	1	54	12	
 67	5	34	23	
 11	38	89	45	
 9	6	75	2	
 
 */
 
",Java
"/*Keyword cipher is a form of monoalphabetic substitution, where a keyword is used as the key. Now
   a encryption is formed of alphabets from [a-z] such that the first part of encrption contains 
   unique letters of the keyword and the rest are the remaining alphabets from [a-z]. That is,
   until the keyword is used up, whereupon the rest of the ciphertext letters are used in alphabetical 
   order, excluding those already used in the key.*/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 //Defining max length of plaintext, keyword, ciphertext
 #define MAXLENGTH 100
 
 /*This is the encryption function that takes plaintext message
   and keyword as input*/
 char* encrypt(char* message, char* keyword) {
 
 	//This variable contains encrypted message
 	static char encrypted_message[MAXLENGTH];
 	//This the pad to be generated using keyword
 	static char pad[MAXLENGTH];
 
 	int count = 0;
 	int i = 0;
 
 	/*If the plaintext contains spaces, replace it by
 	  underscores*/
 	for(int i = 0; i < strlen(message) - 1; i++) {
 		if(message[i] == ' ') {
 			message[i] = '_';
 		}
 	}
 	
 	/*This while loop finds all the unique alphabets in the
 	  keyword and is inserted at the beginning of the pad*/
 	while(i < strlen(keyword) - 1) {
 
 		//If the keyword alphabet is a space, then leave it
 		if(keyword[i] == ' ') {
 			i++;
 			continue;
 		}
 	
 		int not_present = 0;
 		
 		for(int j = 0; j < strlen(keyword) - 1; j++) {
 			if(keyword[i] != pad[j]) {
 				not_present += 1;
 			}
 		}
 		
 		//If the keyword alphabet is not present in the pad
 		if(not_present == strlen(keyword) - 1) {
 			//add it
 			pad[count] = keyword[i];
 			count++;
 		}
 		i++;
 	}
 
 	/*After this while loop, we get first half of our pad.
 	  For example, if the keyword is ""well"", then ""wel"" is
 	  added to the pad*/
 
 	/*Now to fill the pad, all the remaining alphabets those are not previously present 
 	  are added to it*/
 	char alphabet[26] = {'a', 'b', 'c', 'd', 'e', 'f",C
"/*
 Queue is a linear data structure which follows FIFO
 (First In First Out) Rule. It can be implemented using array/
 linked list/ stacks.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 //We are creating a class for array
 class Queue
 {
 private:
     int front;
     int rear;
     int capacity;
     int *ptr;
 
 public:
 
     //Constructor to initialize the data members of Queue class
     Queue(int cap)
     {
         front = 0;
         rear = 0;
         capacity = cap;
         ptr = new int [capacity];
     }
 
     //Checking if the Queue is empty or not
     bool isEmpty()
     {
         if(front == rear)
             return true;
         return false;
     }
 
     //Checking if the Queue is full or not
     bool isFull()
     {
         if((rear+1) % capacity == front)
             return true;
         return false;
     }
 
     //Inserting data into the queue
     void enQueue()
     {
         if(isFull())
             cout<<""\nQueue is Full""<<endl;
         else
         {
             int data;
             cout<<""\nEnter data to be inserted : "";
             cin>>data;
             rear = (rear+1)%capacity;
             ptr[rear] = data;
         }
     }
 
     //Deleting data from the queue
     void deQueue()
     {
         if(isEmpty())
             cout<<""\nQueue is Empty""<<endl;
         else
         {
             int data;
             front = (front+1)%capacity;
             data = ptr[front];
             cout<<endl<<data<<""  is deleted from Queue""<<endl;
         }
     }
 
     //Traversing queue and printing data
     void display()
     {
         int i;
         if(rear == front)
             cout<<""\nQueue is Empty""<<endl;
         else
         {
             cout<<""Queue is : "";
             for(i = front+1 ; i != rear ; i = (i+1) % capacity)
                 cout<<ptr[i]<<""   "";
             cout<<ptr[rear]<<endl;
         }
     }
 };
 
 //Driver Program
 int main()
 {
     int cap,choice;
     cout<<""Enter the ",C-Plus-Plus
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""MgwaYgtxExJG""
    },
    ""source"": [
     ""# Ames House Price Prediction Using Linear Regression""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [Ames House Prices](https://www.kaggle.com/c/house-prices-advanced-regression-techniques/data)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""AxJ-Z3iRE1IZ""
    },
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {
     ""id"": ""cKs5-dO1TJRq""
    },
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""from sklearn import preprocessing  \n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.linear_model import LinearRegression\n"",
     ""from sklearn.metrics import r2_score""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""TJNbWZdqE_Jh""
    },
    ""source"": [
     ""### Getting our Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 3,
    ""metadata"": {
     ""id"": ""Zo5NX8tyTn47""
    },
    ""outputs"": [],
    ""source"": [
     ""df = pd.read_csv('train.csv')""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 4,
    ""metadata"": {
     ""colab"": {
      ""base_uri"": ""https://localhost:8080/"",
      ""height"": 422
     },
     ""id"": ""fzY-HxHLTw_t"",
     ""outputId"": ""87acc824-b8b9-4d76-8267-a6c33ad0122e""
    },
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n",Python
"/* COUNT OF LEAF NODES IN BINARY SEARCH TREE
     Binary Search Tree is a special type of binary tree where
     1. The value of all the nodes in the left sub-tree is less than or equal to the value of the root.
     2. The value of all the nodes in the right sub-tree is greater than value of the root.
     3. This rule will be recursively applied to all the left and right sub-trees of the root.
 
     Leaf node is a node which does not have left or right child
     No. of leaf nodes varies with the order in which the nodes are inserted
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // Declare treeNode with data , rc (right child) and lc (left child )
 typedef struct treeNode
 {
     int data;
     struct treeNode *lc;
     struct treeNode *rc;
 } treeNode;
 
 //to insert a node into BST
 treeNode *insertIntoTree(treeNode *root, int data)
 {
     //If tree is empty insert as root node
     if (root == NULL)
     {
         treeNode *ptr;
         ptr = new treeNode;
         ptr->data = data;
         ptr->lc = NULL;
         ptr->rc = NULL;
         root = ptr;
     }
     else
     {
         // insert recursively in accordance with BST properties
         if (root->data >= data)
         {
             root->lc = insertIntoTree(root->lc, data);
         }
         else if (root->data < data)
         {
             root->rc = insertIntoTree(root->rc, data);
         }
     }
     return root;
 }
 
 //to count the leaf nodes
 int leaf_nodes(treeNode *root)
 {
     //Initially count of leaf nodes is set as 0
     static int count=0;
     //If tree is not empty
     if (root)
     {
         //If the node doesn't have any child increment count
         if (root->lc == NULL && root->rc == NULL)
             count++;
         else
         {
             //recursively check left and right sub-trees
             if (root->lc)
                 leaf_nodes(root->lc);
             if (root->rc)
                 leaf_nodes(root->rc);
         }
     }
     return ",C-Plus-Plus
"import java.util.*;
 
 public class CocktailSort {
 
     private static void swap(int arr[], int i, int j) {
         int temp = arr[i];
         arr[i] = arr[j];
         arr[j] = temp;
     }
 
     private static void cocktailSort(int arr[]) {
         boolean isSwapped = true;
         int begin = 0;
         int last = arr.length-1;
 
         while (isSwapped == true) {
             // set isSwapped to false so that if nothing gets
             // sorted in this iteration we can break right away
             isSwapped = false;
 
             for(int i = begin; i < last; i++) {
                 // going forward
                 if (arr[i] > arr[i+1]) {
                     swap(arr, i, i+1);
                     isSwapped = true;
                 }
             }
 
             // if nothing swapped then the array is already sorted
             if (isSwapped == false)
                 break;
 
             // else, reset isSwapped to check for next iteration
             isSwapped = false;
 
             // since largest item is now in last. we only need
             // to check for one place before it
             last -= 1;
 
             for (int i = last; i >= begin; i--) {
                 // going backward
                 if (arr[i] > arr[i+1]) {
                     swap(arr, i, i+1);
                     isSwapped = true;
                 }
             }
 
             // now the smallest number is on first place
             // so move starting point one position ahead
             begin++;
         }
     }
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
 
         //taking input array
         System.out.println(""Enter size of array:"");
         int size = sc.nextInt();
         int arr[] = new int[size];
         System.out.println(""Enter array elements:"");
         for (int i=0; i<size; i++) {
             arr[i] = sc.nextInt();
         }
         sc.close();
 
         // before sorting
         Sy",Java
"/*
 Description : 
             Given a pointer/ reference to the node which is 
             to be deleted from the linked list of N number nodes.
             The task is to delete the node. Pointer/ reference to head node is not given.     
 */
 
 #include <bitset/stdc++.h>
 using namespace std;
 
 struct Node
 {
     int data;
     struct Node *next;
     Node(int x)
     {
         data = x;
         next = NULL;
     }
 } * head;
 
 // function used to search the data which is given by user
 Node *search_node(Node *head, int search_for_data)
 {
     Node *current = head;
     while (current != NULL)
     {
         // if data found then break
         if (current->data == search_for_data)
         {
             break;
         }
         current = current->next;
     }
     return current;
 }
 
 //function used for the inserting the data into the tree.
 void insert_node()
 {
     // n= number of nodes in tree
     int n, i, value;
     Node *temp;
     cout << ""Enter the number of nodes : "" << endl;
     scanf(""%d"", &n);
     cout << ""Enter the data : "" << endl;
     for (i = 0; i < n; i++)
     {
         scanf(""%d"", &value);
         if (i == 0)
         {
             head = new Node(value);
             temp = head;
             continue;
         }
         else
         {
             temp->next = new Node(value);
             temp = temp->next;
             temp->next = NULL;
         }
     }
 }
 
 // function used for the printing the data of the tree
 void print_tree(Node *node)
 {
     while (node != NULL)
     {
         cout << node->data << "" "";
         node = node->next;
     }
     cout << endl;
 }
 
 // another class
 class Solution
 {
 public:
     // function used to delete the data given by user
     // head pointer is not given
     // reference given of the node to be deleted
     void to_delete_node(Node *del)
     {
         if (del->next == NULL)
         {
             return;
         }
         Node *temp_1 = del->next;
         d",C-Plus-Plus
"# ACKERMANN FUNCTION
 # Definition: A function of two parameters whose value grows very fast.
 # Formal Definition:
 #   A(0, j)=j+1 for j  0
 #  	A(i, 0)=A(i-1, 1) for i > 0
 #  	A(i, j)=A(i-1, A(i, j-1)) for i, j > 0
 # In 1928, Wilhelm Ackermann observed that A(x,y,z),
 # the z-fold iterated exponentiation of x with y,
 # is a recursive function that is not primitive recursive.
 # A(x,y,z) was simplified to a function
 # of 2 variables by Rzsa Pter in 1935.
 # Raphael M. Robinson simplified the initial condition in 1948.
 
 
 def Ackermann_func(m, n):
     history = [[0 for i in range(n + 1)] for j in range(m + 1)]
     for i in range(m + 1):
         for j in range(n + 1):
             if i == 0:
                 history[i][j] = j + 1
             elif j == 0:
                 history[i][j] = history[i-1][1]
             else:
                 a = i - 1
                 b = history[i][j-1]
                 if a == 0:
                     result = b + 1
                 elif b <= n:
                     result = history[i-1][history[i][j-1]]
                 else:
                     result = (b-n)*(a) + history[a][n]
                 history[i][j] = result
     return history[m][n]
 m, n = input(""Enter non-negative values of m and n: "").split()
 m, n = int(m), int(n)
 print(""A(%u, %u) = %u"" % (m, n, Ackermann_func(m, n)))
 
 # SAMPLE INPUT: Enter non-negative values of m and n: 2 2
 # SAMPLE OUTPUT: A(2,2) = 7
 # Time complexity: O( M * N )
 # Space complexity: O( M * N )
",Python
"/*
 FIRST FIT MEMORY ALLOCATION
 Available memory blocks are accepted as input from the user
 The list of available storage is searched and as soon as a 
 free block of size >= N is found, the pointer of that block 
 is returned, after retaining residual space
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 //structure to represent memoryblock with id and size
 typedef struct MemoryBlock
 {
     int id;
     int size;
 } MemoryBlock;
 
 //to print the id of allocated memory block
 void print_block(MemoryBlock block)
 {
     if (block.id != -1 && block.size != -1 && block.size != 0)
         printf(""Block #%d \n"", block.id);
     else
         printf(""Invalid Memory Block\n"");
 }
 
 //linked list to store memory blocks
 typedef struct MemoryManager
 {
     MemoryBlock b;
     struct MemoryManager *llink, *rlink;
 } MemoryManager;
 
 //first fit memory allocation
 MemoryBlock first_fit(MemoryManager *m, int memory)
 {
     MemoryBlock bl;
     //if the list is empty
     if (m == NULL)
     {
         bl.id = -1;
         bl.size = -1;
     }
     else
     {
         MemoryManager *ptr = m, *ptr1, *ptr2, *p;
         while (ptr->rlink != NULL && ptr->b.size < memory)
             ptr = ptr->rlink;
         //if block of size greater than memory is found
         if (ptr->b.size >= memory)
         {
             bl = ptr->b;
             bl.size = ptr->b.size;
             ptr->b.size -= memory;
         }
         else
         {
             bl.id = -1;
             bl.size = -1;
         }
         return bl;
     }
 }
 
 //to add available memory blocks to linked list
 void deallocate(MemoryManager *m, MemoryBlock memory)
 {
     MemoryManager *ptr = m;
     while (ptr->rlink != NULL)
     {
         ptr = ptr->rlink;
     }
     MemoryManager *n = malloc(sizeof(MemoryManager));
     n->b = memory;
     ptr->rlink = n;
     n->llink = ptr;
     n->rlink = NULL;
 }
 
 //driver code
 int main()
 {
     //accept the number of memory blocks and sizes as user input
",C
"/*
 A number is said to be a Harshad Number if it is divisible by the sum of its digits.
 For example: The number 84 is divisible by the sum (12) of its digits (8, 4).
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // Function to check whether the Number is Harshad Number or Not.
 
 bool isHarshad(int number)
 {
     int sum = 0;
     int copy = number;
     while (number > 0)
     {
         int digit = number % 10;
         number = number / 10;
         sum += digit;
     }
     return copy % sum == 0;
 }
 
 int main()
 {
     cout << ""Enter a Number:"" << endl;
     int input;
     cin >> input;
     if (isHarshad(input))
         cout << input << "" is a Harshad Number."" << endl;
     else
         cout << input << "" is not a Harshad Number."" << endl;
     return 0;
 }
 
 /*
 Time Complexity: O(log(n))
 Space Complexity: O(1)
 
 Sample Input/Output
 Enter a Number:
 84
 84 is a Harshad Number.
 
 Enter a Number:
 16
 16 is not a Harshad Number.
 
 */
",C-Plus-Plus
"/*
 /* Problem Description- This is a shortest path algorithm used in graphs which is used to find the shortest 
 distance from a starting vertex to all the vertex. The edge between two vertices having minimum distance is 
 considered and also no vertex is left alone and not connected.
  */
 
  import java.util.*;
  import java.lang.*;
  class dijsktra
  {
      static int Ver;
      int minDistance(int dist[], Boolean sptSet[])
      {
          // Minimum value intialized with maximum value
          int min = Integer.MAX_VALUE;
          int  min_index = -1; //setting minimum index to -1 as array index starts from zero.
 
          for (int v = 0; v < Ver; v++)
              if (sptSet[v] == false && dist[v] <= min) {
                  min = dist[v];
                  min_index = v;
              }
 
          return min_index;
      }
 
      // A utility function to print the constructed distance array
      void printSolution(int dist[])
      {
          System.out.println(""Vertex \t  Distance from Source"");
 		 for (int i = 0; i < Ver; i++)
              System.out.println(i + "" \t\t "" + dist[i]);
 	 }
 	 //to implement dijkstra algorithm by finding the shortest distance
      void dijkstra(int graph[][], int src)
      {
          int dist[] = new int[Ver]; //This will have the shortest distance
          // sptSet[i] will true if vertex i is included in shortest
          Boolean sptSet[] = new Boolean[Ver];
          for (int i = 0; i < Ver; i++) {
              dist[i] = Integer.MAX_VALUE;//all distance initalized as infinite
              sptSet[i] = false;
          }
          dist[src] = 0; //since the sorce vertex will always have distance 0 from itself/
 
          // Find shortest path for all vertices
          for (int count = 0; count < Ver - 1; count++) {
              // Pick the minimum distance vertex from the set of vertices
              int u = minDistance(dist, sptSet);
              // Mark the picked vertex as processed
              ",Java
"/*Problem Description
 You are given a rod of length N inches and an array of prices that contains prices of all pieces of size smaller than N. 
 Determine the maximum value obtainable by cutting up the rod and selling the pieces.
 */
 
 import java.util.Scanner;
 
 class Helper {
     // this method - getValue() will return the final answer to main method 
     public int getValue(int price[], int n) {
         // m variable will help in getting the size array length by using price length 
         int m = price.length ;
         int size[] = new int[m];
         for(int i = 0 ; i < m  ; i++)
             size[i] = i + 1 ;
         // call solve() method for solving the problem
         int ans = solve(price , size, m , n);
         return ans ;
     }
     //solve() method will act as solving the problem
     int solve(int[] price , int[] size , int m , int n  )
     {
         // Create 2-D array to store the value of profit 
         int dp[][] = new int[m+1][n+1] ;        
         for(int i = 0 ; i < m + 1; i++)
         {
             for(int j = 0 ; j < n + 1 ; j++)
             {
                 // if size = 0 or there is 0 value for the size
                 if(i == 0 || j ==0 )
                 {
                     dp[i][j] = 0;                    
                 }
                 /*  if size is less than the current max size then 
                   get the max price from size or neglect if not needed
                 */
                 else if(size[i-1] <= j )
                 {
                     dp[i][j] = Math.max(price[i-1] + dp[i][j - size[i-1] ] , dp[i-1][j] ) ;
                 }
                 // if size is greater than current max size , no value is taken from price array
                 else
                 {
                     dp[i][j] = dp[i-1][j];
                 }
             }
         }
         return dp[m][n];
     }    
 }
 // main class which contains main method
 public class Rod_Cutting {	
 	 public static void mai",Java
"/*Problem Statement: 
 Given n wines in a row, with integers denoting the cost of each wine respectively. 
 Each year you can sell the first or the last wine in the row. 
 Let the initial profits from the wines be P1, P2, P3Pn. 
 In the Yth year, the profit from the ith wine will be Y*P[i]. 
 The goal is to calculate the maximum profit that can be earned by selling all the wines. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int profit(int wines[],int i,int j,int year, int dp[][10])
 {
     if(i>j)
     {
         return 0;
     }
     if(dp[i][j]!=0)
     {
         return dp[i][j];
     }
     int op1=wines[i]*year+profit(wines,i+1,j,year+1,dp);
     int op2=wines[j]*year+profit(wines,i,j-1,year+1,dp);
     return max(op1,op2);
 }
 
 int main()
 {
     int n;
     cout<<""Enter total number of wines: ""<<endl;
     cin>>n;
     int wines[100],dp[10][10]={0};
     cout<<""Enter wine prices: ""<<endl;
     for(int i=0;i<n;i++)
     {
         cin>>wines[i];
     }
     cout<<""The maximum profit is: ""<<profit(wines,0,n-1,1,dp)<<endl;
     return 0;
 }
 /*
 Example:-
 
 Input:-
 Enter total number of wines:
 5
 Enter wine prices:
 2 4 6 2 5
 
 Output:-
 The maximum profit is: 64
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
"//C Program to concatenate two strings without using the strcat() function.
 #include <stdio.h>
 #include <string.h> 
 
 int main() {
   
   char str1[100], str2[100];
   printf(""Enter the first string:"");
   scanf(""%s"", str1);
   printf(""Enter the second string:"");
   scanf(""%s"", str2); 
   int length, j;
 
   length = 0;
   while (str1[length] != '\0') {
     ++length;
   }
 
   for (j = 0; str2[j] != '\0'; ++j, ++length) {
     str1[length] = str2[j];
   }
 
   str1[length] = '\0';
 
   printf(""After concatenation, Final string will be:\n "");
   puts(str1);
 
   return 0;
 }
 
 /*
   INPUT:
   Enter the first string:Hello
   Enter the second string:World
 
   OUTPUT:
   After concatenation, Final string will be:
   HelloWorld
 */",C
"/*
 Introduction 
 Given a N ary Tree ,
 Generate a equivalent child sibling Tree , 
 and  Print the sum of elements of this equivalent Tree.
 It is guaranteed that all node's have unique key values.
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* firstChild;
     Node* nextSibling;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->firstChild = NULL;
     n->nextSibling = NULL;
     return n;
 }
 
 //Function to add Sibling and return it
 struct Node* addSibling(struct Node* root, int data)
 {
     //If root is a null node , return the null node
     if (root == NULL || data==-1)
         return NULL;
     
     //else move to the last sibling and then add the new node as sibling
     while (root->nextSibling)
         root = root->nextSibling;
  
     return (root->nextSibling = newNode(data));
 }
 
 //Function to add Child and return it
 struct Node* addChild(struct Node* root, int data)
 {
     //If root is a null node , return the null node
     if (root == NULL || data==-1)
         return NULL;
  
     //if the first child exists
     //add the new node as a sibling to the first child
     //else add the new node as first child
     if (root->firstChild)
         return addSibling(root->firstChild, data);
     else
         return (root->firstChild = newNode(data));
 }
 
 //Function to find sum of all elements of a given Tree
 long SumOfNaryTree(struct Node* root)
 {
     //If root is a NULL node , return 0
     if(root==NULL)
       return 0;
     
     //else return the sum of tree 
     //by recursively calculating sum of First Child ",C-Plus-Plus
"'''
 Given five positive integers, the aim is to find the minimum and maximum values that can be calculated by summing exactly four of the five integers.
 
 '''
 
 def MMSum(a):
     # sorting the array so that it becomes easier to find the min and max set of values
     a.sort()    
     minn=0
     maxx=0
     for i in range(0,4):
         # summing up all minimum values
         minn+=a[i]           
     for i in range(1,5):
         # summing up all maximum values
         maxx+=a[i]           
     print(minn,maxx)
 
 # getting the input    
 user_input = (input().strip().split()) 
 array = []
 for i in user_input:
     array.append(int(i))
 # calling the Min-Max-Sum function     
 MMSum(array)                           
   
 '''
 
 COMPLEXITY:
 	
 	 Time Complexity -> O(N)
 	 Space Complexity -> O(N)
      
 Sample Input:
 1 2 3 4 5
 
 Sample Output:
 10 14
 
 '''
",Python
"#= For any given array there are 2^N subsets. Thus generating each and every subset using BitMasking.
 We follow the binary representation of whole numbers and use them as boolean value if a character in the Set
 will occur or not. We will remove the duplicate subsets and display the non null unique subsets.
 =#
 
 ## Function 
 
 function subsets(array, n)
     println(""The subsets are: "")
     powerSet = Set()
     for i = 1:(1<<n)
         s = """"
         for j = 1:n
             if (i & (1 << j) > 0)
                 temp = string(array[j])
                 s *= temp
             end
         end
         if (length(s) > 0)
             println(s)
         end
     end
 end
 
 ## Input
 
 print(""Enter the length of array: "")
 n = readline()
 n = parse(Int64, n)
 print(""Enter the elements of array: "")
 array = Int64[]
 for i = 1:n
     temp = readline()
     temp = parse(Int64, temp)
     push!(array, temp)
 end
 
 ## Calling the Function 
 
 subsets(array, n)
 
 #=
 Sample Test Case:
 Input:
     Enter the length of array: 5
     Enter the elements of array: 1 2 3 4 5
 Output:
     The subsets are: 
     124
     234
     2
     1234
     134
     34
     24
     4
     123
     3
     5
     23
     13
     14
     12
     1
 Time complexity: O(2^N)
 Space complexity: O(1)
 =#
 
",Julia
"/**
  * Maximum Sum Subarray of Size K
  * Java program to find the maximum sum of a subarray of fixed size K, 
  * given an array of integers, using the 'Sliding Window Technique'. 
  */
 
 import java.util.*; 
 public class MaximumSumSubarray {
     
     public static int maximumSum(int[] numArray, int K) {
         int currentSum = 0; 
 
         //Calculating sum for first window of size K
         for(int i=0; i<K; i++) 
             currentSum += numArray[i]; 
 
         //Storing maximum sum till current window
         int maxSum = currentSum; 
 
         //Finding sum of all possible K-sized windows, one by one
         int subtractIndex = 0; 
         for(int i=K; i<numArray.length; i++) {
             currentSum += numArray[i] - numArray[subtractIndex]; 
             subtractIndex++; 
             maxSum = Math.max(maxSum, currentSum); 
         }
         return maxSum; 
     }
     
     public static void main(String[] args) {
         Scanner scan = new Scanner(System.in); 
 
         //Taking input from user
         System.out.println(""Enter length of array and size of window: ""); 
         int length = scan.nextInt(); 
         int K = scan.nextInt(); 
         int numArray[] = new int[length]; 
         System.out.println(""Enter array elements: ""); 
         for(int i=0; i<length; i++) {
             numArray[i] = scan.nextInt(); 
         }
 
         if(K > length || K <= 0)
             System.out.println(""Invalid input""); 
         else {
             System.out.println(""Maximum sum of a subarray of size "" + K + "":""); 
             System.out.println(maximumSum(numArray, K));
         }
     }
 
 }
 
 /*
     Time complexity: O(N)
     Space complexity: O(1)
 
     TEST CASES
 
     INPUT
     Enter length of array and size of window: 
     10 3
     Enter array elements: 
     1 7 -2 4 5 2 1 6 11 -4
     OUTPUT
     Maximum sum of a subarray of size 3:
     18
 
     INPUT
     Enter length of array and size of window: 
     8 4
     Enter a",Java
"/* Binary search tree(BST) is a rooted binary tree whose internal nodes each store a key greater than all 
 the keys in the node's left subtree and less than those in its right subtree. */
 
 using System;
 
 namespace Binary_Search_Tree
 {
     public class Node
     {
         public int data;
         public Node left;
         public Node right;
         public Node(int data)
         {
             this.data = data;
             left = null;
             right = null;
         }
     }
     public class BinarySearchTree
     {
         Node root;
         BinarySearchTree()
         {
             root = null;
         }
         public void Insert(int data)
         {
             root = Insert(root, data);
         }
         //Insert New Node in Binary search tree
         public Node Insert(Node root, int data)
         {
             if (root is null)
             {
                 Node newNode = new Node(data);
                 root = newNode;
                 return root;
             }
             if (data < root.data)
             {
                 root.left = Insert(root.left, data);
             }
             else if (data > root.data)
             {
                 root.right = Insert(root.right, data);
             }
             return root;
         }
         //To limit parameters
         public void Inorder()
         {
             Inorder(root);
         }
 
         // to perform inorder traversal of BST
         public void Inorder(Node root)
         {
             if (root != null)
             {
                 Inorder(root.left);
                 Console.WriteLine(root.data);
                 Inorder(root.right);
             }
         }
         //To limit parameters
         public void Postorder()
         {
             Postorder(root);
         }
 
         // to perform postorder traversal of BST
         public void Postorder(Node root)
         {
             if (root != null)
             {
                 Postorder",C-Sharp
"/*
 Given an array of integers where each element represents the maximum number of steps
 that can be made forward from that element.We need to find the minimum number of jumps 
 to reach the end of the array (starting from the first element).
 If an element is 0, then we cannot move through that element.
 
 Approach:
 -------- Stair and Ladder approach-------
 1. At every index, collect a ladder, size of that ladder will be value of element at that index.
 Stairs are number of stairs on ladder.
 
 2. After collecting a ladder, keep it if it is large enough ,and throw if it is small.
 
 3. Keep climbing the current ladder if current ladder gets over use the ladder which we have stored 
    in step 2 and increase the count, since we have made a jump to another ladder.
 */
 #include <iostream>
 using namespace std;
 
 int min_jumps(int arr[], int n)
 {
     /* already at end of array ,no need to jump */
     if (n == 1)
     {
         return 0;
     }
    /* if arr[0] is 0 then we can't jump */
     if (arr[0] == 0)
     {
         return -1;
     }
    /* ladder keeps track of largest ladder we have and stairs keep track of stairs
        in the current ladder, initially jump count is 1 as we have to take a ladder
        to start. */
     int ladder = arr[0];
     int stairs = arr[0];
     int jumps_count = 1;
     for (int i = 1; i < n; i++)
     {
         if (i == n - 1)
         { // Reached end of array
             return jumps_count;
         }
 
         if (i + arr[i] > ladder)
         { /* building up the ladder,i is added to arr[i] as we need to take forward jumps 
            starting from current index ,also we have already traversed till ith index. */
             ladder = i + arr[i];
         }
         //climbing the stairs, hance they are reducing by 1
         stairs--;
         if (stairs == 0)
         { /* When no stairs are left on current ladder,increase the count and jump to our stored ladder.
              new set of stairs will now be lad",C-Plus-Plus
"# INTERPOLATION SEARCH
 
 # If the searching element is present in array,
 # then it returns index of it, else returns -1
 
 
 def interpolationSearch(arr, size, search_element):
     # Assigning indexes
     low = 0
     high = size - 1
     # As array is going to be sorted
     # an element present in array must be in range defined by corner
     while low <= high and search_element >=
     arr[low] and search_element <= arr[high]:
         if low == high:
             if arr[low] == search_element:
                 return low
             return -1
 
         position = low + int(float(high - low) /
         (arr[high] - arr[low])*(search_element - arr[low]))
 
         # Condition of element found
 
         if arr[position] == search_element:
             return position
 
         # If x is larger, x is in upper part
 
         if arr[position] < search_element:
             low = position + 1
         else:
             # If x is smaller, x is in lower part
             high = position - 1
 
     return -1
 
 
 # Starting with the main code
 # Creating array of the size n
 # Size would be taken into the variable n from user
 def main():
     arr = []
     size = int(input('Enter the size of array : '))
 
     # Entering the elements in the array
 
     print ('Enter elements :')
     for index in range(0, size):
         ele = int(input())
         arr.append(ele)
     print ('The elements entered are:\n', arr, '\n')
 
     # Sorting our array
 
     print ('The sorted array is: ')
     arr.sort()
     print (arr, '\n')
 
     # Entering the searching element
 
     search_element = int(input('Enter the element to be searched: '))
 
     index = interpolationSearch(arr, size, search_element)
 
     # If element was found
 
     if index != -1:
         # Returning the index of the element
         print ('Element found at index', index)
     else:
         # Returning -1 as element has not found
         print ('Element not found')
 main()
 
 """"""""
 SAMPLE INP",Python
"import java.util.*;
 class Main
 {   
     static void reverseArray(int a[],int n) //This functions reverses the array upto index n
     {
         int temp[]=new int[n+1]; // temp is the temporary array 
         for(int i=0;i<=n;i++)
         {
             temp[i]=a[n-i];
             }
             for(int i=0;i<=n;i++)
             a[i]=temp[i];
         }
        static int findmax(int a[],int n) //Function to find index of max element upto index n
         {
             int max=a[0];int j=0; //j stores the index of max element
             for(int i=1;i<=n;i++)
               if(a[i]>max)
               {max=a[i];
                   j=i;
                 }
                 return j;
                 
             }
     static void pancakesort(int a[],int n)
     {  int currentLength;
         for(currentLength=n;currentLength>0;--currentLength)
         {
             int j= findmax(a,currentLength-1);
             if(j!=currentLength)
             {
                 reverseArray(a,j);
                 reverseArray(a,currentLength-1);
             }
             }
         }
     public static void main(String[] args)
     {
         Scanner sc=new Scanner(System.in);
         int i,j,k,l,m,n;
         n=sc.nextInt();
         int array[]=new int[n];
         for(i=0;i<n;i++)
         array[i]=sc.nextInt();
         pancakesort(array,n);
         for(i=0;i<n;i++)
         System.out.print(array[i]+"" "");
         System.out.println();
     }
 }
 
 
 /* 
 Input - 
 5 //Array length
 4 3 7 1 2 //Array Elements
 
 Output - 
 1 2 3 4 7 //Sorted Array
 */",Java
"INF = 9999999
 # number of vertices in graph
 V = 5
 # create a 2d array of size 5x5
 # for adjacency matrix to represent graph
 G = [[0, 9, 75, 0, 0],
      [9, 0, 95, 19, 42],
      [75, 95, 0, 51, 66],
      [0, 19, 51, 0, 31],
      [0, 42, 66, 31, 0]]
 # create a array to track selected vertex
 # selected will become true otherwise false
 selected = [0, 0, 0, 0, 0]
 # set number of edge to 0
 no_edge = 0
 # the number of egde in minimum spanning tree will be
 # always less than(V - 1), where V is number of vertices in
 # graph
 # choose 0th vertex and make it true
 selected[0] = True
 # print for edge and weight
 print(""Edge : Weight\n"")
 while (no_edge < V - 1):
     # For every vertex in the set S, find the all adjacent vertices
     #, calculate the distance from the vertex selected at step 1.
     # if the vertex is already in the set S, discard it otherwise
     # choose another vertex nearest to selected vertex  at step 1.
     minimum = INF
     x = 0
     y = 0
     for i in range(V):
         if selected[i]:
             for j in range(V):
                 if ((not selected[j]) and G[i][j]):  
                     # not in selected and there is an edge
                     if minimum > G[i][j]:
                         minimum = G[i][j]
                         x = i
                         y = j
     print(str(x) + ""-"" + str(y) + "":"" + str(G[x][y]))
     selected[y] = True
     no_edge += 1
",Python
"/*Given two arrays:arr1[] and arr2[] of different sizes i.e.,no_of_ele_in_arr1 and no_of_ele_in_arr2 respectively.
 Task :calculate the product of maximum element of first array i.e.,arr1[] and minimum element of second array i.e.,arr2[]
 
 Approach:
 -take two arrays as input.
 -using std library of cpp we will find the maximum element in array arr1 and minimum element in array arr2
 -after getting the maximum and minimum element we will multiply them.
 -return the product.
 */
 
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int find_product(int arr1[], int arr2[], int no_of_ele_in_arr1, int no_of_ele_in_arr2) {
         int num1 = *max_element(arr1, arr1+ no_of_ele_in_arr1);
         int num2 = *min_element(arr2, arr2+ no_of_ele_in_arr2);
         int r = num1*num2;
         return r;
     }
 
 int main() {
     int no_of_ele_in_arr1, no_of_ele_in_arr2, arr1[no_of_ele_in_arr1], arr2[no_of_ele_in_arr2];
     cout << ""enter the no. of elements in array 1\n""; 
     cin >> no_of_ele_in_arr1;
     cout << ""enter the elements of array 1 \n"";
     for (int i = 0; i < no_of_ele_in_arr1; i++) {
         cin >> arr1[i];
     }
     cout << ""enter the no. of elements in array 2 \n""; 
     cin >> no_of_ele_in_arr2;
     cout << ""enter the elements of array 2\n"";
     for (int i = 0; i < no_of_ele_in_arr2; i++) {
         cin >> arr2[i];
     }
     int prod = find_product(arr1 , arr2 , no_of_ele_in_arr1 , no_of_ele_in_arr2);
     cout << prod <<endl;
     return 0;
 }
 
 /*Sample Input : 
 enter the no. of elements in array 1:
 3
 enter the elements of array 1:
 1 2 3
 enter the no. of elements in array 2:
 5
 enter the elements of array 2:
 5 7 3 1 9
 
 Sample Output :
 product of max element of first array and min element of second array: 3
 
  
 Time Complexity : O(n)
 Auxiliary Space : O(1) 
 
 */
 
",C-Plus-Plus
"# Python program to toggle the k-th bit of a number.
 def toggle(num, k):
     return (num ^ (1 << (k-1)))
 
 
 if __name__ == '__main__':
     print(""Enter the number: "", end="""")
     n = int(input())
     print(""Enter the value of k(where you need to toggle the k'th bit): "", end="""")
     b = int(input())
     res = toggle(n, b)
     print(""The given number, after toggling the k-th bit is {}"".format(res))
 
 """"""
 Time Complexity: O(1)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 24
 Enter the value of k(where you need to toggle the k'th bit): 3
 The given number, after toggling the k-th bit is 28.
 
 SAMPLE 2
 Enter the number: 33
 Enter the value of k(where you need to toggle the k'th bit): 12
 The given number, after toggling the k-th bit is 2081.
 """"""
",Python
"/*  
 
 Arrange the elements of array such that to form the  
 biggest possible number, by rearranging them.  
 
 For a given array arr[] having numbers,  
 your task is to arrange the elements of the array arr[],  
 such that the new arrangement forms the biggest number.  
 The output is given in a single number form  
 i.e. the elements should be printed without spaces, 
 forming a single number.
 */  
 
 #include <bits/stdc++.h>  
 
 using namespace std;  
 
 //function to compare between elements  
 int formBiggest(string str1, string str2)  
 {  
 
     string appnd1 = str1.append(str2);  
 
     string appnd2 = str2.append(str1);  
 
     //comparing between appnd1 and appnd2  
     //and returning bigger one 
     return appnd1.compare(appnd2) > 0 ? 1 : 0;  
 
 }  
 
 //main function  
 int main()  
 {  
 
     int n;  
 
     cout<<""Enter the size of array: "";  
     cin>>n;  
 
     vector<string> arr(n);  
 
     cout<<""Enter the elements for the array: "";  
 
     for(int pass = 0; pass < n; pass++)  
     {  
         arr.push_back(arr[pass]);  
     }  
     cout<<""The biggest number so formed is: "";  
 
     sort(arr.begin(), arr.end(), formBiggest);   
 
     for(int pass = 0; pass < n; pass++){  
         cout<<arr[pass];  
     }  
 
     return 0;  
 
 }  
 
 /*  
 
 EXAMPLES:-  
 
 Example 1:  
 Input--  
 Enter the size of array: 5  
 Enter the elements for the array: 44 66 88 01 56  
 Output--  
 The biggest number so formed is: 8866564401  
 
 Example 2:  
 Input--  
 Enter the size of array: 3  
 Enter the elements for the array: 200 545 76  
 Output--  
 The biggest number so formed is: 76545200   
 
 Example 3:  
 Input--  
 Enter the size of array: 1  
 Enter the elements for the array: 220  
 Output--  
 The biggest number so formed is: 220  
 
 TIME COMPLEXITY -> O(Nlog(N))  
 SPACE COMPLEXITY -> O(1)  
 
 */  
",C-Plus-Plus
"/*
 Approach : Swap pairs of elements except the first element.
 As - keep a[0], swap a[1] with a[2], swap a[3] with a[4], and so on.
 So, we will take array and its size as parameters, run a loop from i to size of the array 
 and swap every pair of element using swap function. At the end of loop, we will print the array.
 */
 #include <bits/stdc++.h>
 using namespace std;
 /*helper function that converts given array in zig-zag form*/
 void zigzag(int a[] , int n)
 {
     for(int i=1; i<n; i+=2)
     {
         if(i<n-1)
             swap(a[i],a[i+1]);
     }
     cout<<""\nZig-Zag array is : "";
     for(int i=0; i<n; i++)
         cout<<a[i]<<""  "";
 }
 /*Driver Program*/
 int main()
 {
     int n;
     cout<<""Enter size of array : "";
     cin>>n;
     int a[n];
     cout<<""Enter array : ""<<endl;
     for(int i=0; i<n; i++)
         cin>>a[i];
     zigzag(a,n);
     return 0;
 }
 
 /*
 
 Sample Input/Output:
 
 Input: Enter size of array : 7
        Enter array :
        4
        3
        7
        8
        6
        2
        1
 
 Output:Zig-Zag array is : 4  7  3  6  8  1  2
 
 
 Time Complexity : O(n)
 Space Complexity : O(1)
 
 */
",C-Plus-Plus
"#include <stdio.h>
 #include <malloc.h>
 
 /*
 Code Description :
 Doubly linked list is a type of linked list in which each node
 has a data part and two pointer part. The first pointer points 
 to the previous node in the list and the second pointer points 
 to the next node in the list.
 
 In the code below we have created the structure of doubly linked list.
 We have also provided options to the user to choose among the opearations.
 
 As per the option selected, respective switch-case will execute and function 
 will be called. Brief description of each function is also provided below.
 */
 
 struct node
 {
     int info;
     struct node *prev,*next;
 };
 
 struct node *start = NULL;
 
 //Function Declarations
 void insertstart();
 void insertlast();
 void insertafter(struct node *);
 struct node* find ();
 void insertat();
 void deletefirst();
 void deletelast();
 void deleteafter();
 void viewlist();
 
 
 int main()
 {
     int choice;
     char ans = 'Y';
     
     while(ans == 'Y' || ans == 'y')
     {
         printf(""\n\n Operations on doubly linked list"");
         printf(""\n----------------------------------"");
         printf(""\n 1- To view the list."");
         printf(""\n 2- Insertion of element at starting."");
         printf(""\n 3- Insertion of element at end."");
         printf(""\n 4- Insertion of element at any position by providing previous element."");
         printf(""\n 5- Insertion of element at any position by providing index."");
         printf(""\n 6- Deletion of the first element."");
         printf(""\n 7- Deletion of the last element."");
         printf(""\n 8- Delete an element from any position."");
         printf(""\n 9- To exit."");
         printf(""\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"");
         printf(""\nEnter your choice : "");
         scanf(""%d"" , &choice);
 
         switch(choice)
         {
         case 1:
                 viewlist();
                 break;
         case 2:
                 insertstart();
                 b",C
"/*Problem Statement:
 Given an array with no duplicates. Atree is considered special if it is defined as follows:
 1)The root is the maximum number in the array
 2)The left subtree is the special tree constructed from left part subarray divided by the 
 maximum number.
 3)The right subtree is the special tree constructed from right part subarray divided by the 
 maximum number.
 Construct the special tree and print its inorder traversal */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 class Node
 {
 public:
     int data;
     Node*left;
     Node*right;
 
     Node(int d)
     {
         data = d;
         left = right = NULL;
     }
 
 };
 
 void inorder(Node*root)
 {
     if(root==NULL)
     {
         return;
     }
     inorder(root->left);
     cout<<root->data<<"" "";
     inorder(root->right);
 
 }
 
 Node* specialTree(int *a,int s,int e)
 {
     if(s>e)
     {
         return NULL;
     }
     int k=s;
     for(int i=s;i<=e;i++)
     {
         if(a[i]>a[k])
         {
             k=i;
         }
     }
     Node* root=new Node(a[k]);
     root->left=specialTree(a,s,k-1);
     root->right=specialTree(a,k+1,e);
     return root;
 }
 
 int main()
 {
     int total;
     int arr[100];
     cout<<""Enter the total number of nodes: ""<<endl;
     cin>>total;
     cout<<""Enter nodes: ""<<endl;
     for(int i=0;i<total;i++)
     {
         cin>>arr[i];
     }
     Node* root=specialTree(arr,0,total-1);
     cout<<""Special tree: ""<<endl;
     inorder(root);
     return 0;
 }
 /*
 Example:-
 
 Input:-
 Enter the total number of nodes:
 4
 Enter nodes:
 1 5 3 4
 
 Output:-
 Special tree:
 1 5 3 4
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
"import java.util.*;
 
 class Distinct_Element {
     static void FindDistinct(int arr[], int size, int k) {
         // using set for storing the distinct elements.
         Set<Integer> elements = new HashSet<Integer>();
         for (int i = 0; i <= size - k; i++) {
             for (int j = 0; j < k; j++) {
                 elements.add(arr[i + j]);
             }
             System.out.println(elements.size());
             elements.clear();
         }
 
     }
 
     public static void main(String arg[]) {
         Scanner sc = new Scanner(System.in);
         int len, k;
         System.out.println(""Enter the length of array and window size"");
         len = sc.nextInt();
         k = sc.nextInt();
         int arr[] = new int[len];
         System.out.println(""Enter the array elements"");
 
         for (int i = 0; i < len; i++)
             arr[i] = sc.nextInt();
         System.out.println(""Distinct elements are:"");
         FindDistinct(arr, len, k);
     }
 }
 
 /*
 output:
 Enter the length of array and window size: 4 2
 Enter the array elements: 10 10 20 30
 Distinct elements are: 1 2 2
 Time complexity : O(K^2)
 space complexity : O(size)
 */
",Java
"# Bucket Sort
 '''
 Bucket Sort is a comparison sorting algorithm used to deal with input that is
 distributed over a range.
 The elements of the list are distributed into a number of buckets(or bins).
 Each bucket is then sorted using any stable sorting algoritm.After
 sorting is complete, all the buckets are merged and we get a sorted list.
 Bucket Sort uses a scatter-order-gather approach.
 '''
 
 
 def bucket_sort(arr):
     # create a list containing len(arr) empty buckets where buckets are also list
     bucket_list = []
     for i in enumerate(arr):
         bucket_num = i[0]
         if bucket_num < len(arr):
             bucket_list.append([])
 
     # numerical range of each bucket
     maximum = max(arr)
     size = maximum / len(arr)
 
     # Put list elements into their respective buckets i.e Scatter
     for index, element in enumerate(arr):
         j = int(arr[index]/size)
         if j != len(arr):
             bucket_list[j].append(element)
         else:
             bucket_list[len(arr) - 1].append(element)
 
     # Sorting each bucket individually and Merging
     sorted_arr = []
     for bucket in bucket_list:
         curr = bucket
         curr.sort()                               # Order
         if len(curr) != 0:
             sorted_arr.extend(curr)               # Gather
 
     sorted_arr = [str(i) for i in sorted_arr]
     res = "" "".join(sorted_arr)
     return res
 
 
 def main():
     # Entering list of elements to be sorted
     arr = list(map(float, input(""Enter comma separated number sequence:\n"").split(',')))
 
     sorted_list = bucket_sort(arr)
 
     print('\nSorted List')                # Printing sorted list
     print(sorted_list)
 
 
 if __name__ == ""__main__"":
     main()
 
 
 # Sample I/O
 # Enter sequence of comma separated numbers:
 # 6.3,12.5,7.7,2.6,1.2,4.0
 
 # Sorted List
 # 1.2 2.6 4.0 6.3 7.7 12.5
 # Time Complexity -
 #   1. Best case - O(n+k)
 #   2. Average case - O(n+k)
 #   3. Worst case - O(n^2)
 #   where n ",Python
"/*
 Given an integer n, using phone keypad find out and print all the possible strings that can be made using digits of input n.
 */
 #include<bits/stdc++.h>
 using namespace std;
 
 void printKeypad_rec(int num, string output){
     string index[8] = {""abc"", ""def"", ""ghi"", ""jkl"", ""mno"", ""pqrs"", ""tuv"", ""wxyz""};
     if(num == 0){
         cout << output <<endl;
         return;
     }
     
     int rem = num%10;
     int first = num/10;
     if(rem == 7 || rem == 9){
         printKeypad_rec(first, index[rem - 2][0] + output);
 		printKeypad_rec(first, index[rem - 2][1] + output);
         printKeypad_rec(first, index[rem - 2][2] + output);
         printKeypad_rec(first, index[rem - 2][3] + output);
     }
     else{
         printKeypad_rec(first, index[rem - 2][0] + output);
 		printKeypad_rec(first, index[rem - 2][1] + output);
         printKeypad_rec(first, index[rem - 2][2] + output);
     }
 }
 
 void printKeypad(int num){
     /*
     Given an integer number print all the possible combinations of the keypad. You do not need to return anything just print them.
     */
     
     string output = """";
     printKeypad_rec(num, output);
 }
 
 int main(){
     	int num;
 	cout<<""Enter the integer for which you want the combinations of keypad: "";
 	//take input of integer
     	cin >> num;
 	cout<<""All the combinations of the keypad for given input integer are: ""<<endl;
     	printKeypad(num);
 	//prints all the combinations of the keypad for given input integer
     	return 0;
 }
 
 
 
 /*
 Sample input: 
 Enter the integer for which you want the combinations of keypad: 32
 Sample output:
 All the combinations of the keypad for given input integer are: 
 da
 ea
 fa
 db
 eb
 fb
 dc
 ec
 fc
 
 Time complexity: O(4^n)
 Space complexity: O(1)
 */
",C-Plus-Plus
"'''
 A program to remove the kth index from a string and print the remaining string.In case the value of k
 is greater than length of string then return the complete string as it is.
 '''
 #main function
 def main():
     s=input(""enter a string"")
     k=int(input(""enter the index""))
     l=len(s)
 	#Check whether the value of k is greater than length
     if(k>l):
         print(s)
     #If k is less than length of string then remove the kth index value
     else:
          s1=''
          for i in range(0,l):
              if(i!=k):
                  s1=s1+s[i]
          print(s1)
 if __name__== ""__main__"":
     main()
 
 '''
 Time Complexity:O(n),n is length of string
 Space Complexity:O(1)
 
 Input/Output:
 enter a string python
 enter the index 2
 pyhon
 '''
",Python
"'''
 The sieve of Eratosthenes is an algorithm for finding 
 all prime numbers up to any given limit. It is 
 computationally highly efficient algorithm.
 '''
 
 
 def sieve_of_eratosthenes(n):
     sieve = [True for i in range(n + 1)]
     p = 2
     while p ** 2 <= n:
         if sieve[p]:
             i = p * p
             while i <= n:
                 sieve[i] = False
                 i += p
         p += 1
     length = len(sieve)
     for i in range(2, length):
         if sieve[i]:
             print(i, end="" "")
 
 
 def main():
     print(""Enter the number upto which prime numbers are to be computed: "")
     n = int(input())
     print(""The number of prime numbers less than "" + str(n) + "" is :"")
     sieve_of_eratosthenes(n)
 
 
 if __name__ == ""__main__"":
     main()
 
 
 '''
 Sample I/O:
 
 Enter the number upto which prime numbers are to be computed:
 30
 The number of prime numbers less than 30 is :
 2 3 5 7 11 13 17 19 23 29
 
 Time complexity : O(n*(log(log(n))))
 Space complexity : O(n)
 '''
",Python
"/* This program prints the nth term in the fibonacci sequence. Recursive method
 is used here. Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2)*/
 
 #include <iostream>
 using namespace std;
 
 // This function returns the nth terms in fibonacci sequence
 int fibonacci(int number) {
 	// Base case for n = 0 and n = 1
 	if(number == 0) 
 		return 0;
 	else if(number == 1) 
 		return 1;
 	// Recursively call the function for n-1 and n-2
 	return fibonacci(number - 1) + fibonacci(number - 2);
 }
 
 int main() {
 
 	// Take number as input from the user
 	int number;
 	cout << ""Enter a number: "";
 	cin >> number;
 
 	// If number is less than 0, exit
 	if(number < 0) {
 		cout << ""\nPlease enter a non-negative number."" << endl;
 		exit(0);
 	}
 
 	// Else call the function and print the nth term
 	cout << ""\nThe term at index "" << number << "" of the fibonacci sequence is "" << fibonacci(number) << endl;
 	return 0;
 }
 
 /*
 Sample I/O:
 
 1)
 Enter a number: 7
 
 The term at index 7 of the fibonacci sequence is 13
 
 2)
 Enter a number: -23
 
 Please enter a non-negative number.
 
 */
",C-Plus-Plus
"'''
 It is a python program to get a list having tuples contained,
 to be sorted in ascending order on the basis of the last element 
 in each tuple of a list
 '''
 
 #This is a function which is used to reverse the elements of tuples 
 #It returns a list of reversed tuples
 def lys(ls):
     return [tuple(reversed(tup)) for tup in ls]
 #Driver's code
 def main():
     #It is used to take input a list from user which will contain tuples
     #It makes use of map function as it simplifies the process
     ls=list(tuple(map(int,input().split()))for r in range(int(input('enter number of elements')))) 
     #Here li will store the list of reversed tuples
     li=lys(ls) 
     #It will sort the list in ascending order
     li.sort() 
     #Again we call the function lys so that after sorting the elements get arranged back
     print(lys(li))
 if __name__== ""__main__"":
     main()
 
 
 '''
 Time Complexity-O(nlogn)
 Space Complexity-O(n)
 Input/Output-
 Enter number of elements 5
 5 6 
 7 8
 6 7
 1 2
 3 4 
 [(1, 2), (3, 4), (5, 6), (6, 7), (7, 8)]
 '''
",Python
"/*
 Counting Sort in Dart
 
 Counting sort is a sorting algorithm where the number of occurances of each
 element of the given array is stored in a frequency counter array which is
 used to further map according to their index into the sorted array.
 */
 
 import 'dart:io';
 
 void countSort(List array, int size) {
   // Setting limit for length of array
   const int MAX = 1000;
 
   // Initializing an array to store sorted elements temporarily
   List temp = new List.filled(MAX, null, growable: false);
   // Initializing array to store count of elements
   List count = new List.filled(MAX, 0, growable: false);
 
   // Finding the largest element in the array
   int max = array[0];
   for (int i = 1; i < size; i++) {
     if (array[i] > max) {
       max = array[i];
     }
   }
 
   // Storing the number of occurances of each element in array at the
   // respective index in count array
   for (int i = 0; i < size; i++) {
     count[array[i]] += 1;
   }
 
   // Storing the total count of each element
   for (int i = 1; i <= max; i++) {
     count[i] += count[i - 1];
   }
 
   // Placing the elements according to the index of count array in the
   // temporary array
   for (int i = size - 1; i >= 0; i--) {
     temp[count[array[i]] - 1] = array[i];
     count[array[i]] -= 1;
   }
 
   // Placing elements that are sorted back into the array
   for (int i = 0; i < size; i++) {
     array[i] = temp[i];
   }
 }
 
 main() {
   // Taking user input
   var n, ele;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   List array = new List.filled(n, null, growable: false);
 
   for (int i = 0; i < n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array[i] = ele;
   }
   countSort(array, n);
   print('The sorted array is: $array');
 }
 
 /*
 Time Complexity: O(n+k) where n is the number of elements in input array and k 
 is the max element. 
 Auxiliary Space: O(n+k)
 
 SAMP",Dart
"/*CYCLE SORT:
 	* an in-place unstable sorting Algorithm.
 	* Optimal in terms of the total number of writes to original array.
 	* Algorithm:
 		STEP 1: For arr[i], find it's original_index in the sorted list by counting the smaller elements in arr.
 		STEP 2: If element == arr[original_index], the iteration is skipped Else write it to original_index.
 		STEP 3: If original_index is inhabited by a different element, repeat the above steps. 
 		This is continued until an element is moved to the original position.This is a cycle.
 		Such n cycles are executed.
 */
 
 //importing readline module for dynamic input 
 var readline = require('readline');
 //initialising inputstream and outstream to process.stdin and process.stdout respectively.
 var rl = readline.createInterface(
 	process.stdin, process.stdout);
 
 const cycleSort = (arr) => {
     const n = arr.length;
     //start is the index of the current element.
     for (let start = 0; start < n - 1; start++) {
         
         let currentKey = arr[start];
         let pos = start;
         for (let i = start + 1; i < n; i++) {
             if (arr[i] < currentKey)
                 pos += 1;
         }
         // if pos = start => element is at original position. If so skip.
         if (pos == start) 
             continue;
 
         //check for duplicates in the array. 
         while (currentKey == arr[pos]) { 
             pos++ ;
         }
         //swapping current element and element at its original position.
         const temp = arr[pos];
         arr[pos] = currentKey;
         currentKey = temp;
 
         // rotate the rest of the cycle
         while (pos != start) {
             pos = start;
             //finding original position
             for (let i = start + 1; i < n; i++) {
                 if (arr[i] < currentKey) 
                     pos += 1;
             }
 
             //checking for duplicates
             while (arr[pos] == currentKey) {
                 pos += 1;
            ",JavaScript
"//Implementation of all the basic functionality of queue using array.
 
 #include<iostream>
 using namespace std;
 class QueueUsingArray
 {
     int *data;
     int nextindex;    //Index where the element should be inserted
     int firstindex;    //Index where top value is stored
     int size;    //The no. of elements present in queue
     int capacity;   //The total size of queue
 public:
     QueueUsingArray(int num)
     {
         data = new int[num];
         nextindex = 0;      //indexing start from 0
         firstindex = -1;    //firstindex is initialised by -1 because till now we don't have any element as top .
         size = 0;
         capacity = num;
     }
     int getSize()     //Return the number of elements present in queue
     {
         return size;
     }
     bool isEmpty()     //Indicate whether the queue is empty or not
     {
         return size == 0;
     }
     void enqueue()     //function to insert an element at the rear of the queue
     {
         int element;
         cout<<""Enter the Element to be inserted in queue  "";
         cin>>element;
         if(size == capacity)
         {
             cout<<""Queue is Full !""<<endl;
             return;
         }
         data[nextindex]=element;
         nextindex = (nextindex+1)% capacity;
         if(firstindex == -1)
         {
             firstindex = 0;
         }
         size++;    //increament the size when a new  element is inserted
     }
     int front()     //Return the top value of queue
     {
         if(isEmpty())
         {
             cout<<""Queue is Empty!""<<endl;
             return 0;
         }
         return data[firstindex];
 
     }
     int dequeue()     //function to delete an element from the front of the queue
     {
         if(isEmpty())
         {
             cout<<""Queue is Empty!""<<endl;
             return 0;
         }
         int ans = data[firstindex];
         firstindex = (firstindex+1)% capacity;    //modify the firstindex value to top value",C-Plus-Plus
"// A backtracking problem for checking whether a given string can be segmented into space seperated words in dictionary
 #include <iostream>
 #include<string.h>
 using namespace std;
 
 //This function is used for checking whether a word is present in our array or not
 int presentInArray(string &word){
     string arr[] = {""micro"",""soft"",""hi"",""ring"",""hiring"",""microsoft""};
     int n = sizeof(arr)/sizeof(arr[0]);
     for(int i=0;i<n;i++){
         if(arr[i].compare(word) == 0){
             return true;
         }
     }
     return false;
 }
 
 //this function is used for storing all the words with spaces
 void breakingwords(string str, int n, string ans){
     //Process all wordes one by one
     for(int i=1;i<=n;i++){
         string word = str.substr(0,i);
          
         if(presentInArray(word)){
             if(i==n){
                 ans += word;
                 cout<<ans<<endl;
                 return;
             }
         breakingwords(str.substr(i,n-i),n-i,ans + word +"" "");
         }
     }
 }
 
 
 // It will Print all possible word breaks of given string
 void BreakWords(string str){
     breakingwords(str,str.size(),"""");
 }
 
 int main() {
     string s;
     cin>>s;
     BreakWords(s);
     return 0;
 }
 
 /*
 eg.
 input - microsofthiring
 output - 
 micro soft hi ring
 micro soft hiring
 microsoft hi ring
 microsoft hiring
 Time Complexity - O(n2)
 Space Complexity - O(1)
 */
",C-Plus-Plus
"
 # Given two sorted arrays nums1 and nums2 of size m and n
 # respectively, return the median of the two sorted arrays.  
 
 # function to find median of two arrays
 def findMedianSortedArrays(nums1, nums2):
     newlist = sorted(nums1 + nums2)
 
     # checking if length of merged array is even
     if len(newlist) % 2 != 1:
         first = newlist[len(newlist) // 2]
         second = newlist[len(newlist) // 2 - 1]
         return (first + second) / 2
 
     # checking if length of merged array is odd
     if len(newlist) % 2 == 1:
         return newlist[len(newlist) // 2]
 
 # Driver's code
 if __name__ == ""__main__"":
     # creating an empty lists
     nums1 = []
     nums2 = []
     n = int(input('Enter length of first array: '))
     m = int(input('Enter length of second array: '))
 
     nums1 = list(map(int,input(""\nEnter elements of first array: "").strip().split()))[:n]
     nums2 = list(map(int,input(""\nEnter elements of second array: "").strip().split()))[:m]
 
     print('Median of two arrays is: ' +
         str(findMedianSortedArrays(nums1, nums2)))
 
 # Time Complexity: O(n)
 # Space Complexity: O(n)
 
 # Example 1:
 
 # Input:
 # Enter length of first array:
 # 2
 # Enter length of second array:
 # 1
 # Enter the elements of first array:
 # 1 3
 # Enter the elements of second array:
 # 2
 
 # Output:
 # Median of two arrays is: 2.00000
 
 # Example 2:
 
 # Input:
 # Enter length of first array:
 # 5
 # Enter length of second array:
 # 3
 # Enter the elements of first array:
 # 1 5 6 7 8
 # Enter the elements of second array:
 # 2 4 4
 
 # Output:
 # Median of two arrays is: 4.50000
",Python
"import java.util.*;
 
 /// 0/1 Knapsack can be solved using the dynamic approach wherein
 /// re-computation of same sub problems can be avoided by using a temporary
 /// dp array in bottom-up manner.
 
 /// Solving 0/1 Knapsack using DP reduces the extra work produced
 /// by working on same cases as seen in recursive approach
 
 class Knapsack_01 {
 
     /// Returns the maximum value that can
     /// be put in a knapsack of capacity W
     static int knapSack(int W, int[] wt, int[] val, int n) {
 
         int i, j;
         int[][] grid = new int[n + 1][W + 1];  /// no. of rows = no. of elements+1, no. of col = total knapsack weight+1
 
         /// Build table grid[][] in bottom up manner
         for (i = 0; i <= n; i++)
         {
             for (j = 0; j <= W; j++)
             {
                 if (i == 0 || j == 0) {
 
                     /// 0th row and column will be 0
                     grid[i][j] = 0;
 
                 }else if (wt[i - 1] <= j) {
 
                     /// At a given point, there may be 2 or more than 2 weights that fit in the given range
                     /// Compare and consider the maximum one
                     grid[i][j] = Math.max(val[i - 1] + grid[i - 1][j - wt[i - 1]], grid[i - 1][j]);
 
                 }else{
                     /// If current weight is less than the required weight
                     /// consider the value from the above row of same column
                     grid[i][j] = grid[i - 1][j];
                 }
 
             }
         }
 
         return grid[n][W];
     }
 
     /// Driver code
     public static void main(String[] args) {
 
         Scanner infile = new Scanner(System.in);
         int w,n,i;
 
         System.out.println(""Enter the number of elements: "");
         n = infile.nextInt();
 
         System.out.println(""Enter the maximum weight of knapsack: "");
         w = infile.nextInt();
 
         int[] val = new int[n];
         int[] weights = new int[n];
 
         Syste",Java
"/*
 Left view of binary tree
 
 Given a binary tree, print the nodes in top to bottom manner as visible from left of the tree.
 Input is given in order of root, left child then right child(Inorder traversal). 
 For e.g. 1 2 3 4 5 6 -1 -1 -1 -1 -1 -1 -1
 Tree looks like 
               1
           /      \
       2           3
     /     \       /
   4       5     6
    
 nodes '3', '5' and '6' will be overlapped by '2' and '4' as seen from left side, 
 so when viewed from the left , we would see the nodes 1, 2 and 4 only.
 */
 
 import java.util.*;
 import java.lang.*;
 import java.io.*;
 
 // A class to create a node with left and right as childs and val as the key value of that node
 class node {
     int val;
     node left;
     node right;
 
     public node(int d) {
         val = d;
         left = null;
         right = null;
     }
 };
 
 class BinaryTree {
     // ""maxlev"" is used so that we can differentiate if the left node is of next level or of same level
     static int maxlev = -1;
     Scanner sc = new Scanner(System.in);
 
     public BinaryTree() {
         node root = null;
     }
 
     // A function which creates the binary tree and input the respective nodes using queue
     public node maketree() {
         Queue<node> q = new LinkedList<node>();
         int d = sc.nextInt();
         node root = new node(d);
         q.add(root);
         while (!q.isEmpty()) {
             node temp = q.peek();
             q.poll();
             int l = sc.nextInt();
             int r = sc.nextInt();
             if (l != -1) {
                 temp.left = new node(l);
                 q.add(temp.left);
             }
             if (r != -1) {
                 temp.right = new node(r);
                 q.add(temp.right);
             }
         }
         return root;
     }
 
     public void leftview(node root) {
         printleft(root, 0);
     }
 
     // A function to print the left view of the binary tree
     static void printleft(node root, i",Java
"#include<bits/stdc++.h>
 using namespace std;
 
 //Structure
 typedef struct ed
 {
   int from,dest,wt;
 }ed;
 
 //Bellman ford function began
 void bellman(int nv,ed e[],int src_graph,int ne,int size)
 {
   int u,v,weight,i,j=0;
   int arr[size];
   
   /* initializing array 'arr' with 999.*/
   for(i=0;i<nv;i++)
   {
     //999 is infinte distance
     arr[i]=999;
   }
   arr[src_graph]=0;
   for(i=0;i<nv-1;i++)
   {
     for(j=0;j<ne;j++)
     {
       u=e[j].from;
       v=e[j].dest;
       weight=e[j].wt;
       if(arr[u]!=999 && arr[u]+weight < arr[v])
       {
         arr[v]=arr[u]+weight;
       }  
     } 
   }
   
   /* check for negative cycle*/
   for(j=0;j<ne;j++)
   {
     u=e[j].from;
     v=e[j].dest;
     weight=e[j].wt;
     
     if(arr[u]+weight < arr[v])
     {
       cout<<""\n\nThere is NEGATIVE CYCLE!!\n"";
       return;
     }  
   }
   // Print the output
   cout<<""\n\tOUTPUT\n"";
   cout<<""\nVertex""<<""  Distance from source"";
   for(i=1;i<=nv;i++)
   {
     cout<<""\n""<<i<<""\t""<<arr[i];
   }
 }
 //Bellman Ford function end
 
 //Main Function began
 int main()
 {
   int nv,ne,src_graph,size;
   cout<<""Enter the max size of the array:\n"";
   cin>>size;
   ed e[size];
   //Take input from the user
   cout<<""Enter the number of vertices: "";
   cin>>nv;  
   
   /* if you enter no of vertices: 5 then vertices will be 1,2,3,4,5.*/
   printf(""Enter the source vertex: "");
   cin>>src_graph;  
   //Enter number of edges 
   cout<<""\nEnter no. of edges: "";
   cin>>ne;
   
   for(int i=0;i<ne;i++)
   {
     cout<<""\nEdge ""<<i+1<<""=>"";
     cout<<""\nEnter source vertex :"";
     cin>>e[i].from;
     cout<<""Enter destination vertex :"";
     cin>>e[i].dest;
     cout<<""Enter weight :"";
     cin>>e[i].wt;  
   }
   //calling bellman ford function
   bellman(nv,e,src_graph,ne,size);
   return 0;
 }
 //Main function ends
 
 /*Sample Input Output
 
 Enter the max size of array : 10
 Enter the number of vertices: 4
 Enter the source vertex: 1
 
 Enter no. of ed",C-Plus-Plus
"
 #include <bits/stdc++.h> 
 using namespace std;
 typedef long long ll;
 typedef vector<ll> vl; 
 #define pb push_back 
 
 #define loop(x,n) for(ll x = 1; x <= n; ++x)
 
 //Adjacency List of an Undirected Graph
 vl graph[100001];  
 
 bool vis[100001];
 
 ll in[100001],low[100001];
 
 ll timer=1;  
 
 void dfs(ll source,ll parent){
    vis[source]=true;
    in[source]=low[source]=timer;
    timer++;
    for(auto child:graph[source]){
        
        //if child equal to parent
        if(parent==child) continue;
        
        if(vis[child]==true)
        //back edge
         low[source]=min(low[source],in[child]);
         
         else{
             dfs(child,source);
             
             //condition for having a bridge
             if(low[child]>in[source])
              cout<<source<<""-""<<child<<"" is a bridge\n"";
              
              //visited forward edge
              low[source]=min(low[source],low[child]);
         }
    }
     
 }
  
 int main() 
 { 
     ios_base::sync_with_stdio(false); 
     cin.tie(NULL); 
     
     ll n,m,a,b;
     //n=no. of vertices, m=no. of edges
     cin>>n>>m;     
     
     loop(i,m){
      cin>>a>>b;
      graph[a].pb(b);
      graph[b].pb(a);
      }
 
      loop(i,n){
         //initialise visited array as false;
      vis[i]=false;    
      }
     
     loop(i,n){
        //dfs call
       if(vis[i]==false) dfs(i,-1);  
     } 
     return 0; 
 }
 
 /*
 Input:
 First line contains two space separated integers,(n,m) 
 n- no of vertices, m- no of edges.
 Then m lines follow, each line has 2 space separated integers ui ,vi which denotes edge between vertex ui to vi.
 
 
 TEST CASE
 4 4
 1 2
 2 3
 2 4
 3 4
 
 OUTPUT
 1-2 is a bridge
 
 Time- complexity: O(n+m)
 
 Space Complexity: O(n)
 
 */
 
",C-Plus-Plus
"'''
 Given an array arr and an integer k.Find if there's a triplet in the array which sums up to the given integer k
 
 '''
 
 def TripletSumValue(ary,k):
     #take a final list 
     fnl_lst=[]
     #take a dictionary
     dict={}
     #check whether the numbers is present to producestatus 
     #given sum  
     for i in range(0,len(ary)):
         for j in range(i+1,len(ary)):
 
             sum=ary[i]+ary[j]
             diff=k-sum
             
             if diff in dict.keys():
                 tup=tuple(sorted((diff,ary[i],ary[j])))
                 if tup not in fnl_lst:
                     fnl_lst.append(tup)
             else:
                 dict[ary[j]]=1
     #result 
     return fnl_lst
 
 def main():
    #taking the input 
    arr = list(map(int,input(""Enter the list: "").split()))
    k = int(input(""Enter K: ""))
    print(""Array which sum "",k,"" is "",TripletSumValue(arr,k))
    
 
 if __name__=='__main__':
     main()
 
 '''
 Time Complexity: O(N^2)
 Space Complexity: O(1)
 
 INPUT:
 
 Enter the elements: 1 4 45 6 10 8 
 Enter K: 13
 
 OUTPUT:
 Array which sum 13  is  [(1, 4, 8)]
 
 '''
",Python
"/*
 Disk scheduling is done by operating systems to schedule I/O requests arriving for the disk. 
 The various Disk scheduling algorithms are FCFS, SCAN, CSCAN, and SSTF. 
 Disk scheduling algorithms are the algorithms to allocate the services to the requests.
 
 1. In CSCAN algorithm, the disk arm instead of reversing its direction goes to the other end of the disk and starts servicing the requests from there.
 2. SCAN Disk Scheduling Algorithm is a disk scheduling algorithm that services requests by scanning all the cylinders back and forth.
 3. FCFS is the simplest disk scheduling algorithm that services the requests on First Come First Serve basis.
 4. SSTF (Shortest Seek Time First) selects requests having shortest seek time and they are are executed first.
 
  */
 import java.util.Collections;
 import java.util.Scanner;
 import java.util.Vector;
 
 class node 
 {
 	int distance = 0;
 
 	// true if track has been accessed
 	boolean accessed = false;
 }
 
 class algo {
 
 	void fcfs(int arr[], int head, int size) {
 		int seek_count = 0;
 		int distance, cur_track;
 
 		for (int i = 0; i < size; i++) {
 			cur_track = arr[i];
 
 			// calculate absolute distance
 			distance = Math.abs(cur_track - head);
 			System.out.println(""Head movement: "" + cur_track + ""-"" + head + "" = "" + distance);
 
 			// increment the total count
 			seek_count += distance;
 
 			// accessed track is now new head
 			head = cur_track;
 		}
 		System.out.println("" "");
 		System.out.println(""Total Seek Time :"" + seek_count);
 		System.out.println("" "");
 		// Seek sequence would be the same as request array sequence
 		System.out.print(""Seek Sequence is :"" + ""   "");
 
 		for (int i = 0; i < size; i++) {
 			System.out.print(arr[i] + ""   "");
 		}
 		System.out.println("" "");
 	}
 
 	void scan(int arr[], int head, int size, int disk_size) {
 		String dir = ""left"";
 		int seek_count = 0;
 		int distance, cur_track;
 
 		Vector<Integer> l1 = new Vector<Integer>();
 		Vector<Integer> r1 = new ",Java
"''' SORTING USING BINARY SEARCH TREE
     Binary Search Tree is a special type of binary tree where
     1. The value of all the nodes in the left sub-tree is less 
        than or equal to the value of the root.
     2. The value of all the nodes in the right sub-tree is 
        greater than value of the root.
     3. This rule will be recursively applied to all the left 
        and right sub-trees of the root.
 
     Inorder traversal
     1. Traverse the left subtree
     2. Visit the root.
     3. Traverse the right subtree
 
     Inorder traversal in BST gives sorted list
 '''
 
 # Declare treeNode with data , rc (right child) and lc (left child )
 
 
 class treeNode:
     def __init__(self, item):
         self.data = item
         self.lc = None
         self.rc = None
 
 
 # to insert a node into BST
 def insertIntoTree(root, data):
     # If tree is empty insert as root node
     if root is None:
         root = treeNode(data)
     else:
         # insert recursively in accordance with BST properties
         if root.data >= data:
             root.lc = insertIntoTree(root.lc, data)
         elif root.data < data:
             root.rc = insertIntoTree(root.rc, data)
     return root
 
 
 # to sort-inorder traversal gives sorted list
 def inorder(root):
     # If tree is not empty
     if root is not None:
         # recursively visit left sub-tree,root and right sub-tree
         inorder(root.lc)
         print(root.data, end="" "")
         inorder(root.rc)
 
 
 # driver code
 def main():
     # Initialize tree as empty
     root = None
     # Accept the no. of elements and elements as user input
     n = int(input(""Enter the number of elements: ""))
     print(""Enter the numbers: "")
     for _ in range(0, n):
         data = int(input())
         root = insertIntoTree(root, data)
 
     print(""\nSorted list : "")
     inorder(root)
 
 
 if __name__ == ""__main__"":
     main()
 
 '''
     Sample input:
     Enter the number of elements: 7
     Enter the numbe",Python
"//Demonstrating the working of LAZY PROPOGATION in Segment Tree using the problem statment : To update a range in the array and return the maximum element in the array after updating.
 
 //TIME COMPLEXITY OF LAZY PROPOGATION: O(log(N))   [N here is the range]
 
 #include <bits/stdc++.h>
 using namespace std;
 #define MAX 1000
   
   
 //storing the segment tree
 int tree[MAX] = { 0 };
   
 // For storing the pending updates
 int lazy[MAX] = { 0 };
   
 void updateHelp(int current, int startI, int endI, int us,
                      int ue, int diff)
 {
     if (lazy[current] != 0) {
         
         tree[current] += lazy[current];
   
         if (startI != endI) {
             
             lazy[current * 2 + 1] += lazy[current];
             lazy[current * 2 + 2] += lazy[current];
         }
   
     
         lazy[current] = 0;
     }
   
     
     if (startI > endI || startI > ue || endI < us)
         return;
   
    
     if (startI >= us && endI <= ue) {
         // Adding the difference to current node
         tree[current] += diff;
   
         if (startI != endI) {
           
             lazy[current * 2 + 1] += diff;
             lazy[current * 2 + 2] += diff;
         }
         return;
     }
   
     int mid = (startI + endI) / 2;
     updateHelp(current * 2 + 1, startI, mid, us, ue, diff);
     updateHelp(current * 2 + 2, mid + 1, endI, us, ue, diff);
   
     tree[current] = max(tree[current * 2 + 1], tree[current * 2 + 2]);
 }
   
 // Updating the range of values in segment tree
 
 void updateArray(int n, int us, int ue, int diff)
 {
     updateHelp(0, 0, n - 1, us, ue, diff);
 }
  
 int FindMaxHelp(int startI, int startE, int qs, int qe, int current)
 {
   
    
     if (lazy[current] != 0) {
   
         // Make pending updates to this node. Note that this
         // node represents sum of elements in arr[ss..se] and
         // all these elements must be increased by lazy[si]
         tree[current] += lazy[current];
   
         // Checkin",C-Plus-Plus
"// C program to toggle the k-th bit of a number.
 
 #include <stdio.h>
 
 int toggle_k_bit(int n, int k)
 {
     return n ^ (1 << (k - 1));
 }
 
 int main()
 {
     int n, k;
 
     printf(""Enter the number: "");
     scanf(""%d"", &n);
     printf(""Enter the value of k(where you need to toggle the k'th bit) "");
     scanf(""%d"", &k);
 
     printf(""The given number, after toggling the k-th bit is %d"", toggle_k_bit(n, k));
 
     return 0;
 }
 
 /*
 Time Complexity: O(1)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 24
 Enter the value of k(where you need to toggle the k'th bit): 3
 The given number, after toggling the k-th bit is 28.
 
 SAMPLE 2
 Enter the number: 33
 Enter the value of k(where you need to toggle the k'th bit): 12
 The given number, after toggling the k-th bit is 2081.
 */
",C
"/* This program calculates nth term of the fibonacci sequence using
 Dynamic Programming in Go. In DP, we follow bottom-up approach to
 reach to the desired solution. Doing this prevents multiple calls
 to same function input as in the case of recursion.*/
 
 package main
 
 import (
 	""fmt""
 	""os""
 )
 
 // This function returns the nth term in the fibonacci sequence
 func fibonacci(number int) int {
 
 	// Decalre an array to store values in a bottom-up manner
 	array := make([]int, number + 2)
 
 	// Base case/seeds
 	array[0] = 0
 	array[1] = 1
 
 	// Run the for loop constructing the sequence till number is reached
 	for i := 2; i <= number; i++ {
 		array[i] = array[i - 1] + array[i - 2]
 	}
 
 	// Return the nth term
 	return array[number]
 }
 
 func main() {
 
 	// Take user input
 	fmt.Print(""Enter a number: "")
 	var number int
 	fmt.Scan(&number)
 
 	// If number is less than 0, exit
 	if(number < 0) {
 		fmt.Print(""\nPlease enter a non-neagtive number."", ""\n"")
 		os.Exit(0)
 	}
 
 	// Call the function and print the nth term in the fibonacci sequence
 	var result int = fibonacci(number)
 	fmt.Print(""\nThe term at position "", number, "" in the fibonacci sequence is "", result, "".\n"")
 }
 
 /*
 Sample I/O:
 
 1)
 Enter a number: 16
 
 The term at position 16 in the fibonacci sequence is 987.
 
 2)
 Enter a number: -12
 
 Please enter a non-neagtive number.
 
 */
",Go
"import java.util.*;
 
 public class FirstNonRepeatingChar {
 
     private static int firstNonRepeating(String str) {
         int len = str.length();
         int result = Integer.MAX_VALUE;
         HashMap<Character, CountIndex> countEachChar
             = new HashMap<Character, CountIndex>(len);
         
         for (int i = 0; i < len; i++) {
             if (countEachChar.containsKey(str.charAt(i))) {
                 // if the character already exists in the hashmap,
                 // we increment the counter for it by one
                 countEachChar.get(str.charAt(i)).incrementCount();
             } else {
                 // if first occurrence, then create an entry for it
                 countEachChar.put(str.charAt(i), new CountIndex(i));
             }
         }
 
         for (Map.Entry<Character, CountIndex> entry : countEachChar.entrySet()) 
         {
             // checking all entries for repetition. If all repeating,
             // then Integer.MAX_VALUE is returned
             int c = entry.getValue().count; 
             int ind = entry.getValue().index; 
             if(c == 1 && ind < result) 
             { 
                 result = ind; 
             } 
         } 
         return result;
     }
     
     public static void main(String[] args) {
         // taking String input
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter a string:"");
         String str = sc.nextLine();
         sc.close();
 
         int result = firstNonRepeating(str);
 
         System.out.println(result == Integer.MAX_VALUE
             ? ""Either all characters repeat atleast once or String is empty""
             : ""First non-repeating char:"" + str.charAt(result) + "" at index "" + result);
     }
 }
 
 class CountIndex { 
     int count, index; 
   
     // constructor for first occurrence 
     public CountIndex(int index) 
     { 
         this.count = 1; 
         this.index = index; 
     } 
   
     // method for up",Java
"# Python program for implementation of Shell Sort
 def shellSort(arr):
 
     # Start with a big gap, then reduce the gap
     size = len(arr)
     gap = size // 2
 
     # Do a gapped insertion sort for this gap size.
     while gap > 0:
 
         for i in range(gap, size):
 
             # add a[i] to the elements that have been gap sorted
             # save a[i] in temp and make a hole at position i
             temp = arr[i]
 
             # shift earlier gap-sorted elements up until the correct
             # location for a[i] is found
             j = i
             while j >= gap and arr[j - gap] > temp:
                 arr[j] = arr[j - gap]
                 j -= gap
 
             # put temp (the original a[i]) in its correct location
             arr[j] = temp
         gap //= 2
 
 
 arr = []
 size = int(input('Enter size: '))
 print ('Enter elements:')
 for i in range(0, size):
     item = int(input())
     arr.append(item)
 
 shellSort(arr)
 
 print ('\nSorted Array:')
 for i in range(size):
     print (arr[i])
 
 '''
 Sample I/O:
     Input:
     Enter Size: 5
     Enter Elements:
     5
     4
     3
     2
     1
 
     Output:
     Sorted Array:
     1
     2
     3
     4
     5
 
 Time Complexity: O(n^2)
 Space Complexity: O(1)
 '''
",Python
"/* Java Program to calculate the sum of digits of a number */
 
 import java.util.Scanner;
 public class SumOfDigit {
 
 	/* Function to calculate the sum of digits */
 	static int getSum(int n) {
 		int temp = n;
 		int sum = 0;
 
 		while(temp > 0)
 		{
 			// Extracting the last digit of given number
 			int lastDigit = temp % 10;
 			// Adding the extracted last digit to sum
 			sum += lastDigit;
 			//Removing the last digit of the given number
 			temp /= 10;	
 		}
 		  return sum;
 	}
 	
 	public static void main(String[] args)
 	{
 		System.out.println(""Enter the number for which you want to calculate the sum of digits:"");
 		Scanner sc = new Scanner(System.in);
 		int n = sc.nextInt();
 		int x = getSum(n);
 		System.out.println(""Sum of the digits of ""+n+"" is ""+x+""."");
 	}
 }
 /*
 Sample Input and Output
 
 Example 1:
 Input:
 Enter the number for which you want to calculate the sum of digits:
 745
 Output : Sum of the digits of 745 is 16.
 Explanation : Sum of digits of the number 745 = (7+4+5) = 16
 
 Example 2:
 Input:
 Enter the number for which you want to calculate the sum of digits:
 8674
 Output: Sum of the digits of 8674 is 25.
 Explanation: Sum of digits of the number 8674 = (8+6+7+4) = 25
 
 Space Complexity :O(1)
 Time Complexity : O(logn)
 */
",Java
"
 def encryption():
 
   plain_text=input(""Enter the plain text : "")
 
   global key1  # key 1
   global key2  # key 2
   global cipher_text # to store to the cipher text or the encrypted plain_text
   cipher_text=''
   key1 ,key2=input(""Enter the keys : "").split()
 
   list_encrypted_characters=[] # a list for storing the encrypted characters which we later merged to a string i.e cipher_text
 
   def gcd(number1, number2): # for checking whether two numbers are coprime or not
       while number2 != 0:
           number1, number2 = number2, number1 % number2
       return number1
 
 
   if gcd(int(key1),26)==1 and 0<int(key1)<26 and int(key2) <26  :  # checks whether key1 and 26 are coprime , key1 and key2 < 26
     
     for character in plain_text:
       if character.isalpha()==False: # if the character is not an alphabet then simply append for example if theres a white space or special characters like # , @ , ! etc.
         list_encrypted_characters.append(character)
     
       else:
 
         if character.isupper(): # if the alphabet is upper case
 
           p=ord(character)-65 # converts alphabets to numbers ranging from 0-26 for example A has a ascii value of 65 so 65-65 =0 therefore A is represented as 0 
           e_temp=(int(p)*int(key1)+int(key2))%26   # encryption formula : (p*k1 +k2)mod26
           list_encrypted_characters.append(chr(e_temp+65)) # storing the encrypted character in list
 
         else:  # if the alphabet is lower case
 
           p=ord(character)-97 # converts alphabets to numbers ranging from 0-26 for example c has a ascii value of 99 so 99-97 =2 therefore c is represented as 2
           e_temp=(int(p)*int(key1)+int(key2))%26  # encryption formula : (p*k1 +k2)mod26
           list_encrypted_characters.append(chr(e_temp+97)) # storing the encrypted character in list
 
     
     cipher_text=''.join(list_encrypted_characters)  
     print(""The encrypted text is : "",cipher_text) 
   
   else:
     
     print(""Please enter va",Python
"'''
 Playfair Cipher Encryption
 The Playfair cipher or Playfair square or Wheatstone-Playfair cipher
 is a manual symmetric encryption technique and was the first literal
 digram substitution cipher. The scheme was invented in 1854 by Charles
 Wheatstone but bore the name of Lord Playfair for promoting its use.
 It was used for tactical purposes by British forces in the Second Boer War
 and in World War I and for the same purpose by the Australians during World War II.
 This was because Playfair is reasonably fast to use and requires no special equipment.
 '''
 import re
 import sys
 
 
 def create_matrix(key_text):
     '''
     This function is used to generate a 5 x 5 matrix of the english alphabets
     using the key provided. This key matrix is used for encrypting/decrypting
     the input text.
     :param key_text: input key string
     :type str
 
     :return final_matrix: 5x5 matrix with all the english alphabets except j
     :type list
     '''
     lst = []
     # some processing before creating matrix
     key_text = key_text.replace(' ', '')
     key_text = key_text.lower()
     # remove all the duplicate characters from the key
     for k in key_text:
         if k not in lst:
             lst.append(k)
 
     # adding remaining english alphabets to the matrix
     alphabets = ""abcdefghiklmnopqrstuvwtxyz""
     for alphabet in alphabets:
         if alphabet not in lst:
             lst.append(alphabet)
 
     # creating sub-list of length 5 to form a 5x5 matrix from the list of
     # 25 english alphabets
     final_matrix = []
     for i in range(0, len(lst), 5):
         if i + 5 <= len(lst):
             tmp = lst[i:i+5]
             final_matrix.append(tmp)
 
     return final_matrix
 
 
 def clean_text(text):
     '''
     perform generic cleaning of the plaintext before encryption i.e.
     removal of special charcters, numbers, punctuations, etc.
     :param text: plaintext for encryption
     :type str
 
     :return txt: processed clean tex",Python
"#include<iostream>        //Header file
 using namespace std;      //For cin and cout
 
 /*
     The height of a binary tree is the number of edges between the tree's root node and its furthest leaf node.
     Recursivley compute heights of left subtree and right subtree. Height upto the current node will be maximum of these two + 1(itself). 
 
     Sample Preorder Input : 
     8 10 1 -1 -1 6 9 -1 -1 7 -1 -1 3 -1 14 -1 -1 
     Sample Output: 
     4
 
     @author Aditya Saxena
     @since 28-7-2020
 */
 
 //Implement Binary Tree Data Structure Node
 class Node{
 public:
     int data;
     Node* left;
     Node* right;
 
     //Constructor
     Node( int data ){
         this->data= data;
         left= NULL;
         right= NULL;
     }
 };
 
 //Build Tree function implementation - Recursively builds tree (preorder build) 
 Node* buildTree (){
 
     //Input data
     int d;
     cin>>d;
 
     //If d is -1 then return NULL
     if( d == -1 ){
         return NULL;
     }
 
     //Place data at current node
     Node* root= new Node( d );
 
     //Recursively build left and right subtrees
     root->left= buildTree();
     root->right= buildTree();
 
     return root;
 }
 
 //Implement function to compute height of the tree
 int height( Node* root ){
 
     //Check if NULL, height is zero
     if( root == NULL ){
         return 0;
     }
 
     //Recursivley compute heights of left and right subtrees
     int h1= height( root->left );
     int h2= height( root->right );
 
     return (max( h1, h2 ) + 1);
 
 }
 
 //Driver Funtion
 int main(){
 
     //Build the tree
     cout<<""Enter the binary tree elements preorder wise: "";
     Node* root= buildTree();
 
     //Find height of tree
     cout<<endl<<""The height of the binary tree: ""<<height(root); 
 
     return 0;
 }
",C-Plus-Plus
"/*
 Problem statement: A stream of integers is given and we have to find the median of the stream.
 
 Solution: Median is the middle element that is a boundary of the lower half and the higher half. If the input array size is odd, then the middle element of the sorted data is taken to be the median and if the iput array sizs is even, then the average of the two middle elements from the sorted streams is taken to be the median. Here, we have solved the problem using two heaps that is the less heap and more heap which is implemented using the priority queue class in Java.
 
 Implementation of code:
 
 Step 1: Two heaps have been created. The less heap to store higher half of the stream and the more heap to store the lower half of the stream. The median value is initialized to 0.
 Step 2: Now there can be 3 cases:
 Case 1: When the size of more heap is more than the size of less heap and the element is less than the previous median then, pop the top element of the more heap and insert it into less heap and insert the new element in the more heap or else insert the new element to less heap. The new median is the average of top elements of both the heaps.
 Case 2: When the size of more heap is less than the size of less heap and the element is greater than the previous median then, pop the top element of the less heap and insert into the more heap and insert the new element to less heap or else insert the new element to more heap. The new median is the average of top elements of both the heaps.
 Case 3: If the size of both heaps is equal, then check if the present element is less than the previous median and if it is so, then insert it to the more heap and the new median will be equal to the top element of more heap. But if it is the other side and the present element is more than the previous median then insert it to low heap and the new median will be equal to the top element of low heap.
 */
 
 import java.util.Collections;
 import java.util.PriorityQueue;
 
 public c",Java
"/*
 
 
 This program is about Traversing elements of a binary Tree in a Level Order way.Here we will enter the values for
 the nodes of the tree. 
 It will simply print the elements of the tree level by level by simply storing the  
 addresses of the nodes in a queue and printing the node whose address is on the front 
 ,and calling the same function for left and right subtree recursively and the process 
 is iterated untill  queue doesn't gets emptied.
 
 
 */
 #include <iostream>
 
 #include<queue>
 
 using namespace std;
 
 //  Basic Definition of node in a Binary Tree
 
 struct child {
     int data;
     child*LeftPtr;
     child*RightPtr;
 
     child(int value) {
         data = value;
         LeftPtr = NULL;
         RightPtr = NULL;
     }
 };
 
 //  Function to build tree Recursively 
 
 child * buildTree() {
     int d;
     cin >> d;
 
     if (d == -1) {
         return NULL;
     }
 
     child*root = new child(d);
 
     root->LeftPtr = buildTree();
 
     root->RightPtr = buildTree();
 
     return root;
 }
 
 //  Function for implementing level order traversal using Queue
 
 void levelOrder(child * root) {
 
     if (root == NULL)
         return;
 
     queue <child*> q;
 
     q.push(root);
 
     while (!q.empty()) {
         child*t = q.front();
         cout << t -> data << endl;
 
         if (t->LeftPtr)
             q.push(t->LeftPtr);
         if (t->RightPtr)
             q.push(t->RightPtr);
 
         q.pop();
     }
 
 }
 
 int main() {
 
     cout << ""Enter the values of nodes of the tree: "" << endl;
 
     child*root = buildTree();
 
     cout << ""Level Order Traversal for the following Tree will be:"" << endl;
 
     levelOrder(root);
 
     return 0;
 }
 
 /*  
 Output:-
 Enter the values of nodes of the tree:
 3
 4
 6
 -1
 -1
 7
 -1
 -1
 5
 -1
 -1
 
 
 Level Order Traversal for the following Tree will be:
 3
 4
 5
 6
 7
 
 Time Complexity:- O(n)
 Space Complexity:- O(n) 
 
 */
",C-Plus-Plus
"/*
 Infix, postfix and prefix are three different but equivalent notations of writing
 algebraic expressions.
 In postfix notation, operators follow their operands. 
 In prefix notation, operators precede their operands.
     In this program, the user inputs a postfix expression and the prefix notation for that
 given postfix notation is the output. Postfix notation is converted to prefix notation with
 the help of stack data structure.
 */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #define MAX 30
 
 struct stack
 {
 	char sta[MAX];
 	struct stack * next;
 };
 struct stack *st = NULL;
 char a[MAX], b[MAX], c[MAX];
 
 //push function of stack
 void push(char s[MAX])
 {
 	struct stack *temp = (struct stack *) malloc(sizeof(struct stack));
 	strcpy(temp->sta, s);
 	temp->next = NULL;
 	if (temp == NULL)
 		printf(""Memory Overflow\n"");
 	else
 	{
 		if (st == NULL)
 			st = temp;
 		else
 		{
 			temp->next = st;
 			st = temp;
 		}
 	}
 }
 
 //pop function of stack
 void pop(char d[])
 {
 	struct stack *t = st;
 	st = t->next;
 	strcpy(d, t->sta);
 	free(t);
 }
 
 //Function to count number of elements in stack
 int count()
 {
 	int c = 0;
 	struct stack *t = st;
 	while (t != NULL)
 	{
 		c++;
 		t = t->next;
 	}
 
 	return c;
 }
 
 //Function to convert postfix expression to prefix expression
 void PostfixToPrefix(char post[], char pre[])
 {
 	int i = 0;
 	char op[3];
 	while (post[i] != '\0')
 	{
 		if (isalpha(post[i]) != 0 || isdigit(post[i] != 0))
 		{
 			op[0] = post[i];
 			op[1] = '\0';
 			push(op);
 		}
 		else
 		{
 			if (count() < 2)
 			{
 				printf(""Not sufficient values in the expression\n"");
 				exit(1);
 			}
 			else
 			{
 				op[0] = post[i];
 				op[1] = '\0';
 				pop(a);
 				pop(b);
 				c[0] = '\0';
 				strcat(c, op);
 				strcat(c, b);
 				strcat(c, a);
 				push(c);
 			}
 		}
 
 		i++;
 	}
 
 	if (count() == 1)
 	{
 		pop(pre);
 		printf(""Prefix Expression: %s"", pre);
 	}
 	else
 	{
 		printf(""I",C
"/* C code for Conversion of infix expression to post fix expression */
 
 #include<stdio.h>
 #include<stdlib.h>      /* for exit() */
 #include<ctype.h>     /* for isdigit(char ) */
 #include<string.h>
 
 #define SIZE 100
 
 /* declared here as global variable because stack[]
 * is used by more than one functions */
 
 char stack[SIZE];
 int top = -1;
 
 /* define push operation */
 
 void push(char item)
 {
 	if(top>=SIZE-1)
 	{
 		printf(""\nStack Overflow."");
 	}
 	else
 	{
 		top = top+1;
 		stack[top] = item;
 	}
 }
 
 /* define pop operation */
 
 char pop()
 {
 	char item ;
 
 	if(top <0)
 	{
 		printf(""stack under flow: invalid infix expression"");
 		getchar();
 		/* underflow may occur for invalid expression */
 		/* where ( and ) are not matched */
 		exit(1);
 	}
 	else
 	{
 		item = stack[top];
 		top = top-1;
 		return(item);
 	}
 }
 
 /* define function that is used to determine whether any symbol is operator or not
 (that is symbol is operand)
 * this function returns 1 if symbol is operator else return 0 */
 
 int is_operator(char symbol)
 {
 	if(symbol == '^' || symbol == '*' || symbol == '/' || symbol == '+' || symbol =='-' || symbol=='%')
 	{
 		return 1;
 	}
 	else
 	{
 		return 0;
 	}
 }
 
 /* define function that is used to assign precedence to operator.
 * Here ^ denotes exponent operator.
 * In this function we assume that higher integer value
 * means higher precedence */
 
 int precedence(char symbol)
 {
 	if(symbol == '^')/* exponent operator, highest precedence*/
 	{
 		return(3);
 	}
 	else if(symbol == '*' || symbol == '/' || symbol == '%')
 	{
 		return(2);
 	}
 	else if(symbol == '+' || symbol == '-')          /* lowest precedence */
 	{
 		return(1);
 	}
 	else
 	{
 		return(0);
 	}
 }
 
 void InfixToPostfix(char infix_exp[], char postfix_exp[])
 {
 	int i,j;
 	char item;
 	char x;
 	push('(');                               /* push '(' onto stack */
 	strcat(infix_exp,"")"");                  /* add ')' to infix expression */
 	i=0;
 	j",C
"/*Problem Statement: 
 You are given a max heap, 
 your task is to delete the peak elements from the max heap until the last element is left. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void upward_heapify(vector<int> &max_heap, int index)
 {
     if(index==0)
         return;
     
     if(max_heap[(index-1)/2] < max_heap[index])
     {
         int temp = max_heap[index];
         max_heap[index] = max_heap[(index-1)/2];
         max_heap[(index-1)/2] = temp;
         upward_heapify(max_heap, (index-1)/2);
     }
     else
     {
         return;
     }
 }
 
 void insert(vector<int> &max_heap, int key)
 {
     max_heap.push_back(key);
     upward_heapify(max_heap, max_heap.size()-1);
 }
 
 void downward_heapify(vector<int> &max_heap, int index)
 {
 
     int size = max_heap.size();
     if(index>=max_heap.size()/2)
     {
         return;
     }
     if(index*2 + 1 >= size) 
     {
         return;
     }
     if(index*2 + 2 >= size) 
     {
         //If only left child exists
         if(max_heap[index*2 + 1] > max_heap[index]) 
         {
             swap(max_heap[index*2 + 1], max_heap[index]);
             downward_heapify(max_heap, index*2 + 1);
         }
     } 
     else 
     {
         // If both child exists
         int maxIndex = max_heap[index*2 + 1] > max_heap[index*2 + 2] ? index*2 + 1 : index*2 + 2;
         if(max_heap[index] < max_heap[maxIndex]) 
         {
             swap(max_heap[index], max_heap[maxIndex]);
             downward_heapify(max_heap, maxIndex);
         }
     }
 }
 
 void delete_peak(vector<int> &max_heap)
 {
     swap(max_heap[0],max_heap[max_heap.size()-1]);
     max_heap.pop_back();
     downward_heapify(max_heap, 0);
 }
 
 void display(vector<int> &max_heap)
 {
     for(int i=0;i<max_heap.size();i++)
         cout<<max_heap[i]<<"" "";
     cout<<endl;
 }
 
 int main()
 {
     vector<int> max_heap;
     int n,temp;
     cout<<""Enter total elements: ""<<endl;
     cin>>n;
     cout<<""Enter all elements of max heap",C-Plus-Plus
"/**
  * Given a number and you need to check if a number is T-prime or not. 
  * A number is called T-prime if it has exactly three factors.
  * Input:
  * First line of input contains a number of integer data type.
  * Output:
  * A single line telling whether a number is T-prime or not.
  *
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 int Check_T_Prime(int n)
 {
     if (n <= 3)
     {
         return 0;
     }
     else
     {
         long long int square_root = sqrt(n);
         int perfect_square_prime = 0, i;
 
         //to check if number is perfect square or not.
         if (square_root * square_root == n)
         {
             for (i = 2; i <= sqrt(square_root); i++)
             {
                 
                 /* If the square root of the 
                 user input number (num) is prime then it's T-prime otherwise it's not.
                 Because for T-prime number should have 3 factors(one the number itself)
                 and other 2 from square root as it prime number.  
                 */
                 if (square_root % i == 0)
                 {
                     perfect_square_prime = 1;
                     break;
                 }
             }
             if (perfect_square_prime == 0)
                 return 1;
             else
                 return 0;
         }
         else
             return 0;
     }
 }
 
 int main()
 {
 
     long long int num;
     cout << ""Enter the number: "" << endl;
     cin >> num;
 
     int result = Check_T_Prime(num);
 
     if (result == 1)
         cout << num << "" is T-prime. "" << endl;
     else
         cout << num << "" is not T-prime. "" << endl;
 }
 
 /*
  * Example:
  * Input:
  * 3
  * Output:
  * 3 is not T-prime.
  * 
  * Input:
  * 49
  * Output:
  * 49 is T-prime;
 */
 
 /*
 *Time complexity : O(sqrt(n)) 
 *Space complexity : O(1)
 */
",C-Plus-Plus
"""""""Julia program to implement Exponential Search algorithm.
 Exponential Search Algorithm is an optimized Binary Search to search an element in sorted array.
 It is specifically used when the size of array is infinite.
 """"""
 
 function binary_search(arr, low, n, ele)
     high = n
     while high >= low
         mid = low + (high - low)  2
         # If the mid element is the required element, return that index
         if(arr[mid] == ele)
             return mid
         # ele is greater than mid element then ele would be present in first half of the array
         elseif (arr[mid] > ele)
             high = mid - 1
         #Else if  ele is smaller than mid element then ele would be present in last half of the array
         else
             low = mid + 1
         end
     end
     # If the element is not found return 0
     return 0
 end
 
 
 function exponential_search(arr, n, ele)
     if(arr[1] == ele)
         return false
     end
     i = 2
     while( i < n && arr[i] <= ele)
         i = i * 2
     end
     mini = i < (n-1) ? i : (n-1)
     return binary_search(arr, i2, mini, ele )
 end
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""Array is Empty!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())] 
 print(""Which number do you want to search in the array? "")
 ele = readline()
 ele = parse(Int, ele)
 # Sort the array in ascending order
 arr = sort(arr)
 res = exponential_search(arr, n, ele)
 if (res == 0)
     print(""The number $ele is not present in the array"")
 else
     print(""The number $ele is present in the array."")
 end
 
 
 
 """"""
 Time Complexity - O(log(n)), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 How many numbers are present in the array? 5 
 Enter the numbers: 1 2 3 4 5
 Which number do you want to search in the array? 6
 The number 6 is not pre",Julia
"/*
 The best fit strategy will not allocate a block of size > N , as it is found in the first-fit method;
 instead it will continue searching to find a suitable block so that the block size is closer to the block size of request.
 The below program is an implementation of best fit algorithm using array data structure.
 */
 
 class Block{
     constructor(){
         this.size = 0
         this.ID = 0
         this.fragment = 0
     }
 }
 
 class Process{
     constructor(){
         this.Num = 0
         this.size = 0
         this.block = null
     }
 }
 
 class Bestfit{
     initialiseBlocks(arr,sizes,n){
         for(let i=0;i<n;i++){
             arr[i].size = sizes[i]
             arr[i].fragment = sizes[i]
             arr[i].ID = i + 1
         }
     }
 
     printResult(arr2, numOfProcess){
         console.log(
         ""Process No            Process Size          Block ID          Block Size         Block Fragment""
         );
         for(let i=0;i<numOfProcess;i++){
             console.log(
                 arr2[i].Num
                 + ""                     ""
                 + arr2[i].size
                 + ""                     ""
                 + arr2[i].block.ID
                 + ""                     ""
                 + arr2[i].block.size
                 + ""                     ""
                 + arr2[i].block.fragment
             )
         }
 
     }
     bestfit(arr, sizes, n, arr2, numOfProcess){
         let minBlock = new Block()
         for(let i=0;i<numOfProcess;i++){
             let min = 100
             for(let j=0;j<numOfProcess;j++){
                 if(arr2[i].size <= arr[j].fragment && arr[j].fragment < min){
                     min = arr[j].fragment
                     minBlock = arr[j]
                 }
 
             }
             minBlock.fragment = minBlock.fragment - arr2[i].size
             arr2[i].block = new Block()
             arr2[i].block.size = minBlock.size
             arr2[i].block.ID = minBlock.ID
",JavaScript
"/*
 Validating BST: This program check if the given tree is BST or not.
 BST: A tree with following conditions:
 1. At max 2 childern.
 2. Value stored in left child < Value of Parent node < Value of right child. (Must be valid for every node)
 
 Author: @Mohim-Singla
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 //initializing structure
 struct node{
 int data;
 node* lchild;
 node* rchild;
 };
 //Function to create tree
 node* create_node (int data)
 {
     node* temp = new node;
     temp -> data = data;
     temp -> lchild = temp -> rchild = NULL;
     return temp;
 }
 
 node* create (node* root, int data)
 {
     if(root == NULL)
     {
         root = create_node (data);
         return root;
     }
     else
     {
         if (data < root->data)
         {
             root -> lchild = create (root -> lchild, data);
         }
         else
         {
             root -> rchild = create (root -> rchild, data);
         }
         return root;
     }
 }
 //BST Check Function
 bool check (node* root, int minv, int maxv)
 {
     if (root == NULL)
     {
         return true;
     }
     else if (root -> data > minv && root -> data < maxv && check (root -> lchild, minv, root -> data) && check (root -> rchild, root -> data, maxv))
     {
         return true;
     }
     else
     {
         return false;
     }
 }
 
 //Displaying output
 void check_output (node* root, int minv, int maxv)
 {
     bool ans = check (root, INT_MIN, INT_MAX);
     if (ans)
     {
         cout << ""True"" << endl;
     }
     else
     {
         cout << ""False"" << endl;
     }
 }
 
 int main ()
 {
     //creating a BST
     node* root = NULL;
     int counts;
     cout << ""Enter number of nodes: "" ;
     cin >> counts;
     for (int i = 0; i < counts; i++)
     {
         int datas;
         cin >> datas;
         root = create (root, datas);
     }
 
     check_output (root, INT_MIN, INT_MAX);
 
     //converting bst to binary tree
     root -> lchild -> data = 18;
    ",C-Plus-Plus
"/*
 In recreational number theory, a narcissistic number is also known
 as a pluperfect digital invariant (PPDI), an Armstrong number or a
 plus perfect number is a number that is the sum of its digits
 each raised to the power of the number of digits.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // Function to check whether the Number is Armstrong Number or Not.
 
 bool is_armstrong(int n)
 {
 	if (n < 0)
 	{
 		return false;
 	}
 	int sum = 0;
 	int var = n;
 	int number_of_digits = floor(log10(n) + 1);
 	while (var > 0)
 	{
 		int rem = var % 10;
 		sum = sum + pow(rem, number_of_digits);
 		var = var / 10;
 	}
 	return n == sum;
 }
 
 int main()
 {
 	cout << ""Enter the Number to check whether it is Armstrong Number or Not:"" << endl;
 	int n;
 	cin >> n;
 	if (is_armstrong(n))
 		cout << n << "" is Armstrong Number."" << endl;
 	else
 		cout << n << "" is Not Armstrong Number."" << endl;
 	return 0;
 }
 
 /*
 Input:
 Enter the Number to check whether it is Armstrong Number or Not:
 153
 Output:
 153 is Armstrong Number.
 Input:
 Enter the Number to check whether it is Armstrong Number or Not:
 12
 Output:
 12 is Not Armstrong Number.
 
 Time Complexity: O(log(n))
 Space Complexity: O(1)
 */
",C-Plus-Plus
"/*
 	Strassen's Algorithm is an algorithm for Matrix multiplication.
 	It is faster(optimal) than the standard matrix multiplication algorithm and
 	is useful in practice for large matrices. It uses the Divide N Conquer Approach
 	and recursively divides a Matrix into four small matrices.
 */
 
 import java.util.Scanner;
 
 public class Strassens_Algo_for_Matrix_multiplication {
 
     // Function to multiply matrices
     // A and B are the two matrices to be multiplied
     public int[][] multiply(int[][] A, int[][] B) {
         // Order of matrix
         int n = A.length;
 
         // Creating a 2D square matrix with size n
         int[][] output = new int[n][n];
 
         // Base case
         // If there is only single element in the two matrices
         if (n == 1)
 
             // Returnng the simple multiplication of
             // two elements in matrices
             output[0][0] = A[0][0] * B[0][0];
 
         else {
             // Dividing the two Matrices into parts
             // by storing sub-parts to variables
             /*
              * A = [A11 A12 A21 A22]
              *
              * B = [B11 B12 B21 B22]
              */
             int[][] A11 = new int[n / 2][n / 2];
             int[][] A12 = new int[n / 2][n / 2];
             int[][] A21 = new int[n / 2][n / 2];
             int[][] A22 = new int[n / 2][n / 2];
             int[][] B11 = new int[n / 2][n / 2];
             int[][] B12 = new int[n / 2][n / 2];
             int[][] B21 = new int[n / 2][n / 2];
             int[][] B22 = new int[n / 2][n / 2];
 
             // Dividing matrix A into 4 halves i.e A11, A12, A21, A22
             split(A, A11, 0, 0);
             split(A, A12, 0, n / 2);
             split(A, A21, n / 2, 0);
             split(A, A22, n / 2, n / 2);
 
             // Dividing matrix B into 4 halves i.e B11, B12, B21, B22
             split(B, B11, 0, 0);
             split(B, B12, 0, n / 2);
             split(B, B21, n / 2, 0);
             s",Java
"//algorithm for removing remove outermost parantheses in O(n) time complexity and O(1) space complexity
 
 #include <stdio.h>
 
 char * remove_outer_parantheses(char * S)
 {
     int count = 0;
     int stack = 0;
     char *ans = S;
     char c; 
     while (c = *S++)
     {
         if (c == ')') 
         {
             --stack;
         }
         if (stack > 0) 
         {
             ans[count++] = c;
         }
         if (c == '(') 
         {
             ++stack;
         }
             
     }
     ans[count] = '\0';
     return ans;
 }
 
 int main()
 {   //taking input from the user
     char s[1000];
     printf("" Enter the string\n "");
     scanf("" %s "",s);
     //printing result
     printf(""The final string is : %s\n "",remove_outer_parantheses(s));
     return 0;
 }
 
 /*
 Sample Input 1:
 Input: ""(()())(())""
 Output: The final string is : ()()()
   
 Sample Input 2:
 Input: ""(())()""
 Output: The final string is : ()
 */",C
"/*
 HEAP SORT
 
 It is a sorting technique based on the heap data structure.
 
 Heap is a complete binary tree, in which every level except the last, is filled
 completely with its nodes, and nodes are far left.
 
 We implement this sorting in an array using Max Heap, in which the parent node 
 value is greater than it child node values. 
 */
 
 import 'dart:io';
 
 void swap(List arr, int i1, int i2) {
   // Swapping elements in array
   int temp = arr[i1];
   arr[i1] = arr[i2];
   arr[i2] = temp;
 }
 
 void maxHeap(List arr, int n, int i) {
   // Making a max heap (root = largest element) using complete binary tree in array.
   // Setting indices for root, left child and right child.
   int root = i;
   int left_c = (2 * i) + 1;
   int right_c = (2 * i) + 2;
 
   // If left child is greater than root, changing the index of root accordingly
   if (left_c < n && arr[left_c] > arr[root]) {
     root = left_c;
   }
 
   // If right child is greater than root, changing the index of root accordingly
   if (right_c < n && arr[right_c] > arr[root]) {
     root = right_c;
   }
 
   // Recursively calling maxHeap till we set the largest element at root
   if (root != i) {
     swap(arr, i, root);
     maxHeap(arr, n, root);
   }
 }
 
 void heapSort(arr, n) {
   for (int i = (n ~/ 2); i >= 0; i--) {
     // Building maximum heap
     maxHeap(arr, n, i);
   }
 
   for (int i = n - 1; i >= 1; i--) {
     // Move current root to end and sorting it
     swap(arr, 0, i);
 
     // Bringing largest element to root
     maxHeap(arr, i, 0);
   }
 }
 
 main() {
   var array = [];
 
   var n, ele;
   print('Enter the number of elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter value for element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
 
   heapSort(array, n);
   print('The sorted array is $array');
 }
 
 /*
 TIME COMPLEXITY: O(n*logn)
 SPACE COMPEXITY: O(1)
 
 SAMPLE",Dart
"/**
  * Infix to Postfix Expression
  *
  * This program converts an infix expression entered by the user
  * into the Postfix expression.
  * The program uses a stack to keep the track of the operators and
  * paranthesis of the input expression.
  *
  * Author: iamvs-2002
  */
 
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Scanner;
 import java.util.Stack;
 
 public class InfixToPostfix 
 {
     public static void main(String[] args) 
     {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Kindly enter the infix expression: "");
         String infix = sc.nextLine();
 
         InfixToPostfix x = new InfixToPostfix();
         String postfix = x.infixtopostfix(infix);
 
         System.out.println(""Postfix Expression: ""+postfix);
     }
 
     static int priority(char c)
     {
         switch (c)
         {
             case '+':
                 return 1;
             case '-':
                 return 1;
             case '*':
                 return 2;
             case '/':
                 return 2;
             case '^':
                 return 3;
             default:
                 return -1;
         }
     }
 
     private String infixtopostfix(String expression)
     {
         String result = """";
 
         Stack<Character> stack = new Stack<>();
 
         int i=0;
         for (i = 0; i < expression.length() ; i++) 
         {
             char c = expression.charAt(i);
             if(priority(c)>0)
             {
                 //if the topmost operator in the stack has a priority greater than or equal to c
                 //pop it and add to result string
                 //else push it into the stack
                 while(stack.isEmpty()==false && (priority(stack.peek())>=priority(c)))
                 {
                     result = result + stack.pop();
                 }
                 stack.push(c);
             }
             else if(c==')')
             {
                 //if c",Java
"/*
 A child runs up a staircase with 'n' steps and can hop either 1 step, 2 steps or 3 steps at a time.
 Implement a method to count and return all possible ways in which the child can run-up to the stairs.
 */
 
 
 #include<bits/stdc++.h>
 using namespace std;
 
 long staircase(int n)
 {
     long *ans = new long[n+1];
     
     ans[0] = 1;
     
     for(int i=1;i<=n;i++)
     {
         long x=0;
         long y=0;
         long z=0;
                     
         
         if(i-1>=0)
             x = ans[i-1];
         if(i-2>=0)
             y = ans[i-2];
         if(i-3>=0)
             z = ans[i-3];
         
         ans[i] = x+y+z;
     }
     
     long finalAns = ans[n];
     delete [] ans;
     return finalAns;
 }
 
 int main()
 {
 	int n;
   	cout<<""Enter the number of steps""<<endl;
 	cin >> n;
   	cout<<""The total number of possible ways are:""<<endl;
 	cout << staircase(n);
 }
 
 
 /*
 Sample Input 1:
 Enter the number of steps
 4
 
 Sample Output 1:
 The total number of possible ways are:
 7
 
 Time Complexity: O(n)
 
 Space Complexity: O(n)
 */
",C-Plus-Plus
"/*
 Celebrity Problem
 
 Problem: In a party, we need to check if there is a celebrity who is known to everyone and he/she knows no one.
 Input: A 2D co-relation matrix where rows and columns represent ids of persons present in the party and 
 a value of matrix[i][j] = 1 indicates that the i'th person knows j'th person and a value of 0 indicates that
 i'th person don't know j'th person. The primary diagonal must always be filled with zeroes, as a default value,
 as thier values dont alter the solution logic.
 */
 
 // C program to solve the Celebrity Problem
 #include <stdio.h>
 
 /* If a celeb is present in the party, then his/her id'th column would be filled with 1 as values 
    except for the diagonal element and td'th row would be filled with 0s. */
 int find_celebrity(int person[][9000], int n) {
     int low = 0;
     int high = n - 1;
 
     /* While loop to check if there is a column with value as 1 only except the diagonal value. 
        We start checking from the last column indexin the first row. */
     while (1) {
         if (low == high)
             break;
 
         if (person[low][high] == 1)
             low++;
 
         else
             high--;
     }
     for (int i = 0; i < n; i++) {
         if (low == i)
             continue;
         /* Check if low'th index is a celeb or not by checking
            if he/she knows anyone or anyone knows the celeb */
         if (person[low][i] == 1 || person[i][low] == 0)
             return -1;
     }
     return low;
 }
 
 int main() {
     int n;
     printf(""How many people are present in the party? "");
     scanf(""%d"",&n);
     int person[n][9000];
     printf(""Enter thier co-relation graph: "");
     // Input the co-relation matrix
     for (int i = 0; i < n; i++) {
         for (int j = 0; j < n; j++) {
             scanf(""%d"",&person[i][j]);
         }
     }
     int celeb = find_celebrity(person, n);
     if (celeb >= 0) {
         printf(""Celebrity is present at the %d"", celeb);
         prin",C
"/* 
 Finding square root of an integer by using Binary Search DART.
 
 Given an integer x, find its square root. If x is not a perfect square, 
 then return floor(x).
 */
 
 import 'dart:io';
 
 int square_root_binary_search(int n) {
   int root = 1;
 
   // Return same number when n is 0 and 1.
   if (n == 0 || n == 1) return n;
 
   // Using Binary Search to find Square Root or nearest
   // square root of n.
   int left = 1, right = n;
   while (left <= right) {
     int mid = left + (right - left) ~/ 2;
 
     if (mid * mid == n) return mid;
     if (mid * mid < n) {
       left = mid + 1;
       root = mid;
     } else
       right = mid - 1;
   }
   return root;
 }
 
 void main() {
   // taking input from user
   var n;
   print('Enter the element: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   int sq_root;
   print(""\nSquare Root of $n is: "");
   sq_root = square_root_binary_search(n);
   print(sq_root);
 }
 /*
 TIME COMPLEXITY: O(log n).
 SPACE COMPLEXITY: O(1).
 
 SAMPLE INPUT/OUTPUT:
 Enter the element:
 67
 
 Square Root of 67 is:
 8
 */
 
",Dart
"/*
 K Closest Points to Origin
 =================================
 
 Problem Statement:
 Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k,
 Print the k closest points to the origin i.e (0, 0).
 The distance between two points on the X-Y plane is the Euclidean distance (i.e, (x1 - x2)^2 + (y1 - y2)^2).
 
 Concept:
 For all the pairs in the points array we calculate the eucledian distance between that point and the origin.
 We store a pair of the point and the eucledian distance in a Min-Heap.
 We use a Min-Heap because we need first K closest point i.e points with minimum distance from the origin.
 At the end we print first K points from the Min-Heap.
 */
 
 #include <iostream>
 #include <queue>
 #include <vector>
 #include <math.h>
 using namespace std;
 // made a user defined pair which would be of the form {distance, coordinate}
 using user_defined_pair = pair<long long, vector<int>>; 
 
 // calculate eucledian distance between point and (0, 0)
 long long eucledian_distance(vector<int> coordinates) 
 {
     int x = coordinates[0];
     int y = coordinates[1];
     return sqrt(x * x + y * y);
 }
 
 vector<vector<int>> kClosest(vector<vector<int>> points, int k)
 {
     // syntax to create a min_heap
     priority_queue<user_defined_pair, vector<user_defined_pair>, greater<user_defined_pair>> min_heap; 
     vector<vector<int>> result;
 
     for (auto coordinates : points)
     {
         float distance = eucledian_distance(coordinates);
         user_defined_pair distance_coordinate_pair = {distance, coordinates};
         // push a pair of {distance, coordinate} in min_heap
         min_heap.push(distance_coordinate_pair); 
     }
 
     while (k != 0)
     {
         user_defined_pair distance_coordinate_pair = min_heap.top();
         // add first k coodinates in result vector
         result.push_back(distance_coordinate_pair.second); 
         min_heap.pop();
         k--;
     }
 
     return result;",C-Plus-Plus
"/*Inorder successor of a node is the next node in inorder traversal of the BST.
 There is no inorder successor of the last node in inorder traversal of the BST.
 Inorder predecessor of a node is the previous node in inorder traversal of the BST.
 There is no inorder predecessor of the first node in inorder traversal of the BST.
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 struct tree
 {
 	struct tree * lptr;
 	int data;
 	struct tree * rptr;
 };
 
 //Insert function of BST
 void insert(struct tree **b, int n)
 {
 	if (*b == NULL)
 	{
 		struct tree *new = (struct tree *) malloc(sizeof(struct tree));
 		new->data = n;
 		new->lptr = new->rptr = NULL;
 		*b = new;
 	}
 	else
 	{
 		if ((*b)->data > n)
 			insert(&((*b)->lptr), n);
 		else
 			insert(&((*b)->rptr), n);
 	}
 }
 
 //Inorder display function using recursion
 void inorder(struct tree *b)
 {
 	if (b != NULL)
 	{
 		inorder(b->lptr);
 		printf(""%d  "", b->data);
 		inorder(b->rptr);
 	}
 }
 
 //Function to find inorder predecessor of a node
 int in_pre(struct tree *b, int node)
 {
 	struct tree *x = b, *xpre;
 	int pre, flag = 0;
 	while (x != NULL && x->data != node)
 	{
 		if (x->data > node)
 			x = x->lptr;
 		else
 		{
 			flag = 1;
 			pre = x->data;
 			x = x->rptr;
 		}
 	}
 
 	if (x == NULL)
 	{
 		printf(""Node not present in tree\n"");
 		return 0;
 	}
 
 	if (x->lptr != NULL)
 	{
 		xpre = x->lptr;
 		while (xpre->rptr != NULL)
 		{
 			xpre = xpre->rptr;
 		}
 
 		printf(""Predecessor of %d is %d\n"", node, xpre->data);
 		return 0;
 	}
 	else if (flag == 1)
 		printf(""Predecessor of %d is %d\n"", node, pre);
 	else
 		printf(""Predecessor of %d does not exist\n"", node);
 }
 
 //Function to find inorder successor of a node
 int in_succ(struct tree *b, int node)
 {
 	struct tree *x = b;
 	int xsucc, f = 0;
 	while (x != NULL && x->data != node)
 	{
 		if (x->data > node)
 		{
 			f = 1;
 			xsucc = x->data;
 			x = x->lptr;
 		}
 		else
 			x = x->rptr;
 	}
 
 	if (x == NULL)
 	{
 		printf(""Node no",C
"#include <stdio.h>
 #include <stdlib.h>
 
 int rob(int num[], int n) {
     if (n == 0) return 0;
     int *d = (int *)calloc(n + 2, sizeof(int));
     int i;
     d[0] = d[1] = 0; 
     for (i = 2; i < n + 2; i++) {
         if (d[i - 2] + num[i - 2] > d[i - 1]) {
             d[i] = d[i - 2] + num[i - 2];
         }
         else {
             d[i] = d[i - 1];
         }
     }
     return d[n + 1];
 }
 
 int main() {
     int num;
     printf(""Enter number of houses: "");
     scanf(""%d"",&num);
     int money[num];
     printf(""\nEnter money in each house: "");
     for(int i=0;i<num;i++)
     {
            scanf(""%d"",&money[i]);
     }
     printf(""\nTotal amount that can be robbed: %d"", rob(money, num));
 
     return 0;
 }
 
 /*
 Time Complexity: n(log(n))
 Space Complexity: n
 Sample input: 
 Enter number of houses: 4
 Enter money in each house: 1 2 3 1 
 Total amount that can be robbed: 4
 */
",C
"/*
 The traversal operation is a frequently used operation on a binary tree. This operation is used to visit each node in the tree exactly once
 A full traversal on a binary tree gives a linear ordering of data in the tree .  This is the iterative preorder tree traversal algorithms
 */
 #include <bits/stdc++.h>
 
 using namespace std;
 //structure for the binary tree node
 class TreeNode
 {
 public:
     char data;
     TreeNode *left;
     TreeNode *right;
 };
 //structure for stack which is used for the iterative traversal algorithms
 //stack is implemented using linked list
 class Stack
 {
 public:
     TreeNode *node;
     Stack *next;
 };
 //push operation for the stack
 void push(Stack **s, TreeNode *node)
 {
     Stack *New = new Stack();
     New->node = node;
     New->next = (*s);
     (*s) = New;
 }
 // pop operation for the stack
 TreeNode *pop(Stack **s)
 {
     if ((*s) != NULL)
     {
         TreeNode *ptr = (*s)->node;
         (*s) = (*s)->next;
         return ptr;
     }
 }
 //checks whether the stack is empty or not
 int isEmpty(Stack **s)
 {
     if ((*s) == NULL)
     {
         return 1;
     }
     return 0;
 }
 //iterative preorder traversal
 void preorder(TreeNode *root)
 {
     TreeNode *ptr = root;
     Stack *s = NULL;
     push(&s, root);
     while (!isEmpty(&s))
     {
         ptr = pop(&s);
         if (ptr != NULL)
         {
             printf(""%c "", ptr->data);
             push(&s, ptr->right);
             push(&s, ptr->left);
         }
     }
 }
 //search function returns the pointer to the node which contains the value key , it is used in the insertion operation
 TreeNode *search(TreeNode *root, int k)
 {
     if (root == NULL)
     {
         return NULL;
     }
     else if (root->data == k)
     {
         return root;
     }
     else
     {
         TreeNode *x = search(root->left, k);
         if (x)
             return x; //if we find in left subtree, return result
         return search(root->right, k);
     }
 }
 ",C-Plus-Plus
"// C++ Program to calculate last digit number of fibonacci series
 
 #include <iostream>
 using namespace std;
 
 // Constraints for this function is 010^7.
 
 int get_fibonacci_last_digit(long long n) {
 	int first = 0; // first integer of fibonacci series
 	int second = 1; // second integer of fibonacci series
 
 	int result;
 
 	for (int i = 2; i <= n; i++) {
 		result = (first + second) % 10; // storing the remainder in result instead of whole fibonacci series
 		first = second;
 		second = result;
 	}
 
 	return result;
 }
 
 // Below algorithm is taken from Geeksforgeeks
 
 // Finds nth fibonacci number
 long long int  fib(long long int f[], long long int n) {
 	// 0th and 1st number of
 	// the series are 0 and 1
 	f[0] = 0;
 	f[1] = 1;
 
 	// Add the previous 2 numbers
 	// in the series and store
 	// last digit of result
 	for (long long int i = 2; i <= n; i++)
 		f[i] = (f[i - 1] + f[i - 2]) % 10;
 
 	return f[n];
 }
 
 // Returns last digit of n'th Fibonacci Number
 int findLastDigit(int n) {
 	long long int f[60] = {0};
 
 	// Precomputing units digit of
 	// first 60 Fibonacci numbers
 	fib(f, 60);
 
 	return f[n % 60];
 }
 
 
 int main() {
 	int number;
 	cin >> number;
 	//int result = get_fibonacci_last_digit(number);
 	int result = findLastDigit(number);
 	cout << result << '\n';
 
 	return 0;
 }
 
 /*
 Sample I/O:
 Input:
 200
 Output:
 5
 
 Time Complexity: O(1) for findLastDigit() and O(n) for get_fibonacci_last_digit()
 Space Complexity : O(1) for findLastDigit() and O(n) for get_fibonacci_last_digit()
 
 */
",C-Plus-Plus
"/*
 k largest elements in an array by using DART.
 
 Given an array, find K largest elements from it.
 */
 import 'dart:io';
 
 List K_largest(var array, int k) {
   // sorting the array in descending order
   array.sort();
   array = new List.from(array.reversed);
 
   // List to store K elements.
   var kLarge = [];
   for (int i = 0; i < k; i++) {
     kLarge.add(array[i]);
   }
   return kLarge;
 }
 
 void main() {
   var data = [];
 
   // taking input from user and storing it in data array
   var n, ele, k;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   print(""Enter size of K: "");
   k = stdin.readLineSync();
   k = int.parse(k);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     data.add(ele);
   }
 
   print(""Entered List is: "");
   print(data);
 
   print(""\nK Largest element are: "");
   var k_element = K_largest(data, k);
   print(k_element);
 }
 
 /*
 TIME COMPLEXITY: O(n)
 SPACE COMPLEXITY: O(k)
 
 SAMPLE INPUT/OUTPUT:
 Enter the number of Elements: 
 5
 Enter size of K: 
 3
 Enter Element 1: 
 10
 Enter Element 2: 
 22
 Enter Element 3: 
 45
 Enter Element 4: 
 11 
 Enter Element 5: 
 2
 Entered List is: 
 [10, 22, 45, 11, 2]
 
 K Largest element are:
 [45, 22, 11]
 */
",Dart
"/*	Dijkstra's Algorithm 
 To find the shortest path between nodes in a graph*/
 #include <stdio.h>
 #include <stdlib.h>
 
 void minimum_distance_path(int, int[][20], int, int);
 void dijkstra_algo(int[][20], int[], int[][20], int, int, int);
 void main()
 {
 
 	int size;
 	//Enter the maximum size of the node
 	//for cost distance and path
 	printf(""Enter the maximum size of node:"");
 	scanf(""%d"", &size);
 	int cost[size][size], distance[size], path[size][size], n, v, p, row, column, min, index = 1, i, j;
 	//use enters no of nodes
 	printf(""Enter no of nodes :  "");
 	scanf(""%d"", &n);
 
 	//user enters cost of matrix
 	printf(""Enter cost matrix :  "");
 	for (i = 1; i <= n; i++)
 	{
 		for (j = 1; j <= n; j++)
 		{
 			scanf(""%d"", &cost[i][j]);
 		}
 	}
 	//user enters node to be visited
 	printf(""Enter node to visit :  "");
 	scanf(""%d"", &v);
 	//user enters no of paths for particular node
 	printf(""Enter paths for the selected node : "");
 	scanf(""%d"", &p);
 
 	//path matrix
 	printf(""Enter path matrix \n"");
 	for (i = 1; i <= p; i++)
 	{
 		for (j = 1; j <= n; j++)
 		{
 			scanf(""%d"", &path[i][j]);
 		}
 	}
 	dijkstra_algo(cost, distance, path, n, v, p);
 }
 // Implementing Dijkstra's Algorithm 
 void dijkstra_algo(int cost[][20], int distance[], int path[][20], int n, int v, int p)
 {
 	int i, row, column, min, j, index;
 	for (i = 1; i <= p; i++)
 	{
 		distance[i] = 0;
 		row = 1;
 		for (j = 1; j < n; j++)
 		{
 			if (row != v)
 			{
 				//till i visit the last node
 				column = path[i][j + 1];
 				distance[i] = distance[i] + cost[row][column];
 			}
 			row = column;
 		}
 	}
 
 	//which distance to be considered
 	min = distance[1];
 	for (i = 1; i <= p; i++)
 	{
 		if (distance[i] <= min)
 		{
 			min = distance[i];
 			index = i;
 		}
 	}
 	minimum_distance_path(min, path, index, n);
 }
 // Function to print the minimum path distance
 void minimum_distance_path(int min, int path[][20], int index, int n)
 {
 	int i;
 	printf(""min distance is %d\n"", min);",C
"/*JUMP SEARCH:
 Jump Search is a searching algorithm for sorted arrays. 
 The basic idea is to check fewer elements (than linear search) by jumping ahead by fixed steps or skipping some elements in place of searching all elements.
 */
 
 #include<iostream>
 #include<cmath>
 
 using namespace std;
 
 int jump_search(int a[], int n, int find)
 {
     int step = sqrt(n);
     int pre_step = 0;
     while (a[min(step, n) - 1]  < find) 
     { 
         pre_step = step; 
         step += sqrt(n); 
         if (pre_step >= n)
         {
             return -1;	
         } 
     }
     while(a[pre_step] < find)
     {
         pre_step++;
         if(pre_step == min(step,n))
         {
             return -1;
         }
     }
     if(a[pre_step] == find)
     {
         return pre_step;
     }
     else
     {
         return -1;
     }
 }
 
 int main()
 {
     int n,search;
     cout << ""Enter no. of elements in an array: "";
     cin >> n;
     int arr[n];
     cout << ""Enter elements in an array in increasing order: "";
     for(int i=0;i<n;i++)
     {
         cin >> arr[i];
     }
     cout << ""Enter a number to be searched: "";
     cin >> search;
     int result = jump_search(arr,n,search);
     if(result == -1)
     {
         cout << search << "" is not present in the array."" << endl;
     }
     else
     {
         cout << search << "" is present at index no "" << result+1 << endl;
     }
     return 0;
 }
 
 /*
 SAMPLE INPUT:
 Enter no. of elements in an array: 
 12
 Enter elements in an array in increasing order: 
 2 4 6 8 10 11 14 17 20 33 36 40
 Enter a number to be searched: 
 17
 
 SAMPLE OUTPUT:
 17 is present at index no 8
 */
",C-Plus-Plus
"/*Problem Statement: 
 We are given a binary tree having N+1 nodes, N edges and an integer x.
 The task is to find the count of the total number of subtrees having total node's
 data sum equal to value X. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 char a[1000];
 vector<int> v;
 
 class Node
 {
 public:
     int data;
     Node*left;
     Node*right;
 
     Node(int d)
     {
         data = d;
         left = right = NULL;
     }
 
 };
 
 void StringToNums()
 {
     //Dividing the string characters by a space
     char *ans=strtok(a,"" "");
     while(ans!=NULL)
     {
         //The corresponding integer of the character is being pushed
         v.push_back(stoi(ans));
         ans=strtok(NULL,"" "");
     }
 }
 
 Node* CreateTree()
 {
     if(strlen(a)==0 or v.size()==0)
     {
         return NULL;
     }
     int no=v[0];
     Node* root=new Node(no);
     int i=1;
     queue<Node*> q;
     q.push(root);
     while(!q.empty() and i<v.size())
     {
         Node* temp=q.front();
         q.pop();
         no=v[i];
         i++;
         temp->left=new Node(no);
         q.push(temp->left);
         if(i>=v.size())
         {
             break;
         }
         //If elements are remaining in the array, then make it the right child
         no=v[i++];
         temp->right=new Node(no);
         q.push(temp->right);
         if(i>=v.size())
         {
             break;
         }
     }
     return root;
 }
 
 int Sum(Node* root)
 {
     if(root==NULL)
     {
         return 0;
     }
     int left=Sum(root->left);
     int right=Sum(root->right);
     return root->data+left+right;
 }
 
 int countSubtrees(Node* root,int x)
 {
     if(root==NULL)
     {
         return 0;
     }
     int ans=0;
     /*If the data value of the node+left child+right child is equal to x, 
     then we have found the subtree */
     if(Sum(root)==x)
     {
         ans=1;
     }
     int left=countSubtrees(root->left,x);
     int right=countSubtrees(root->right,x);
     re",C-Plus-Plus
"/*RAIL FENCE TRANSPOSITION TECHNIQUE
   It is a type of transposition cipher technique which encrypts the plain 
   text message into a cipher text by rearranging the characters of the 
   plain text. The alternate characters are picked first, starting from the 
   first character. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 //we use this function to encrypt the plaintext
 void encrypt(string s,int key) {
     
     int n = s.length();
     char array[key][n]; 
     // To diffrentiate between filled slots and empty slots
     for(int i=0;i<key;i++){
         for (int j=0;j<n;j++){
             array[i][j] = '_';
         }
     }   
     
     bool flag = false;
     int a=0;
     int b=0;
   
     /*we check the direction of flow and reverse the direction
       if we filled the top or bottom rail*/
     for(int i=0;i<n;i++){
     
         if (a==0 || a==key-1){
             flag = !flag;
         }
         array[a][b++] = s[i];
         if(flag == true)
            a++;
         else
            a--;
     }   
   
     string cipher;
     //computing the cipher string here
     for (int i=0;i<key;i++){
         for (int j=0;j<n;j++){
             if (array[i][j]!='_'){
                 cipher.push_back(array[i][j]);
             }
         }
     }   
     cout<<""Encrypted plaintext is              : ""<<cipher<<endl;
 }
 
 /*
   Sample I/O :
 
   Enter a message you want to encrypt : This is Rail Fence Cipher
   Enter a key to encrypt the message  : 4
   Encrypted plaintext is              : Ts  rhi lFeCei Riecihsanp
 
   Time Complexity: O(nm)
   Space Complexity: O(mn)
 */
",C-Plus-Plus
"/*--------------- RECONSTRUCT ITINERARY-------*/
 
 /* In this problem we are given a 2-d vector named Tickets
    You are given a list of airline tickets where 
    tickets[i] = [fromi, toi] represent the departure and the arrival airports of one flight.
 
    ---TASK---
    You are to return the vector that contains the inorder form of the intinerary. 
    All of the tickets belong to a man who departs from ""JFK"", thus, the itinerary 
    must begin with ""JFK"". 
    If there are multiple valid itineraries, you should return the itinerary that has 
    the smallest lexical order when read as a single string. 
 
    ---EXAMPLE---
    Given tickets vector
    [[""MUC"",""LHR""],
     [""JFK"",""MUC""],
     [""SFO"",""SJC""],
     [""LHR"",""SFO""]]
 
    ---APPROACH---
    1. Make an adjacency list from the given 2-d vector of the form 
        string -> multiset of strings
    2. Make a stack
    3. Iterate over the list, for every list[i] add the strings in the multiset to stack and remove it from the set
    4. If the list[i] is empty then, pop the top element from the stack ans push it to the final answer vector
    5. Keep on repeating the steps 3 and 4 untill the stack is empty
    6. Now the answer vector stores the reverse inorder for our itinerary
    7. Reverse the ans vector and then return.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 vector<string> findItinerary(vector<vector<string>> &tickets)
 {
     // map to store the adjacency list of the airports
     // Multiset is used so that the airports are in lexicographic order
     map<string, multiset<string>> adj;
 
     // vector to store the answer
     vector<string> ans;
 
     stack<string> myStack;
     myStack.push(""JFK""); // for the starting is always from JFK
 
     // making the adjacency list of the strings
     for (int i = 0; i < tickets.size(); i++)
     {
         adj[tickets[i][0]].insert(tickets[i][1]);
     }
     // Iterating over the list and stack
     while (!myStack.empty())
     {
     ",C-Plus-Plus
"""""""Minimize Amplitude After K Removals
 
 
 You are given a list of integers nums, and an integer k.
 Given that you must remove k elements in nums,
 return the minimum max(nums) - min(nums) value we can achieve.
 
 Constraints:-
 
 1  n  100,000 where n is the length of nums
 k < n
 
 Approach :- we have to sort the list first and take a 'p' variable
 in which it stores the length of the list after removing the k.
 Taken an 'm' variable which stores the min possible max(nums)-min(nums)
 firstly and needs to be changed when we get the less max(nums)-min(nums).
 Now, take a for loop which is to be iterated from 0 to len(nums)-p+1 ,
 during the for loop I will check the difference i+p-1'th term to the i'th term
 when I get the lease min I will change the min value to it.
 At the end will return the 'm'(min(max(nums)-min(nums)))""""""
 
 
 # function for the sum
 def evaluate(nums , k) :
 
     nums = sorted(nums)
 
     # storing initial len(nums)-k
     p = len(nums) - k
 
     # initial max is stored in m
     m = nums[-1] - nums[0]
 
     i = 0
 
     while i < len(nums) - p + 1:
 
         # Actual process
         if nums[i + p - 1] - nums[i] < m:
             m = nums[i + p - 1] - nums[i]
 
         i += 1
     return m
 
 
 if __name__ == ""__main__"":
 
     # input list
     list1 = [int(num) for num in input(""Enter the list items : "").split()]
 
     # input the inp
     inp = int(input(""Enter the number of items to be removed : ""))
 
     # printing max possible from list
     print(""The manimum Possible difference is : "" , evaluate(list1 , inp))
 
 
 TestCase = """"""
 Input:-
 
 nums = [84, 45, 2, 1, 894, 156, 68, 48]
 k = 4
 
 output:-
 The manimum Possible difference is : 39
 
 Time Complexity:  O(nlogn)
 Space Complexity: O(1) """"""
",Python
"/*
 Matrix is a 2-D Array.
 The Subtraction of a matrix is possible by subtracting the element of another matrix having same order.
 This code gives the output as as difference between two input matrices.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 //Function that computes Matrix Subtraction
 void subtract(int row_1, int column_1, int matrix_1[][10], int matrix_2[][10])
 {
     int matrix_3[10][10];
     for(int i = 0; i < row_1; i++)
         for(int j = 0; j < column_1; j++)
         //Subtracting both the matrix
             matrix_3[i][j] = matrix_1[i][j] - matrix_2[i][j];
             cout<<""Matrix after subtraction is -->\n"";
     for(int i = 0; i < row_1; i++)
     {   for(int j = 0; j < column_1; j++)
         {
             cout<<matrix_3[i][j]<<""\t"";
         }
         cout << ""\n"";
     }
 }
 
 //Function that takes input of both matrices
 void input(int row_1, int column_1, int matrix_1[][10], int matrix_2[][10])
 {
     cout<<""Enter the values in matrix 1 -->\n"";
     for(int i = 0; i < row_1; i++)
         for(int j = 0; j < column_1; j++)
             cin >> matrix_1[i][j];
             cout<<""\n\nEnter the values in matrix 2 -->\n"";
     for(int i = 0; i < row_1; i++)
         for(int j = 0; j < column_1; j++)
             cin >> matrix_2[i][j];
 }
 
 int main()
 {
   int row_1, row_2, column_1, column_2;
   cout<<""\nEnter the number of rows in matrix 1 = "";
   cin >> row_1;
   cout <<""\nEnter the number of columns in matrix 1 = "";
   cin >> column_1;
   cout << ""\nEnter the number of rows in matrix 2 = "";
   cin >> row_2;
   cout << ""\nEnter the number of columns in matrix 2 = "";
   cin >> column_2;
   int matrix_1[10][10], matrix_2[10][10];
   if (row_1 == row_2 && column_1 == column_2)
    {
      input(row_1, column_1, matrix_1, matrix_2);
      subtract(row_1, column_1, matrix_1, matrix_2);
    }
   else
   cout << ""Subtraction of the given matrices is not possible."";
 }
 
 /*
 SAMPLE INPUT AND OUTPUT :
 Enter the number of rows in m",C-Plus-Plus
"# Python program to count distinct elements in every window of size k
 from collections import defaultdict
 
 
 def Distinct_count(array, window):
 
     # Creates an empty hashmap
     hash_map = defaultdict(lambda: 0)
     count_distinct = 0
 
     for i in range(window):
         if hash_map[array[i]] == 0:
             count_distinct += 1
         hash_map[array[i]] += 1
 
     # Print count of first window
     print(count_distinct)
 
     # Traverse through the remaining array
     for i in range(window, size):
         # If there was only one occurrence, reduce distinct count.
         if hash_map[array[i - window]] == 1:
             count_distinct -= 1
         hash_map[array[i - window]] -= 1
 
     # increment distinct element count
         if hash_map[array[i]] == 0:
             count_distinct += 1
         hash_map[array[i]] += 1
 
         # Print count of current window
         print(count_distinct)
 
 
 size = int(input(""Enter Size: ""))
 array = [int(i) for i in input(""Enter Array: "").split()]
 window = int(input(""Enter window: ""))
 Distinct_count(array, window)
 
 '''
 Sample I/O:
 Input:
 Enter Size: 7
 Enter Array: 1 2 3 4 2 3 4
 Enter window: 4
 
 Output:
 4
 3
 3
 3
 
 Time Complexity: O(size)
 Space Complexity: O(Size)
 '''
",Python
"/**
 A backtracking algorithm to solve 9X9 suduko
 0's in the input are treated empty cells
 Assumption : Given configuration is correct
 **/
 
 import java.io.*;
 import java.util.*;
 
 public class SudukoSolver {
   public static void display(int[][] board){
     for(int i = 0; i < board.length; i++){
       for(int j = 0; j < board[0].length; j++){
         System.out.print(board[i][j] + "" "");
       }
       System.out.println();
     }
   }
   
   // backtracking soln
   public static boolean solve(int[][] board, int i, int j, 
     boolean[][] rows, boolean[][] cols, boolean[][][] boxes) {
       
       if(i == 9)
         return true;
         
       if(board[i][j] == 0) {
           
         for(int k=0; k<9; k++) {
             
           if(rows[k][i] == false && cols[k][j] == false
             && boxes[k][i/3][j/3] == false) {
               board[i][j] = k+1;
               rows[k][i] = true;
               cols[k][j] = true;
               boxes[k][i/3][j/3] = true;
                 
               if(solve(board, i+j/8, (j+1)%9, rows, cols, boxes))
                 return true;
                 
               board[i][j] = 0;
               rows[k][i] = false;
               cols[k][j] = false;
               boxes[k][i/3][j/3] = false;
             }
         }
         
         return false;
       } else
         return solve(board, i+j/8, (j+1)%9, rows, cols, boxes);
     }
 
   public static void solveSudoku(int[][] board, int x, int y) {
     // write yopur code here
     boolean[][] rows = new boolean[9][9];
     boolean[][] cols = new boolean[9][9];
     boolean[][][] boxes = new boolean[9][3][3];
     
     for(int i=0; i<9; i++)
       for(int j=0; j<9; j++)
         if(board[i][j] != 0) {
           int num = board[i][j]-1;
           rows[num][i] = true;
           cols[num][j] = true;
           boxes[num][i/3][j/3] = true;
         }
         
     solve(board,0,0,rows,cols,boxes);
     display(board);
   }
 
   public static void ",Java
"/* Program to rearrange a given linked list so that all odd indexed nodes are arranged first,
    followed by the even indexed nodes in one iteration through the linked list*/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class ListNode {
 public:
     int val;
     ListNode* next;
 };
 
 ListNode* odd_even_linked_list(ListNode* head)
 {
 
     //if linked list has only 1 node, no rearrangement required
     if (head->next == NULL) {
         return head;
     }
 
     //Head of the LinkedList containing odd indexed elements
     ListNode* head_odd = new ListNode();
 
     //Head of the LinkedList containing even indexed elements
     ListNode* head_even = new ListNode();
 
     head_odd = head;
     head_even = head->next;
 
     //Counter for odd indexed nodes
     ListNode* counter_odd = head_odd;
     //Counter for even indexed nodes
     ListNode* counter_even = head_even;
 
     while ((counter_odd->next) != NULL && (counter_even->next) != NULL) {
         //pointer to next odd indexed element
         counter_odd->next = counter_odd->next->next;
         //pointer to next even indexed element
         counter_even->next = counter_even->next->next;
         counter_odd = counter_odd->next;
         counter_even = counter_even->next;
     }
 
     //join the 2 linked list
     counter_odd->next = head_even;
 
     return head;
 }
 
 int main()
 {
     int nodes;
     cin >> nodes;
 
     int node_value;
     cin >> node_value;
 
     ListNode* head = new ListNode();
 
     head->val = node_value;
     head->next = NULL;
 
     ListNode* temp = head;
 
     for (int i = 1; i < nodes; i++) {
         cin >> node_value;
         ListNode* new_node = new ListNode();
         new_node->val = node_value;
         temp->next = new_node;
         new_node->next = NULL;
         temp = temp->next;
     }
 
     ListNode* head_new = odd_even_linked_list(head);
 
     //print the rearranged linked list
     temp = head_new;
     while (temp != NULL) {
         cout",C-Plus-Plus
"""""""
 Purpose: Given a binary matrix of N*M order where 0 is the wall and 1 is way.
         Find the shortest distance from a source cell to a destination cell,
         traversing through limited cells only. Also you can move only
         up, down, left and right. If found then print the distance and
         path in separate lines, else return -1.
 """"""
 
 from heapq import heappop, heappush
 
 # Manhattan Distance for heuristic functionn
 
 
 def heuristic_function(p1, p2):
     x1, y1 = p1
     x2, y2 = p2
     return abs(x1 - x2) + abs(y1 - y2)
 
 
 def Astar(maze, src, des, way=1):
 
     # Base Case: If there is no way from the source, returnn False
     if(maze[src[0]][src[1]] != 1):
         return False
 
     # Dimention of the maze
     n = len(maze)
     m = len(maze[0])
 
     hp = []
     count = 0
     x, y = src
 
     # To keep a track of visited nodes, also mark source as visited
     visited = [[False] * m for i in range(n)]
     visited[x][y] = True
 
     # All possible moves from a cell
     moves = {(1, 0): 'D', (-1, 0): 'U', (0, 1): 'R', (0, -1): 'L'}
     parent = {}
 
     # Initilize the heap with the source cell
     heappush(hp, [0, count, src])
 
     # Initilze the G_score for each node to infinity
     # And G_score of source is 0
     g_score = [[float('inf')] * m for i in range(n)]
     g_score[x][y] = 0
 
     # Initilze the F_score for each node to infinity
     # And F score of source is 1
     # F_source = G_score + heuristic function
     f_score = [[float('inf')] * m for i in range(n)]
     f_score[x][y] = 1
 
     while hp:
         cur_pos = heappop(hp)[2]
         # print(cur_pos)
         xx, yy = cur_pos
 
         if cur_pos == des:
             path = ''
 
             # Calculate the path by backtracking with the parent dict
             while cur_pos != src:
                 print(cur_pos)
                 prev_move = parent[cur_pos]
                 m = (cur_pos[0] - prev_move[0], cur_pos[1] - prev_move[1])
        ",Python
"/** CONCEPT
  This code computes the number of insertions and deletions required to convert one string to another
  *Calculate the length of the longest common subsequence
  *Characters not present in the string X but present in string Y need to be inserted
  *Characters not present in the string Y but present in string X need to be deleted
 **/
 #include <bits/stdc++.h>
 using namespace std;
 
 void minInsertDel(string x, string y, int n, int m)
 {
     int dp[n + 1][m + 1];
 
     /*Base conditions
     For calculating the longest common subsequence
     If the length of any one of the string is zero, then the length of common subsequence will be zero
     */
     for (int i = 0; i < n + 1; i++)
     {
         for (int j = 0; j < m + 1; j++)
         {
             if (i == 0 || j == 0)
                 dp[i][j] = 0;
         }
     }
 
     for (int i = 1; i < n + 1; i++)
     {
         for (int j = 1; j < m + 1; j++)
         {
             if (x[i - 1] == y[j - 1])
                 dp[i][j] = 1 + dp[i - 1][j - 1];
             else
                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
         }
     }
 
     //Displaying the minimum number of insertions and deletions
     cout << ""Minimum insertions="" << m - dp[n][m] << ""\nMinimum deletions="" << n - dp[n][m] << ""\n"";
 }
 
 //Driver Code
 int main()
 {
     string x, y;
     cin >> x >> y;
     int n = x.length();
     int m = y.length();
     minInsertDel(x, y, n, m);
 }
 /*
  *TIME COMPLEXITY- O(n^2)
  *INPUT:
   X= abcdef
   Y= abcdg
   OUTPUT:
   Minimum insertions=1
   Minimum deletions=2
 */
",C-Plus-Plus
"/* Given n non-negative integers representing the histogram's bar height where 
 the width of each bar is 1, find the area of largest rectangle in the histogram */
 
 import java.util.*;
 import java.lang.*;
 import java.io.*;
 
 class RectArea {
     private static int largestRectangleArea(int[] array) {
         int n = array.length;
         Stack<Integer> s = new Stack<Integer>();
         int[] left_nearest_small = new int[n];
         int[] right_nearest_small = new int[n];
         for(int i = 0; i < n; i++) {
             while(!s.isEmpty() && array[s.peek()] >= array[i])
                 s.pop();
             left_nearest_small[i] = (s.isEmpty() ? -1 : s.peek());
             s.push(i);
         }
         s = new Stack<Integer>();
         for(int i = n-1; i >= 0; i--) {
             while(!s.isEmpty() && array[s.peek()] >= array[i])
                 s.pop();
             right_nearest_small[i] = (s.isEmpty() ? n : s.peek());
             s.push(i);
         }
         int area = 0;
         // find area for each possible bar being the maximum heighted bar in the considered bars
         for(int i = 0; i < n; i++)
             area = Math.max(area, (right_nearest_small[i]-left_nearest_small[i]-1)*array[i]);
         return area;
     }
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         int n = sc.nextInt();
         int[] array = new int[n];
         // take input
         for(int i = 0; i < n; i++)
             array[i] = sc.nextInt();
         System.out.println(largestRectangleArea(array));
     }
 }
 
 
 /**
 
 Input:
 6
 2 1 5 6 2 3
 Output:
 10
 TimeComplexity : O(n)
 SpaceComplexity : O(n)
 
 **/
 
 
",Java
"/*Recursive:*/
 import java.util.Scanner;
 
 public class CountDigits {
 
 	public static int countdigit(int n) {
 	        if(n==0){
                    return 0;
                 }
                 return 1 + countdigit(n/10);  
 
 	}
 	
 	public static void main(String[] args) {
 
 		Scanner sc=new Scanner(System.in);
 		
 		System.out.print(""Enter a number : "");
 		int n=sc.nextInt();
 		
 		System.out.println(""Number of digits in a number are : "");
 		System.out.println(countdigit(n));
 				
 	}
 /*	
  	Sample Input : 
 	Enter a number : 24567
  	
 	Sample Output : 5
 	 	
 */
",Java
"// Description: This program finds the leftmost non repeating character in a string.
 // For example: s = ""aabcdb"", output should be: 3 (index of c)
 #include<bits/stdc++.h>
 using namespace std;
 
 int leftmostnonrepeatingchar(string s){
     int res = numeric_limits<int>::max();  //Initialised res to infinity
     vector<int> fi(256, -1);               //An array to store first indices of string characters(size is 256 because there are 256 ascii characters
     for(int i = 0; i < s.size(); i++){     //Traversing through string   
         if(fi[s[i]] == -1){                //If this position in array is -1, that means its a non repeating element
             fi[s[i]] = i;
         }else{
             fi[s[i]] = -2;                 //If it is -2 that means this element has already been repeated before
         }
     }
     for(int i = 0; i < 256; i++){
         if(fi[i] >= 0){
             res = min(res, fi[i]);         //finding the leftmost non repeating char index
         }
     }
     return (res == numeric_limits<int>::max())? -1: res;
 }
 
 int main(){
     string s;
     cout << ""Enter the string: "";
     cin >> s;
     cout << ""The leftmost non repeating character in the string is: "" << leftmostnonrepeatingchar(s);
     return 0;
 }
 /*Sample test case:
 s = ""aabcdb"", all elements of fi array are initialised as -1
 After traversing through string, our res would become 3 */
 
",C-Plus-Plus
"/*Solution to check if a binary tree is a Binary Search tree.
 This solution works for duplicate input values of nodes as well.
 
 Constraints:
 0<= NodeValue <= 10^4
   
 Incorrect Approach:
 It is not enough to check if the left and right node of current node are smaller and larger than it respectively.
 This approach would't work for the following example which is actually not a Binary Search Tree --
      15
     /   \
   12     28
  /  \
 9    24 
 
 
 Correct Approach:
 It is a property of Binary Search Tree that its inorder traversal produces a sorted list in ascending order. By inorder traversal of the tree we store the elements in a list and then check if the list is sorted.
 Time Complexity : O(n)
 Space Complexity : O(n)
  */
 
 
 
 import java.util.*;
 
 //Class which defines the structure of each node in the binary tree
 class Node {
     int data;
     Node left, right;
     Node(int data) {
         this.data = data;
     }
 }
 public class CheckBST {
     //Create a binary tree by taking input level wise
     public static Node createBinaryTree() {
         Scanner sc = new Scanner(System.in);
         System.out.print(""Enter root node value or -1 to exit: "");
         int rootData = sc.nextInt();
         Node root = null;
         if (rootData != -1) {
             root = new Node(rootData);
         } else {
             sc.close();
             return root;
         }
         Queue < Node > tree = new LinkedList < > ();
         tree.add(root);
         while (!tree.isEmpty()) {
             Node temp = tree.remove();
             System.out.print(""Enter left  child of "" + temp.data + "" or -1 if there is no left child: "");
             int leftChild = sc.nextInt();
             // if leftChild is not null create and add left child node
             if (leftChild != -1) {
                 Node child = new Node(leftChild);
                 tree.add(child);
                 temp.left = child;
             }
             System.out.print(""Enter r",Java
"# Python program to find the unique numbers in an array out
 # of which two numbers occur exactly once and are distinct.
 # You need to find the other two numbers and print them in ascending order.
 
 if __name__ == '__main__':
     n = int(input(""Enter the number of elements: ""))
     arr = list(map(int, input().split(' ')[:n]))
     xors = 0
     for i in range(0, n):
         xors = xors ^ arr[i]
     xors = xors & ~(xors - 1)
     x = 0
     y = 0
     for i in range(0, n):
         if arr[i] & xors > 0:
             x = x ^ arr[i]
         else:
             y = y ^ arr[i]
     if x > y:
         swap(x, y)
     print(""The distinct numbers are "", x, "" and "", y)
 
 # Time Complexity: O(N)
 # Space Complexity: O(1)
 
 # Input
 # Enter the number of elements: 6
 # 2 3 1 4 2 1
 
 # Ouput
 # The distinct numbers are  3  and  4
",Python
"/*Problem Statement:
 Sequence (ai) of natural numbers is defined as follows:
 ai = bi (for i <= k)
 ai = c1ai-1 + c2ai-2 + ... + ckai-k (for i > k)
 where bj and cj are given natural numbers for 1<=j<=k.
 Your task is to compute am + am+1 + am+2 + ... + an for given m <= n and 
 output it modulo a given positive integer p. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int k;
 vector<int> a,b,c;
 vector<vector<int> > product_elements(vector<vector<int> > A,vector<vector<int> > B )
 {
     vector<vector<int> > C(k+1,vector<int>(k+1));
     for(int i=1;i<=k;i++)
     {
         for(int j=1;j<=k;j++)
         {
             for(int x=1;x<=k;x++)
             {
                 C[i][j] = (C[i][j] + (A[i][x]*B[x][j]));
             }
 
         }
     }
     return C;
 }
 
 vector<vector<int> >  power(vector<vector<int> > A,int p)
 {
     if(p==1)
     {
         return A;
     }
     if(p&1)
     {
         return product_elements(A, power(A,p-1));
     }
     else
     {
         vector<vector<int> > X = power(A,p/2);
         return product_elements(X,X);
     }
 
 }
 
 int special_sequence(int n)
 {
     if(n==0)
     {
         return 0;
     }
     if(n<=k)
     {
         return b[n-1];
     }
     vector<int> F1(k+1);
     for(int i=1;i<=k;i++)
     {
         F1[i] = b[i-1];
     }
     vector<vector<int> > T(k+1,vector<int>(k+1));
     for(int i=1;i<=k;i++)
     {
         for(int j=1;j<=k;j++)
         {
             // every row except the last one has either 0 or 1 in it
             if(i<k)
             {
                 if(j==i+1)
                 {
                     T[i][j] = 1;
                 }
                 else
                 {
                     T[i][j] = 0;
                 }
                 continue;
             }
             //storing the Coefficients in reverse order
             T[i][j] = c[k-j];
         }
     }
     T = power(T,n-1);
     int res = 0;
     for(int i=1;i<=k;i++){
         res = (res + (T[1][i]*F1[i]));
",C-Plus-Plus
"""""""
 This is a program written in python for finding GCD of two numbers. 
 This solution uses recursive approach as implementation.
 Recursive approach means a fuction calling itself for which a base condition is given so that the program knows where to terminate.
 """"""
 
 #definition of functions to find GCD of 2 numbers.
 def gcd_of_nums(x,y):
     #choose the smaller number
     if x > y:
         t=x
         x=y
         y=t
 
     if(x==0):
         return y
     else:
         return gcd_of_nums(x,y%x)
 
 def main():
     num1 = int(input(""Enter 1st number: ""))
     num2 = int(input(""Enter 2nd number: ""))
 
     print(""The GCD is: "", gcd_of_nums(num1,num2))
     
 if __name__ == ""__main__"":
     main()    
 
 
 """"""
 Output:
 
 Enter 1st number: 48
 Enter 2nd number: 6
 The GCD is:  6
 
 Enter 1st number: 43
 Enter 2nd number: 54
 The GCD is:  1
 """"""
 print(""\n"")
",Python
"/*
 Vector
 -------
 A vector is a re-sizeable array. Internally, vectors use a dynamically allocated array
 to store their elements. If the array is full and new elements have to be added
 in it, then a new array of twice the size is declared and all the elements from the
 previous array are copied onto the new array. This is an expensive operation
 
 push_back() Time Complexity: O(current size)
 
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 template<typename T>
 class Vector {
 
 	int cs; // Current Size : Gives count of the elements currently in vector
 	int ms; // Maximum Size : Gives count of the maximum elements that can be in vector
 	T *arr;	// Array declared
 public:
 	// Constructor
 	Vector() {
 		cs = 0;
 		ms = 1;
 		// Array is dynamically allocated memory space
 		arr = new T[ms];
 	}
 
 	// Inserts new element into the vector from back
 	void push_back(const T d) {
 
 		if (cs == ms) {
 			// Array is full
 			T *oldArr = arr;
 			// arr points to a new memory location with twice memory space
 			arr = new T[2 * ms];
 			ms = 2 * ms;
 			// Copy elements from oldArr
 			for (int i = 0; i < cs; i++) {
 				arr[i] = oldArr[i];
 			}
 			// clear the old memory
 			delete [] oldArr;
 		}
 
 		// Insert new element
 		arr[cs] = d;
 		cs++;
 	}
 
 	// Removes last element from the vector
 	void pop_back() {
 		cs--;
 	}
 
 	// Returns the element at the front of the vector
 	T front() const {
 		return arr[0];
 	}
 
 	// Returns the element at the back of the vector
 	T back() const {
 		return arr[cs - 1];
 	}
 
 	// Returns whether vector is empty
 	bool empty() const {
 		return cs == 0;
 	}
 
 	// Returns current size of the vector
 	int size() const {
 		return cs;
 	}
 
 	// Returns maximum size of the vector
 	int capacity() const {
 		return ms;
 	}
 
 	// Returns iterator to the start of the vector
 	T* begin() const {
 		return arr;
 	}
 
 	// Returns iterator to the end of the vector
 	T* end() const {
 		return arr + cs;
 	}
 
 	// ",C-Plus-Plus
"'''In Vernam cipher, also known as the One-Time Pad, the length of the
    plaintext, ciphertext, and key is the same. A number is assigned to
    each character of the plain-text and the key according to alphabetical
    order. Both the number are added and it is greater than 26, then %26 is
    taken to form the corresponding cipher-text.
 '''
 
 import sys
 
 '''This function assigns a number from 
    [0-25] to characters [a-z] respectively.'''
 
 def ascii_to_dec(text): 
     ascii_text = []
     text = text.lower()
     for i in text:
         ascii_text.append(ord(i) - 97)
     return ascii_text
 
 
 '''This is the encryption function which takes plaintext 
    and keyword as input. It then converts both plaintext 
    and keyword to a number. Adds them. Take %26 to form 
    the corresponding ciphertext.'''
 
 def encryption(message, keyword):
     pad = ascii_to_dec(keyword)
     mess = ascii_to_dec(message)
     enc = []
     for i in range(len(message)):
         character = chr(((mess[i] + pad[i]) % 26) + 97)
         if message[i].islower():
             enc.append(character)
         else:
             enc.append(character.upper())
     return ''.join(enc)
 
 '''This is the decryption function which takes ciphertext
    and keyword as input. It then converts both ciphertext
    and keyword to a number. Subtracts them. Takes %26 to 
    form the corresponding plaintext'''
 
 def decryption(ciphertext, keyword):
     pad = ascii_to_dec(keyword)
     cipher = ascii_to_dec(ciphertext)
     dec = []
     for i in range(len(ciphertext)):
         character = chr(((cipher[i] - pad[i]) % 26) + 97)
         if ciphertext[i].islower():
             dec.append(character)
         else:
             dec.append(character.upper())
     return ''.join(dec)
 
 # Driver function
 if __name__=='__main__':
 
     print(""-""*20, ""Vernam Cipher"", ""-""*20)
     print(""1. Encrypt a plaintext"")
     print(""2. Decrypt a ciphertext"")
     print(""3. Exit"")
 
     # Taking choice f",Python
"/**
  * Minimum Window Substring 
  *          OR
  * Smallest Window in a String Containing All Characters of Another String
  * Given two strings string1 and string2, find the smallest substring in 
  * string1 containing all characters of string2. 
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 string minWindow(string str, string pattern)
 { //unordered map for storing the characters in pattern that we need to check for in str
     unordered_map<char, int> letters;
     for (auto c : pattern)
         letters[c]++;
     //counts number of pattern'str letters in current window
     int count = 0;
     int low = 0, min_length = INT_MAX, min_start = 0;
     for (int high = 0; high < str.length(); high++) {
         if (letters[str[high]] > 0)
             count++; //means that this letter is in pattern
         //reduce the count for the letter on which we are currently
         letters[str[high]]--;
         if (count == pattern.length()) {
             //if current windows contains all of the letters in pattern
             while (low < high && letters[str[low]] < 0)
                 letters[str[low]]++, low++;
             //move low ahead if its not of any significance
             if (min_length > high - low)
                 //update the min length
                 min_length = high - (min_start = low) + 1;
             //move low ahead and also increment the value
             letters[str[low++]]++;
             //count-- as we are moving low ahead & low pointed to a char in pattern before
             count--;
         }
     }
     //check for edge case & return the result
     return min_length == INT_MAX ? """" : str.substr(min_start, min_length);
 }
 int main()
 {
     //taking input from user
     string str, pattern;
     cout << ""Enter a String text: "";
     cin >> str;
     cout << ""Enter a String pattern: "";
     cin >> pattern;
     cout << ""Smallest substring in text, containing all characters in pattern: "";
     cout << minWindow(str, pa",C-Plus-Plus
"//Unique_Number_III
 //Given an array that contains all elements occurring 3 times, but one occurs only once. Find that unique element.
 
 using System.IO;
 using System;
 
 class Neoalgo {
   static void Main() {
     int[] count = new int[64];
     int len, no, i;
     Console.WriteLine(""Enter number of element:"");
     len = Convert.ToInt32(Console.ReadLine());
     Console.WriteLine(""Enter space separated elements:"");
     for (i = 0; i < len; i++) {
       //Reading array element
       no = Convert.ToInt32(Console.ReadLine());
 
       int j = 0;
       //""AND"" each element of the array with each set digit
       while (no > 0) {
         int last_bit = no & 1;
         count[j] += last_bit;
         j++;
         no = no >> 1;
       }
     }
 
     //consider all bits whose count is not multiple of 3
     int num = 1;
     int ans = 0;
     for (i = 0; i < 64; i++) {
       count[i] %= 3;
       ans += (count[i] * num);
       num = num << 1;
     }
     Console.Write(""unique num is:"");
     Console.Write(ans);
   }
 }
 /* output
 
 Enter number of element: 7
 Enter space separated elements: 10 10 12 21 21 10 21
 unique num is: 12
 
 Time Complexity:O(n)
 */
 
",C-Sharp
"/*Problem Statement: 
 A knight is a piece used in the game of chess. The chessboard itself is square array of cells. 
 Each time a knight moves, its resulting position is two rows and one column, 
 or two columns and one row away from its starting position. 
 Thus a knight starting on row r, column c  which well denote as (r,c)  can move to any of the squares (r-2,c-1),
 (r-2,c+1), (r-1,c-2), (r-1,c+2), (r+1,c-2), (r+1,c+2), (r+2,c-1), or (r+2,c+1).
 Of course, the knight may not move to any square that is not on the board.
 Suppose the chessboard is not square, but instead has rows with variable numbers of columns, 
 and with each row offset zero or more columns to the right of the row above it. 
 The figure to the left illustrates one possible configuration. 
 How many of the squares in such a modified chessboard can a knight, 
 starting in the upper left square (marked with an asterisk), 
 not reach in any number of moves without resting in any square more than once? Minimize this number. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int n,cols,empty,board[10][10],sum=0,visited;
 void knight_squares(int i,int j,int count)
 {
     if(i<0 || i>=10 || j<0 || j>=10 || board[i][j] == 0)
     {
         return;
     }
     int ans = 0;
     board[i][j] = 0;
     visited = max(visited,count+1);
     /* Going to all possible moves,
     the knight can visit */
     knight_squares(i-1,j-2,count+1);
     knight_squares(i-2,j-1,count+1);
     knight_squares(i+1,j-2,count+1);
     knight_squares(i+2,j-1,count+1);
     knight_squares(i-1,j+2,count+1);
     knight_squares(i-2,j+1,count+1);
     knight_squares(i+1,j+2,count+1);
     knight_squares(i+2,j+1,count+1);
     //backtracking
     board[i][j] = 1;
 }
 
 int main()
 {
     cout<<""Enter the side of square: ""<<endl;
     cin>>n;
     sum = 0;
     cout<<""Enter cells: ""<<endl;
     for(int i=0;i<n;i++)
     {
         for(int j=0;j<n;j++)
         {
             cin>>board[i][j];
             if(board[i]",C-Plus-Plus
"'''
     Given head pointer you have to delete the value of the node to delete
 '''
 
 
 class ListNode():      
     #Node Class            
     def __init__(self,value=None):
         self.data = value
         self.next = None
 # function for creating linked list
 def create_LinkedList(head,val):           
     if(head.next!=None):
         temp = head.next
         while(temp.next!=None):
             temp = temp.next
         newnode = ListNode(val)
         newnode.next = None
         temp.next = newnode
         
     else:
         newnode = ListNode(val)
         newnode.next = None
         head.next = newnode
         
 #function for displaying  linked list
 def print_linkedlist(head):                 
     temp = head.next
     while(temp!=None):
         print(temp.data,end =' ')
         temp = temp.next
     print()
 
     #function to delete a node from linked list
 def delete_node(node):                         
      if node.next is not None:
             node.data, node.next = node.next.data, node.next.next
         
 if __name__ == '__main__': 
     head = ListNode()
     n = int(input(""Enter total no of elemets in linked list :""))
     for i in range(n):
         create_LinkedList(head,int(input()))
     print_linkedlist(head)
     delete_node(head.next.next)
     print_linkedlist(head)
     
     
     
 # OUPUT :
 # Enter total no of elemets in linked list :5
 # 3
 # 4
 # 5
 # 6
 # 7
 # 3 4 5 6 7 
 # 3 5 6 7 
 
 '''
 Time complexity : O(N)
 Space complexity :O(1)
 '''
 
 
 
     
",Python
"/*
 Given the number of rows , print the pascal's triangle having that many rows.
 */
 #include <bits/stdc++.h>
 using namespace std;
 int main()
 {
     long int n;
     cout << ""Enter the number of rows"" << endl;
     cin >> n; // Enter the number of rows in the triangle
     long int dp[n][n];
     cout << ""The Pascal's Triangle is : "" << endl;
     for (int row = 0; row < n; row++)
     {
         for (int i = 0; i <= row; i++)
         {
             if (row == i || i == 0)
                 dp[row][i] = 1; //Initialize first and last element of ach row with 1
             else
                 dp[row][i] = dp[row - 1][i - 1] + dp[row - 1][i]; //Other values are sum of values just above and left of above
             cout << dp[row][i] << "" "";
         }
         cout << endl;
     }
     return 0;
 }
 /*Piyush Kumar
    Time Complexity - O(n^2)
    Space Complexity - O(n^2) auxiliary space
    Sample Input -
    Enter the number of rows
    4 
    Sample Output -
    The Pascal's Triangle is :  
        1
       1 1
      1 2 1
     1 3 3 1 */",C-Plus-Plus
"/*
     This is a simple program in go language to conver a given
     number if in range ( i.e number <= 2147483647 ) into its
     binary equivalent and print it out.
 
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 // global variable
 var array[32] int
 
 // This funtion prints the binary equivalent of decimal number
 func printnumbers(counter int) {
 
    fmt.Print(""The binary equivalent of the given number is :"")
 
    var i int
    for i = counter-1; i >= 0; i-- {
 
        fmt.Print(array[i])
 
    }
 
 }
 
 /* This function converts the entered number from decimal to 
    binary number and stores the elements in a array*/
 func dectobin(n int) {
 
    var r int
    r = 0
 
    var counter int
    counter = 0
 
    /* We divide the number by 2 and store its remainder in
       an array and then update the number as the quotient
       divided by 2*/
    for n != 0 {
 
       r = n % 2
       array[counter] = r
       n = n/2
 
       counter +=1
 
    }
 
    //calling printnumbers function to print the binary number
    printnumbers(counter)
 
 }
 
 //driver function
 func main() {
 
    var number int
 
    //The decimal number we need to convert
    fmt.Print(""Enter the number you want to convert :"")
    fmt.Scan(&number)
 
    // checking if the entered number is in range or not
    if(number <= 2147483647) {
 
        dectobin(number)
 
    }else {
 
        fmt.Print(""The number entered not in range"")
 
    }
 
 }
 
 /*
    Sample I/O :
 
    a) In range :
 
    Enter the number you want to convert :10
    The binary equivalent of the given number is :1010      
 
    b) Not in range :
 
    Enter the number you want to convert :2147483648 
    The number entered not in range
 
 */
 
",Go
"import java.util.HashMap;
 import java.util.Map;
 import java.util.NavigableSet;
 import java.util.TreeSet;
 
 /**
  * There are more efficient ways of implementing this. The decision of using the predefined Java structures
  * was mainly due to laziness rather than any other thing.
  * 
  * @author Ricardo Prins
  * @since 6-26-2020
  */
 public class Dijkstra {
 
     class Graph {
         // mapping of vertex names to Vertex objects, built from a set of Edges
         private final Map<String, Vertex> graph;
         
         public Graph(Edge[] edges) {
             graph = new HashMap<>(edges.length);
 
             // one pass to find all vertices
             for (Edge e : edges) {
                 if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));
                 if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));
             }
 
             // another pass to set neighbouring vertices
             for (Edge e : edges) {
                 graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);
                 // graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); //for an undirected graph
             }
         }
 
         public void dijkstra(String startName) {
             if (!graph.containsKey(startName)) {
                 System.err.printf(""Graph doesn't contain start vertex \""%s\""\n"", startName);
                 return;
             }
             final Vertex source = graph.get(startName);
             NavigableSet<Vertex> q = new TreeSet<>();
 
             for (Vertex v : graph.values()) {
                 v.previous = v == source ? source : null;
                 v.dist = v == source ? 0 : Integer.MAX_VALUE;
                 q.add(v);
             }
 
             dijkstra(q);
         }
 
         private void dijkstra(final NavigableSet<Vertex> q) {
             Vertex u, v;
             while (!q.isEmpty()) {
                 u = q.pollFirst();
                 if (u.dist == Integer.MAX_VALUE) break;
 
",Java
"/* C program to print the n'th term in the Golomb sequence
 Golomb sequence is a non-decreasing integer sequence where n'th
 term is  equal to the number of times n appears in the sequence */
 
 #include <stdio.h>
 
 int golomb_sequence(int n)
 {
     // Create a dp array, with value initialized as 0.
     int dp[n + 1];
 
     dp[1] = 1;
 
     // Identify the previous term 'prev' and go prev terms behind and find a number.
     // Now assign the current element with an incremented value of that element.
     for (int i = 2; i <= n; i++)
     {
         int prev = dp[i - 1];
         int back_index = i - dp[prev];
         dp[i] = 1 + dp[back_index];
     }
     return dp[n];
 }
 
 int main()
 {
     int n;
     printf(""Enter the value of n?, where you need the n'th number in the golomb sequence."");
     scanf(""%d"", &n);
     if (n <= 0)
     {
         printf(""The given value of n is invalid."");
         return 0;
     }
     int res = golomb_sequence(n);
     printf(""The %d \'th term in the golomb sequence is %d"", n, res);
     return 0;
 }
 
 /*
 Time Complexity: O(n), where 'n' is the given number
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the value of n?, where you need the n'th number in the golomb sequence. 5
 The 5'th term in the golomb sequence is 3.
 
 SAMPLE 2
 
 Enter the value of n?, where you need the n'th number in the golomb sequence. 867
 The 867'th term in the golomb sequence is 79.
 */
",C
"/**
  * In this algorithm we keep halving one number and doubling the 2nd one.
  * While halving, if we get an odd number, we add the 2nd doubled number to the result.
  * This goes on until the halving makes the first reach 0
  * 
  * It is also known as the Ancient Egyptian Multiplication, used by scribes to do multiplication
  * without using the multiplication table.
  */
 import java.util.*;
 
 public class RussianPeasant {
 
     public static void main(String[] args) {
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter 2 numbers:"");
         int a = scanner.nextInt();
         int b = scanner.nextInt();
 
         int result = 0; // for storing the product
 
         // as long as second number is greater than 0
         while (b > 0) {
 
             // if second becomes odd add first to result
             if ((b & 1) != 0) {
                 result += a;
             }
 
             // double first and halve the second
             a = a << 1;
             b = b >> 1;
         }
 
         System.out.println(""Product:"" + result);
         scanner.close();
     }
 }
 /*
 * Sample input/output
 * Enter 2 numbers:
 * 20 12
 * Product:240
 *
 * Time complexity: O(1)
 */
",Java
"/*
 sleepSort -> It is a unique sorting technique in which javascript's  timeout function is used.
 To know what timeout function is , refer to this article : https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout
 
 Drawbacks and constraints of sleepSort:
 1. Sleepsort technique cannot be used in case of negative numbers, because it prints some unwanted result(unsorted array).
 2. It might not be very useful in case of large integers in the array as large integers could cause a long duartion timeout. 
 */
 
 let numbers = [10, 50, 3, 7, 1, 75];
 
 console.log(""Sorted Array : "");
 numbers.forEach((num) => {
   // Here creating timeout of duration  = element of array
   setTimeout(() => {
     console.log(num);
   }, num);
 });
 
 // Output : 1 3 7 10 50 75
 
 /*
 Above code prints an unwamted result when array contains both 0 and 1 as its elemnnts,
 i.e. 1 gets printed before 0 which is an unsorted condition, but to prevent this we can 
 multiply the timeout with some constant e.g. 2*num or 3*num, but this can cause large timeout 
 for some large elements of the array.
 */
 
 let numbers2 = [10, 50, 3, 7, 1, 75, 0];
 
 console.log(""Sorted Array : "");
 numbers2.forEach((num) => {
   // Here creating timeout of duration  = 2 * element of array
   setTimeout(() => {
     console.log(num);
   }, 2 * num);
 });
 
 // Output : 0 1 3 7 10 50 75
",JavaScript
""""""" Subset Sum Problem in Python
 
 Given a set of integers, and a value, we have to check if there exist a subset such that
 its sum is equal to the given value
 
 The problem can be solved using Dynamic Programming
 """"""
 
 
 def subsetSum(arr, size, S):
     # A 2D List containing boolean values, True and False
     # Fill every element of the 2D list with False as value
     dp = ([[False for i in range(S + 1)] for i in range(n + 1)])
 
     for i in range(0, size + 1):
         for j in range(0, S + 1):
 
             # Sum = 0 is always possible, by taking no elements in the subset
             if j == 0:
                 dp[i][0] = True
 
             if i > 0:
                 # If the value of current element is less than sum j, then either
                 # include it and the current element or leave it and take previous best
                 if arr[i - 1] <= j:
                     dp[i][j] = dp[i - 1][j] or dp[i - 1][j - arr[i - 1]]
                 # Else take the previous best
                 else:
                     dp[i][j] = dp[i - 1][j]
 
     return dp[size][S]
 
 
 if __name__ == '__main__':
     print(""How many numbers are there in the set? "", end="""")
     n = int(input())
     print(""Enter the numbers in the set: "", end="""")
     a = [int(x) for x in input().split(' ')]
     print(""Enter the sum value: "", end="""")
     s = int(input())
     res = subsetSum(a, n, s)
     if res is False:
         print(""No subset adds upto given sum"")
     else:
         print(""Subset with given sum is present"")
 
 
 # Time Complexity: O(sum * size of array)
 # Space Complexity: O(sum * size of array)
 
 # SAMPLE INPUT AND OUTPUT
 
 # How many numbers are there in the set? 6
 # Enter the numbers in the set: 3 34 4 12 5 2
 # Enter the sum value: 9
 # Subset with given sum is present
",Python
"/*
 Given a chain of matrices A1, A2, A3,.....An, you have to figure out the most efficient 
 way to multiply these matrices. In other words, determine where to place parentheses to 
 minimize the number of multiplications.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int matrixChainMultiplication(int arr, int n){
     /
         For simplicity of the program, one extra row and one
         extra column are allocated in dp[][]. Oth row and oth
         column of dp[][] are not used
     /
 
     n += 1;
 
     /
         dp[i,j] = Minimum number of scalar multiplications needed
         to compute the matrix A[i]A[i+1]...A[j] = A[i..j] where
         dimension of A[i] is arr[i-1] x arr[i]
     */
 
     vector<vector<int>> dp(n, vector <int>(n));
 
     //Cost is zero when multiplying one matrix
     for(int i=1; i<n; i++){
         dp[i][i]=0;
     }
 
     //L is chain length
     for(int L=2; L<n; L++){
         for(int i=1; i<n-L+1; i++){
             int j = i+L-1;
             dp[i][j] = INT_MAX;
             for(int k=i; k<=j-1; k++){
                 int q = dp[i][k] + dp[k+1][j] + (arr[i-1] * arr[k] * arr[j]);
                 if(q<dp[i][j])
                     dp[i][j]=q;
             }
         }
     }
     return dp[1][n-1];
 }
 
 int main() {
     int size;
     cout<<""Enter the size of the array:"";
     cin >> size;
     int* arr = new int[size];
    cout<<""Enter the array elements:""
     for (int i = 0; i <= size; i++) {
         cin >> arr[i];
     }
 
     cout << matrixChainMultiplication(arr, size);
 
     delete[] arr;
 }
 
 /*
 Time Complexity: O(N^3);
 Space Complexity: O(N^2)
 where N is the number of matrices to multiply
 
 Sample Input:
 5
 2 4 6 12 11 21
 Sample Output:
 918
 */
",C-Plus-Plus
"/* SORTING USING BINARY SEARCH TREE
     Binary Search Tree is a special type of binary tree where 
     1. The value of all the nodes in the left sub-tree is less than or equal to the value of the root.
     2. The value of all the nodes in the right sub-tree is greater than value of the root.
     3. This rule will be recursively applied to all the left and right sub-trees of the root.
 
     Inorder traversal 
     1. Traverse the left subtree
     2. Visit the root.
     3. Traverse the right subtree
 
     Inorder traversal in BST gives sorted list
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 // Declare treeNode with data , rc (right child) and lc (left child )
 typedef struct treeNode
 {
     int data;
     struct treeNode *lc;
     struct treeNode *rc;
 } treeNode;
 
 int count = 0;
 
 //to insert a node into BST
 treeNode *insertIntoTree(treeNode *root, int data)
 {
     //If tree is empty insert as root node
     if (root == NULL)
     {
         treeNode *ptr;
         ptr = malloc(sizeof(treeNode));
         ptr->data = data;
         ptr->lc = NULL;
         ptr->rc = NULL;
         root = ptr;
     }
     else
     {
         // insert recursively in accordance with BST properties
         if (root->data >= data)
         {
             root->lc = insertIntoTree(root->lc, data);
         }
         else if (root->data < data)
         {
             root->rc = insertIntoTree(root->rc, data);
         }
     }
     return root;
 }
 
 //to sort-inorder traversal gives sorted list
 void inorder(treeNode *root)
 {
     //If tree is empty
     if (root)
     {
         // recursively visit left sub-tree,root and right sub-tree
         inorder(root->lc);
         printf(""%d "", root->data);
         inorder(root->rc);
     }
 }
 
 // driver code
 void main()
 {
     //Initialize tree as empty
     treeNode *root;
     root = NULL;
     int n, data;
     //Accept the no. of elements and elements as user input
     scanf(""%d"", &n);
 
     for (int i = 0; i",C
"/*
 Given a Binary Search Tree, the program finds the Youngest and Oldest 
 member of given two numbers.
 Youngest member is the Parent of the given 2 nodes only if they are siblings.
 Oldest member is the root node of the BST.
 */
 
 #include<iostream>
 using namespace std;
 
 struct BST
 {
 	int a,count = 0, level = 0; 
 	BST *left = NULL;
 	BST *right = NULL;
 };
 
 //points to the root node
 BST *start = NULL; 
 int l1,l2;
 
 //function to convert array into Binary Search Tree with shortest height
 BST *arr_to_BST(int arr[20], int beg, int end) 
 {
 	BST *ptr;
 	
 	if(beg <= end)
 	{
 		ptr = new BST;
 		ptr->left = NULL;
 		ptr->right = NULL;
 		ptr->a = arr[(beg+end)/2];
 		int mid = (beg+end)/2;
 		ptr->left = arr_to_BST(arr,beg,mid-1);
 		ptr->right = arr_to_BST(arr,mid+1,end);	
 		return ptr;
 	}
 	else
 		return NULL;
 }
 
 //function to print Binary Search Tree
 void Display_BST(BST *ptr) 
 {
 	cout<<""\na:""<<ptr->a;
 	
 	if(ptr->left != NULL)
 		cout<<""\tleft:""<<ptr->left->a;
 	
 	if(ptr->right != NULL)
 		cout<<""\tright:""<<ptr->right->a;
 	
 	if(ptr->left != NULL)
 		Display_BST(ptr->left);
 	
 	if(ptr->right != NULL)
 		Display_BST(ptr->right);
 }
 
 //function to assign level values to corresponding nodes
 void level_assign(BST *ptr, int value=0) 
 {
 	ptr->level = value;
 	if(ptr->left != NULL)
 		level_assign(ptr->left,value+1);
 	if(ptr->right != NULL)
 		level_assign(ptr->right,value+1);
 }
 
 //returns level of the number
 int find_number(BST *ptr,int n) 
 {
 	if(ptr->a == n)
 		return ptr->level;
 	else if(n < ptr->a)
 		find_number(ptr->left,n);
 	else
 		find_number(ptr->right,n);
 }
 
 //function to print the value of youngest member for given numbers
 void Display(BST *ptr, int n1, int n2) 
 {
 	if(n1 < ptr->a && n2 > ptr->a)
 	{
 		cout<<""\nyoungest:""<<ptr->a;
 		return;
 	}
 	else if(ptr->level == (l1-1) || ptr->level == (l2-1))
 	{
 		cout<<""\nyoungest:""<<ptr->a;
 		return;
 	}
 	if(ptr->left != NULL && (n1 < ptr->a || n2 < ptr->a))
 		Dis",C-Plus-Plus
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# LAPTOP PRICE PREDICTION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [Laptop Pricing](https://www.kaggle.com/andrewgeorgeissac/laptop-price-predictor?select=laptop_pricing.csv)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import numpy as np\n"",
     ""import seaborn as sb\n"",
     ""from sklearn import preprocessing\n"",
     ""from statsmodels.stats.outliers_influence import variance_inflation_factor\n"",
     ""import matplotlib.pyplot as plt\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.ensemble import RandomForestRegressor\n"",
     ""from sklearn.metrics import r2_score""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting our Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n"",
        ""<table border=\""1\"" class=\""dataframe\"">\n"",
        ""  <thead>\n"",
        ""    <tr style=\""text-align: right;\"">\n"",
        ""      <th></th>\n"",
        ""      <th>Manufacturer</th>\n"",
        ""      <th>IntelCore(i-)</th>\n"",
        ""      <th>IntelCoreGen</th>\n"",
        ""      <th>processing s",Python
"/*
 
 FCFS: First Come First Serve algorithm 
 
 It is a CPU scheduling algorithm, in which the process are taken on the basis of their arrival time. 
 The process that arrives first, is alloted the CPU first for the execution. Its working is similar to 
 that of the FIFO in queue. It is a non-preemptive algorithm which means that the next process cannot be 
 scheduled in the middle of the ongoing execution of a process in CPU.  
 
 Terms explanation:
 1. Burst time is the time taken by a process to complete its execution.
 2. Waiting time is the total time for which a process has to wait for its chance to get the CPU for execution.
 3. Turn around time is the total time between the submission of a process and its completion.
 
 Implementation of the code:
 Step 1: The number of process are scanned along with their respective burst time.
 Step 2: Waiting time for a process is calculated by adding the burst time of the previous process. Waiting time for first process is taken as 0.
 Step 3: Turn around time of a process is calculated which is the sum of burst time and waiting time of that process.
 Step 4: Average waiting time and average turn around time are calculated by diving the total waiting and turn around time by nummber of process.
 
 */
 
 #include <stdio.h>
 
 // Function to calculate waiting time 
 void waitingTime(int process[], int wt[], int n, int bt[])
 {
     int i,j;
 	
     // waiting time for the first process is taken to be 0
 	wt[0] = 0;
 
 	// waiting time being calculated for a process by adding the burst time of previous process
 	for (i = 1; i < n; i++)
 	{
 		wt[i] = 0;
 		for (j = 0; j < i; j++)
 			wt[i] = wt[i] + bt[j];
 	}
 }
 
 // Function to calculate turn around time
 void turnaroundtime(int process[], int n, int bt[], int wt[], int tat[])
 {
     int i;
 	
     //turn around time being calculated by adding waiting and burst time of each process
 	for (i = 0; i < n; i++)
 	{
 		tat[i] = bt[i] + wt[i];
 	}
 }
 
 // Funtion to calculat",C
"""""""
     Introduction:
         Symmetric encryption is a powerful encryption strategy used for transferring digital
         information over an in-secure channer. For this however we need a key which is present
         with both the Sender and the Receiver. The same key would be used for the encryption and
         decryption. However, exchange of the symmetric key needs to be secure to ensure that the
         transmitted data is not tampered with. Here comes, Diffie Helman Key Exchange protocol using
         which two parties can generate a common symmetric key based on the data transmitted between them.
         The symmetric key, however is never shared directly between the two parties.
 
     Purpose:
         The code segment below mimics the diffie helman protocol in the real world. It shows the flow
         of information from the beginning of a connection till the end where both parties have
         successfully generated a symmetric key at their respective ends.
 """"""
 
 import random
 from math import sqrt
 
 def miller_rabin(num):
     """"""
         Probabilistic measure to check whether a large number is a prime or not
     """"""
 
     # Find d in d*2^r
     r = 0
     d = num-1
     while d % 2 == 0:
         d //= 2
         r += 1
     a = random.randint(2, num-2)
 
     result = fast_exponentiation(a, d, num)
     if result == 1 or result == num-1:
         # Is a prime number
         return True
 
     while d != num-1:
         result = (result*result) % num
         d *= 2
         if result == 1:
             # Is a composite number
             return False
         if result == num-1:
             # Is a prime number
             return True
 
     # Is a composite number
     return False
 
 def get_prime(start=20, end=25):
     """"""
         Generates a prime number in the inclusive range [2**start, 2**end]. Default value of\
         start is 20 and end is 25.
     """"""
 
     n = random.randint(2**start, 2**end)
     while n % 2 == 0:
  ",Python
"""""""
 This is a pure Python implementation of the insertion sort algorithm
 
 """"""
 
 """""" Implementation of the insertion sort algorithm in Python
     :parameter array: A mutable ordered collection with comparable items inside
     
     :return : the same collection ordered by ascending
     Examples:
     >>> insertion_sort([0, 5, 3, 2, 2])
     [0, 2, 2, 3, 5]
     >>> insertion_sort([])
     []
     >>> insertion_sort([-2, -5, -45])
     [-45, -5, -2]
 """"""
 def insertion_sort(array):
     # Loop from the second element of the array until
     # the last element
     for i in range(1, len(array)):
         # This is the element we want to position in its
         # correct place
         key_item = array[i]
 
         # Initialize the variable that will be used to
         # find the correct position of the element referenced
         # by `key_item`
         j = i - 1
 
         # Run through the list of items (the left
         # portion of the array) and find the correct position
         # of the element referenced by `key_item`. Do this only
         # if `key_item` is smaller than its adjacent values.
         while j >= 0 and array[j] > key_item:
             # Shift the value one position to the left
             # and reposition j to point to the next element
             # (from right to left)
             array[j + 1] = array[j]
             j -= 1
 
         # When you finish shifting the elements, you can position
         # `key_item` in its correct location
         array[j + 1] = key_item
 
     return array
 
 
 
 if __name__ == ""__main__"":
 
 
     user_input = list(map(int, input(""Enter a sequence of comma seprated numbers:\n"").split(',')))
     
     # calling the insertion_sort function
     sorted_collection =insertion_sort(user_input)
     print(sorted_collection)",Python
"import java.util.Scanner;
 
 public class ZAlgorithm {
 
     public static void main(String[] args) {
         // taking the user input
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter the text:"");
         String text = scanner.nextLine();
         System.out.println(""Enter the pattern to be searched:"");
         String pattern = scanner.nextLine();
         scanner.close();
 
         searchPattern(text, pattern);
     }
 
     private static void searchPattern(String text, String pattern) {
         String concatNewStr = pattern + ""$"" + text;
         int[] zArr = new int[concatNewStr.length()];
 
         //get the z array
         getZarr(concatNewStr, zArr);
 
         // looping to find the array locations
         for (int i = 0; i < zArr.length; i++) {
             if(zArr[i] == pattern.length()) {
                 System.out.println(""Found pattern at index "" + (i - pattern.length() - 1));
             }
         }
     }
 
     private static void getZarr(String concatNewStr, int[] zArr) {
         int n = concatNewStr.length();
 
         // [left,right] make a window which matches with prefix of s
         int left = 0, right = 0;
 
         for (int i = 1; i < concatNewStr.length(); ++i) {
 
             // if i>right nothing matches
             if (i > right) {
 
                 left = right = i;
 
                 // right-left = 0 in starting, so it will start checking from 0'th index.
                 while (right < n && concatNewStr.charAt(right - left) == concatNewStr.charAt(right)) {
                     right++;
                 }
 
                 zArr[i] = right - left;
                 right--;
 
             } else {
 
                 // k = i-left so k corresponds to number which matches in [left,right] interval.
                 int k = i - left;
 
                 // if zArr[k] is less than remaining interval then zArr[i] will be equal to zArr[k].
                 if (zArr[k] < right - i + 1) {
  ",Java
"#include <stdio.h>
 #include <string.h>
 int find_occ(char main_str[100], char sub_str[100], int main_len, int sub_len);
 int main()
 {
     char word[100], sub[100];
     scanf(""%s%s"", word, sub);
     int len_word, len_sub, occ; //find length of both strings
     len_word = strlen(word);
     len_sub = strlen(sub);
     if (len_word = 0 || len_sub == 0 || len_word < len_sub) //if either string is empty or length of substring is greater than the main string
         printf(""Enter valid strings."");
     else
     {
         occ = find_occ(word, sub, len_word, len_sub);
         printf(""Number of occurences of %s in %s: %d"", sub, word, occ);
     }
     return 0;
 }
 int find_occ(char main_str[100], char sub_str[100], int main_len, int sub_len)
 {
     int occ = 0, len_m; //loop variables and variable to store occurence
     for (len_m = 0; len_m <= (main_len - sub_len); len_m++)
     {
         int len_s;
         for (len_s = 0; len_s < sub_len; len_s++)
         {
             if (main_str[len_m + len_s] != sub_str[len_s])
                 break;
         }
         if (len_s == sub_len)
         {
             occ++;
             len_s = 0;
         }
     }
     return occ;
 }
 
 /*
 Time Complexity: O(len_word*len_sub)
 Space Complexity: O(len_word)
 
 Sample Input:
 abcchifjrnccdnrr
 cc
 Output:
 Number of occurences of cc in abcchifjrnccdnrr: 2
 */
",C
"/*
 Optimal Division of numbers 
 
 For the given array of integers arr[], you have to
 perform float division of adjacent integers present in arr[].
 You can add as many number of parenthesis you want at any position 
 to change the priority of positions. But your task is to add
 parenthesis in such a way that the expression gives 
 the maximum value after evaluation.
 */
 
 import java.io.* ;
 import java.util.* ;
 
 public class Optimal_division_of_numbers
 {
     //function to find expression such as to maximize the value of expression
     public String optimizedDivisionOfNum(int[] arr)
     {
         //In case of just one element present in array
         //we simply write the number
         if (arr.length == 1)
         {
             return arr[0] + "" "";
         }
         //In case of 2 elements present in the array 
         //we just need to divide the two 
         if (arr.length == 2)
         {
             return arr[0] + "" / "" + arr[1];
         }
 
         //otherwise adding parenthesis
         StringBuilder reqExpression = new StringBuilder(arr[0] + "" / ( "" + arr[1]);
 
         //the approach that we develop over here is that
         //we try to manimize the denominator part
         //as far as possible so as to maximize the value 
         //of the expression that we are getting
         //Thus trying to minimize the denominator
         for(int pass = 2; pass < arr.length; pass++)
         {
             reqExpression.append("" / "" + arr[i]);
         }
         reqExpression.append("" ) "");
 
         return reqExpression.toString();
     }
 
     //drivers code
     public static void main(String[] args) 
     {
         //for input
         Scanner sc = new Scanner(System.in);
 
         //size of array
         System.out.println(""Enter size greater than or equal to 1"");
         System.out.println(""Enter the number of elements of array: "");
         int size = sc.nextInt();
 
         int []arr = new int[size];
         //array element",Java
"/*
 Implement the basic functionality of stack using Linked List Data structure
 
 @author: Rishikeshrajrxl
 @created: 17/08/2020
 */
 
 #include <iostream>
 using namespace std;
 
 struct node
 {                          //declaration of node
 int data;
 struct node*next;
 }*head=NULL,*temp,*ptr;
 
 void Push();             //Function declaration
 void Peek();           
 void Pop();
 void Is_Empty();
 void Display();
 void count();
 int ele;
 
 int main()              //Main() starts
 {
 int ch;
 cout<< ""\n\n\t Implement the basic functionality of stack""<<endl;         //Displaying the Features in a tabular manner         
 cout<<""\t **************************************************""<<endl;
 do{
 cout<<""\t 1) Push\t \t 2) Pop ""<<endl; 
 cout<<""\t 3) Peek\t \t 4) Is_Empty""<<endl;
 cout<<""\t 5) Display\t \t 6) count""<<endl;
 cout<<""\t 7) Exit""<<endl;
 cout<<""\t ***************************************************\nENTER YOUR CHOICE : "";
 cin >>ch;
   switch(ch)
   {
     case 1:
     Push();
     break;
 
     case 2:
     Pop();
     break;
 
     case 3:
     Peek();
     break;
 
     case 4:
     Is_Empty();
     break;
 
     case 5:
     Display();
     break;
 
     case 6:
     count();
     break;
     
     case 7:
     exit(0);
     break;
     
     default:
     cout<<""Invalid Input. Please enter the Number between 1 to 7 \n""<<endl;
   }
 }while(ch!=0);
     return 0;
 }                       // Main() Ends
 //--------------------------------------------------------------------------
 void Push()             //Insertion at the top 
 {
     ptr=(struct node*)malloc(sizeof(struct node));
     cout<<""ENTER THE ELEMENT : "";
     cin>>ele;
     ptr->data=ele;
     ptr->next=head;
     head=ptr;
     cout<<""Pushed Successfully""<<endl;
 }
 //---------------------------------------------------------------------------
 void Pop()                //deletion from the top
 {
     if(head==NULL){
         cout<<""Stack is Empty""<<endl;
     }
     else{
         temp=",C-Plus-Plus
"/*
  * The Problem is Checking if a Graph is a Tree or not
  * Complexity O(V+E)
  * V: No. of Vertices
  * E: No. of Edges
  */
 using System;
 using System.Collections.Generic;
 using System.Linq;
 using System.Text;
 using System.Threading.Tasks;
 
 namespace NeoAlgo
 {
     class Program
     {
         /*
          * Using DFS Algorithm to check if node is visited(W) or Not Visited(G)
          * If it's not Visited it will mark it as visited and visit its neighbours
          * If it's visited, it will return true (it's Cycle)
         */
         static bool DFS(string u, ref Dictionary<string, char> Color, ref Dictionary<string, List<string>> Graph, ref Dictionary<string, string> Parent)
         {
             Color[u] = 'G';
             //Node u is visited but its neighbours not
             foreach (string v in Graph[u])
             {
                 if (Color[v] == 'W')
                 {
                     Parent[v] = u;
                     if (DFS(v, ref Color, ref Graph, ref Parent))
                         return true;
                 }
                 else if (Color[v] == 'G')
                     return true;
             }
             Color[u] = 'B';
             //Node u is visited and finished visiting its neighbours
             return false;
         }
         static bool isCycle(string[] vertices, List<KeyValuePair<string, string>> edges)
         {
 
             Dictionary<string, char> Color = new Dictionary<string, char>();
             Dictionary<string, string> Parent = new Dictionary<string, string>();
             Dictionary<string, List<string>> Graph = new Dictionary<string, List<string>>();
             int j = 0;
             for (int i = 0; i < edges.Count;)
             {
                 if (Graph.ContainsKey(edges[i].Key))
                 {
 
                     Graph[edges[i].Key].Add(edges[i].Value);
                     i++;
                 }
                 else
                 {
                     if ",C-Sharp
"// Nth Catalan Number 
 using System; 
 class CatalanNumber 
 { 
     // A recursive function to find 
     // nth catalan number 
     static int catalan(int n) 
     { 
         int res = 0; 
         
         // Base case 
         if (n <= 1) 
         { 
             return 1; 
         } 
         for (int i = 0; i < n; i++) 
         {
             res += catalan(i) * catalan(n - i - 1); 
         } 
         return res; 
     } 
     
     // Main Function
     public static void Main() 
     { 
         int number;
         Console.Write(""Enter the Number: "");
         number = int.Parse(Console.ReadLine());
         Console.Write(""Nth Catalan numbers are: "");
         // Catalan Numbers
         for (int i = 0; i < number; i++) 
             Console.Write(catalan(i) + "" ""); 
     } 
 } 
 
 /*
 Input:
 Enter the Number: 4
 Output:
 Nth Catalan numbers are: 1 1 2 5
 
 Time Complexity: O(2^n)
 Space Complexity: O(1)
 */
",C-Sharp
"/*
 Binary tree is a data structure that has at most 2 child node i.e. left and right child
 For BFS traversal, we will traverse all nodes level by level. That means first root node
 is traversed, then all the direct children of the root node is traversed.
 Similarly we move to their children and so on.
 */
 #include <bits/stdc++.h>
 using namespace std;
 /*structure of the binary tree*/
 struct Node
 {
     int info;                      //data part
     struct Node *left, *right;     //left and right node which will contain address of left and right subtree
 };
 /*function to create tree*/
 struct Node* create()
 {
     int data;
     Node *tree;
     tree = new Node;
     cout<<""\nEnter data to be inserted or type -1 : "";
     cin>>data;
     //condition for termination
     if(data == -1)
         return 0;
     tree->info=data;
     cout<<""Enter left child of ""<<data;
     tree->left=create();
     cout<<""Enter right child of ""<<data;
     tree->right=create();
     return tree;
 };
 /*
 BFS traversal is similar to the Level Order Traversal. We will travel the
 tree row wise i.e. first row then second and so on.
 So first, we will push root node into the queue,then dequeue(the root node)
 and enqueue all of its children. Print the node that was dequeued
 Then repeat this process until queue becomes empty.
 */
 void BFS_traversal(Node *root)
 {
     if(root == NULL)
         return;
     queue<Node*> q;
     cout<<root->info<<"" "";
     q.push(root);
     while(!q.empty())
     {
         root = q.front();
         q.pop();
         if(root->left)
         {
             cout<<root->left->info<<"" "";
             q.push(root->left);
         }
         if(root->right)
         {
             cout<<root->right->info<<"" "";
             q.push(root->right);
         }
     }
 }
 /*Driver Program*/
 int main()
 {
     Node *root = NULL;
     root = create();
     cout << ""BFS Traversal of the tree is : "";
     BFS_traversal(root);
     return 0;
 }
 /*
 
 Sample Input",C-Plus-Plus
"/*
 Introduction 
 Given a Binary Search Tree ,Check if its a AVL Tree or not
 A BST is said to be a AVL Tree 
 - if difference between heights of its subtrees is atmost 1
 
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 /* Function to create a node with 'value' as the data stored in it. 
  Both the children of this new Node are initially null. */
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to insert a node with given value to the root
 struct Node* insert(struct Node* root,int element) 
 {
     /*If the root is NULL , create a node with given element and assign it to root
     else if the root itself is the node with given data , return 
     else recursively insert it in one of the subtrees accordingly */
     if(root==NULL)
         root = newNode(element);
     else if(root->key < element)
         root->right = insert(root->right,element);
     else if(root->key > element)
         root->left = insert(root->left,element);
     
     return root;
 }
 
 // Function to calculate height of a given Tree recursively
 int Height(struct Node* root)
 {
     /* If root is a NULL node return 0
     else recursively calculate heights of subtrees and get height of the root */
     if(root==NULL)
       return 0;
     else
       return 1 + max( Height(root->left) , Height(root->right) );
 }
 
 //Function to determine whether given Tree is AVL Tree or not
 bool IsAVLTree(struct Node* root)
 {
     /* If heights of subtrees differ atmost by 1 , return True
      else return False */
     if(abs( Height(root->left) - Height(root->right) ) <= 1)
       return true;
     else
       return false;
 }
 
 // Driver code
 int main()
 {
     int n;
     c",C-Plus-Plus
"/*
    This is a simple program in go language to check if a given
    number is armstrong number or not. An armstrong number is
    a number that is equal to the sum of cubes of its individual digits.
    Example : 153 = 1^3+5^3+3^3 = 153!
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 // global variable 
 var number int
 
 // This fuction checks if the given number is armstrong or not
 func check(sum int) {
 
     if(number == sum){
 
        fmt.Print(""This is an Armstrong number "")
 
     }else{
 
         fmt.Print(""This is not Armstrong number"")
     }
 
 }
 
 // This function calculates the sum of cubes of digits 
 func armstrongnumber() {
 
    var sum int
    var n int
    n = number
    sum = 0
    var r int
    r = 0
 
    for n != 0 {
 
       r = n%10
       sum += (r*r*r)
       n = n/10
 
    }
 
    // calling the check function
    check(sum)
 
 }
 
 // driver function
 func main() {
 
    fmt.Print(""Enter the number you want to check for :"")
    // Taking the number as input we need to check
    fmt.Scan(&number)
 
    // calling the armstrong number
    armstrongnumber()
 }
 
 /*
    Simple I/O :
 
    a) Is an armstrong number :
 
    Enter the number you want to check for :153
    This is an Armstrong number
 
    b) Is not an armstrong number :
 
    Enter the number you want to check for :76
    This is not Armstrong number   
 
 */
 
",Go
"
 #include <iostream>
 #include <vector> // for 2D vector
 using namespace std;
 
 //Edit distance Recursive approach
 int edit_distance_recursive (string &x, string &y, int m, int n)
 {
     //base case
     if (m==0) return n;
     if (n==0) return m;
 
     if(x[m-1]==y[n-1]) //if matches
     {
       return edit_distance_recursive(x,y,m-1,n-1);
     }
 
     return 1+min( min(edit_distance_recursive(x,y,m,n-1),edit_distance_recursive(x,y,m-1,n)), edit_distance_recursive(x,y,m-1,n-1));
 
 }
 
 //Edit distance DP approach
 int edit_distance_dp (string &x, string &y)
 {
     int len_x = x.length();
     int len_y = y.length();
 
     vector<vector<int> > dp (len_x+1, vector<int> (len_y+1,0));
     //base case
     //making last row and column of dp array 0
     for(int i=0;i<=len_x;i++)
         dp[i][0]=i;
     for(int j=0;j<=len_y;j++)
         dp[0][j]=j;
 
     for(int i=1;i<=len_x;i++)
     {
         for(int j=1;j<=len_y;j++)
         {
             if(x[i-1]==y[j-1]) //if matches
                 dp[i][j] = dp[i-1][j-1];
             else     //if doesn't match
                 dp[i][j] = 1+min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]));
         }
 
     }
 
     return dp[len_x][len_y];   //return last element
 }
 
 
 int main()
 {
     string str1,str2;
     cout <<""Enter first string: "";
     cin>>str1;
     cout <<""Enter second string: "";
     cin>>str2;
 
     int m=str1.length();
     int n=str2.length();
 
     cout<<""minimum number of edits to convert string1 to string2 Using Recursive approach: "";
     cout<<edit_distance_recursive(str1,str2,m,n)<<endl;
 
     cout<<""minimum number of edits to convert string1 to string2 Using DP approach: "";
     cout<<edit_distance_dp(str1,str2)<<endl;
 }
 
 /*
 working
 input: sunday saturday
 output:3
 */
",C-Plus-Plus
"/*
 * Scheduling a resource among several competing activities 
 * Complexity : O(NLog(N))
 * Given:
 	A single resource
 	A set S of N activities, each with:
 		si = start time of activity i
 		fi = finish time of activity i
 * Required:
     Find max-size of compatible activities
 */
 #include <iostream>
 #include <algorithm>
 
 using namespace std;
 
 struct Activity {
 	int	start;
 	int	end;
 };
 bool sorting(Activity a, Activity b)
 {
 	return (a.end < b.end);
 }
 
 int main() {
 	cout << ""Enter Number of Activities: "";
 	int N;
 	cin >> N;
 	Activity* AllActivities = new Activity[N];
 	for (int i = 0; i < N; i++) {
 		cout << ""Enter Start Time of Activity "" << i + 1 << "": "";
 		int STime; //Start Time
 		cin >> STime;
 		cout << ""Enter Finish Time of Activity "" << i + 1 << "": "";
 		int FTime; //Finish Time;
 		cin >> FTime;
 		AllActivities[i].start = STime;
 		AllActivities[i].end = FTime;
 	}
 	//Sorting activities according to finish time in O(NLog(N))
 	sort(AllActivities, AllActivities + N, sorting);
 	int Size_of_CompatibleActivities = 1;
 	int j = 0;
 	for (int i = 1; i < N; i++) {
 		if (AllActivities[i].start >= AllActivities[j].end)
 		{
 			Size_of_CompatibleActivities++;
 			j = i;
 		}
 	}
 	cout << ""Number of Activities that can fit in on resource: "" << Size_of_CompatibleActivities << endl;
 
 	/*
 	* EX: After Sorting According to Finish Time
 	      Activities: 0 1 2 3 4 5 6  7  8  9  10
 	*     Start Time: 1 3 0 5 3 5 6  8  8  2  12
 	*    Finish Time: 4 5 6 7 8 9 10 11 12 13 14
 	* Output : 4
 	* Activities: 0 3 7 10
 	*/
 	return 0;
 }
",C-Plus-Plus
"""""""
 Python program to find the n-th element from Stern's Diatomic Series
 Stern's diatomic series is the sequence which generates the integer sequence that arises
 in the Calkin-Wilf tree. This sequence can be computed by the fusc function.
 """"""
 
 
 def stern_diatomic_num(n):
     if(n == 0):
         return 0
 
     dp = [0] * (n+1)
 
     dp[1] = 1
     # Traverse and Fill the `dp` array.
     for i in range(2, n+1):
         # If i is even
         if(i % 2 == 0):
             dp[i] = dp[i // 2]
         # If i is odd
         else:
             dp[i] = dp[(i - 1) // 2] + dp[(i + 1) // 2]
     return dp[n]
 
 
 if __name__ == '__main__':
     print(""Enter the value of n(where you need the nth Stern's Diatomic number): "", end="""")
     n = int(input())
     if(n < 0):
         print(""Invalid Value of n !!!"")
         exit()
     res = stern_diatomic_num(n)
     print(""The {}'th Stern's Diatomic is {}."".format(n, res))
 
 
 """"""
 Time Complexity: O(n), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the value of n(where you need the nth Stern's Diatomic number): 258
 The 258'th Stern's Diatomic is 8.
 
 SAMPLE 2
 Enter the value of n(where you need the nth Stern's Diatomic number): -98
 Invalid Value of n !!!
 """"""
",Python
"public class LinearSearch<T>
 {
     public static int Search(T[] array, T element)
     {
         for (int i = 0; i < array.Length; i++)
         {
             if (array[i].Equals(element))
             {
                 return i;
             }
         }
 
         return -1;
     }
 }
 
",C-Sharp
"/*
 
 Problem Statement:
 For a matrix of order n X m, with non-decreasing elements both along rows and columns, 
 A ""successful submatrix for K"" is a square submatrix of A, i.e. a submatrix with n row 
 and n column, for any integer n, such that the average of all the integers in this submatrix is  K.
 Find the number of such possible successful submatrices for given K.
 
 Algorithm:
 1. Preprocess matrix A such that every element in the auxiliary matrix contains the sum of all the elements 
 preceding it (row-wise & column-wise)... ie, aux[i][j] stores sum of elements from (0,0) to (i,j).
 
 2. Thereby, sum of the required submatrix can be found dynamically using : 
 aux(bottom_right) - aux(bottom_left) - aux(top_right) + aux(top_left)
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 typedef long long int ll;
 
 // function to return number of successful submatrix for k
 int successful_submat(ll n, ll m, ll k){
     ll count=0;
     ll mat[n+1][m+1], aux[n+1][m+1], arr[n];
     // pad top & left margins of matrix with zeros
     for (ll i = 0; i <= n; i++)
         mat[i][0] = 0;
     for (ll i = 0; i <= m; i++)
         mat[0][i] = 0;
 
     // input matrix
     cout << ""Enter the matrix of order "" << n << "" X "" << m << endl;
     for (ll i = 1; i <= n; i++)
         for (ll j = 1; j <= m; j++)
             cin >> mat[i][j];
 
     /* build auxiliary matrix */
     // Function to preprocess input mat[n][m]
     // Fills aux[n][m] such that aux[i][j] stores sum of elements from (0,0) to (i,j)
 
     // Copy first row of mat[][] to aux[][]
     for (ll i=0; i<= m; i++)
         aux[0][i] = mat[0][i];
 
     // Do column wise sum
     for (ll i=1; i<= n; i++)
         for (ll j=0; j<= m; j++)
             aux[i][j] = mat[i][j] + aux[i-1][j];
 
     // Do row wise sum
     for (ll i=0; i<=n; i++)
         for (ll j=1; j<=m; j++)
             aux[i][j] += aux[i][j-1];
 
     // dynamically find average of elements of each submatrix
     for(ll order=1;order",C-Plus-Plus
"/*
 C program to find the n'th number in the tribonacci series
 Tribonacci series is a generalization of the Fibonacci sequence, in which the current term is the sum of the previous three terms
 */
 
 #include<stdio.h>
 
 long int find_tribonacci(int n)
 {
     long int dp[n];
     for(int i = 0;i < n ;i++)
     {
         dp[i] = 0;
     }
     dp[2] = 1;
 
     for(int i = 3;i < n; i++)
     {
         dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3];
     }
     return dp[n-1];
 }
 
 
 int main()
 {
     int n, ans;
     printf(""Enter the value of n?, where you need the n'th number in the tribonacci sequence. "");
     scanf(""%d"",&n);
     ans = find_tribonacci(n);
     printf(""The %d'th term in the tribonacci series is %d"", n, ans);
 }
 
 
 /*
 Time Complexity - O(n)
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the value of n?, where you need the n'th number in the tribonacci sequence. 12
 The 12'th term in the tribonacci series is 149.
 
 SAMPLE II
 
 Enter the value of n?, where you need the n'th number in the tribonacci sequence. 23
 The 23'th term in the tribonacci series is 121415
 */
",C
"/*
 Given two strings find out the length of the shortest supersequence formed from the two strings.
 ALGORITHM:
 *The idea is to find out the longest common subsequence first.
 *This subsequence will be present once in both the strings.
 *So on adding the length of the two strings the subsequence will be counted twice.
 *Subtract the length of lcs from both the strings and add once.
 *This gives length of shortest supersequence
 */ 
 
 import java.util.Scanner;
 import java.lang.Math;
 
 public class shortestSuperSeq
 {
     public static int shortestSuperSequence(String x,String y, int n,int m)
     {
         int dp[][]=new int[n+1][m+1];
 
         for(int i=0;i<n+1;i++)
         {
             for(int j=0;j<m+1;j++)
             {
                 if(i==0 || j==0)
                 dp[i][j]=0;
             }
         }
 
         for(int i=1;i<n+1;i++)
         {
             for(int j=1;j<m+1;j++)
             {
                 if(x.charAt(i-1)==y.charAt(j-1))
                 dp[i][j]=1+dp[i-1][j-1];
                 else
                 dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
             }
         }
         return dp[n][m];
     }
 
     public static void main(String args[])
     {
         Scanner s=new Scanner(System.in);
         System.out.println(""Enter two strings: "");
         String x=s.next();
         String y=s.next();
         int n=x.length();
         int m=y.length();
         System.out.println(""The length of the shortest supersequence: ""+(n+m-shortestSuperSequence(x,y,n,m)));
     }
 }
 
 /*
 Time Complexity: O(n*m)
 
 Space complexity: O(n*m)
 
 Input:
 
 Enter two strings: 
 abc
 acd
 
 Output:
 
 The length of the supersequence: 4
 */
",Java
"'''  
 DOUBLE ENDED QUEUE
 Double ended queue or dequeue is a special type of queue 
 wherein elements can be inserted or deleted from both ends
 i.e front and rear
 '''
 
 # to insert an element to the front of double ended queue
 def enqueue_front(n):
     global rear
     global front
     global dequeue
     # If dequeue is not full
     if ((rear + 1) % 10 != front):
         # If dequeue is empty insert as first element
         if front == -1:
             front = 0
             rear = 0
         # decrement front in circular manner and insert
         else:
             front = (front + 9) % 10
         dequeue[front] = n
 
 
 # to insert an element to the rear of double ended queue
 def enqueue_rear(n):
     global rear
     global front
     global dequeue
     if ((rear + 1) % 10 != front):
         if (rear == -1):
 
             front = 0
             rear = 0
         # increment rear in circular manner and insert
         else:
             rear = (rear + 1) % 10
         dequeue[rear] = n
 
 
 # to delete an element and return it from the front of dequeue
 def delete_front():
     global rear
     global front
     global dequeue
     item = -1
     # If dequeue is empty
     if (front == -1):
         return -1
     else:
         item = dequeue[front]
         # if there is only one element
         if (front == rear):
             front = -1
             rear = -1
         else:
             front = (front + 1) % 10
     return item
 
 
 # to delete an element and return it from the rear of dequeue
 def delete_rear():
     global rear
     global front
     global dequeue
     item = -1
     if (rear == -1):
         return -1
     else:
         item = dequeue[rear]
         if (front == rear):
             front = -1
             rear = -1
         else:
             rear = (rear + 9) % 10
     return item
 
 
 # to display the double ended queue from front to rear
 def display():
     global rear
     global front
     global dequeue
     if (f",Python
"/*
 Search for key in row-wise and column-wise sorted matrix
 
 Staircase Search Method:
 
 In a sorted matrix, consider the top right corner. If we go down then the value increases
 and if we go left then the value decreases.
 
 Time Complexity: O(max(n, m))
 Auxiliary Space: O(1)
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void staircase_search(int** a, int n, int m, int key) {
 
 	// int n = sizeof(a) / sizeof(a[0]);
 	// int m = sizeof(a[0]) / sizeof(a[0][0]);
 
 	// Start from top right corner
 	int i = 0, j = m - 1;
 
 	// While we donot find key
 	while (a[i][j] != key) {
 
 		// If curr value is less
 		if (a[i][j] < key) {
 			// that means array value must increase, for that we have to go down
 			i++;
 		}
 
 		// If curr value is greater
 		if (a[i][j] > key) {
 			// that means array value must decrease, for that we have to go down
 			j--;
 		}
 	}
 
 	// If key is found, then print key
 	if (a[i][j] == key) {
 		cout << i << "" "" << j;
 	} else {
 		cout << ""Key not found"";
 	}
 }
 
 
 int main() {
 
 	// Take in input
 	int n, m;
 	cin >> n >> m;
 	int key; cin >> key;
 
 	// Declare 2D Matrix dynamically
 	int** a = new int*[n];
 	for (int i = 0; i < n; i++) {
 		a[i] = new int[m] {0};
 	}
 
 	// Take matrix input
 	for (int i = 0; i < n; i++) {
 		for (int j = 0; j < m; j++) {
 			cin >> a[i][j];
 		}
 	}
 
 	staircase_search(a, n, m, key);
 
 }
 
 /*
 Input:
 4 4
 16
 1 4 8 10
 2 5 9 15
 6 16 18 20
 11 17 19 23
 
 Output:
 2 1
 */
",C-Plus-Plus
"/*
 Given an array nums with n objects colored red, white, or blue,
 sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
 
 We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.
 
 Example 1:
 Input: nums = [2,0,2,1,1,0]
 Output: [0,0,1,1,2,2]
 
 Example 2:
 Input: nums = [2,0,1]
 Output: [0,1,2]
 
 Example 3:
 Input: nums = [0]
 Output: [0]
 
 Example 4:
 Input: nums = [1]
 Output: [1]
 
 Constraints:
 
 n == nums.length
 1 <= n <= 300
 nums[i] is 0, 1, or 2.
 
 link to the problem: https://leetcode.com/problems/sort-colors/
 */
 
 #include <bits/stdc++.h>
 #define MAX 100
 using namespace std;
 
 class Sort_Col {
 	int n;
 	int a[MAX];
   public:
 	void sort_colors(int a[]) {
 		int lo = 0;
 		int hi = n - 1;
 		int mid = 0;
 
 		// Iterate till all the elements
 		// are sorted
 		while (mid <= hi) {
 			switch (a[mid]) {
 
 			// If the element is 0
 			case 0:
 				swap(a[lo++], a[mid++]);
 				break;
 
 			// If the element is 1 .
 			case 1:
 				mid++;
 				break;
 
 			// If the element is 2
 			case 2:
 				swap(a[mid], a[hi--]);
 				break;
 			}
 		}
 	}
 
 	void set_data() {
 		cout << ""Enter number of elements: "" << endl;
 		cin >> n;
 		cout << ""Input Numbers:"" << endl;
 
 		for (int i = 0; i < n; i++) {
 			cin >> a[i];
 		}
 	}
 
 	void display() {
 		sort_colors(a);
 
 		cout << ""["";
 		for (int i = 0; i < n; i++) {
 			cout << a[i] << ""  "";
 		}
 		cout << ""]"";
 	}
 
 };
 
 int main() {
 	Sort_Col sc;
 	sc.set_data();
 	sc.display();
 	return 0;
 }
 
 
 /*
 Complexity Analysis:
 Time Complexity: O(n) as only one traversal of the array is needed.
 Space Complexity: O(1) as no extra space is required.
 
 Example 1:
 Input: nums = [2,0,2,1,1,0]
 Output: [0,0,1,1,2,2]
 
 Example 2:
 Input: nums = [2,0,1]
 Output: [0,1,2]
 
 Example 3:
 Input: nums = [0]
 Output: [0]
 
 Example 4:
 Input: nums = [1]
 Output: [1]
 */
",C-Plus-Plus
"# Double Factorial.
 
 
 def double_fact_i(n):   # iterative implementation
     ans = 1
     for i in range(n, 1, -2):
         ans *= i
     return ans
 
 
 def double_fact_r(n):          # recursive implementation
     if n == 0 or n == 1:       # checking for 1 or 0
         return 1
     return n * double_fact_r(n - 2)
 
 
 if __name__ == ""__main__"":
     n = input(""enter number"")
     print(""Answer using Iterative method: "" + str(double_fact_i(n)))
     print(""Answer using recursive method: "" + str(double_fact_r(n)))
 
 '''
 output:
 enter number4
 Answer using Iterative method: 8
 Answer using recursive method: 8
 enter number5
 Answer using Iterative method: 15
 Answer using recursive method: 15
 Time complexity : O(n) '''
",Python
"package Binary_Tree;
 
 import java.util.Scanner;
 
 public class Binary_Tree {
     private Node root;
     private int size;
     Scanner s=new Scanner(System.in);
     
     public Binary_Tree(){
         root=takeInput(null,false);
     }
 
     public Node takeInput(Node parent,Boolean isleftorright){
         if(parent==null){
             System.out.println(""Enter the value of root node"");
         }
         else {
             if(isleftorright){
                 System.out.println(""enter the value of left child of ""+parent.value);
             }
             else {
                 System.out.println(""enter the value of right child ""+parent.value);
             }
         }
         int value=s.nextInt();
         Node node=new Node(value,null,null);
         boolean choice;
         System.out.println(""Do you have left child of ""+node.value);
         choice=s.nextBoolean();
         if(choice){
             node.left=takeInput(node,true);
         }
 
         System.out.println(""Do you have right child of ""+node.value);
         choice=s.nextBoolean();
         if(choice){
             node.right=takeInput(node,false);
         }
         return node;
     }
 
     public void preOrder() {
 
         preOrder(root);
     }
 
     private void preOrder(Node node) {
         if (node == null) {
             return;
         }
         System.out.print(node.value + "","");
         preOrder(node.left);
         preOrder(node.right);
     }
     
     private class Node{
         private Node left;
         private Node right;
         private int value;
 
         private Node(int value, Node left, Node right){
             this.value=value;
             this.left=left;
             this.right=right;
         }
     }
 }",Java
"//function to make pattern table to store when sub-patterns in given pattern repeat
 function makePatternTable(pattern) {
   const patternTable = [];
   let prefIndex = 0,
     sufIndex = 1;
 
   while (sufIndex < pattern.length) {
     if (pattern[prefIndex] === pattern[sufIndex]) {
       //found a match in sub-pattern, store index+1
       patternTable[sufIndex] = prefIndex + 1;
       sufIndex++;
       prefIndex++;
     } else if (prefIndex === 0) {
       patternTable[sufIndex] = 0;
       sufIndex += 1;
     } else {
       prefIndex = patternTable[prefIndex - 1];
     }
   }
 
   //return the pattern table made to find the pattern's occurrence
   return patternTable;
 }
 
 function kmpSearch(text, pattern) {
   if (pattern.length === 0) {
     return 0;
   }
 
   const patTable = makePatternTable(pattern);
   let textIndex = 0,
     patIndex = 0;
 
   while (textIndex < text.length) {
     if (text[textIndex] === pattern[patIndex]) {
       // We've found a match.
       if (patIndex === pattern.length - 1) {
         return textIndex - pattern.length + 1;
       }
       patIndex++;
       textIndex++;
     } else if (patIndex > 0) {
       patIndex = patTable[patIndex - 1];
     } else {
       patIndex = 0;
       textIndex++;
     }
   }
 
   return -1;
 }
 
 result = kmpSearch(""hakincodes"", ""kin"");
 if (result === -1) {
   console.log(""Pattern is not present in the text."");
 } else {
   console.log(`Pattern is present in text at index ${result}`);
 }
 
 /*
 Output for above sample input:
 Pattern is present in text at index 2
 
 Time complexity = O(m+n)
 Space complexity = O(n)
 m = number of characters in text
 n = number of characters in pattern
 */
",JavaScript
"""""""
 Purpose: Given a binary matrix of N*M order where 0 is the wall and 1 is way.
         Find the shortest distance from a source cell to a destination cell,
         traversing through limited cells only. Also you can move only
         up, down, left and right. If found then print the distance and
         path in separate lines, else return -1.
 
 """"""
 from collections import deque
 
 
 # Main BFS function to find the path
 def BFS(maze, src, des, way=1):
 
     # Base case: is source has no way, return false
     if maze[src[0]][src[1]] != way:
         return False
 
     # Dimeention of the matrix and a queue is initlized with the source vertex
     n = len(maze)
     m = len(maze[0])
     queue = deque([(src[0], src[1], 0)])
 
     # To keep a track of the visdited nodes and parents
     visited = [[False] * m for i in range(n)]
     parent = {}
 
     # All possible moves from a cell
     move = {(1, 0): 'D', (-1, 0): 'U', (0, 1): 'R', (0, -1): 'L'}
 
     while queue:
 
         # Extract the left most node from the queue
         v = queue.popleft()
 
         # If the node is destination, calculate the path and return
         if (v[0], v[1]) == des:
             path = ''
             dis = v[2]
             cur = (v[0], v[1])
 
             # Calculate the path by backtracking with the parent dict
             while cur != src:
                 prev_move = parent[cur]
                 m = (cur[0] - prev_move[0], cur[1] - prev_move[1])
                 path += move[m]
                 cur = prev_move
 
             # Return the distance and path
             return dis, path[::-1]
 
         # For a given node check each possible move
         for i in move.keys():
             r = v[0] + i[0]
             c = v[1] + i[1]
 
             # If the next node inside the maze , has a way and not yet visited
             # then mark it visited and push it in the queue
             if 0 <= r < n and 0 <= c < m and maze[r][c] == way and not visited[r][c]:
   ",Python
"let number = 1234567;
 
 // Iterative Method
 function countDigitsIterative(num) {
   let digits = 0;
   while (num) {
     // This condition becomes false when num becomes 0(zero)
     digits++;
     num = parseInt(num / 10);
     // Here, parseInt method is used to convert divided decimal number to integer, e.g. 126/10 = 12.6, parseInt(12.6) = 12
   }
   return digits;
 }
 
 console.log(countDigitsIterative(number)); // Output : 7
 
 // Recursive Method
 function countDigitsRecursive(num) {
   if (num === 0) {
     return 0;
   }
   return 1 + countDigitsRecursive(parseInt(num / 10));
 }
 
 console.log(countDigitsRecursive(number)); // Output : 7
 
 // String Method
 let strNum = number.toString(); // convert number to string , 1234 -> ""1234""
 
 console.log(strNum.length); // Output : 7
 
 // Logarithm Approach
 let logNum = 1 + Math.floor(Math.log10(number));
 
 console.log(logNum); // Output : 7
 
 // Not very useful but still a working approach
 let numArr = strNum.split(""""); // splitting a string and converting it into an Array , ""1234"" -> [""1"", ""2"", ""3"", ""4""]
 
 console.log(numArr.length); // Output : 7
",JavaScript
"/*
 
 A queue is a linear data structure that follows the First in, First out principle (i.e. the first added elements are removed first).
 Generally, a queue is implemented using Linked List but other approach can be used i.e using two stacks.
 Below is the implementation of a queue using a Two Stacks.
 
 In this program, the user can provide a choice to perform operations on a Queue. It is created using an ES6 class syntax. 
 prompt & colors are node packages for taking user input and displaying text in different colors respectively. 
 
 */
 
 const prompt = require(""prompt-sync"")({ sigint: true });
 const colors = require(""colors"");
 
 // Setting the Color schema
 colors.setTheme({
   display: ""green"",
   insert: ""white"",
   delete: ""red"",
   leave: ""yellow"",
   end: ""rainbow"",
   wrong: ""america"",
 });
 
 // Creating the node class to create nodes
 class Node {
   constructor(value, next = null) {
     this.value = value;
     this.next = next;
   }
 }
 
 // Creating stack class
 class Stack {
   constructor() {
     this.first = null;
     this.last = null;
     this.length = 0;
   }
 
   // Add element at the end operation in stack
   push(value, decode) {
     let newNode;
     if (decode) newNode = value;
     else newNode = new Node(value);
 
     if (this.length === 0) {
       this.first = newNode;
       this.last = newNode;
     } else {
       const temp = this.first;
       this.first = newNode;
       this.first.next = temp;
     }
 
     this.length++;
     return this.length;
   }
 
   // Delete the very last element in the stack
   pop() {
     if (this.length === 0) return null;
     const temp = this.first;
 
     if (this.first === this.last) {
       this.first = null;
       this.last = null;
     } else {
       this.first = this.first.next;
     }
 
     temp.next = null;
     this.length--;
     return temp;
   }
 }
 
 // Creating a Queue class to perform operations
 class Queue {
   constructor() {
     // Instantiating the First stack",JavaScript
"// C++ program to implement Pigeon Hole  Sort
 
 #include <bits/stdc++.h>
 using namespace std;
 
 struct LargestAndSmallest
 {
     int largest;
     int smallest;
 };
 
 //To find the largest and Smallest elements in an array with minimum comparisons
 struct LargestAndSmallest find_max_min_elements(int arr[], int n)
 {
     struct LargestAndSmallest pair;
     int i;
     //If there is only one element
     if (n % 2 == 1)
     {
         pair.smallest = arr[0];
         pair.largest = arr[0];
         i = 1;
     }
     else //Else If there is more than one element
     {
         if (arr[0] > arr[1])
         {
             pair.smallest = arr[1];
             pair.largest = arr[0];
         }
         else
         {
             pair.smallest = arr[0];
             pair.largest = arr[1];
         }
         i = 2;
     }
 
     while (i < n - 1)
     {
         if (arr[i] > arr[i + 1])
         {
             if (arr[i] > pair.largest)
                 pair.largest = arr[i];
 
             if (arr[i + 1] < pair.smallest)
                 pair.smallest = arr[i + 1];
         }
         else
         {
             if (arr[i + 1] > pair.largest)
                 pair.largest = arr[i + 1];
 
             if (arr[i] < pair.smallest)
                 pair.smallest = arr[i];
         }
         i = i + 2;
     }
     return pair;
 }
 
 // Pigeon hole sort
 void pigeon_hole_sort(int arr[], int n)
 {
     LargestAndSmallest pair = find_max_min_elements(arr, n);
 
     // Find statistical range of the given array
     int range = pair.largest - pair.smallest + 1;
 
     // Declare an array with the size of the range.
     int holes[range];
 
     memset(holes, 0, sizeof(holes)); //Initialize the new array with value 0.
 
     //Filling the 'holes' array with the input array values
     for (int j = 0; j < n; j++)
         holes[arr[j] - pair.smallest]++;
 
     // Put the elements back into the array in ascending occurence order.
     int j = 0;
     for (int i = 0; i ",C-Plus-Plus
"/**
  * Nodes are the ""elements"" of a linked list.
  * They are represented as objects here to include the ""next node"" property
  */
 class Node {
   constructor(data) {
     this.data = data;
     this.next = null;
   }
 }
 
 /**
  * With nodes defined, we can create a LinkedList class
  * that will use nodes to instantiate LinkedList objects.
  */
 class LinkedList {
   // TODO: Re-implement the constructor to receive an array, and then convert it to a LinkedList.
   constructor(head = null) {
     this.head = head;
   }
 
   size() {
     let count = 0;
     let node = this.head;
     while (node) {
       count++;
       node = node.next;
     }
     return count;
   }
 
   clear() {
     this.head = null;
   }
 
   getLast() {
     let lastNode = this.head;
     if (lastNode) {
       while (lastNode.next) {
         lastNode = lastNode.next;
       }
     }
     return lastNode;
   }
 
   getFirst() {
     return this.head;
   }
 }
 
 // Just a simple implementation of the Linked List
 
 // First, we define the values.
 const arr = [0, 1, 2, 3, 4];
 
 // Second, we create the nodes.
 const firstNode = new Node(arr[0]);
 const secondNode = new Node(arr[1]);
 const thirdNode = new Node(arr[2]);
 const fourthNode = new Node(arr[3]);
 const fifthNode = new Node(arr[4]);
 
 // Third, we establish the linking between nodes.
 firstNode.next = secondNode;
 secondNode.next = thirdNode;
 thirdNode.next = fourthNode;
 fourthNode.next = fifthNode;
 
 // Fourth, we instantiate a LinkedList only using the first node (head).
 const linkedList = new LinkedList(firstNode);
 
 // Calling some Linked List methods.
 console.log(""After populating the linked list:"");
 console.log(""First node: "", linkedList.getFirst());
 console.log(""Last node: "", linkedList.getLast());
 console.log(""List size: "", linkedList.size());
 
 // Clearing linked list
 console.log(""\nAfter clearing the list:"");
 linkedList.clear();
 console.log(""First node: "", linkedList.getFirst());
 console.log(""Last node",JavaScript
"/*
 Given two linked lists: list1 and list2 of sizes l1 and l2 respectively.
 We need to remove list1's nodes from the ath node to the bth node, and put list2 in their place.
 
 SAMPLE INPUT:
 list1 = [0,1,2,3,4,5,6]
 a = 3, b = 4
 list2 = [100,101,102]
 
 SAMPLE OUTPUT:
 [0,1,2,100,101,102,5]
 
 Here [3,4,5] in list1 is removed and list2 is inserted in place of that.
 
 */
 
 import java.util.*;
 import java.io.*;
 class LinkedList
 {
 
 static ListNode list1,list2;
 
 public static class ListNode {
    int data;
    ListNode next;
    ListNode() {}
    ListNode(int data) { this.data = data; }
    ListNode(int data, ListNode next) { this.data= data; this.next = next; }
  }
   
   
   public static void insertNode(ListNode list, int data)
   {
   	ListNode n=new ListNode(data,null);//new node
     ListNode head=list;
   	if(head==null)
   		head=n;
     else
     {
     	ListNode ptr=list;
     	while(ptr.next!=null)//traverse till last existing node
     		ptr=ptr.next;
 
     	ptr.next=n;
     }
   }
 
   public static ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {
         ListNode temp=list1;
         ListNode a1=null;
         ListNode b1=null;
         int c=0;
         while(temp!=null)
         {
             if(c==a-1)
                 a1=temp;//node right before ath position
             if(c==b+1)
                 b1=temp;//node right after bth position
             temp=temp.next;
             c++;//stores the total number of nodes in list1
         }
         temp=list1;
         a1.next=list2;//list2 is connected to node right before ath position in list1
         while(list2.next!=null)//traversing to end of list2
         {
             list2=list2.next;
         }
         list2.next=b1;//last node of list2 is connected to the node right after bth position in list1
         
         return list1;
     }
 
     public static void printLinkedList(ListNode head)
     {
     	ListNode ptr=head;
     	while(ptr.next!=null)
     ",Java
"/*
 *  Gnome Sort or Stupid Sort is a sorting algorithm that arranges all the elements in their correct positions
 *  by means of a series of swaps in a single loop.
 *
 *  A run thorugh of the numbers is conducted, comparing each of the current numbers (initially
 *  the second element) to the number before them.
 *		If numbers are not in order,
 *			Numbers are swapped
 *			Move back to compare previous pair of numbers
 *			If no previous number, move to next number
 *		Else if numbers are in order,
 *			Move to next number
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 /* Takes integer array and size as input and sorts the array as per afore-mentioned method */
 void gnome_sort(int* array, int size)
 {
 	int index = 0;
 	while (index < size) 
 	{
 		if (index == 0 || array[index] >= array[index - 1])	
 			++index;
 		else {
 			int temp = array[index];
 			array[index] = array[index - 1];
 			array[index - 1] = temp;
 			--index;
 		}
 	}
 }
 /* In the main function, inputs from user are read, gnome_sort() is invoked and output is printed */ 
 int main()
 {
 	int size, index;
 	printf(""How many numbers are to be sorted? "");
 	scanf(""%d"", &size);
 	int* array = (int*)malloc(sizeof(int) * size);	
 	printf(""Enter the numbers to be sorted: \n"");
 	for (index = 0; index < size; ++index) {
 		scanf(""%d"", &array[index]);
 	}
 	
 	gnome_sort(array, size);
 	
 	printf(""Numbers after sorting: \n"");
 	for (index = 0; index < size; ++index) {
 		printf(""%d "", array[index]);
 	}	
 	printf(""\n\n"");
 	return 0;
 }
 /*
                   [Sample I/O]
 	How many numbers are to be sorted? 6
 	Enter the numbers to be sorted:
 	91 87 75 1 3 108
 	Numbers after sorting:
 	1 3 75 87 91 108
                 [Complexities]
 	Time Complexity  : O(n^2)
 	Space Complexity : O(1)
 */
",C
"/*
 Given an array of numbers find the next greater element to the left of each element.
 ALGORITHM:
 *Using Stack class in Java, the problem can be solved in O(n) complexity
 */
 import java.lang.Scanner;
 import java.util.Stack;
 
 public class NextGreaterElement
 {
     public static void nextGreaterElementToLeft(int a[],int n)
     {
         Stack<Integer> st=new Stack<>();
         int v[]=new int[n];
         for(int i=0;i<n;i++)
         {
             if(st.empty())
             v[i]=-1;
             else if(st.empty()!=true && st.top()>a[i])
             v[i]=st.top();
             else if(st.empty()!=true && st.top()<=a[i])
             {
                 while(st.empty()!=true && st.top()<=a[i])
                 st.pop();
                 if(st.empty())
                 v[i]=-1;
                 else if(st.top()>a[i])
                 v[i]=st.top();
             }
         }
         for(int i=0;i<n;i++)
         System.out.print(v[i]+"" "");
     }
 
     public static void main(String args[])
     {
         Scanner s=new Scanner(System.in);
         System.out.println(""Enter the size of the array: "");
         int n=s.nextInt(System.in);
         System.out.println(""Enter the elements: "");
         int a[]=new int[n];
         for(int i=0;i<n;i++)
         a[i]=s.nextInt();
         nextGreaterElementToLeft(a,n);        
     }
 }
 
 /*
 Time Complexity: O(n)
 
 Space Complexity: O(n)
 
 Input:
 
 Enter the size of the array: 
 5
 Enter the elements:
 9 3 7 1 0
 
 Output:
 
 -1 9 9 7 1
 */",Java
"/* Below code is an implementation of Vigenere Cipher in Java.
 It is a form of substitution cipher. Given a plaintext and a key.
 If the length of key is smaller than that of plaintext, then we 
 repeat the contents of the key in a circular fashion till both of
 their lengths is same. Plaintext and key are converted to number 
 [0-25] and then each character of plaintext is shifted by character
 present at the same index in the key to form the encrypted message.*/
 
 import java.util.*;
 import java.lang.*;
 
 public class VigenereCipher {
 
 	/*This method generates the key if the length of key
 	is shorter than the length of the plaintext.*/
 	static String generateKey(String key, int size) {
 
 		int i = 0;
 		/*In a circular fashion, we add the contents of
 		the key from front to the end, till the length of
 		the key becomes equal to the length of the plaintext.*/
 		while(i < size) {
 			if(i == size) {
 				i = 0;
 			}
 			if(key.length() == size) {
 				break;
 			}
 			key += key.charAt(i);
 			i = i + 1;
 		}
 		// Return the final key to be used
 		return key;
 	}
 
 	// This method generates the cipher text
 	static String generateCipher(String plaintext, String key) {
 		
 		/* Calling the above function to ensure that the length
 		of the key is same as length of the plaintext*/
 		String keyUpdated = generateKey(key, plaintext.length());
 		String ciphertext = new String("""");
 
 		// Shifting the plaintext to generate the ciphertext
 		for(int i = 0; i < plaintext.length(); i++) {
 			int temp = 0;
 			temp = (plaintext.charAt(i) - 97) + (keyUpdated.charAt(i) - 97);
 			temp = temp % 26;
 			temp = temp + 97;
 			ciphertext += (char) temp;
 		}
 		// Returns the ciphertext
 		return ciphertext;
 	}
 
 	/* This method formats the ciphertext according to the plaintext.
 	From the encrypt function above, we send plaintext in lowercase.
 	So, the ciphertext we get is also in all lowercase. Here, we format
 	the ciphertext so that wherever there is capi",Java
"
 # Reference from GeeksForGeeks
 '''
 Lucas Theorem : 
 Lucas' theorem is a result about binomial coefficients modulo a prime p.
 We will be given three numbers n, r and p and we need to compute value of nCr mod p.
 Excample 1:
 Q.) : Find the remainder when 1000C300 is divided by 13.
 Sol : First we write 1000 and 300 in terms of the sum of power of 13
              1000 = 5(13^2) + 11(13) + 12 
               300 = 1(13^2) + 10(13) + 1
         Then apply Lucas Theorem:
                                 1000C300 = (5C1) * (11C10) * (12C1)
                                          = 5 * 11 * 12
                                          = 5 *(-2) * (-1) 
                                          = 10
 Example 2:
 Input:  n = 10, r = 2, p = 13
 Output: 6
 '''
 '''defining the modulo function.'''
 def Mod(n, r, p): 
     arr = [0] * (n + 1);   
            #The array arr is going to store the
            # last row of the triangle 
            # at the end. And last entry  
            # of last row is nCr 
     arr[0] = 1;    
     for i in range(1, (n + 1)):       
         j = min(i, r);  
         while(j > 0): 
             arr[j] = (arr[j] + arr[j - 1]) % p; 
             j -= 1; 
     return arr[r]; 
 ###################################################
 '''
 calculate the last digit of n and r for base p, 
 then recur 
 the remaining digits 
 '''
 def Lucas(n, r, p): 
     if (r == 0):
         return 1;  
     nth = int(n % p); 
     rth = int(r % p);            
     return (Lucas(int(n / p), int(r / p), p) * Mod(nth, rth, p)) % p; 
 ########################################################################
 n = int(input(""Enter The Value of n : ""))
 r = int(input(""Enter The Value of r : ""))
 p = int(input(""Enter The Value of p : ""))
 print(""Value of nCr % p is"",Lucas(n, r, p)); 
 
 '''
   Time Complexity : O(P^2)
   Space Complexity : O(P)
 '''
",Python
"/*
 	==============================================================
 			Implementing QUEUE using STACK data structure
 	==============================================================
 	  queue can be implemented in two ways:
 
 	  1 -> By making enQueue() operation costly :
 		This method push the new element at the top of enQueueStack,
 		so that deQueue operation just pops from enQueueStack.
 		To put the element at top of enQueueStack, deQueueStack is used.
 
 	  2 -> By making deQueue() operation costly :
 		In this method, in en-queue operation, the new element is entered at the top of enQueueStack.
 		In de-queue operation, all the elements of enQueueStack are moved to deQueueStack and top of deQueueStack is returned.
 		finally all the elements of deQueueStack are moved to enQueueStack
 
 	This program uses second way
 
 */
 
 package main
 
 import (
 	""fmt""
 )
 
 // LENGTH of every Stack and Queue in this program
 const LENGTH int = 10
 
 // STACK user-definded data type to hold the variables for our stack data structure
 type STACK struct {
 	top   int
 	array [LENGTH]int
 }
 
 // init(): this will initialize the stack for use
 func (stack *STACK) initStack() {
 	stack.top = -1
 }
 
 // isEmpty(): this checks if stack is empty or not
 func (stack *STACK) isEmpty() bool {
 	if stack.top < 0 {
 		return true
 	}
 	return false
 }
 
 // isFull(): this checks if stack is full or not
 func (stack *STACK) isFull() bool {
 	if stack.top >= LENGTH-1 {
 		return true
 	}
 	return false
 }
 
 // push(): this will push the value to the top of the stack
 func (stack *STACK) push(value int) {
 	if stack.isFull() {
 		fmt.Println(""Stack is Full"")
 	} else {
 		stack.top++
 		stack.array[stack.top] = value
 
 	}
 }
 
 // pop(): this will remove the value from the top of the stack
 func (stack *STACK) pop() int {
 	var data int
 	if stack.isEmpty() {
 		fmt.Println(""Stack is empty"")
 	} else {
 		data = stack.array[stack.top]
 		stack.top--
 
 	}
 
 	return data
 }
 
 // ",Go
"/*
 
 Introduction 
 Given a Binary Tree , Find its height without using recursion.
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 Function returns the height of the tree 
 
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Function to find Height of Binary Tree without using recursion
 int FindHeightNonRecursive(struct Node* root)
 {
     //kepp counting levels , and finally return total no.of levels
     //Initialise level as 0
     int level=0;
     // If ",C-Plus-Plus
"/*
 In this algorithm we keep halving one number and doubling the 2nd one.
 While halving, if we get an odd number, we add the 2nd doubled number to the result.
 This goes on until the halving makes the first reach 0
 It is also known as the Ancient Egyptian Multiplication, used by scribes to do multiplication
 without using the multiplication table.
  */
 
 const findProduct = (num1, num2) => {
   if (typeof num1 != ""number"" || typeof num2 != ""number"") {
     return ""N/A"";
   }
 
   let result = 0;
 
   // running the loop as long as 2nd number is greater than 0
   while (num2 > 0) {
     // if 2nd becomes odd, we add whatever value of num1
     // we have to result
     if ((num2 & 1) !== 0) {
       result += num1;
     }
 
     // double first and halve the second
     num1 = num1 << 1;
     num2 = num2 >> 1;
   }
 
   return result;
 };
 
 var product1 = findProduct(1328, 596);
 var product2 = findProduct(""hello"", 96);
 console.log(""Product 1:"" + product1);
 console.log(""Product 2:"" + product2);
 
 /*
 Output for above sample input:
 Product 1:791488
 Product 2:N/A
 Time complexity = O(1)
 */
",JavaScript
"/*
 Given two sequences, find the length of longest subsequence present in both of them.
 A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.
 */
 
 #include <iostream>
 #include <vector> // for 2D vector
 using namespace std;
 
 int lowest_common_subsequence(string &x, string &y)
 {
     int len_x = x.length();
     int len_y = y.length();
 
     vector<vector<int> > dp (len_x+1, vector<int> (len_y+1,0));
 
     for(int i=1;i<=len_x;i++)
     {
         for(int j=1;j<=len_y;j++)
         {
             int q=0;
 
             if(x[i-1]==y[j-1]) //if matches
                 q=1+dp[i-1][j-1];
             else     //if doesn't match
                 q=max(dp[i-1][j],dp[i][j-1]);
 
         dp[i][j]=q;
         }
     }
 
     return dp[len_x][len_y]; //return last element
 }
 
 int main()
 {
     string str1,str2;
     cout<<""Enter string1 and string2: "";
     cin>>str1>>str2;
     cout<<""output : ""<<lowest_common_subsequence(str1,str2)<<endl;
 }
 
 /*
    Enter string1 and string2 : ABCDEFGH BDHCEG
    output : 4
 */
 
 // Time and Space complexity : O(mn), where m = length of string1 and n = length of string2
",C-Plus-Plus
"/*Keyword cipher is a form of monoalphabetic substitution, where a keyword is used as the key. Now
   a encryption is formed of alphabets from [a-z] such that the first part of encrption contains 
   unique letters of the keyword and the rest are the remaining alphabets from [a-z]. That is,
   until the keyword is used up, whereupon the rest of the ciphertext letters are used in alphabetical 
   order, excluding those already used in the key.*/
 
 import java.util.*;
 
 public class KeyWord{
    
    //This function builds the encoder based on the key given as input
    static String encoder(char[] key){
        
         String str = """";
         int[] array = new int[26];
 
         for(int k=0;k<26;k++){
             array[k] = 0;  
         }
         
         //Iterating the key and building the encoder
         for(int i=0;i<key.length;i++){
           if(key[i] != ' '){
             if(array[key[i]-97] == 0){
                  str += key[i];
                  array[key[i]-97] = 1;                     
             }
           }
         }
          
         //Adding the remaining alphabetics
         for(int i=0;i<26;i++){
           if(array[i] == 0){
              array[i] = 1;
              str += (char)(i+97);
           }
         }
         
         return str;
    }
   
    //We cipher the text in this function
    static void cipher(String plaintext,String keyencoder){
 
         String output="""";
         char space = ' ';
         char[] message = plaintext.toCharArray();        
        
         /*for every letter in the plaintext we replace it with
           the corresponding letter in the encoded string we use*/  
         for(int i=0;i<message.length;i++){
           if(message[i] == space)
              //adding the space if input has one
              output += message[i];
           else 
              output += keyencoder.charAt(message[i]-97);
         } 
         
         //printing the cipher text 
         System.out.println(""The ",Java
"/* Find a Median of two Sorted arrays of equal size. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function to find Median of two Sorted array of equal size */
 int solve()
 {
     /* Input n1 = size of array 1
        Input n2 = size of array 2 */
     int n1,n2;
     cin >> n1 >> n2;
 
     int arr1[n1],arr2[n2];
 
     /* Input values in array 1 */
     for (int i = 0; i < n1; ++i)
     {
         cin >> arr1[i];
     }
 
     /* Input values in array 2 */
     for (int i = 0; i < n2; ++i)
     {
         cin >> arr2[i];
     }
 
     /* Create a vector */
     vector<int> v;
 
     /* Push array 1 element in vector */
     for (int i = 0; i < n1; ++i)
     {
         v.push_back(arr1[i]);
     }
 
     /* Push array 2 element in vector */
     for (int i = 0; i < n2; ++i)
     {
         v.push_back(arr2[i]);
     }
 
     /* Sort the given vector */
     sort(v.begin(), v.end());
     
     /* Find medina using this formula */
     int mid = (v[v.size()/2 - 1] + v[v.size()/2]) / 2;
     
     /* Return Calculated median */
     return mid;
 }
 
 int main()
 {
     int Median = solve();
 
     cout << ""Median is : "" << Median <<endl;
     return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
         5 5
         1 12 15 26 38
         2 13 17 30 45
         
 
     Output 1 :
 
         Median is : 16
 
     Input 2 :
 
         5 5
         1 2 3 4 5
         6 7 8 9 10
     
     Output 2 :
     
         Median is : 5
     
     Time complexity: O(nlogn)
     Space Complexity: O(n)
 */
",C-Plus-Plus
"/*In Vernam cipher(also known as the One-Time Pad), the length of the plaintext, ciphertext, and key is the same.
   Below is an implementation of Vernam cipher in the C language.*/
 
 /*Basically, here the ith letter of the cipher text is fomred by shifting the ith letter of the plaintext with 
  * the ith letter of key.
  * */
 
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 
 //This defines the maximum length of the string in which we want to perform encrypt and decrypt operations.
 #define LENGTH_MAX 100 
 
 // This is the decrypt function which takes ciphertext and key as input
 char *decrypt(char *ciphertext, char *key) { 
 
 	static char decrypted[LENGTH_MAX];
 
 	for(int i = 0; i < strlen(key); i++) {
 
 		//Convert the character to ASCII
 		int ct = ciphertext[i] - 0;
 
 		ct -= 65;
 		//We number alphabets as A-0, B-1, ..... , Z-25. So, 
 		//We shift the obtained ASCII value by 65.	
 
 		//We perform similar steps for the key.
 		int k = key[i] - 0;
 		k -= 65;
 		
 		//The plaintext is obtained by shifting the ciphertext backwards by the key
 		int pt = ct - k;
 		
 		//If the value goes below 0, we add 26 to it, as number of cycle doesn't matter
 		//Since, at last we take mod by 26.	
 		while(pt < 0) {
 			pt += 26;
 		}
 
 		pt = pt % 26;
 		
 		//We add back 65 to convert it back to ASCII and then to char
 		pt += 65;
 
 		char plaintext = pt;
 
 		decrypted[i] = plaintext;
 	}
 	//Return the decrypted message	
 	return decrypted;	
 }
 
 // This is the encrypt function which takes plaintext and key as input
 char* encrypt(char *plaintext, char *key) { 
 
 	static char encrypted[LENGTH_MAX];
 
 	for(int i = 0; i < strlen(key); i++) {
 	
 		//Convert the character to ASCII
 		int pt = plaintext[i] - 0;
 
 		//We number alphabets as A-0, B-1, ..... , Z-25. So, 
 		//We shift the obtained ASCII value by 65.
 		pt -= 65;
 
 		//We perform similar steps for the key.
 		int k = key[i] - 0;
 		k -= 65;
 
 		//The ciphertext is obtained by shi",C
"/*
 It's an 0_N knapsack problem. In
 which, Given two integer arrays 
 val[0..n-1] and wt[0..n-1] which
 represent values and weights ass
 -ociated with n items respectively.
 Also given an integer cap which 
 represents knapsack capacity, find
 out the maximum value subset of 
 val[] such that sum of the weights
 of this subset is smaller than or
 equal to cap. You cannot break an 
 item, either pick the complete item,
 or dont pick it (0-1 property).You
 can pick an element more than once.
 Note: Maximum value subset means the 
 subset with maximum sum of all the 
 values in subset.
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 #define ll long long int
 
 ll dp[1000] = {
     0
 };
 ll Zero_N_Knapsack(ll cap,
     ll val[], ll W[], ll n)
 {
     for (ll i = 0; i <= cap; i++) {
         for (ll j = 0; j < n; j++) {
             if (val[j] <= i) {
                 dp[i] = max(dp[i], dp[i - val[j]] + W[j]);
             }
         }
     }
     return dp[cap];
 }
 
 int main()
 {
     ll n, cap, i, j;
     cin >> n >> cap;
     ll val[n];
     for (i = 0; i < n; i++)
         cin >> val[i];
     ll wt[n];
     for (i = 0; i < n; i++)
         cin >> wt[i];
     std::map<ll, ll> A;
     for (i = 0; i < n; i++) {
         map<ll, ll>::iterator M = A.find(val[i]);
         if (M != A.end()) {
             if (M->second < wt[i])
                 M->second = wt[i];
         }
         else {
             A.insert(make_pair(val[i], wt[i]));
         }
     }
     ll T = A.size();
     i = 0;
     cout << Zero_N_Knapsack(cap, val, wt, n);
     return 0;
 }
 
 /*
 TimeComplexity=O(n*W)
 Auxiliary Space=O(W)
 n=No. of Items
 W=Capacity of Knapsack
 Sample Input
 5 11
 3 2 4 5 1
 4 3 5 6 1
 Sample Output
 16
 */
 
",C-Plus-Plus
"// C code for maximum water Container
 
 #include<stdio.h>
 int maxArea(int[], int);
 
 // function to find the maximum Area
 int maxArea(int A[], int length) {
   int start = 0;
   int end = length - 1;
   int area = 0;
   int min;
   while (start < end) {
     // Calculating the max area 
     if (A[start] < A[end]) {
       min = A[start];
     } else {
       min = A[end];
     }
     int t = end - start;
     if (area < (min * t)) {
       area = min * t;
     }
 
     if (A[start] < A[end])
       start += 1;
 
     else
       end -= 1;
   }
   return area;
 
 }
 //driver code to check above function
 int main() {
   int size1, size2; 
   printf(""Input-->"");
   printf(""Enter the a size : \n"");
   scanf(""%d"", & size1);
   printf(""Enter the b size :\n"");
   scanf(""%d"", & size2);
   int a[size1],b[size2];
   printf(""Enter the elements of a container :\n"");
   for (int i = 0; i < size1; i++) {
     scanf(""%d"", & a[i]);
   }
   printf(""Enter the elements of b container\n"");
   for (int i = 0; i < size2; i++) {
     scanf(""%d"", & b[i]);
   }
   int A = maxArea(a, size1);
   int B = maxArea(b, size2);
   printf(""Output-->\n"");
   if (A > B) {
     printf(""Container a contain more water i.e %d\n"", A);
   } else {
     printf(""Container b contain more water i.e %d\n"", B);
   }
   return 0;
 }
 
 /*
  Input-->
  Enter the a size : 4
  Enter the b size : 5
  Enter the elements of a container :
  1 5 4 3
  Enter the elements of b container :
  3 2 1 4 5
  Output-->
  Container b contain more water i.e 12
 
  Time Compelxity: O(n).
  As only one traversal of the array is required, so time complexity is O(n) where n is size of array.
  Space Complexity: O(1).
  No extra space is required, so space complexity is constant
 */
",C
"/* Find first and last positions of an element in a sorted array
 
 ALGORITHM: 
 * Take n = array size and element by user input
 * Take first = store first positions of an element and last = store last positions of an element
 * For finding first positions of an element
    * First_positions:
       int i,first=-1
       for i=0 to i<n
         if a[i]==element
            first = i
            break
       return first
    ** here first stored 1st index of an element
 * For finding last positions of an element
    * Last_positions:
       int i,last=-1
       for i=n-1 to i>=0
         if a[i]==element
            last = i
            break
       return last
    ** here last stored last index of an element
 * print first and last.
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //Finding first positions of an element
 int First_positions(int a[],int n,int element)
 {
     int i,first=-1;
     for(i=0;i<n;i++)
     {
         if(a[i]==element)
         {
            first = i;
            break;
         }
     }
     return first;
 }
 
 //Finding last positions of an element
 int Last_positions(int a[],int n,int element)
 {
     int i,last=-1;
     for(i=n-1;i>=0;i--)
     {
         if(a[i]==element)
         {
            last = i;
            break;
         }
     }
     return last;
 }
 
  int main()
 {
     int n,element,i,first,last;
     cout<<""array size : "";
     cin>>n;
     cout<<""element : "";
     cin>>element;
     int a[n];
     for(i=0;i<n;i++)
     {
         cin>>a[i]; 
     }
     //Finding first positions of an element
     first = First_positions(a,n,element);
     //Finding last positions of an element
     last = Last_positions(a,n,element);
 
     cout<<""first position of an element is : ""<<first<<endl;
     cout<<""last position of an element is : ""<<last<<endl;
 
 }
 
 /*
 INPUT:  
 array size : 10
 element : 4
 1 2 4 4 4 4 4 4 50 90
 
 OUTPUT: 
 first position of an element is : 2
 last position of an element is : 7
 
 Time Co",C-Plus-Plus
"//INTERPOLATION SEARCH
 #include<bits/stdc++.h> //Importing library (This is the special type of library which will include all basic libraries)
 
 using namespace std;
 
 // If the searching element is present it will return its index, else it will return -1. 
 
 int interpolationSearch(int arr[], int n, int x) {
   int low = 0, high = (n - 1); //Assigning lower index as 0 and higher index as n-1
 
   while (low <= high && x >= arr[low] && x <= arr[high]) {
     if (low == high) {
       if (arr[low] == x) return low;
       return -1;
     }
     // Probing the position with keeping uniform distribution in mind. 
     int pos = low + (((double)(high - low) /
       (arr[high] - arr[low])) * (x - arr[low]));
 
     // Condition of element to be found 
     if (arr[pos] == x)
       return pos;
 
     // If x is larger, x is in upper part 
     if (arr[pos] < x)
       low = pos + 1;
 
     // If x is smaller, x is in the lower part 
     else
       high = pos - 1;
   }
   return -1;
 }
 
 int main() //Starting our main function 
 {
 
   int num, x, loc;
   std::cout << ""Enter size of an array: "";
   std::cin >> num;
   int arr[num]; //Creating array of the size num
   std::cout << ""Enter elements: "" << std::endl;
 
   for (int i = 0; i < num; i++) //Enter the elements in the array
   {
     std::cin >> arr[i];
   }
 
   //Sorting our array
 
   int n = sizeof(arr) / sizeof(arr[0]);
   sort(arr, arr + n);
 
   cout << ""\nArray after sorting using ""
   ""default sort is : \n"" << std::endl;
   for (int i = 0; i < n; ++i) {
     cout << arr[i] << "" "";
 
   }
   cout << std::endl;
 
   //Entering the searching element
   std::cout << ""Enter element to be searched: "" << std::endl;
   cin >> x; //Element to be searched 
   int index = interpolationSearch(arr, n, x);
   //If element was found 
   if (index != -1)
     cout << ""Element found at index "" << index; //Returning the index pf the element
   else
     cout << ""Element not found.""; //Returning -1 as element has not",C-Plus-Plus
"'''
 Lowest Common Ancestor is defined as the lowest node 
 that is farthest from the root and has p and q it's descendants.
 And we allow the node to be descendant of itself.
 
 Purpose: Find the lowest common ancestor of two nodes in a binary search tree.
 
 Intuition: LCA is the split point where the two nodes won't be part of same subtree 
 or one being the parent of the other.
 
 Time Complexity: O(N), in worst case we may have to visit all the nodes.
 SPace Complexity: O(1)
 '''
 
 
 # class that represents a node of the binary search tree
 class Node:
     
     def __init__(self, val):
         self.left=None
         self.right=None
         self.val=val
     
     # insert a new node in the BST
     def insert(self, root, val):
         
         node=Node(val)
         
         # if tree is empty return this new node
         if root is None:
             return node
         
         # otherwise traverse the tree to insert the node
         current=root
         while True:
             # case for node to be inserted in right subtree
             if current.val<val:
                 if current.right is None:
                     current.right = node
                     return root
                 current=current.right
                 
             # case for node to be inserted in left subtree
             elif current.val>val:
                 if current.left is None:
                     current.left= node
                     return root
                 current=current.left
                 
     # function for finding the lowest common ancestor of two nodes
     # iterative version
     def lowestCommonAncestor(self, root, p, q):
         pVal=p
         qVal=q
         node=root
         # traverse the tree
         while node:
             # if p>current node and q> current node, 
             # then traverse the right subtree
             if pVal>node.val and qVal>node.val:
                 node=node.right
             # when p< current.node",Python
"/*  Find number of digits in an integer : 
 	This program will gives you the result in O(1) Time Complexity  
 */
 
 using System; 
   
 class CountDigits { 
   
     static int countDigit(long num) {
         return (int)Math.Floor(Math.Log10(num) + 1); 
     }
     
     public static void Main() 
     { 
         Console.WriteLine(""Enter the number: "");
         long num = Convert.ToInt32(Console.ReadLine());
         Console.WriteLine(""Number of digits= "" + countDigit(num)); 
     } 
 }
 /*
 	Sample Input/Output-
 	Enter the number: 7890
 	Number of digits= 4
 
 */
",C-Sharp
"// C Program to find the Factorial of a number
 #include <stdio.h>
 
 long long unsigned int factorial(int num)
 {
     if (num == 0)
         return 1;
     return num * factorial(num - 1);
 }
 
 int main()
 {
     int num;
     printf(""\nEnter the number: "");
     scanf(""%d"", &num);
 
     // Factorials are undefined for negative integers
     if (num < 0)
     {
         printf(""Factorials are undefined for negative integers"");
     }
 
     // Call the function
     long long unsigned int fact = factorial(num);
     // Print the obtained factorial
     printf(""The factorial of the given number is: %lld"", fact);
     return 0;
 }
 
 /*
 
 Time Complexity- O(num), where 'num' is the given number
 Space Complexity- O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the number: 12
 The factorial of the given number is: 479001600
 
 */
",C
"import java.util.Scanner;
 
 public class linkedListReverse {
 static Node head;
 class Node{
 	public int data;
 	public Node next;
 	Node(int data){
 		this.data=data;
 	}
 }
 
 void add(int data)
 {   Node ctr=head;
 	Node ptr = new Node(data);
 	if(ctr==null)
 	{
 		head=ptr;
 		ptr.next=null;
 	}
 	else 
 	{
 		
 		while(ctr.next!=null)
 			ctr=ctr.next;
 		ctr.next=ptr;
 		ptr.next=null;
 	}
 }
 
 public void print() {
 	Node ctr=head;
 	
 
 	
 	while(ctr!=null)
 	{
 		System.out.print(ctr.data+"" "");
 		ctr=ctr.next;
 	}
 	
 	
 	
 }
 
 public static void main(String[] args)
 {
 	Scanner sc=new Scanner(System.in);
 	linkedListReverse ll = new linkedListReverse();
 	String choice;int data; 
 	
 	System.out.println(""Enter y to add a data to Linked List"");
 	
 	choice = sc.nextLine();
 		while(!choice.isEmpty() && choice.charAt(0)=='y') {
 			
 		
 		System.out.println(""Enter data to enter into the linked list"");
 		data=sc.nextInt();
 		ll.add(data);
 		ll.print();
 		System.out.println();
 System.out.println(""Enter y to add a data to Linked List"");
 		sc.nextLine();
 		choice = sc.nextLine();
 	}
 	Node ctr=head;Node ptr,temp;
 	if(ctr==null)
 		System.out.println(""Linked List is empty"");
 	else {
 	ptr=null;
 	temp=ctr.next;
 	while(ctr.next!=null)
 	{
 		ctr.next=ptr;
 		ptr=ctr;
 		ctr=temp;
 		temp=temp.next;
 		
 		
 	}
 	ctr.next=ptr;
 head=ctr;
 ll.print();
 }
 }
 }
",Java
"""""""Julia program to implement Comb Sort
 Comb sort is an improvised Bubble sort. Bubble sort removes its inversions one by one whereas In Comb sort,
 more than one inversion is removed by one swap and hence it is more efficient than Bubble sort.
 """"""
 
 function comb_sort(arr, n)
     flag = 1
     space = n
     while (space > 1 || flag == 1)
         # Here empirically found shrink factor 1.3 is used.
         space = (space * 10)  13
 
         # Assigning space its minimum value of 1
         if (space < 1)
             space = 1
         end
         flag = 0
 
         # Compare elements with the space value
         for i in 1:(n - space)
             if (arr[i] > arr[i + space])
                 arr[i], arr[i + space] = arr[i + space], arr[i]
                 flag = 1
             end
         end
     end
 end
     
      
 
 print(""How many numbers do you want to sort? "")
 n = readline()
 n = parse(Int64, n)
 if (n <= 0)
     println(""No numbers to sort!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 comb_sort(arr, n)
 print(""The numbers in sorted order is "")
 print(arr)
 
 
 """"""
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 How many numbers do you want to sort? 6
 Enter the numbers: 123 13 42 324 153 43 
 The numbers in sorted order is [13, 42, 43, 123, 153, 324]
 """"""
",Julia
"/*A CPP implementation of count of set bits in an integer using a LookUp 
 table technique - Piyush Kumar */
 #include <bits/stdc++.h>
 #include <iostream>
 using namespace std;
 int main()
 {
     int arr[] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4}; // An array containg count of set bits from 0 - 15
 
     long long int number, count = 0;
     cout << ""Enter the Integer value : "";
     cin >> number; // Input
 
     while (number != 0)
     {
         count += arr[number & 0xF];
         number >>= 4;
     }
     cout << ""Number of set bits in the given integer are : "" << count;
     return 0;
 }
 
 /* Time Complexity : Worst case - O((logn)/k)
                      Best case  - O(1)
 Space Complexity : k - bit approach - O(2^k) 
 where n is the given integer and k is the number of bits in each nibble
 4 - bit - form :
                     0 - 0000
                     1 - 0001
                     2 - 0010
                     .... 
 Sample Input - 9 (1001)
 Sample Output - 2 
 Sample Input - 124(0111 1100)
 Sample Output - 5  --> 3 in upper nibble ,2 in lower nibble*/",C-Plus-Plus
"'''
 Introduction 
     There are two singly linked lists in a system
     Write a program to get the point where two linked list merge. 
     If they do not merge , print that the given lists do not merge
 '''
 
 
 # Code / Solution
 # A Linked List Node
 class Node:
     def __init__(self, data, next=None):
         self.data = data
         self.next = next
  
 # Utility function to find the total number of nodes in a linked list
 def size(head):
 
     # Initialise a int ""count"" with 0 value
     count = 0
     # Traverse all nodes till u reach tail
     while head:
         # Every time u visit a node , increment ""count"" and move head pointer forward
         count += 1
         head = head.next
     return count
 
 # Utility function to find if given nodes are equal
 def eq(head1, head2):
 
     # If both nodes are NONE , they are equal
     if(!head1 and !head2):
         return True
     # If one of the nodes is NONE , they are not equal        
     if(None in (head1, head2)):
         return False 
     # If data's of both nodes are equal , 
     # return if their successive nodes are equal recursively
     if(head1.data == head2.data):
         return eq(head1.next, head2.next)
     # else return False
     return False
 
 # Utility function to find the intersection point of two linked lists.
 # Assume that the first linked list is of longer size than second
 def findIntersection(first, second, k):
 
     # advance the bigger list by `k` nodes
     i = 0
     while i < k and first:
         first = first.next   
         i += 1
  
     # simultaneously move both lists at the same speed until they meet
     while first and second:
         # if both lists meet any node, then that node is the intersection point
         if eq(first, second):
             return first
         # advance both lists by one node
         first = first.next
         second = second.next
  
     # return None if both lists don't meet
     return None
 
 
 # Function to find the i",Python
"""""""
 Python program to get count of digits.
 Count of digits refers to the sum of the frequency of all distinct digits in a number.
 """"""
 
 # Function to count digits in the number
 
 def count_of_digits(n):
     if(n==0):
       return 1
     # Initializing cnt variable to zero
 
     cnt = 0
     while True: 
         if(n==0):
           break
         # Increasing the cnt
 
         cnt+=1 
         # Removing the least significant digit
 
         n = n//10
     return cnt
 
 if __name__ == '__main__':
     # Taking Input
 
     n = int(input(""Enter the number :""))
     # Printing Output
 
     print(""The count of digits in the given number is: {} "".format(count_of_digits(n)))
 
 """"""
 Time Complexity - O(n), n is the count of digits in the number
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 SAMPLE I
 
 INPUT
 Enter the number: 8965
 
 OUTPUT
 The count of digits in the given number is: 4
 
 """"""
 
",Python
"#!/usr/bin/python
 # -*- coding: utf-8 -*-
 
 
 def calculateLps(pattern, lps):
 
     # length of previous lps
 
     length = 0
     lps[0] = 0
 
     iterator = 1
     while iterator < len(pattern):
         if pattern[iterator] == pattern[length]:
             length += 1
             lps[iterator] = length
             iterator += 1
         else:
             if length != 0:
 
                 # iterator is not incremented here
 
                 length = lps[length - 1]
             else:
                 lps[iterator] = 0
                 iterator += 1
 
 
 # this is the function used to check if pattern is there in text
 
 def KMPSearch(pattern, text):
     sizePattern = len(pattern)
     sizeText = len(text)
 
     # lps will hold the longest prefix suffix values for pattern
 
     lps = [0] * sizePattern
     j = 0
 
     # this function will calculate the longest prefix suffix
 
     calculateLps(pattern, lps)
 
     i = 0
     while i < sizeText:
         if pattern[j] == text[i]:
             i += 1
             j += 1
 
         if j == sizePattern:
             print('Pattern found at ' + str(i - j + 1))
             # print the pattern starting index
             j = lps[j - 1]
         elif i < sizeText and pattern[j] != text[i]:
             if j != 0:
                 j = lps[j - 1]
             else:
                 i += 1
 
 
 # for dynamic input use the below code
 
 text = input('Enter the input string : ')
 pattern = input('Enter the string to be searched : ')
 KMPSearch(pattern, text)
 
 # text = ""aaanunaanuaunnanuubhanu""
 # pattern = ""anu""
 # KMPSearch(pattern, text)
 
 # ''' Output
 # Pattern found at 3
 # Pattern found at 8
 # Pattern found at 15
 # Pattern found at 21
",Python
"'''
 Its a simple python program to rotate array by k elements.
 Approch : First Select first k elements and puth them in seperate array , then move all the elements after position k to their left by k steps.
 After this we just put the elements which are in seperate array at the end in reverse order.  
 it will rotate the array by k elements.
 '''
 
 # function to totate the array A
 def rotateArr(A, k, N):
     # first k elements
     lst = A[0:k]
     # shifting all elements to left by k steps
     for i in range(0, N - k):
         A[i] = A[i + k]
     # adding first k elemets to end in rerverse order
     A[N - k:] = lst[:]
     return A
 
 def main():
     print(""Enter the value of no of elements in array and K in one line"")
     nd = [int(x) for x in input().strip().split()]
     N = nd[0]
     k = nd[1]
     print(""Enter the array in one line"")
     A = [int(x) for x in input().strip().split()]
     rotateArr(A, k, N)
     print(""After rotating array by "",k,"" elements the array is "")
     # printing the result
     for i in A:
         print(i, end="" "")
     print()
 
 
 # Driver Code
 if __name__ == ""__main__"":
     main()
 
 '''
 Sample Input/Output:
 
 Enter the value of no of elements in array and K in one line
 5 2
 Enter the array in one line
 1 2 3 4 5
 
 Output:
 After rotating array by 2 elements the array is 
 3 4 5 1 2
 
 Time Complexity : O(n)
 Space Complexity : O(k)
 
 '''
",Python
"/*Given a binary tree as input, output it as the linkedlist in-place.
 The ""Linkedlist"" should be in the same order as ""Preorder Traversal"" of the given binary tree.
 */
 
 #include <iostream>
 #include <queue>
 using namespace std;
 
 struct TreeNode
 {
     int val;
     TreeNode *left;
     TreeNode *right;
 };
 
 TreeNode *node(int val)
 {
     TreeNode *c = new TreeNode;
     c->val = val;
     c->left = c->right = NULL;
     return c;
 }
 
 /*Here,flatten is defined as the function to convert binary tree to linkedlist by altering the left node and making the right node point to null.*/
 
 TreeNode *flatten(TreeNode *A)
 {
      //if the tree is empty
     if (A == NULL)
     {
         return A;
     }
     //for the case of leaf node
     if (A->left == NULL && A->right == NULL) 
     {
         return A;
     }
     if (A->right != NULL && A->left == NULL)
     {
         A->right = flatten(A->right);
         return A;
     }
     else
     {
         TreeNode *j = A;
         TreeNode *p = j->right;
         TreeNode *q = j->left;
         while (q->right != NULL)
         {
             q = q->right;
         }
         q->right = p;
         j->right = flatten(j->left);
         j->left = NULL;
         return j;
     }
 }
 //function for output.
 void inorder_output(TreeNode *root) 
 {
     if (root == NULL)
     {
         return;
     }
     inorder_output(root->left);
     cout << root->val << "" "";
     inorder_output(root->right);
 }
  //code for inserting the required value to every node of tree to be formed.
 TreeNode *insert_value(TreeNode *root, int val, queue<TreeNode *> &t)
 {
     TreeNode *temp = node(val);
     if (val == -1)
     {
         temp = NULL;
     }
     if (root == NULL)
     {
         root = temp;
     }
     else if (t.front()->left == NULL)
         t.front()->left = temp;
     else
     {
         t.front()->right = temp;
         t.pop();
     }
     t.push(temp);
     return root;
 }
 //code for creating tree
 TreeNode *",C-Plus-Plus
"""""""
 Julia program to reverse the bits of a number
 Given an integer, reverse its bits in its binary equivalent and 
 print the new number obtained in its decimal form
 """"""
 
 function reverse_bits(n)
     rev = 0
 
     while(n > 0)
         # Shift the bit of the reversed(answer) number to the right
         rev = rev << 1
         #  Stores the temporary lsb of the given number
         rem = n & 1
         # Set the lsb of the answer variable with the stored value
         rev = rem | rev
         # Drops the already processed lsb of the given number
         n = n >> 1
     end
     return rev
 end
 
 print(""Enter the number? "")
 num = readline()
 num = parse(Int, num)
 rev = reverse_bits(num)
 print(""The bits-reversed number is: $rev"")
 
 """"""
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 39
 The bits-reversed number is: 57
 """"""
",Julia
"public class BinarySearch
 {
     // This search method work only on sorted array 
     static int Search(int[] array, int element)
     {
         int left = 0;
         int right = array.Length - 1;
 
         while (left <= right)
         {
             int middle = left + (right - left) / 2;
 
             if (array[middle] == element)
             {
                 return middle;
             }
 
             // If element greater than the middle element we search on the right half 
             if (array[middle] < element)
             {
                 left = middle + 1;
             }
             else
             {
                 right = middle - 1;
             }
         }
 
         // element not found 
         return -1;
     }
 }
 
",C-Sharp
"/**
  * Maximum Sum Subarray od Size k
  * Cpp program to find the maximum currentSum of a subarray of fixed size k,
  * given an array of integers, using the 'Sliding Window Technique',
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // Returns maximum Sum in a subarray of size k
 int max_sum_subarray(int len, int arr[], int k)
 {
     int currentSum = 0;
     int maxSum = INT_MIN;
     //Pointers to represent start and end of every window
     int start = 0, end = 0;
     //Finding sum of all possible k-sized windows, one by one
     while (end < len) {
         currentSum = currentSum + arr[end];
         //Increment end if current window size is less than k
         if (end - start + 1 < k)
             end++;
         else if (end - start + 1 == k) {
             maxSum = max(currentSum, maxSum);
             //Compute sums of remaining windows by removing
             // first element of previous window
             currentSum = currentSum - arr[start];
             //slide the  window
             start++;
             end++;
         }
     }
     return maxSum;
 }
 
 int main()
 {
     //taking input from user
     int len, k;
     cout << ""Enter length of array: "";
     cin >> len;
     cout << ""Enter array elements: "";
     int arr[len];
     for (int start = 0; start < len; start++)
         cin >> arr[start];
     cout << ""Enter size of window: "";
     cin >> k;
     cout << ""Maximum currentSum of a subarray of size k: "";
     cout << max_sum_subarray(len, arr, k);
 }
 
 /*
     Test cases:
 
     INPUT:-
     Enter length of array: 7
     Enter array elements: 2 5 1 8 2 9 1
     Enter size of window: 3
     OUTPUT:
     Maximum currentSum of a subarray of size k: 19
 
     INPUT
     length of array: 10
     Enter array elements: 1 7 -2 4 5 2 1 6 11 -4
     Enter size of window: 3
     OUTPUT
     Maximum sum of a subarray of size 3: 18
 
     Time complexity: O(n)
     Space complexity: O(1)
 
 */
",C-Plus-Plus
"import java.util.Iterator;
 import java.util.PriorityQueue;
 import java.util.Scanner;
 
 /*Priority Queue data structure is a special queue in which the elements are present not as per FIFO order 
  *but as per the natural elements or any xyz comparator used during queue creation.
 */
 
 public class PriorityQueueEg {
     
     private static Scanner sc = new Scanner(System.in);
 
     public static void printingthequeue(PriorityQueue<String> queue) {
         Iterator iterator = queue.iterator();  
         while(iterator.hasNext())
         { 
             System.out.print(iterator.next() + "" "");  
         }  
     }
 
     public static void main(String args[])
     {  
         System.out.println(""Kindly enter the number of strings in the queue: "");
         int n = sc.nextInt();
 
         PriorityQueue<String> queue = new PriorityQueue<String>();  
         
         //taking n strings as input from the user
         for(int i=0;i<n;i++)
         {
             System.out.println(""Kindly enter the ""+i+""'th element"");
             queue.add(sc.next());
         }
 
         //print the head of the PriorityQueue
         System.out.println(""PriorityQueue Head : ""+ queue.element());  
         
         //Define the iterator for PriorityQueue and print its elements 
         System.out.println(""\nPriorityQueue : ""); 
 
         //to print the queue, using Iterator
         printingthequeue(queue);
     }
 
 }
 
 /*
 Output:
 
 Kindly enter the number of strings in the queue:                                                                                              
 3                                                                                                                                             
 Kindly enter the 0'th element                                                                                                                 
 ram                                                                                                            ",Java
"#include<stdio.h>
 #include<conio.h>
 
 void insertAtBeginning(int);
 void insertAtEnd(int);
 void insertAtAfter(int,int);
 void deleteBeginning();
 void deleteEnd();
 void deleteSpecific(int);
 void display();
 
 struct Node
 {
    int data;
    struct Node *next;
 }*head = NULL;
 
 void main()
 {
    int choice1, choice2, value, location;
    clrscr();
    while(1)
    {
       printf(""\n*********** MENU *************\n"");
       printf(""1. Insert\n2. Delete\n3. Display\n4. Exit\nEnter your choice: "");
       scanf(""%d"",&choice1);
       switch()
       {
          case 1: printf(""Enter the value to be inserted: "");
          		 scanf(""%d"",&value);
                  while(1)
                  {
                  	printf(""\nSelect from the following Inserting options\n"");
                  	printf(""1. At Beginning\n2. At End\n3. After a Node\n4. Cancel\nEnter your choice: "");
                     scanf(""%d"",&choice2);
                     switch(choice2)
                     {
                        case 1: 	insertAtBeginning(value);
                        		break;
                        case 2: 	insertAtEnd(value);
                        		break;
                        case 3: 	printf(""Enter the location after which you want to insert: "");
                        		scanf(""%d"",&location);
                        		insertAfter(value,location);
                        		break;
                        case 4: 	goto EndSwitch;
                        default: printf(""\nPlease select correct Inserting option!!!\n"");
                     }
                  }
          case 2: while(1)
                  {
                  	printf(""\nSelect from the following Deleting options\n"");
                  	printf(""1. At Beginning\n2. At End\n3. Specific Node\n4. Cancel\nEnter your choice: "");
                     scanf(""%d"",&choice2);
                     switch(choice2)
                     {
                        case 1: 	deleteBeginning();
                        		br",C-Plus-Plus
"# Python program to count the number of set bits in a number
 
 def countNumSetBits(num):
     cnt = 0
     while(num > 0):
         cnt = cnt + (num & 1)
         num = (num >> 1)
     return cnt
 
 
 if __name__ == '__main__':
     print(""Enter the number: "")
     num = int(input())
     res = countNumSetBits(num)
     print(""The number of set bits present in the given number is $res"")
 
 
 """"""
 Time Complexity: O(log(n)), where n is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the number: 12354
 The number of set bits present in the given number is 4
 
 SAMPLE II
 
 Enter the number: 2048
 The number of set bits present in the given number is 1
 """"""
",Python
"/* This is Program in go language to check whether a given number is
    Strong number or not. Strong number is a special number whose
    sum of factorial of digits is equal to the original number.
    Eg: 145 is strong number. Since, 1! + 4! + 5! = 145   
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 //global variable
 var a int
 
 //This function will return us the factorial of a given number
 func factorial(n int)int {
 
   if(n == 0){
      return 1
   }else{
      return n*factorial(n-1)
   }
 
 }
 
 //This function tells us if the given number is a strong number or not
 func strongnumber() {
 
   var number int
   number = a
   var sum int
   sum = 0
   var digits int
   /* we calculate the sum of the factorials of individual digits 
      of the number given*/
   for number!=0 {
 
     digits = number%10
     sum += factorial(digits)
     number /= 10
   }
 
   // checking if the sum is same as orginal number
   if (sum == a){
 
     fmt.Print(""The given number is a strong number!"")
 
   }else{
 
     fmt.Print(""The given number is not a strong number!"")
   }
 
 }
 
 //driver function
 func main() {
 
    fmt.Print(""Enter the number we need to check :"")
    // Taking the input for the number we need to check
    fmt.Scan(&a)
 
    //calling the strongnumber function
    strongnumber()
 }
 
 /*
    Simple I/O :
 
    a) Is a strong number :
 
    Enter the number we need to check :40585
    The given number is a strong number!
 
    b) Is not a strong number :
 
    Enter the number we need to check :45
    The given number is not a strong number!   
 */
 
",Go
"/**
 
 The Floyd Warshall Algorithm is used to find minimum distances between
 every pair of vertices in a given edge weighted directed Graph.
 The Floyd-Warshall algorithm is an example of dynamic programming. 
 It breaks the problem down into smaller subproblems, then combines 
 the answers to those subproblems to solve the big, initial problem. 
 
 */
 
 import java.util.Scanner;
 
 public class Floyd_Warshall_Algorithm {
 
 	public static void display(int v, int[][] answerMatrix) {
 
 		System.out.println(""Matrix displaying minimum costs between the pairs of vertices."");
 
 		// display final matrix after all the updations of shortest cost path from
 		// vertex i to j
 		// value at i,j represents minimum cost from vertex i to vertex j.
 		for (int i = 0; i < v; i++) {
 			for (int j = 0; j < v; j++) {
 				System.out.print(answerMatrix[i][j] + "" "");
 			}
 			System.out.println();
 		}
 	}
 
 	public static void floydWarshallAlgorithm(int v, int[][] graph) {
 
 		// answer matrix where we will be storing minimum cost between two pair of
 		// vertices.
 		int[][] answerMatrix = new int[v][v];
 
 		// just copy down values of graph into ans matrix.
 		for (int i = 0; i < v; i++) {
 			for (int j = 0; j < v; j++) {
 				answerMatrix[i][j] = graph[i][j];
 			}
 		}
 
 		// update the matrix by keeping each vertex as a main rout part once.
 		for (int k = 0; k < v; k++) {
 			// k represents that we are keeping kth vertex constant.
 			// means that path from i to j must pass from k.
 
 			for (int i = 0; i < v; i++) {
 				for (int j = 0; j < v; j++) {
 
 					int oc = answerMatrix[i][j];
 					int nc = answerMatrix[i][k] + answerMatrix[k][j];
 
 					if (nc < oc) {
 						answerMatrix[i][j] = nc;
 					}
 				}
 			}
 		}
 
 		display(v, answerMatrix);
 	}
 
 	public static void main(String[] args) {
 
 		Scanner sc = new Scanner(System.in);
 
 		System.out.println(""Enter no. of vertices in the Graph."");
 		int v = sc.nextInt();
 
 		int[][] graph = new int[v][v",Java
"// Manacher's Algorithm is used to the find all the pairs (i,j) such that substring s[ij] is a palindrome.
 #include <stdio.h>
 #include <string.h>
 
 // Function to find the minumum between two numbers
 int min(int num1, int num2)
 {
 	return (num1 > num2) ? num2 : num1;
 }
 
 // Function to find the maximum between two numbers
 int max(int num1, int num2)
 {
 	return (num1 > num2) ? num1 : num2;
 }
 
 // Function to find the palindromic pairs and length of longest palindromic substring
 int manacher_algo(char str[])
 {
 	int n = strlen(str);
 	int d1[100] = {};  //d1 - odd length palindrome, 
 	int d2[100] = {};  //d2 - even length palindrome
 	for (int i = 0, l = 0, r = -1; i < n; ++i)
 	{
 		int k;
 		if (i > r)
 			k = 1;
 		else
 			k = min(d1[l + r - i], r - i + 1);
 		while (0 <= i - k && i + k < n && str[i - k] == str[i + k])
 		{
 			k++;
 		}
 
 		d1[i] = k--;
 		if (i + k > r)
 		{
 			l = i - k;
 			r = i + k;
 		}
 	}
 
 	for (int i = 0, l = 0, r = -1; i < n; ++i)
 	{
 		int k;
 		if (i > r)
 			k = 0;
 		else
 			k = min(d2[l + r - i + 1], r - i + 1);
 		while (0 <= i - k - 1 && i + k < n && str[i - k - 1] == str[i + k])
 		{
 			k++;
 		}
 
 		d2[i] = k--;
 		if (i + k > r)
 		{
 			l = i - k - 1;
 			r = i + k;
 		}
 	}
 
 	int ans = 0;
 	printf(""Following are the pairs which are palindromes: \n"");
 	for (int i = 0; i < n; ++i)
 	{
 		int x = d1[i];
 		while (x)
 		{
 			ans = max(ans, 2 *x - 1);
 			printf(""%d %d\n"", i - x + 1, i + x - 1);
 			x--;
 		}
 	}
 
 	for (int i = 0; i < n; ++i)
 	{
 		int x = d2[i];
 		while (x)
 		{
 			ans = max(ans, 2 *x);
 			printf(""%d %d\n"", i - x, i + x - 1);
 			x--;
 		}
 	}
 
 	return ans;
 }
 
 int main()
 {
 	char str[10];
 	int ans;
 	printf(""Enter the string:"");
     scanf(""%s"", str);
 	ans = manacher_algo(str);
 	printf(""Length of longest palindromic substring: %d"", ans);
 	return 0;
 }
 
 /*
 
 Sample Output
 Enter the string:abcba
 Following are the pairs which are palindromes: 
 0 0
 1 1
 0 4
 1 3
 2",C
"/*
 The traversal operation is a frequently used operation on a binary tree. This operation is used to visit each node in the tree exactly once
 A full traversal on a binary tree gives a linear ordering of data in the tree .  This is the iterative preorder tree traversal algorithms
 */
 #include <stdio.h>
 #include <stdlib.h>
 //structure for the binary tree node
 typedef struct Tree
 {
     char data;
     struct Tree *left;
     struct Tree *right;
 } TreeNode;
 //structure for stack which is used for the iterative traversal algorithms
 //stack is implemented using linked list
 typedef struct Stack
 {
     TreeNode *node;
     struct Stack *next;
 } Stack;
 //push operation for the stack
 void push(Stack **s, TreeNode *node)
 {
     Stack *New = (Stack *)malloc(sizeof(Stack));
     New->node = node;
     New->next = (*s);
     (*s) = New;
 }
 // pop operation for the stack
 TreeNode *pop(Stack **s)
 {
     if ((*s) != NULL)
     {
         TreeNode *ptr = (*s)->node;
         (*s) = (*s)->next;
         return ptr;
     }
 }
 //checks whether the stack is empty or not
 int isEmpty(Stack **s)
 {
     if ((*s) == NULL)
     {
         return 1;
     }
     return 0;
 }
 //iterative preorder traversal
 void preorder(TreeNode *root)
 {
     TreeNode *ptr = root;
     Stack *s = NULL;
     push(&s, root);
     while (!isEmpty(&s))
     {
         ptr = pop(&s);
         if (ptr != NULL)
         {
             printf(""%c "", ptr->data);
             push(&s, ptr->right);
             push(&s, ptr->left);
         }
     }
 }
 //Search_Link returns the pointer to the node which contains the value key , it is used in the insertion operation
 TreeNode *Search_Link(TreeNode *root, char key)
 {
     TreeNode *ptr = root;
     if (ptr->data != key)
     {
         if (ptr->left != NULL)
         {
             Search_Link(ptr->left, key);
         }
         if (ptr->right != NULL)
         {
             Search_Link(ptr->right, key);
         }
         if (ptr->right == NUL",C
"/*
    We will create a LinkedList first and display its elements.
    After that we will delete some elements from the LinkedList
    * Delete from beginning - In this case we will simply move the head pointer
       to the next node. In case if we have only one element in the LL then we 
       will assign null to head which is the pointer to the first and only node in the LL. 
    * Delete from end - In this case we will take a pointer and initialize 
       it to the head pointer and we will move this pointer till end-1 so 
       that we can access the last node.    
    * Delete from any position - In this case we will take a pointer variable
       and initialize it to the head pointer and we will move this pointer till 
       position-1 so that we can access the desired position node.
 */
 
 import java.util.Scanner;
 
 public class DeleteElementLL {
      
 	//creating the Node class having one data part and one pointer to the next node
 	class Node{
 		 int data;      
 		 Node next;
 		 
 		 // Constructor to initialize the data and next pointer
 		 Node(int data){
 			 this.data = data;      
 			 this.next = null;  
 		 }
 	}
 	  
 	  // creating the head of the list
 	  Node head = null; 
 	  
 	  public void createList(int newData) {
 		  
 		/* creating a new node with data value.
 		   If list is empty head points to the newly
 		   created node and if list is not empty, we create
 		   temp variable and traverse the list till end
 		   and insert the node at the end */
              
 		  Node new_Node = new Node(newData); 
 		  Node temp = head;
 		  if(head==null) {
 			  head = new_Node;
 		  }
 		  else {
 		     	while(temp.next!=null) {
 		     		temp = temp.next;
 		     	}
 		     	temp.next = new_Node;
 		  }
 	  } 
 	
 	  public void displayList() {
 		  /* creating a temp variable 
 		     traversing and printing the list*/
 		  
 		  Node temp = head;  
 		 
 		  while(temp != null) {
 			  System.out.print(temp.data + "" "");
 			  temp",Java
"/*
 Description : 
         We have to find wether the number is power of 2 or not . If it is then return yes else no 
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 bool power_of_2(int n)
 {
 	// if zero then it will return true
 	return (n&& !(n&n-1));
 }
 int main()
 {
 	int num;
     cout<<""Enter the number : ""<<endl;
 	cin>>num;
 	power_of_2(num)? cout<<""Yes\n"": cout<<""No\n"";
 }
 
 /*
 Time complexity : O(1)
 Space complexity : O(1)
 */
 
 /*
 Input :
 Enter the number : 
 64
 
 Output :
 Yes
 
 */
 
",C-Plus-Plus
"/*
  This problem will be solved using dp.
  We will be given two strings and we have to print the 
  shortest string that has both X and Y as subsequences. 
  If multiple shortest supersequence exists, print any one of them.
 
 */
 
 #include <iostream>
 using namespace std;
 int t[1001][1001];
 
 int longestSubsequence(string X,string Y,int m,int n){
     // if length of any string is 0 then we cannot find common string
     for(int i=0;i<m+1;i++){
         for(int j=0;j<n+1;j++){
             if(i==0 || j==0)
             t[i][j] = 0;
         }
     }
 
     for(int i=1;i<m+1;i++){
         for(int j=1;j<n+1;j++){
             //if letters of both string are equal then we will decrease row and column both by 1
             if(X[i-1] == Y[j-1]){
                 t[i][j] = t[i-1][j-1] + 1;
             }
             //if letters of both string are not equal then first we will decrease row by 1 and then column by 1 and find maximum value b/w two
             else{
                 t[i][j] = max(t[i-1][j], t[i][j-1]);
             }
         }
     }
     
     return m + n - t[m][n];
 }
 
 int main() {
     string X,Y;
     cin>>X>>Y;
     int m = X.length();
     int n = Y.length();
     //memset(t,-1,sizeof(t));
     cout<<longestSubsequence(X,Y,m,n);
     return 0;
 }
 /*
 Input -
 Enter string X and string Y -
 geek
 eke
 Output -
 Length of Shortest Common Superstring -
 5
 Time Complexity - O(m*n)
 Space Complexity - O(m*n)
 */
",C-Plus-Plus
"// CPP program to find Hailstone Sequence of a given number N up to 1
 
 /* 
 The Hailstone sequence of numbers can be generated from a starting positive integer, N by:
  If N = 1, then the sequence ends.
  If N is even, then the next N of the sequence = N / 2
  If N is odd, then the next N of the sequence = (3 * N) + 1 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int HailstoneSequence(int N)
 {
     static int count;
 
     if (N == 1 && count == 0)
     {
         cout << N << "" "";
         return count;
     }
 
     else if (N == 1 && count != 0)
     {
         cout << N << "" "";
         count++;
         return count;
     }
 
     else if (N % 2 == 0)
     {
         cout << N << "" "";
         count++;
         HailstoneSequence(N / 2);
     }
 
     else if (N % 2 != 0)
     {
         cout << N << "" "";
         count++;
         HailstoneSequence(3 * N + 1);
     }
 }
 
 // Driver code
 int main()
 {
     int N, ans;
     cout << ""Enter a number: "";
     cin >> N;
     cout << ""\nHailstone Sequence upto 1:"" << endl;
     ans = HailstoneSequence(N);
     cout <<""\n\nNumber of Steps involved: ""<< ans << endl;
     return 0;
 }
 
 /*
 OUTPUT 1:
 Enter a number: 7
 Hailstone Sequence upto 1:
 7 22 11 34 17 52 26 13 40 20 10 5 16 8 4 2 1
 Number of Steps involved: 17
     
 OUTPUT 2:
 Enter a number: 6
 Hailstone Sequence upto 1:
 6 3 10 5 16 8 4 2 1
 Number of Steps involved: 9
 */
",C-Plus-Plus
"/*
 Detecting a loop/cycle in a linked list.
 Algorithm/Approach:
 We use two pointers- slow and fast pointers to traverse the linked list.
 If there is a loop in the linked list, then we will never encounter a NULL pointer. 
 Also, since we are using a slow and a fast pointer, these two pointers will point the same node at one oint of time.
 This indicates a loop/cycle in linked list.
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 typedef struct Node {
     int data;
     struct Node *next;
 } Node;
 Node *head;
 
 Node * newNode(int val) {
     Node *new_node = (Node *)malloc(sizeof(Node ));
     new_node -> data = val;
     new_node -> next = NULL;
     return new_node;
 }
 
 void insertNode(int value) {
     /* inserting a new node */
     Node *new_node = newNode(value);
     if (!head) {
         head = new_node;
     }
     else {
         new_node -> next = head;
         head = new_node;
     }
 }
 
 int detectLoop(Node *head) {
     Node *fastPtr, *slowPtr;
     /* using two pointer */
     slowPtr = fastPtr = head;
     do {
         slowPtr = slowPtr -> next;
         fastPtr = fastPtr -> next;
         fastPtr = fastPtr ? fastPtr -> next : fastPtr;
     } while (fastPtr && slowPtr && fastPtr != slowPtr);
     return slowPtr == fastPtr;
 }
 
 void display() {
     Node *p = head;
     while (p) {
         printf(""%d "", p -> data);
         p = p -> next;
     }
     printf(""\n"");
 }
 
 int main() {
     int size, val;
     printf(""Enter the size of linked list:\n"");
     scanf(""%d"", &size);
     printf(""Enter the elements of the linked list:\n"");
     for (int i = 0; i < size; i ++) {
         scanf(""%d"", &val);
         insertNode(val);
     }
     
     /* before introducing a loop */
     if (detectLoop(head)) {
         printf(""A loop has been detected in the linked list!\n"");
     }
     else {
         printf(""No loop detected in the linked list!\n"");
     }
 
     /* after introducing a loop */
     head -> next -> next = head;
     if (detectL",C
"/**
 This function is a recursive function, which calls itself over and over
 according to the number of digits in the number. Using that and adding each
 digit raised to the power of the number of digits, it keeps adding them
 and we get the sum we need to compare with the number input.
  */
 import 'dart:io';
 import 'dart:math';
 
 // recursive function which add digits raised to the power of number of digits
 int armstrong(int num, int len) {
   if(num < 10) {
     return pow(num, len).toInt();
   } else {
     return (pow(num % 10, len).toInt() + armstrong(num ~/ 10, len));
   }
 }
 
 // Main Function, Entry Point of Program
 void main() {
   print(""Enter a number:"");
   int num = int.parse(stdin.readLineSync()!);
   int len = num.toString().length;
 
   // Call function to check number is Armstrong
   if (num == armstrong(num, len)) {
     print(""$num is an Armstrong Number"");
   } else {
     print(""$num is not an Armstrong Number"");
   }
 }
 
 /**
 Sample Input and Output :
 Enter a number:
 153
 153 is an Armstrong Number
 
 Enter a number:
 213
 213 is not an Armstrong Number
 
 Time complexity = O(n)
 Space complexity = O(1)
  */
",Dart
"/* 
 AVL Trees: These are self-balancing trees where the difference between the heights
 of left and right subtree(for any node) is not more than 1 and less than -1. This concept
 came about so as to ensure that the opeations on BST doesn't become of the order of O(n)
 as it becomes more and more skewed. In other words, AVL trees ensures that the balance of 
 the tree is maintained, thus maintaining the order of the operations on it as O(log n).
 properties of AVL:
  (1) It is a BST and (2) No duplicate nodes allowed 
  (3) |height of left subtree - height of right subtree| <=1
 */
 #include <iostream>
 #include <bits/stdc++.h>
 using namespace std;
 struct Node{
     Node* left;
     Node* right;
     int data;
     int bf;//balance factor of the node
     int height;
 };
 
 int find_height(Node* current_node){
     if(current_node==NULL) return(0);
     //cur_node is the pointer to the current Node
     Node* node=current_node;
     //The balance factor >0 means that left subtree has greater height
     //if it is <0 then, right subtree has greater height
     if(node->bf>=0){
         node = node->left;
     }
     else if(node->bf<0){
         node = node->right;
     }
     int height=0;
     while(node!=NULL){
         height++;
         if(node->bf<0){
             node = node->right;
         }
         else if(node->bf>=0){
             node = node->left;
         }
     }
     //one is added as the height of a single node is 1 and is added to
     //the height of the longest subtree.
     return(1+height);
 }
 
 //critical node is a node which has a balance factor either
 // greater than  1 or less than -1.
 
 int find_balance_factor(Node* node){
     return(find_height(node->left)-find_height(node->right));
 }
 
 
 /*
 right rotation can be illustrated as follows:
 
    (critical_node)                                     (next_node)
     /                       (right rotation)           /          \
  (next_node)             ====================>        ",C-Plus-Plus
"#include<iostream>        //Header file 
 using namespace std;      //For cin and cout
 
 /*
     Quicksort is a divide-and-conquer algorithm. It works by selecting a 'pivot' element from the array
     and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. 
     The sub-arrays are then sorted recursively. This can be done in-place, requiring small additional amounts of memory to perform the sorting.
 
     @author Aditya Saxena
     @since 27-6-2020
 */
 
 //Implement partitionPivot function
 int partitionPivot( int a[], int start, int end ){
 
     int i= start-1;
     int j= start;
     int pivot= a[end];
 
     //Traverse the array - whenever an element smaller than pivot occurs, swap it with (i+1)th element 
     for(j= start; j<= end-1; j++){
         
         if(a[j] <= pivot){
             i++;
             swap(a[i],a[j]);
         }
     }
 
     //Place the pivot element at i+1 (between smaller and larger elements)
     swap(a[i+1],a[end]);
 
     //Return position of pivot
     return i+1;
 }
 
 //Implement Quick Sort function
 void quickSort( int a[], int start, int end ){
 
     //base case
     //If start (index) crosses end (index), there are no elements to sort further, thus return
     if( start >= end ){
         return;
     }
 
     //Taking end element as pivot, place the pivot element in its right position such that
     //elements left to the pivot are smaller than pivot and elements right to the pivot are greater than pivot
     //Return pivot's position (index)
     int p= partitionPivot( a, start, end );
 
     //Recursively sort left and right part of the pivot element
     //Left part of the pivot
     quickSort( a, start, p-1 );
     //Right part of the pivot
     quickSort( a, p+1, end);
 
     return;
 }
 
 int main(){
 
     int n;
     cout<<""Enter the number of elements: "";
     cin>>n;
 
     int a[n];
     cout<<endl<<""Enter the elements of the array: "";
     
",C-Plus-Plus
"/* 
 Kth - Permutation Sequence 
 
 The set [1, 2, 3, ..., n] contains a total of n! unique permutations.
 By listing and labeling all of the permutations in order, we get the following sequence for n = 3:
 ""123""
 ""132""
 ""213""
 ""231""
 ""312""
 ""321""
 Given n and k, return the kth permutation sequence in the string type.
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 string Solve(int n, int k)
 {
     // factorial is the variable to store the n!
     long long int factorial = 1;
     // vector to store the number from 1 to n
     vector<int> num;
     for(int i = 1;i < n;i++)
     {
         factorial = factorial * i;
         num.push_back(i);
     }
     num.push_back(n);
     // str variable to store the ans or kth sequence
     string str = """";
     k = k - 1;
     while(true){
         // adding the k / factorial number in the string
         str += to_string(num[k / factorial]);
         // erasing the element from the vector as it is already added in the string
         num.erase(num.begin() + k / factorial);
         if(num.size() == 0){
             break;
         }
         // updating the k
         k %= factorial;
         // updating the factorial
         factorial /= num.size();
     }
     return str;
 }
 
 int main()
 {
     int testCases;
     cout << ""Enter the number of testcases: "";
     cin >> testCases;
     while(testCases--){
         //n is the size of the each permutation
         int n; 
         cout<<""Enter the number n: "";
         cin>>n;
         // k is the kth - permutation in the set of n!
         int k;
         cout<<""Enter the number k: "";
         cin>>k;
         string ans = Solve(n,k);
         cout<<""The kth permutation is: '""<<ans<<""'""<<endl;
     }
     return 0;
 }
 
 /*
 
 FOR EXAMPLE:--
 
 Example 1:
 Input:-
 Enter the number of testcases: 2
 Enter the number n: 4
 Enter the number of k: 17
 Enter the number n: 3
 Enter the number k: 2
 Output:-
 The kth permutation is: '3412'
 The kth permutation is: '132",C-Plus-Plus
"/*
 The Problem states that Given array arr[n] of integer where each element arr[i] represent 
 number of task given to each student.Your task is to find if it possible to redistribute the 
 task where i'th student assign i number of task. Example is it possible to assign 2 task to 2nd Student. 
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 void solve(int arr[], int n)
 {
     int sum_of_task = 0, sum_of_i = 0;
     for (int i = 1; i <= n; i++)
     {
         sum_of_task = sum_of_task + arr[i];
         sum_of_i += i;
     }
     if (sum_of_i == sum_of_task)
         cout << ""Yes It is possible\n"";
     else
         cout << ""No It is not Possible\n"";
 }
 int main()
 {
     int n;
     cout<<""Enter number of Student:"";
     cin >> n;
     int arr[n];
     cout<<""Enter number of task assign to each\n"";
     for (int i = 1; i <= n; i++)
     {
         cout<<""Student ""<<i<<"":"";
         cin >> arr[i];
     }
     solve(arr, n);
     
 }
 
 /*
 Sample Input:
 Enter number of Student:5
 Enter number of task assign to each
 Student 1:7
 Student 2:4
 Student 3:1
 Student 4:1
 Student 5:2
 
 Sample Output:
 Yes It is possible
 
 Time-Complexity: O(n)
 Space-Complexity: O(1)
 
 */
",C-Plus-Plus
"/**
 A backtracking algorithm to solve 9X9 suduko
 0's in the input are treated empty cells
 Assumption : Given configuration is correct
 **/
 
 #include <stdio.h>
 #include <stdbool.h>
 
 #define N 9
 
 void display(int board[N][N]){
   for(int i = 0; i < N; i++){
     for(int j = 0; j < N; j++){
       printf(""%d "", board[i][j]);
     }
     printf(""\n"");
   }
 }
 
 // backtracking soln
 bool solve(int board[N][N], int i, int j, 
   bool rows[N][N], bool cols[N][N], bool boxes[N][3][3]) {
     
     if(i == 9)
       return true;
       
     if(board[i][j] == 0) {
         
       for(int k=0; k<9; k++) {
           
         if(rows[k][i] == false && cols[k][j] == false
           && boxes[k][i/3][j/3] == false) {
             board[i][j] = k+1;
             rows[k][i] = true;
             cols[k][j] = true;
             boxes[k][i/3][j/3] = true;
               
             if(solve(board, i+j/8, (j+1)%9, rows, cols, boxes))
               return true;
               
             board[i][j] = 0;
             rows[k][i] = false;
             cols[k][j] = false;
             boxes[k][i/3][j/3] = false;
           }
       }
       
       return false;
     } else
       return solve(board, i+j/8, (j+1)%9, rows, cols, boxes);
   }
 
 void solveSudoku(int board[N][N], int x, int y) {
   // write yopur code here
   bool rows[N][N], cols[N][N], boxes[9][3][3];
 
   // intialization
   for(int i=0; i<N; i++)
     for(int j=0; j<N; j++) {
       rows[i][j] = false;
       cols[i][j] = false;
     }
 
   // intialization
   for(int i=0; i<N; i++)
     for(int j=0; j<3; j++)
       for(int k=0; k<3; k++)
         boxes[i][j][k] = false;
   
   for(int i=0; i<9; i++)
     for(int j=0; j<9; j++)
       if(board[i][j] != 0) {
         int num = board[i][j]-1;
         rows[num][i] = true;
         cols[num][j] = true;
         boxes[num][i/3][j/3] = true;
       }
       
   solve(board,0,0,rows,cols,boxes);
   display(board);
 }
 
 int main() {
   int arr[N][N];
 
   /",C
"/*
 Bellman Ford algorithm can handle negative weights which dijkstra couldn't.
 However it cannot handle negative cycles and have more complexity than Dijkstra.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 struct Edge { 
   int src, dest, weight; 
 }; 
 
 struct Graph { 
   int V, E; 
   struct Edge* edge; 
 }; 
   
 struct Graph* createGraph(int V, int E) 
 { 
   struct Graph* graph = new Graph; 
   graph->V = V; 
   graph->E = E; 
   graph->edge = new Edge[E]; 
   return graph; 
 } 
 
 void showDist(int dist[], int n) 
 { 
   cout<<""Vertex Distance from Source""<<endl; 
   for (int i = 0; i < n; ++i) 
     cout<<i<<""  ""<<dist[i]<<endl; 
 } 
 
 void bellmanFord(struct Graph* graph, int src){
   int V = graph->V; 
   int E = graph->E; 
   int dist[V];
 
   for (int i = 0; i < V; i++) 
     dist[i] = INT_MAX; 
   dist[src] = 0;
 
   for(int i=0;i<V-1;i++){
     for (int j = 0; j < E; j++){
       int u = graph->edge[j].src; 
       int v = graph->edge[j].dest; 
       int w = graph->edge[j].weight; 
       if (dist[u] != INT_MAX && dist[u] + w < dist[v]) 
         dist[v] = dist[u] + w;
     }
   }
 
   for (int i = 0; i < E; i++) { 
     int u = graph->edge[i].src; 
     int v = graph->edge[i].dest; 
     int weight = graph->edge[i].weight; 
     if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) { 
       cout<<""Graph contains negative weight cycle, hence the shortest distance is not gauranteed""<<endl; 
       return; 
     } 
   } 
   showDist(dist,V);
 }
 
 int main(){
   int n,m;
   cin>>n>>m;
   struct Graph* graph = createGraph(n, m);
     
   for(int i=0;i<m;i++){
     int u,v,w;
     cin>>u>>v>>w;
     graph->edge[i].src = u-1; 
     graph->edge[i].dest = v-1; 
     graph->edge[i].weight = w;
   }
 
   bellmanFord(graph,0);
   return 0;
 }
 
 /*
 Input:
 First line contains two space separated integers,(N,M) 
 N- no of vertices, M- no of edges.
 Then M lines follow, each line has 3 space separated integers ui ,vi ,wi which denotes edge from ver",C-Plus-Plus
"import java.util.Scanner;
 
 public class MaximumSumRectangle {
 
     public static void main(String[] args) {
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter number of rows and columns:"");
         int r = scanner.nextInt();
         int c = scanner.nextInt();
         int[][] matrix = new int[r][c];
         System.out.println(""Enter elements of the matrix:"");
         for (int i = 0; i < r; i++) {
             for (int j = 0; j < c; j++) {
                 matrix[i][j] = scanner.nextInt();
             }
         }
 
         System.out.println(""Maximum sum is:"" + maxSum(matrix));
     }
 
     private static int maxSum(int[][] matrix) {
 
         int r = matrix.length;
         int c = matrix[0].length;
         int[][] prevSum = new int[r + 1][c];
 
         for(int i = 0; i < r; i++) {
             for(int j = 0; j < c; j++) {
                 prevSum[i + 1][j] = prevSum[i][j] + matrix[i][j];
             }
         }
 
         // solving with the method of Kadane's Algorithm
         int maxSum = -1;
         int minSum = Integer.MIN_VALUE;
         int negRow = 0, negCol = 0;
         int rStart = 0, rEnd = 0, cStart = 0, cEnd = 0;
         for(int rowBegin = 0; rowBegin < r; rowBegin++) {
             for(int row = rowBegin; row < r; row++){
                 int sum = 0;
                 int curColStart = 0;
                 for(int col = 0; col < c; col++) {
                     sum += prevSum[row + 1][col] - prevSum[rowBegin][col];
                     if(sum < 0) {
                         if(minSum < sum) {
                             minSum = sum;
                             negRow = row;
                             negCol = col;
                         }
                         sum = 0;
                         curColStart = col + 1;
                     }
                     else if(maxSum < sum) {
                         maxSum = sum;
                         rStart = rowBegin;
                        ",Java
"'''
 This is a simple program for reversing first k elements in a queue.
 Approch: First make a queue and insert all elements into it.
          Then we pass the queue , k and n to function reverseK for reversing it, after reversing it will return a lists
          In reverseK function we use a stack , we will dequeue first k elements and push them in stack
          Then we just pop all elements from stack and enque to queue and then we deque the remaining item and add them at last.
 '''
 
 
 def enqueue(lst, item):
     # insert at last
     lst.append(item)
 
 
 def dequeue(lst):
     # remove 1st item
     item = lst.pop(0)
     return item
 
 
 def reverseK(queue, k, n):
     # first deque k elements from queue and push them into stack
     stack = []
     for i in range(0, k):
         d_item = dequeue(queue)
         stack.append(d_item)
 
     # then pop all elements from stack and enque to queue
     while(len(stack) != 0):
         pi = stack.pop()
         enqueue(queue, pi)
 
     # now deque the remaining item and add them at last
     for i in range(0, len(queue)-k):
         d_item = dequeue(queue)
         enqueue(queue, d_item)
     return queue
 
 
 if __name__ == '__main__':
     print(""Enter the number of elements in array"")
     n = int(input())
     print(""Enter the array"")
     a = list(map(int, input().strip().split()))
     print(""Enter value of k"")
     k = int(input())
     queue = []  # our queue to be used
     for i in range(n):
         queue.append(a[i])  # enqueue elements of array in our queue
 
     print(*reverseK(queue, k, n))
 
 '''
 Sample Input/Output :
 
 Enter the number of elements in array
 5
 Enter value of k
 2
 Enter the array
 1 2 3 4 5
 
 Output: 2 1 3 4 5
 
 Time complexity : 0(n)
 Space complexity : 0(n)
 '''
",Python
"//Given a string S consisting only of opening and closing curly brackets '{' and '}' find out the minimum number of reversals required to make a balanced expression.
 //
 //        Input
 //        The first line of input contains an integer T, denoting the number of test cases. Then T test cases
 //        follow. The first line of each test case contains a string S consisting only of { and }.
 //
 //        Output
 //        Print out minimum reversals required to make S balanced. If it cannot be balanced, then print -1.
 //
 //        Constraints
 //        1 <= T <= 100
 //        0 <= |S| <= 50
 //
 //        Examples
 //        Input
 //        4
 //        }{{}}{{{
 //        {{}}}}
 //        {{}{{{}{{}}{{
 //        {{{{}}}}
 //
 //        Output
 //        3
 //        1
 //        -1
 //        0
 
 import java.util.Scanner;
 import java.util.Stack;
 
 public class Count_the_Reversals {
     public static void main(String[] args) {
         Stack ss=new Stack();
         System.out.println(ss.size());
 
         Scanner s=new Scanner(System.in);
         int t=s.nextInt();
         while (t-->0){
             Stack<Character> stack=new Stack<>();
             String str=s.next();
             if (str.length()%2!=0){
                 System.out.println(-1);
             }
             else {
                 for (int i = 0; i <str.length() ; i++) {
                     if(str.charAt(i)=='{'){
                         stack.push(str.charAt(i));
 
 
                     }
                     else {
                         if(!stack.isEmpty()&&stack.peek()=='{'){
                             stack.pop();
                         }
                         else {
                             stack.push(str.charAt(i));
                         }
                     }
 
                 }
                 int m=stack.size();
                 int n = 0;
                 while (!stack.empty() && stack.peek() == '{')
                 {
                     stack",Java
"// Java Program for Kadane's Algorithm.
 
 import java.util.*;
 public class kadanes_Java {
 
    public static void main(String[] args) {
       Scanner sc = new Scanner(System.in);
       int n = sc.nextInt();
       int[] arr = new int[n];
       int maxSoFar = Integer.MIN_VALUE;
       int curSum = 0;
       for (int i = 0; i < arr.length; i++) {
          arr[i] = sc.nextInt();
       }
       for (int i = 0; i < arr.length; i++) {
          if (curSum + arr[i] < 0)
             curSum = 0;
          else
             curSum = curSum + arr[i];
          if (curSum > maxSoFar)
             maxSoFar = curSum;
       }
       System.out.println(maxSoFar);
       sc.close();
    }
 }
",Java
"/*
 Sum of all the possible divisors of a natural number
 
 You will be given a natural number and your task is
 to find all possible divisors of the given number and
 return their sum as the output.
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 //function to sum up all the possible divisors of a natural number
 int divisorSum(int number)
 {
     int ans = 0;
     for(int pass = 2; pass <= sqrt(number); pass++)
     {
         //for i is a divisor then remainder must be 0
         if(number % pass == 0)
         {
             //if the divisors are same we count only one of 
             //them in sum
             if(pass == (number / pass))
             {
                 ans = ans + pass;
             }
             //otherwise we count both for sum
             else
             {
                 ans = ans + (pass + (number / pass));
             }
         }
     }
     return (ans + 1);
 }
 
 //driver code
 int main()
 {
     int number;
     cout << ""Enter a natural number: "";
     cin >> number;
     cout << ""Sum of all possible divisors of "" << number << "" is: "" << divisorSum(number);
     return 0;
 }
 
 /*
 EXAMPLE:-
 
 Example 1:-
 Input--
 Enter a natural number: 40
 Output--
 Sum of all possible divisors of 40 is: 90
 
 Example 2:-
 Input--
 Enter a natural number: 1
 Output--
 Sum of all possible divisors of 1 is: 1
 
 TIME COMPLEXITY--> O(sqrt(N))
 SPACE COMPLEXITY--> O(1)
 */
",C-Plus-Plus
"/*
 
 Interpolation search is a searching algorithm which works similarly to binary search i.e. it works on sorted array.
 Interpolation search finds a particular item by computing the probe position.
 
 If the middle item is greater than the item, then the probe position is again calculated in the sub-array to the right of the middle item.
 Otherwise, the item is searched in the subarray to the left of the middle item.
 
 Time Complexity - (log (log n))
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 function interpolationSearch(key) {
   let lowIndex = 0;
   let mid = -1;
   let highIndex = array.length - 1;
 
   // Check if key lies in the lowerBound & upperBound of array
   while (
     lowIndex <= highIndex &&
     key >= array[lowIndex] &&
     key <= array[highIndex]
   ) {
 
     // Check if array contains only one element
     if (array.length === 1) {
       if (key === array[lowIndex]) return console.log(""Found"", array[lowIndex]);
       return console.log(""Not Found"");
     }
 
     // Calculate the mid position ( or Probe )
     mid =
       lowIndex +
       Math.floor(
         ((highIndex - lowIndex) / (array[highIndex] - array[lowIndex])) *
           (key - array[lowIndex])
       );
 
     // Check whether the key is found, if not then update the range i.e lowerBound & upperBound
     if (array[mid] === key) {
       return console.log(""Found"", array[mid]);
     } else {
       if (array[mid] < key) {
         lowIndex = mid + 1;
       } else if (array[mid] > key) {
         highIndex = mid - 1;
       }
     }
   }
 
   return console.log(""Not Found"");
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i ",JavaScript
"""""""
 Julia program to find the Delannoy number for a given rectangular grid.
 A Delannoy number describes the number of paths from the southwest corner 
 (0, 0) of a rectangular grid to the northeast corner (m, n) using only single steps north, northeast, or east.
 Delannoy number is named after the French mathematican Henri Delannoy.
 """"""
 
 function delannoy_number(r, c)
 
     # Initialize the dp array with '0' as value.
     dp = zeros(Int, c + 1, r + 1)
 
     for i in 1:c
         dp[1,i] = 1
     end
     for i in 2:c+1
         dp[i,1] = 1
     end
     # From Each point calculate the number of paths, to the north-east point, that can be reached by 
     # traversing through the immediate right or immediate top or immediate top-right point.
     for i in 2:c+1
         for j in 2:r+1
             dp[i,j] = dp[i-1,j] + dp[i-1,j-1] + dp[i,j-1]
         end
     end
     return dp[c+1,r+1]
 end    
         
 
 print(""Enter the co-ordinates of the north-east corner.\nEnter the row co-ordinate: "")
 x = readline()
 x = parse(Int, x)
 print(""Enter the column co-ordinate: "")
 y = readline()
 y = parse(Int, y)
 res = delannoy_number(x, y)
 print(""The Delannoy number of the given grid is $res."")
 
 
 """"""
 Time Complexity - O(x * y), where `x`, `y` is the given co-ordinates.
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the co-ordinates of the north-east corner.
 Enter the row co-ordinate: 5
 Enter the column co-ordinate: 6
 The Delannoy number of the given grid is 3653.
 """"""
",Julia
"/* This is a simple program to check if we have a noble number or not
    from the given array. An integer is said to be Noble in an array
    if the number of integers greater than integer is equal to integer.
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 // global variables
 var number int
 var arr [100]int
 
 //This function helps us in finding the noble number
 func nobleInteger() int{
 
     for i:=0;i<number;i++ {
 
       count :=0
       for j:=0;j<number;j++ {
          if(arr[i]<arr[j]){
             count += 1
          }
       }
 
       // if the count of greater elements = arr[i]
       if(count == arr[i]){
          fmt.Print(""Noble integer is "",arr[i])
          return 1
       }
 
     }
 
     fmt.Printf(""Noble integer not found"")
     return 0
 }
 
 // driver function
 func main(){
 
     fmt.Print(""Enter the no of elements of the Array :"")
     //taking the array size
     fmt.Scan(&number)
 
     var n int
     fmt.Print(""Enter the elements of the array :"")
     // scanning the elements of the array
     for i:=0;i<number;i++ {
        fmt.Scan(&n)
        arr[i] = n
     }
 
     //calling the noble integer function 
     nobleInteger()
 
 }
 
 /* Sample I/O :
 
    a) If no noble integer :
 
    Enter the no of elements of the Array :5
    Enter the elements of the array :1 2 3 4 5
    Noble integer not found
 
    b) If there is noble number :
 
    Enter the no of elements of the Array :5
    Enter the elements of the array :10 3 20 40 2
    Noble integer is 3   
 */
 
",Go
"/*
 This problem is solved using dp.
 In this problem we have to check whether the values of subset of array is equal to sum or not.
 if equal then we will return true else we will return false.
 */
 #include <iostream>
 using namespace std;
 
 // This function is for checking whther the subset of array sum is equal to value or not
 bool subsetSum(int arr[], int sum, int n)
 {
     // We will create matrix t of size (n+1)*(sum+1)
     int t[n + 1][sum + 1];
 
     /* if j is 0 i.e. sum is 0 and i i.e. arr has whatever values it will always return true
     because if sum is 0 then we don't need to find if subset of array is equal to sum or not */
     for (int i = 0; i <= n; i++) {
         t[i][0] = true;
     }
 
     /* But if i is 0 i.e array has no value and sum has some value then we can nver make 
     subset of array value equal to sum so it will always give false */
     for (int j = 0; j <= sum; j++) {
         t[0][j] = false;
     }
 
     for (int i = 0; i <= n; i++) {
         for (int j = 0; j <= sum; j++) {
             // if subset sum value equal to sum the we will return true
             if (arr[i - 1] == j) {
                 t[i][j] = true;
             }
             // if subset sum value less than sum then we will proceed further and we add value to it
             else if (arr[i - 1] < j) {
                 t[i][j] = t[i - 1][j - arr[i - 1]];
             }
             // if subset sum value grater than sum then we will proceed further
             else {
                 t[i][j] = t[i - 1][j];
             }
         }
     }
     return t[n][sum];
 }
 
 // driver code
 int main()
 {
     // n is size of array
     int n, sum;
     cin >> n >> sum;
     int arr[n + 1];
 
     // input array
     for (int i = 0; i < n; i++) {
         cin >> arr[i];
     }
 
     /* by recalling function we will check if function return true we will print Yes 
     else we will print No */
     if (subsetSum(arr, sum, n) == true) {
         cout << ""Yes"" <",C-Plus-Plus
"/* Prime Factorization using Sieve */
 
 using System; 
 using System.Collections; 
   
 class PFS
 { 
     static int MAX = 100001; 
     static int[] small_pf = new int[MAX]; 
       
     static void prime_sieve() 
     { 
         small_pf[1] = 1; 
         for (int i = 2; i < MAX; i++) 
             small_pf[i] = i; 
       
         for (int i = 4; i < MAX; i += 2) 
             small_pf[i] = 2; 
       
         for (int i = 3; i * i < MAX; i++) 
         { 
             if (small_pf[i] == i) 
             { 
                 for (int j = i * i; j < MAX; j += i) 
                     if (small_pf[j] == j) 
                         small_pf[j] = i; 
             } 
         } 
     } 
 
     static ArrayList get_Factor(int x) 
     { 
         ArrayList r = new ArrayList(); 
         while (x != 1) 
         { 
             r.Add(small_pf[x]); 
             x = x / small_pf[x]; 
         } 
         return r; 
     } 
       
     public static void Main() 
     { 
         prime_sieve(); 
         Console.WriteLine(""Enter a value:"");
         int val = Convert.ToInt32(Console.ReadLine());
         
         Console.WriteLine(""Prime factors are:""); 
         ArrayList p = get_Factor(val); 
       
         for (int i = 0; i < p.Count; i++) 
             Console.Write(p[i] + "" ""); 
         Console.WriteLine(""""); 
     } 
 } 
   
 /* OUTPUT
 
 Enter a value:                                                                                                                                
 562                                                                                                                                           
 Prime factors are:                                                                                                                            
 2 281
 
 */",C-Sharp
"/**
  *
  * Merge sort uses the concept of divide-and-conquer to sort the given list of elements.
  * It breaks down the problem into smaller subproblems until they become simple enough to solve directly.
  * 
  * Time Complexity: O(nlogn)
  * 
  * Space Complexity: O(n) 
  */
 function merge(left, right) {
   let arr = [];
   // Break out of loop if any one of the array gets empty
   while (left.length && right.length) {
     // Pick the smaller among the smallest element of left and right sub arrays
     if (left[0] < right[0]) {
       arr.push(left.shift());
     } else {
       arr.push(right.shift());
     }
   }
 
   // Concatenating the leftover elements
   // (in case we didn't go through the entire left or right array)
   return [...arr, ...left, ...right];
 }
 
 function mergeSort(array) {
   const half = array.length / 2;
 
   // Base case or terminating case
   if (array.length < 2) {
     return array;
   }
 
   const left = array.splice(0, half);
   return merge(mergeSort(left), mergeSort(array));
 }
 
 var array = prompt(""Enter Numbers to Sort (Comma Separated) : "").split("","");
 // You Can also give static input if prompt() not works for you. like this :
 // array = [4, 8, 7, 2, 11, 1, 3];
 
 console.log(mergeSort(array));
 
 /*
  * Sample Input:
  * 96,56,53,85,115,20
  *
  * Sample Output:
  * 20,53,56,85,96,115
  */
",JavaScript
"/*
 The traversal operation is a frequently used operation on a binary tree. This operation is used to visit each node in the tree exactly once
 A full traversal on a binary tree gives a linear ordering of data in the tree .  This is the iterative postorder tree traversal algorithms
 */
 #include <stdio.h>
 #include <stdlib.h>
 //structure for the binary tree node
 typedef struct Tree
 {
     char data;
     struct Tree *left;
     struct Tree *right;
 } TreeNode;
 //structure for stack which is used for the iterative traversal algorithms
 //stack is implemented using linked list
 typedef struct Stack
 {
     TreeNode *node;
     struct Stack *next;
 } Stack;
 //push operation for the stack
 void push(Stack **s, TreeNode *node)
 {
     Stack *New = (Stack *)malloc(sizeof(Stack));
     New->node = node;
     New->next = (*s);
     (*s) = New;
 }
 // pop operation for the stack
 TreeNode *pop(Stack **s)
 {
     if ((*s) != NULL)
     {
         TreeNode *ptr = (*s)->node;
         (*s) = (*s)->next;
         return ptr;
     }
 }
 //checks whether the stack is empty or not
 int isEmpty(Stack **s)
 {
     if ((*s) == NULL)
     {
         return 1;
     }
     return 0;
 }
 //iterative postorder traversal
 void postorder(TreeNode *root)
 {
     Stack *s1 = NULL;
     Stack *s2 = NULL;
     TreeNode *ptr = root;
     push(&s1, root);
     while (!isEmpty(&s1))
     {
         ptr = pop(&s1);
         if (ptr != NULL)
         {
             push(&s2, ptr);
         }
         if (ptr->left)
         {
             push(&s1, ptr->left);
         }
         if (ptr->right)
         {
             push(&s1, ptr->right);
         }
     }
     while (!isEmpty(&s2))
     {
         printf(""%c "", pop(&s2)->data);
     }
 }
 //Search_Link returns the pointer to the node which contains the value key , it is used in the insertion operation
 TreeNode *Search_Link(TreeNode *root, char key)
 {
     TreeNode *ptr = root;
     if (ptr->data != key)
     {
         if (ptr->left != NU",C
"/*
    This program will print Left view of tree by using concept of Depth First Search with some modification
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 struct node {
 	node(int x): data(x), left_child(NULL), right_child(NULL) {}
 	int data;
 	node *left_child;
 	node *right_child;
 };
 
 class bin_tree {
 	node *root;
   public:
 	// constructor of tree
 	bin_tree() {
 		root = NULL;
 	}
 	void insert_data(int x) {
 		//if tree is empty
 		if (!root) {
 			node *tnode = new node(x);
 			root = tnode;
 		}
 		//if tree if not empty
 		else {
 			node *temp = root;
 			while (1) {
 				//if data to be inserted is less then the data of current node
 				if (x < temp->data ) {
 					//if left child of current node is node present
 					///we simple add new node with the data to be inserted
 					if (!temp->left_child) {
 						node *tnode = new node(x);
 						temp->left_child = tnode;
 						break;
 					}
 					//else we change the current node pointer 
 					//with pointer of left child node pointer
 					else
 						temp = temp->left_child;
 				}
 				//if data to be inserted is grater then 
 				//or equal to the data of current node
 				else {
 					//if right child of current node is node present 
 					//we simple add new node with the data to be inserted
 					if (!temp->right_child) {
 						node *tnode = new node(x);
 						temp->right_child = tnode;
 						break;
 					}
 					//else we change the current node pointer 
 					//with pointer of left child node pointer
 					else
 						temp = temp->right_child;
 				}
 			}
 		}
 	}
 	void left_view(node* , int& , int );
 	void left_view_of_tree();
 };
 
 void bin_tree :: left_view_of_tree() {
 	
 	int last = 0;
 	int current = 1;
 	left_view(root, last, current);
 }
 
 void bin_tree :: left_view(node* r, int &l, int c) {
 	//if no node is found
 	if (!r)
 		return;
 	//if we are at unvisited level
 	if (c > l) {
 		cout << r->data << "" "";
 		l++;
 	}
 
 	left_view(r->left_child, l, c + 1);
",C-Plus-Plus
"/* C++ program to compute factorial of big numbers
    We will we finding factorial of quite big numbers,
    which can't be solved with the general approach of recursion */
    
 #include<bits/stdc++.h>
 using namespace std;
 
 /* This function calculates product and carry,
    `rsize` is size of vector `res`*/
 int multiply(int x, vector<int> &res, int rsize){
 
     int carry = 0;
 	for (int i=0; i<rsize; i++)
 	{
 		int product = res[i] * x + carry;
 
 		/* Storing the last digit of `prod` in res */
 		res[i] = product % 10;
 		carry = product/10;
 	}
 
 	/* Put carry in res and increment the result size */
 	while (carry)
 	{
 		res.push_back(carry%10);
 		carry = carry/10;
 		rsize++;
 	}
 	return rsize;
 }
 
 /* Function finds factorial of large numbers
    and prints them */
 void largeFactorial(int num)
 {
 	vector<int> res; 
 	res.push_back(1);
 	int rsize = 1;
 
 	/* Applying general factorial formula */
 	for (int x=2; x<=num; x++)
 		rsize = multiply(x, res, rsize);
 
 	cout << ""Factorial of ""<< num << "" is : "";
 	for (int i=rsize-1; i>=0; i--)
 		cout << res[i];
 }
 
 /* Driver Function */
 int main()
 {
 	int num;
 	/*Taking input of the number*/
 	cout << ""Enter the number : "";
 	cin >> num;
     largeFactorial(num);
     return 0;
 }
 
 /*
 SAMPLE I/O =>
 1.
 Enter the number : 51
 Factorial of 51 is : 1551118753287382280224243016469303211063259720016986112000000000000
 2.
 Enter the number : 69
 Factorial of 69 is : 171122452428141311372468338881272839092270544893520369393648040923257279754140647424000000000000000
 Time complexity : O(n^2)
 Space complexity : O(log(n!))
 */
",C-Plus-Plus
"def get_index(arr: list, N: int, key: int, search_left: bool) -> int:
     """"""Returns left-most or right-most index of key in a sorted list arr. 
 
     This function takes an list and a key and finds 
     the left most or right most index of that key in the list depending
     on the value of search_left flag using binary search technique.
 
     Parameters
     -------------
         arr         : The list in which search is to be performed
         N           : size of the list
         key         : The element whose frequency is to be calculated
         search_left : To indicate search direction 
 
     Returns
     -------------
         index       : The left-most or right-most index 
     """"""
     # initializing necessary variables
     left = 0
     right = N - 1
     found_index = -1
 
     # Performing binary search using search_left flag
     while left <= right:
         mid = (left + right) // 2
 
         if arr[mid] == key:
             found_index = mid
             if search_left:
                 right = mid - 1
             else:  # search right
                 left = mid + 1
 
         elif arr[mid] > key:
             right = mid - 1
 
         else:
             left = mid + 1
 
     return found_index
 
 
 def get_freq_using_bs(arr, N, key):
     """""" Returns frequency of Key in arr using Binary Search
 
     This function internally calls get_index() function to 
     find left most and right most index of a key and calculates
     total occurence.
 
     Parameters
     -------------
         arr     : The list in which search is to be performed
         N       : size of the list
         key     : The element whose frequency is to be calculated
 
     Returns
     -------------
         -1      : if Key is not present
         count   : The frequency of key
     """"""
 
     # Sorting inorder to use binary search
     # use any stable sorting algorithm
     arr.sort()
 
     # finding first and last occurrence of key
     first_occurence",Python
"''' python program for Euler's Totient Function '''
 def euler_totient(num):
     ''' Takes in a variable num and return the number of coprimes of n '''
     arr=[]
     for count in range(num + 1):
         arr.append(count)
         
     for count in range(2, num + 1):
       '''if this condition is satisfied then we are removing the coprimes of j '''
       if arr[count] == count:                    
             for j in range( count ,num + 1 ,count):
                 arr[j] -= (arr[j] / count)  
                     
     return int(arr[num])  
     
     
 print(""Enter a number : "")
 ''' taking input from the user '''
 num = int(input())                       
 if(num < 0):                   
     print(""inavlid input"")
 else:
     print(euler_totient(num))
     
 '''sample input
 euler_totient(4) will be 2 as coprime will be (1,4),(3,4)
 euler_totient(6) will be 2 as coprime will be (1,6),(5,6)
 euler_totient(9) will be 6 as coprime will be (1,9),(2,9),(4,9),(5,9),(7,9),(8,9)
 here we are considering (2,3) and (3,2) as same pair
  '''
",Python
"/*
  Given a singly linked list of integers, sort it using 'Merge Sort.'
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Node {
   public:
     int data;
   Node * next;
   Node(int data) {
     this -> data = data;
     this -> next = NULL;
   }
 };
 
 //function to take input from the user
 
 Node * takeinput() {
   int data;
   cin >> data;
   Node * head = NULL, * tail = NULL;
   while (data != -1) {
     Node * newnode = new Node(data);
     if (head == NULL) {
       head = newnode;
       tail = newnode;
     } else {
       tail -> next = newnode;
       tail = newnode;
     }
     cin >> data;
   }
   return head;
 }
 
 //function to print the linked list
 
 void print(Node * head) {
   Node * temp = head;
   while (temp != NULL) {
     cout << temp -> data << "" "";
     temp = temp -> next;
   }
   cout << endl;
 }
 
 //function to calculate the mid point of linked list
 
 Node * midPoint(Node * head) {
   if (head == NULL || head -> next == NULL) {
     return head;
   }
   Node * slow = head;
   Node * fast = head -> next;
   while (fast != NULL && fast -> next != NULL) {
     slow = slow -> next;
     fast = fast -> next -> next;
   }
   return slow;
 }
 
 //function to merge two sorted linked lists
 
 Node * merge(Node * head1, Node * head2) {
   Node * headnew = NULL;
   Node * tailnew = NULL;
   if (head1 == NULL)
     return head2;
   if (head2 == NULL)
     return head1;
   if (head1 -> data < head2 -> data) {
     headnew = head1;
     tailnew = head1;
     head1 = head1 -> next;
   } else {
     headnew = head2;
     tailnew = head2;
     head2 = head2 -> next;
   }
   while (head1 != NULL && head2 != NULL) {
     if (head1 -> data < head2 -> data) {
       tailnew -> next = head1;
       tailnew = head1;
       head1 = head1 -> next;
     } else {
       tailnew -> next = head2;
       tailnew = head2;
       head2 = head2 -> next;
     }
   }
   if (head1 == NULL) {
     tailnew -> next = head2;
   } else if (head2 == NULL) {
    ",C-Plus-Plus
"/*
 This algorithm is used to calculate nCr under some mod.
 
 nCr = factorial(n)/(factorial(r)*factorial(n-r))
 
 nCr%mod = factorial(n)*inverse(factorial(r))%mod*inverse(factorial(n-r)%mod)%mod (here inverse is modinverse)
 
 We use Fermat's little theorem to calculate modinverse of a value
 According to Fermat's little theorem 
 num^(p-1)=1(mod p)
 Multiplying by side by num^-1, we get
 num^(p-2)=num^-1(mod p)
 
 So, to get inverse, we need to calulate (mod-2)th power of num under modulo mod.
 */
 
 import 'dart:io';
 
 int inverse(int val, int mod) {
   int power = mod - 2;
   int answer = 1;
   while (power > 0) {
     if (power % 2 == 1) {
       answer = ((answer * val).floor() % mod).floor();
     }
     val = ((val * val).floor() % mod).floor();
     power = (power / 2).floor();
   }
   return answer;
 }
 
 int nCr(int n, int r, int mod) {
   late int facn, facr, facnr;
   int curr_value = 1;
   for (int i = 1; i <= n; ++i) {
     curr_value = curr_value * i;
     if (i == n) {
       facn = curr_value;
     }
     if (i == r) {
       facr = curr_value;
     }
     if (i == n - r) {
       facnr = curr_value;
     }
   }
   int answer = facn * inverse(facr, mod) % mod * inverse(facnr % mod, mod) % mod;
   return answer;
 }
 
 void main() {
   int n, r, mod;
   print(""Enter value of n: "");
   n =  int.parse(stdin.readLineSync()!);
   print(""Enter value of r: "");
   r = int.parse(stdin.readLineSync()!);
   print(""Enter value of mod: "");
   mod = int.parse(stdin.readLineSync()!);
   int nCrUnderMod = nCr(n, r, mod);
   print(""nCr%mod = $nCrUnderMod"");
 }
 
 /*
 Sample I/O
 
 1. 
     INPUT 
     Enter value of n: 3
     Enter value of r: 2
     Enter value of mod: 1
     OUTPUT
     nCr%mod = 0
 2.
     INPUT
     Enter value of n: 11
     Enter value of r: 7 
     Enter value of mod: 13
     OUTPUT
     nCr%mod = 5
 */
 
 /*
   Time Complexity: O(n)
   Space Complexity: O(1)
 */
",Dart
"/* This program implements Doubly Linked List for creation,insertion and Reversing the Linked List
 
 A Doubly Linked List (DLL) contains an extra pointer, typically called previous pointer, together with next pointer and data which are there in singly linked list.
 
 @author: GudlaArunKumar
 @created: 30/06/2020
 */
 
 
 
 #include <iostream>
 using namespace std;
 
 struct Node{          // Created structure Node which contains Data, previous and Next pointer 
     struct Node *prev;
     int data;
     struct Node *next;
 }*first=NULL;         //Declared struct object as First globally
 
 void create(int arr[],int n){   //Creation of Doubly Linked List
 struct Node *tmp,*last;
 first=new Node;
 first->data=arr[0];
 first->prev=first->next=NULL;
 last=first;
 for(int i=1;i<n;i++)
 {
  tmp = new Node;
  tmp->data = arr[i];
  tmp->next=last->next;
  tmp->prev=last;
  last->next=tmp;
  last=tmp;
 }
  }
  
 void display(struct Node *p)   //Displaying the elements in Doubly Linked List while travsersing through Next pointer only
 {
      cout <<""Elements in doubly Linked list are:"" << endl;
     while(p!=NULL)
     {
         cout << p->data << "" "";
         p=p->next;
     }
     cout << endl;
 }
 
 int Length(struct Node *p)   //Calculates Length of DLL
 {
     int count =0;
     while(p!=NULL)
     {
         count++;
         p=p->next;
     }
     return count;
 }
 
 void Insert(int pos,int x)   //Insertion operation takes place with repect to position given by User
 {
     struct Node *tmp,*p=first;
     if(pos==0)
     {
      tmp = new Node;
      tmp->data=x;
      tmp->next=first;
      tmp->prev=NULL;
      first->prev=tmp;
      first=tmp;
     }
 else
 {
     tmp = new Node;
     tmp->data=x;
     for(int i=0;i<pos-1;i++)
     {
         p=p->next;
     }
     tmp->next=p->next;
     tmp->prev=p;
     if(p->next)
     {
         p->next->prev=tmp;
     }
     p->next=tmp;
 }
 }
 
 void ReverseList(struct Node *p)   //Reversing the DLL by swapping Prev and ",C-Plus-Plus
"/*
 This is a code of circular queue data structure. It is a linear data structure, which obeys the principal
  of First in First Out(FIFO). Circular queue data structure is a updated version of linear queue data structure,
  which have some advantages over linear queue. The following code shows the implementation of circular queue data structure,
  in a very clean and understandable way.
 */
 
 #include<iostream>
 #include<stdlib.h>
 
 // Defining max size of the queue as 5
 
 #define max 5
 
 using namespace std;
 
 // Writing a class where all the basic functions of the circular queue presides
 
 class CircularQueue
 {
     /*
     Defining all the variables as public variables.
     (It is not necessory of define the variables as public,you can define the variables as private also)*/       
     public:
     int front;
     int rear;
     int arr[max];
 
     // Initializing a default constructor of the class
     CircularQueue(){
     front = -1;
     rear = -1;
         for(int i = 0; i < max; i++){
             arr[i] = 0;
         }
     }
 
     // Defining the isFull function to check whether the queue is full or not
     bool isFull(){
         if ((rear + 1) % max == front)
             return true;
         else
             return false;
     }
 
     // Defining the isEmpty function to check whether the queue is empty or not
     bool isEmpty(){
         if (front == -1 && rear == -1)
             return true;
         else
             return false;
     }
 
     // Defining the enqueue function, to insert an item in the queue
     void enqueue(int item){
         if(isFull())
         {
             cout << ""Queue is full"" << endl;
         }
         else if (isEmpty()){
             front=rear=0;
             arr[rear] = item;
         }
         else {
             rear = (rear + 1) % 5;
             arr[rear] = item;
         }
 
     }
 
     // Defining the dequeue function, to delete item from the queue
     int dequeue(){
         int x = 0;",C-Plus-Plus
"/*
 __Kth largest element in an array__
 Given an array of integers of size n and an integer k, find the kth largest number in the array.
 
 Input:
 Integer n denoting the size of input array
 Next line contains n space-separated numbers denoting the array elements.
 Next line contains integer k.
 
 Output:
 single line containing the kth largest element of array.
 */
 
 import java.util.*;
 
 public class Kth_largest_element_in_array {
 
     public static int findKthLargest(int[] arr, int k) {
         //checking that test case is valid or not
         if(arr.length == 0 || k > arr.length) return Integer.MIN_VALUE;
 
         //Declaring a priority queue to store values
         PriorityQueue<Integer> priority_queue = new PriorityQueue<>();
         
         for(int indx = 0; indx < arr.length; indx++){
             //add every element of array to priority queue
             priority_queue.add(arr[indx]);
 
             //if number of elements (indx+1) is more than k, remove number from queue
             if (indx+1 > k) priority_queue.poll();
         }
         
         //kth largest number = top of priority queue
         return priority_queue.peek();
     }    
     public static void main(String[] args){
 
         Scanner inp = new Scanner(System.in);
         int n = inp.nextInt();
         int[] numbers = new int[n];
 
         for(int x = 0; x < n; x++){
             numbers[x] = inp.nextInt();
         }
 
         int k = inp.nextInt();
 
         System.out.println(findKthLargest(numbers, k)); 
 
         inp.close();
     }
 }
 
 /*Sample I/O
 Sample 1
 5          -> n
 6 8 2 4 1  -> array elements
 2          -> k
 
 6    (Output)
 
 Sample 2
 10
 2 8 5 6 7 0 1 5 9 6
 5
 
 6    (Output)
 
 Time Complexity = O(n + klogn)
 Space Complexity = O(n)
 */
 
",Java
"/*
 C program to check whether the number is automorphic or not.
 Automorphic number is a number whose square ends with the original number itself
 */
 #include <stdio.h>
 
 int automorphic_num(int);
 int main()
 {
 	int n, l;
 	printf(""Enter the number to check:\n"");
 	scanf(""%d"", &n);
 	l = automorphic_num(n);
 	if (l == n)
 		printf(""\nAUTOMORPHIC NUMBER !"");
 	else
 		printf(""\nNOT AUTOMORPHIC NUMBER !"");
 	return 0;
 }
 
 // Function to check if the number is automorphic or not
 int automorphic_num(int n)
 {
 	int s, temp, l;
 	temp = n;
 	s = n * n;
 	int flag = 1;
 	while (n != 0)
 	{
 		flag = flag * 10;
 		n = n / 10;
 	}
 
 	l = s % flag;
 	return l;
 }
 
 /*
 Sample Input-Output:1
 Enter the number to check:
 7
 NOT AUTOMORPHIC NUMBER !
 
 Sample Input-Output:2
 Enter the number to check:
 5
 AUTOMORPHIC NUMBER !
 
 Time Complexity: O(n)
 */
 
",C
"'''
 Given an array Arr that contains N integers (may be positive, negative or zero).
 Find the product of the maximum product subarray.
 
 Example 1:
 
 Input:{6, -3, -10, 0, 2}
 Output: 180
 Explanation: Subarray with maximum product
 is  6, -3, -10 which gives product as 180.
 Example 2:
 
 Input:{2, 3, 4, 5, -1, 0}
 Output: 120
 Explanation: Subarray with maximum product
 is 2, 3, 4, 5 which gives product as 120.
 
 '''
 def maximum_product_subarray(arr):
     arr2 = arr[::-1]
     for i in range(1, len(arr)):
         arr[i] *= arr[i - 1] or 1
         arr2[i] *= arr2[i - 1] or 1
     return max(arr + arr2)
 
 if __name__ == ""__main__"":
     arr = list(map(int,input(""Enter the number: "").split()))
     print(""Maximum Subarray product is "",maximum_product_subarray(arr))
 
 '''
 Time complexcity  = O(n)
 space complexcity = O(1)
 
 INPUT 
 Enter the Number: 6 -3 -10 0 2
 
 OUTPUT
 Maximum Subarray product is 180
 '''
",Python
"#include<bits/stdc++.h>
 using namespace std;
 
 int main() {
 
   int m, n;
   cout << ""Enter the total number of elements in array1 and array2 respectively\n"";
   cin >> m >> n;
 
   int arr1[m], arr2[n];
   cout << ""enter 1st array elements\n"";
   for (int i = 0; i < m; i++) {
     cin >> arr1[i];
   }
   cout << ""enter 2nd array elements\n"";
   for (int i = 0; i < n; i++) {
 
     cin >> arr2[i];
   }
   
   // iterating through first array from the end and the second array from start.
   for (int i = m - 1, j = 0; i >= 0 && j < n; i--, j++) {
     int temp;
     // swap if number in 1st array is greater than 2nd array.
     if (arr1[i] > arr2[j]) {
       swap(arr1[i] , arr2[j]); 
     }
   }
   
   //sorting both the arrays to get final result.
   sort(arr1, arr1 + m);
   sort(arr2, arr2 + n);
   cout << ""answer: "";
   for (int i = 0; i < m; i++) {
     cout << arr1[i] << "" "";
   }
   for (int i = 0; i < n; i++) {
     cout << arr2[i] << "" "";
   }
   cout << endl;
 
   return 0;
 }
 
 /*
 
 Time complexity : NlogN (where N will be max of n and m)
 
 Sample output:
 Enter the total number of elements in array1 and array2 respectively
 3 4
 enter 1st array elements
 2 4 6
 enter 2nd array elements
 1 3 5 7
 answer: 1 2 3 4 5 6 7
 
 */
",C-Plus-Plus
"/*
 
 Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
 
 An input string is valid if:
     1) Open brackets must be closed by the same type of brackets.
     2) Open brackets must be closed in the correct order.
 
 Time Complexity - O(n)
     
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Object with respective brackets pairs
 const paris = {
   ""("": "")"",
   ""{"": ""}"",
   ""["": ""]"",
 };
 
 // Check if string is valid or not
 const isValid = (string) => {
   if (string.length === 0) return false;
 
   const stack = []; // Create stack
 
   for (let x = 0; x < string.length; x++) {
     if (paris[string[x]]) {
       stack.push(string[x]); // if character exists , push it into the stack
     } else {
       const leftBracket = stack.pop(); // get the top most bracket from stack
       const correctBracket = paris[leftBracket]; // get the right bracket of the left bracket
       if (string[x] !== correctBracket) return false; // return if they don't match
     }
   }
 
   return stack.length === 0;
 };
 
 // Take string as input
 let string = prompt(""Enter first string  - "");
 
 // Call the algortihm
 let isValidString = isValid(string);
 
 if (isValidString) console.log(""It's valid"");
 else console.log(""It's not valid"");
 
 /*
 
 > node ValidParentheses
 
 1) Enter first string  - {()[]}
 It's valid
 
 2) Enter first string  - {)
 It's not valid
 
 */
 
",JavaScript
"/*
 A stack is a linear data structure in which elements are added and removed only from
 one end which is called the top. Hence, a stack is called a LIFO (Last-in-First-out) data structure.    
     In this program, the stack is sorted in ascending order without using another user defined stack.
 Using the sort function, the elements of the stack are first popped out of the stack in a recursive manner.
 Then, the insert function is called which pushes the elements back in the stack in ascending order. 
 */
 #include <stdio.h>
 #include <stdlib.h>
 
 struct stack
 {
 	int *arr;
 	int top;
 	int size;
 };
 
 //push function of stack
 void push(struct stack **s, int x)
 {
 	if ((((*s)->top)) == ((*s)->size) - 1)
 		printf(""STACK OVERFLOW\n"");
 	else
 	{
 		((*s)->top) += 1;
 		(*s)->arr[(*s)->top] = x;
 	}
 }
 
 //pop function of stack
 int pop(struct stack **s)
 {
 	if ((*s)->top != -1)
 	{
 		int n = (*s)->arr[(*s)->top];
 		((*s)->top) --;
 		return n;
 	}
 }
 
 //display function of stack
 void display(struct stack **sta)
 {
 	struct stack *s = *sta;
 	if (s->top == -1)
 		return;
 	else
 	{
 		int n = pop(&s);
 		printf(""%d "", n);
 		display(&s);
 		push(&s, n);
 	}
 }
 
 //function used by sort function to push elements back in stack in ascending order
 int insert(struct stack **sta, int x)
 {
 	struct stack *s = *sta;
 	if (s->top == -1 || s->arr[s->top] > x)
 	{
 		push(&s, x);
 		return 0;
 	}
 
 	int n = pop(&s);
 	insert(&s, x);
 	push(&s, n);
 }
 
 //function to sort the stack
 void sort(struct stack **s)
 {
 	int n = pop(&(*s));
 	if ((*s)->top != -1)
 		sort(&(*s));
 	insert(&(*s), n);
 }
 
 void main()
 {
 	struct stack *s = (struct stack *) malloc(sizeof(struct stack));
 	printf(""Enter the size of stack : "");
 	scanf(""%d"", &s->size);
 	s->arr = (int*) malloc((s->size) *(sizeof(int)));
 	s->top = -1;
 	int op;
 	char c = 'Y';
 	while (c == 'y' || c == 'Y') {
 		printf(""\nEnter an option:\n1.push()\t2.pop()\n3.display()\t4.sort()\n"");
 		printf(""Enter yo",C
"'''
 A program that returns the count of perfect squares less than or equal to a given number.
 It also displays those numbers which are perfect squares within the range of that number.
 The number should be greater than or equal to 1
 '''
 #importing math function as it will be used for square root
 import math
 #count function
 def countsq(n):
     c=0
     for i in range(1,n+1):
         x=int(math.sqrt(i))
 		#Checks whether the number is perfect square or not
         if((x*x)==i):
             c=c+1
             print(i)
     return c
 #Driver's code
 def main():
     n1=int(input(""Enter a number""))
     c1=countsq(n1)
     print(""The number of perfect squares are"",c1)
 if __name__==""__main__"":
     main()
 
 
 '''
 Time Complexity:O(n)
 Space Complexity:O(1)
 
 Input/Output
 Enter a number 55
 1
 4
 9
 16
 25
 36
 49
 The number of perfect squares are 7
 '''
",Python
"/* side views of any binary tree
 we can view the tree from two sides , i.e left and right.
 */
 // including the header files
 #include <bits/stdc++.h>
  using namespace std;
  //creating a class to define the node structure
  class Node{
    public://access specifier since all the the members in a class are by default private
      int val;
      Node* left;
      Node* right;
  };
  Node* create(Node* root)
     {
     int x;
     //firstly the left half of the tree will be constructed and then the right half
     cin>>x;
     if (x== -1)
     {
     return NULL;
     } 
     root=new Node;
     root->val=x;
     cout<<""enter left child""<<endl;
     root->left=create(root->left);
     cout<<""enter right child""<<endl;
     root->right=create(root->right);
     return root;
 }
 
    void inorder(Node* root)
    {
    if(!root)
    {
    return;
     }
    inorder(root->left);
    cout<<root->val<<endl;
    inorder(root->right);
    }
 
  /* we make a fuction ""RightView"" to print the right side of the tree.
     to print the right view we need to print all the rightmost elements in the level order traversal.
     therefore we approach the problem by defining a queue to store the elements for our each level and checking to print the rightmost node of the level.
  */
 
  void RightView(Node* root)
  {
  	if (root==NULL)
  	{  
  	return;
     }
    //declaring the queue 
      queue<Node*>q;
      q.push(root);
      //test conditions
      while(!q.empty())
      {
       int 	nodes = q.size();
       for(int i=0;i<nodes;i++)
       {
       	//storing the nodes of each traversal in the a current variable and thereby popping it until we have an empty queue.
       	Node* current = q.front();
       	q.pop();
       	
       	
       	if(i==(nodes-1))//test condition to print the rightmost node in the presesnt level .
       	{
       		cout<<current->val<<"" "";
 		  }
 		  //checking if the nodes have any successor nodes, if they are presesnt we push them in the queue",C-Plus-Plus
"/* Shamir's Secret Sharing algorithm:
  * Generates a specified number of shares
  * where putting together a fixed number of
  * a subset of those shares reveals an encoded
  * secret value.
  */
 
 #include<iostream>
 #include<vector>
 #include<map>
 #include<random>
 #include<type_traits>
 using namespace std;
 
 // Chosen RNG engine: mersenne twister
 mt19937 rng;
 // Global seed for chosen RNG engine
 mt19937::result_type seed_val;
 
 /* Initialise chosen RNG with seed value that is
  * entropy taken from system's entropy source
  * (generally /dev/urandom on Linux).
  */
 void rng_init() {
     random_device rand_dev;
     seed_val = rand_dev();
     rng.seed(seed_val);
 }
 
 /* Populate a vector with specified number
  * of random natural numbers generated by chosen RNG.
  */
 vector<unsigned> gen_rand_uints(unsigned num) {
     rng_init();
 
     // Use random values from a uniform distribution
     uniform_int_distribution<unsigned> uint_dist;
     vector<unsigned> rand_ints;
     for (unsigned i = 0; i < num; i++) {
         rand_ints.push_back(uint_dist(rng));
     }
 
     return rand_ints;
 }
 
 /* Generate a map from share number to share value for
  * Shamir's Secret Sharing algorithm, using the specified
  * secret natural number that is to be protected.
  *
  * The shares are a set of points which map from values of
  * x to values of f(x), where f(x) is a polynomial of
  * degree (min_shares - 1), and f(0) = secret.
  */
 map<unsigned, unsigned> sss_gen_shares(unsigned min_shares, unsigned max_shares, unsigned secret) {
     vector<unsigned> poly_coeffs = gen_rand_uints(min_shares - 1);
     map<unsigned, unsigned> shares;
     for (unsigned x = 1; x <= max_shares; x++) {
         unsigned y = secret; // f(0)
         for (unsigned i = 1; i <= poly_coeffs.size(); i++) {
             unsigned term = poly_coeffs[i] * unsigned(pow(x, i));
             y += term;
         }
         shares[x] = y;
     }
 
     return shares;
 }
 
 /* Recover the secre",C-Plus-Plus
"/*
 Retrieve Binary Search Tree
 
 You are provided with the roots of the binary search tree
 where it has been conditionaaly mentioned that
 any two of the nodes of the tree are swapped by mistake.
 Your task is to recover the original tree without 
 changing any any of its configuration.
 You have been asked to find a solution without the use of 
 extra space i.e. constant space.
 */
 
 import java.io.*;
 import java.util.Scanner;
 import java.util.*;
 
 //defining a class for storing nodes of tree
 class BTNode 
 {
     int value;
     BTNode left;
     BTNode right;
     BTNode() 
     {}
     BTNode(int value) 
     {
         this.value = value; 
     }
     BTNode(int value, BTNode left, BTNode right) 
     {
         this.value = value;
         this.left = left;
         this.right = right;
     }
 }
 
 public class RetrieveBST
 {
     //function of to recover the changed binary 
     //search tree
     public void retrieveTree(BTNode root){
         if(root == null) 
         {
             return;
         }
 
         BTNode previous = null;
         BTNode first = null, second = null;
 
         while(root != null)
         {
             //for no node present at the left side of the tree
             if(root.left == null)
             {
                 //we print root
                 if(previous != null && previous.value > root.value)
                 {
                     if(first == null)
                     {
                         first = previous;
                     }
                     second = root;
                 }
                 previous = root;
 
                 root = root.right;
             }
             else
             {
                 BTNode temp = root.left;
                 while(temp.right != null && temp.right != root)
                 {
                     temp = temp.right;
                 }
 
                 if(temp.right == null)
                 {
                     //then we move to extreme left
       ",Java
"/*
 In mathematics, matrix addition is the operation of adding two matrices by adding 
 the corresponding entries together.This program takes two matrices of order n*m and 
 stores it in two-dimensional array. Then, the program adds these two matrices and 
 displays it on the screen.
 */
 
 import java.util.Scanner;
 
 class Code {
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the number of rows of the first matrix"");
         int n1 = sc.nextInt();
         System.out.println(""Enter the number of columns of the first matrix"");
         int m1 = sc.nextInt();
         System.out.println(""Enter the elements of the first matrix"");
         int arr_1[][] = new int[n1][m1];
         for (int i = 0; i < n1; i++) {
             for (int j = 0; j < m1; j++) {
                 arr_1[i][j] = sc.nextInt();
             }
         }
         System.out.println(""Enter the number of rows of the second matrix"");
         int n2 = sc.nextInt();
         System.out.println(""Enter the number of columns of the second matrix"");
         int m2 = sc.nextInt();
         System.out.println(""Enter the elements of the second matrix"");
         int arr_2[][] = new int[n2][m2];
         for (int i = 0; i < n2; i++) {
             for (int j = 0; j < m2; j++) {
                 arr_2[i][j] = sc.nextInt();
             }
         }
         int res[][] = new int[n1][m1];
         for (int i = 0; i < n1; i++) {
             for (int j = 0; j < m1; j++) {
                 res[i][j] = arr_1[i][j] + arr_2[i][j];
             }
         }
         System.out.println(""The result of matrix addition is :"");
         for (int i = 0; i < n1; i++) {
             for (int j = 0; j < m1; j++) {
                 System.out.print(res[i][j] + "" "");
             }
             System.out.println();
         }
         sc.close();
     }
 }
 
 /*
 Sample I/O: 
 Enter the number of rows of the first matrix 3 
 Enter the number of co",Java
"import java.util.*;
 import java.lang.*;
 import java.io.*;
 
 class Stacks {
     public String removeOuterParentheses(String S) {
         if (S.length() == 0) return """";
         Stack<Character> stack = new Stack<>();
         int count = 0;
         
         for (int i = S.length() - 1; i > 0; i--)
             stack.push(S.charAt(i));
             
         String ans = """";
         while (!stack.isEmpty()){
             if (stack.peek() == '('){
                 if (count >= 0)
                     ans+= stack.peek();
                 count++;
             }
             else{
                 if (count != 0)
                     ans += stack.peek();
                 count --;
             }
             stack.pop();
         }
         return ans;
     }
 }
 
 /*
 TIME COMPLEXITY: 0(N) where n is size of string
 SPACE COMPLEXITY:0(N) where n is size of string
 TEST CASE
 
 INPUT
 ""(()())(())""
 
 OUTPUT
 ""()()()""
 
 INPUT
 ""(()())(())(()(()))""
 
 OUTPUT
 ""()()()()(())""
 
 */
 
",Java
"#Python program to implement stack using list (array)
 class Stack:
     #constructor
     def __init__(self):
         self.stack = []
         self.top = None
 
     #inserting on top
     def push(self, value):
         self.stack.append(value)
         self.top = len(self.stack)-1
 
     #check if stack is empty
     def is_empty(self):
         if self.stack == []:
             print(""Stack is empty !"")
         else:
             print(""Stack not empty yet"")
 
     #removing an element from top
     def pop(self):
         if self.stack == []:
             print(""Underflow"")
         else:
             value = self.stack.pop()
             self.top = len(self.stack)
             print(""The popped element is "", value)
 
     #get the top element
     def peek(self):
         if self.stack == []:
             print(""Underflow"")
         else:
             print(""Top element is : "" , self.stack[-1])
 
     #display stack elements
     def display(self):
         if self.stack == []:
             print(""Underflow"")
         else:
             print(""Stack elements are :"")
             for i in range(self.top, -1, -1):
                 print(self.stack[i])
 
 #executable code
 if __name__ == '__main__':
     s = Stack()
     print(""     MENU        "")
     print(""1. Push\n2. Pop\n3. Peek\n4. Empty\n5. Display\n6. Exit"")
     while True:
         ch = int(input(""Enter your choice : ""))
         if ch == 1:
             val = int(input(""Enter a value : ""))
             s.push(val)
         elif ch == 2:
             s.pop()
         elif ch == 3:
             s.peek()
         elif ch == 4:
             s.is_empty()
         elif ch == 5:
             s.display()
         elif ch == 6:
             break
         else:
             print(""Wrong choice"")
             
 """"""
 SAMPLE I/O:
 
      MENU
 1. Push
 2. Pop
 3. Peek
 4. Empty
 5. Display
 6. Exit
 Enter your choice : 1
 Enter a value : 10
 Enter your choice : 1
 Enter a value : 20
 Enter your choice : 1
 Enter",Python
"/*
 A min heap has the property that the parent is less than or equal to the child nodes. 
 When using a 0-indexed array,
 Left child of a node at i is (2 * i + 1)
 Right child of a node at i is (2 * i + 2)
 Parent is (i - 1) / 2
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 typedef struct heap{
     int currentSize, capacity;
     int *arr;
 }heap;
 
 heap * createHeap(int capacity) {
     heap *h = (heap *)malloc(sizeof(heap));
     h -> arr = (int *)malloc(capacity * sizeof(int));
     h -> currentSize = -1;
     h -> capacity = capacity;
     return h;
 }
 /* to initialize an empty heap of a given capacity */
 
 void search(heap *h, int key) {
     int index;
     for (index = 0; index <= h -> currentSize; index ++) {
         if (h -> arr[index] == key) {
             printf(""Found at position %d!\n"", index + 1);
             return;
         }
     }
     printf(""Not found!\n"");
 }
 /* to search if a given element is present in the heap or not */
 
 void swap(int arr[10], int index1, int index2) {
     int temp = arr[index1];
     arr[index1] = arr[index2];
     arr[index2] = temp;
 }
 /* to swap elements at two positions of an array */
 
 void upHeapify(heap *h, int index) {
     int parent = (index - 1) / 2;
     if (h -> arr[parent] > h -> arr[index]) {
         swap(h -> arr, parent, index);
         upHeapify(h, parent);
     }
 }
 /* moving an element up the heap to satisfy the min heap property */
 
 void insert(heap *h, int value) {
     if (h -> currentSize == h -> capacity - 1) {
         printf(""Heap is full. Cannot insert\n"");
         return;
     }
     h -> arr[ ++ h -> currentSize] = value;
     upHeapify(h, h -> currentSize);
     printf(""Inserted!\n"");
 }
 /* inserting an element into the heap */
 
 void downHeapify(heap *h, int index) {
     int lChild = 2 * index + 1, rChild = 2 * index + 2, smallest = index;
     if (lChild <= h -> currentSize && h -> arr[lChild] < h -> arr[smallest])
         smallest = lChild;
     if (rChild <= h ->",C
"'''
 WATER JUG PROBLEM USING BFS AND DFS
 
 Given Problem: You are given a 'm' liter jug and a 'n' liter jug where 
 '0<m<n'. Both the jugs are initially empty. The jugs don't have markings 
 to allow measuring smaller quantities. You have to use the jugs to measure 
 'd' liters of water where 'd<n'. Determine the minimum no of operations to 
 be performed to obtain 'd' liters of water in one of jug.
 
 The aim is to solve this problem using BFS or DFS as per user's choice.
 
 '''
 import collections
 
 # This method return a key value for a given node. 
 # Node is a list of two integers representing current state of the jugs
 def get_index(node):
     return pow(7, node[0]) * pow(5, node[1])
 
 #This method accepts an input for asking the choice for type of searching required i.e. BFS or DFS.
 #Method return True for BFS, False otherwise
 def get_search_type():
     s = input(""Enter 'b' for BFS, 'd' for DFS: "")
     s = s.lower()
     
     while s!='b' and s!='d':
         s = input(""The input is not valid! Enter 'b' for BFS, 'd' for DFS: "")
         s = s[0].lower()  
     return s=='b'
 
 #This method accept volumes of the jugs as an input from the user.
 #Returns a list of two integers representing volumes of the jugs.
 def get_jugs():
     print(""Receiving the volume of the jugs..."")
     jugs = []
     
     temp = int(input(""Enter first jug volume (>1): ""))
     while temp < 1:
         temp = int(input(""Enter a valid amount (>1): ""))     
     jugs.append(temp)
     
     temp = int(input(""Enter second jug volume (>1): ""))
     while temp < 1:
         temp = int(input(""Enter a valid amount (>1): ""))     
     
     jugs.append(temp)
     
     return jugs
 
 #This method accepts the desired amount of water as an input from the user whereas 
 #the parameter jugs is a list of two integers representing volumes of the jugs
 #Returns the desired amount of water as goal
 def get_goal(jugs):
     
     print(""Receiving the desired amount of the water..."")
 
     ",Python
"# find the size of Maximum Square Matrix With All 1s
 
 
 def MaxSquare(mat):
     # creating a null matrix
     ans = 0
     temp = [[0] * len(mat[0])] * len(mat)
     # Traversing through the given matrix
     for i in range(len(mat)):
         for j in range(len(mat[0])):
             temp[i][j] = mat[i][j]
             # checking if it is not a corner case:
             if i > 0 and j > 0 and mat[i][j] == 1:
                 temp[i][j] = min(temp[i][j - 1], temp[i - 1][j])
                 temp[i][j] = min(temp[i][j], temp[i - 1][j - 1]) + 1
             # for finding max size of square mat
             if ans < temp[i][j]:
                 ans = temp[i][j]
     return ans
 
 
 mat = []
 rows = input(""Enter rows"")
 col = input(""Enter col"")
 for i in range(0, int(rows)):
     mat.append([int(j) for j in input().split()])
 
 print(""output is"", MaxSquare(mat))
 '''
 output:
 Enter rows3
 Enter col3
 0 0 0
 0 1 0
 0 0 0
 
 output is 1
 
 Enter rows3
 Enter col3
 0 1 1
 0 1 1
 0 0 0
 
 output is 2
 
 Time Complexity : O(rows*col)'''
",Python
"/*
 Description :
         Given an array(0-based indexing), you have to find the max sum of i*A[i] where A[i] is the element at index i in the array.
         The only operation allowed is to rotate(clock-wise or counter clock-wise) the array any number of times.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // function to find the combination of the number and sum
 int maxi_sum(int A[], int N)
 {
     // c_s = current sum
     int c_s = 0;
     for (int i = 0; i < N; i++)
     {
         c_s += A[i];
     }
     int c_v = 0;
     for (int i = 0; i < N; i++)
     {
         c_v = c_v + i * A[i];
     }
     int ans = c_v;
     for (int i = 1; i < N; i++)
     {
         int n_v = c_v - (c_s - A[i - 1]) + A[i - 1] * (N - 1);
 
         c_v = n_v;
         ans = max(ans, n_v);
     }
 
     return ans;
 }
 
 int main()
 {
     // input number
     int num;
     cout << ""Enter the size of array : "" << endl;
     cin >> num;
     // array to store input
     int arr[num];
 
     cout << ""Enter the elements in the array : "" << endl;
     for (int i = 0; i < num; i++)
     {
         cin >> arr[i];
     }
     cout << ""Maximum sum which can be obtained : "" << endl;
     cout << maxi_sum(arr, num) << endl;
     return 0;
 }
 
 /*
 Time complexity - O(N)
 Space complexity - O(1)
 */
 
 /*
 Test Case :
  Input :
  Enter the size of array : 
  4
  Enter the elements in the array : 
  8 3 1 2
 
  Output :
  Maximum sum which can be obtained :
  29
 */
 
",C-Plus-Plus
"# Julia program to count the number of set bits in a number
 
 function countNumSetBits(num)
     cnt = 0
     while(num > 0)
         cnt = cnt + (num & 1)
         num = (num>>1)
     end 
     return cnt
 end
 
 
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 res = countNumSetBits(num)
 print(""The number of set bits present in the given number is $res"")
 
 
 """"""
 Time Complexity: O(log(n)), where n is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the number: 12354
 The number of set bits present in the given number is 4
 
 SAMPLE II
 
 Enter the number: 2048
 The number of set bits present in the given number is 1
 """"""
",Julia
"/*  Find Kth smallest element in a row-wise and column-wise sorted Matrix. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function to find kth smallest element in the matrix */
 int solve()
 {
     /* Input row = size of row.
        Input col = size of column. */
     int row,col;
     cin >> row >> col;
 
     /* Input elements in matrix. */
     int a[row][col];
     for (int i = 0; i < row; ++i)
     {
         for (int j = 0; j < col; ++j)
         {
             cin >> a[i][j];
         }
     }    
     
     /* Input k */
     int k;
     cin >> k;
 
     /* Define a min-heap priority queue */
     priority_queue<int, vector<int>> pq;
 
     for (int i = 0; i < row; ++i)
     {
         for (int j = 0; j < col; ++j)
         { 
             /* Add the elements in first row of matrix */
             if(pq.size() < k)
             {
                 pq.push(a[i][j]);
             }
             else
             {
                 /* Pop an element and store the element.
                    Add the element lying in matrix into priority queue. */
                 if(a[i][j] < pq.top())
                 {
                    pq.pop();
                    pq.push(a[i][j]);
                 }
             }
         }
     }
     /* Return last element value store in priority queue. */
     return pq.top();
 }
 
 int main()
 {
     int k = solve();
         cout << ""kth Smallest Element is : "" << k << endl;
     return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
 
         4 4
         10 20 30 40
         15 25 35 45
         24 29 37 48
         32 33 39 50
         3
 
     Output 1 :
 
         kth Smallest Element is : 20
 
     Input 2 :
 
         4 4
         10 20 30 40
         15 25 35 45
         24 29 37 48
         32 33 39 50
         7
 
     Output 2 :
 
         kth Smallest Element is : 30
     
     Time complexity: O(r*c)
     Space Complexity: O(1)
 */
",C-Plus-Plus
"// Converting Integer number to its Roman form
 // Whenever user type any integer value, they will get the roman value for a particular integer value.
 
 package main
 
 import ""fmt""
 
 func main() {
 	var number int
 	fmt.Print(""Enter a number : "")
 	fmt.Scan(&number)
 	fmt.Println(""Roman number of"", number, ""is"", calIntToRoman(number))
 }
 
 // applying simple mathematics
 // checking of respective roman number for each digit
 
 func calIntToRoman(number int) string {
 	result := """"
 
 	j := 1
 
 	// storing integer value
 	// help to convert it's respective roman number
 	intValue := [13]int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1}
 	romanValue := [13]string{""M"", ""CM"", ""D"", ""CD"", ""C"", ""XC"", ""L"", ""XL"", ""X"", ""IX"", ""V"", ""IV"", ""I""}
 
 	// iterating integer and roman value
 	// the number contains perticular integer value, based on that adds it's roman value
 	for i := 0; i < 13; i++ {
 		if number >= intValue[i] {
 			f := number / intValue[i]
 			number = number % intValue[i]
 			for j <= f {
 				result = result + romanValue[i]
 				j++
 			}
 		}
 		j = 1
 	}
 	return result
 }
 
 // Sample Input/Output
 // Input : Enter a number : 15
 // Output : Roman number of 15 is XV
",Go
"#include <bits/stdc++.h>
 using namespace std;
 
 int num_of_digits(int num){
     int count = 0;                                       //count is a variable for number of digits
     
     while(num > 0){                                      //Ex : num = 324, count = 0 (Initially)
         count++;                                         //     num = 324, count = 1 (1st iteration)
         num /= 10;                                       //     num = 32, count = 2 (2nd iteration)
     }                                                    //     num = 3, count = 3 (3rd iteration)
                                                          //     num = 0, out of the loop
     return count;
 }
 
 int num_of_digits_recursive(int num){
     if(num == 0){                                        //Base case
         return 0;
     }
     
     return 1 + num_of_digits_recursive(num / 10);        
 }
 
 int num_of_digits_stringsoln(int num){
     string number = to_string(num);
     return number.size();                                //returning string length
 }
 
 int num_of_digits_logbased(int num){
     return floor(log10(num) + 1);                        //Number of digits in integer = upper bound of log10(N)
 }
 
 int main() {
     int num;
     cin >> num;                                           //Inputting the number
     cout << ""The number of digits in given integer (using normal approach): "" << num_of_digits(num) << endl;
     cout << ""The number of digits in given integer (using recursive approach): "" << num_of_digits_recursive(num) << endl;
     cout << ""The number of digits in given integer (using string): "" << num_of_digits_stringsoln(num) << endl;
     cout << ""The number of digits in given integer (log based approach): "" << num_of_digits_logbased(num) << endl;
     return 0;
 }
",C-Plus-Plus
"'''
 Given an array of intervals, merge all overlapping intervals, 
 and return an array of the non-overlapping intervals that cover all the intervals in the input.
 
 Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
 Output: [[1,6],[8,10],[15,18]]
 Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
 
 '''
 def merge(intervals):
   #sort the array 
   intervals.sort()
   #take another empty list
   intervals_stack = []
   for pair in intervals:
     if len(intervals_stack) == 0:  
       intervals_stack.append(pair) #adding all the number in intervals elements in empty list 
     #check number is equal or greater and less than pop elements 
     else:
       current_pair = intervals_stack[-1]
       if current_pair[1]>=pair[0]:
         intervals_stack.pop()
         if current_pair[1]<pair[1]:
           new_pair = [current_pair[0],pair[1]]
           intervals_stack.append(new_pair)
         else:
           new_pair = [current_pair[0],current_pair[1]]
           intervals_stack.append(new_pair)
 
       else:
         intervals_stack.append(pair)
    # result             
   return intervals_stack
 
 if __name__ == '__main__':
     R = int(input(""Enter the number of rows:""))
     C = int(input(""Enter the number of columns:""))
     interval = [[int(input(""Enter the elements: "")) for x in range (C)] for y in range(R)] 
     print(""Overlapping interval: "",interval)
     print(""Non-overlapping intervals: "",merge(interval))
 
 """"""
 Time complexity : O(n^2) 
 Space complexity : O(n^2) 
 
 INPUT:-
 Enter the number of rows:4
 Enter the number of columns:2
 Enter the elements: 1
 Enter the elements: 3
 Enter the elements: 2
 Enter the elements: 6
 Enter the elements: 8
 Enter the elements: 10
 Enter the elements: 15
 Enter the elements: 18
 
 OUTPUT:-
 Overlapping interval:  [[1, 3], [2, 6], [8, 10], [15, 18]]
 Non-overlapping intervals:  [[1, 6], [8, 10], [15, 18]]
 
 """"""
",Python
"/*
 Jack and Harry are playing a new game today. They form a tower of N coins 
 and make a move in alternate turns. harry plays first. In one step, the player 
 can remove either 1, X, or Y coins from the tower. The person to make the last 
 move wins the game. Find who wins the game for different number of coins.
 */
 
 
 #include <bits/stdc++.h>
 using namespace std;
 
 string findWinner(int totalcoins, int coinsThatCanBeRemoved1, int coinsThatCanBeRemoved2) {
     //We are assuming that coinsThatCanBeRemoved2 is greater than or equal to coinsThatCanBeRemoved1
     if(coinsThatCanBeRemoved1>coinsThatCanBeRemoved2){
         swap(coinsThatCanBeRemoved1,coinsThatCanBeRemoved2);
     }
     /*
         dp[i] represents whether Harry will win provided that ""i"" coins
         are remaining and it is Harry's turn.
         If Harry will win in that scenario, dp[i] will be true otherwise
         it'll be false.
     */
     
     bool*dp = new bool[totalcoins+1];
     
     //i represents number of remaining coins
     for(int i=1; i<=totalcoins; ++i){
         /*
             Trivial case : if 1, coinsThatCanBeRemoved1 or coinsThatCanBeRemoved2 coins are remaining and it's Harry's turn,
             he will simply pick up all coins and win the game.
         */
         
         if(i==1 || i==coinsThatCanBeRemoved1 || i==coinsThatCanBeRemoved2){
             dp[i]=true;
         }
         
         /*
             If less than coinsThatCanBeRemoved1 coins remain, each player can only pick up one coin per turn.
             so the result of the game when i coins are remaining will be the reverse
             of the result when there were i - 1 coins.
         */
         
         else if(i<coinsThatCanBeRemoved1){
             dp[i] = !dp[i-1];
         }
         
         /*
             If the number of coins is between coinsThatCanBeRemoved1 and coinsThatCanBeRemoved2, each player can pick up either 1 or coinsThatCanBeRemoved1 coins
             per turn. Now, ea",C-Plus-Plus
"// C++ program to implement Stooge  Sort
 /*
 The function of the stooge sort function is to check if the value at index 0 is 
 greater than the value at last index, if YES then to swap those values.
 Call the Stooge sort function recursively on initial 2/3rd of the array, last 2/3rd
 and again initial 2/3rd to get the given array sorted
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 void stooge_sort(int arr[], int start, int end)
 {
     // If the value at last index is smaller than the value at index 0, Swap them.
     if (arr[start] > arr[end])
         swap(arr[start], arr[end]);
 
     // For finding the first and last two by third elements in the array
     if (end - start + 1 > 2)
     {
         int twobythird = (end - start + 1) / 3;
 
         //Recursively call the function on the initial two by third, last two by third followed by the initial two by third
         if ((end - twobythird) >= start)
             stooge_sort(arr, start, end - twobythird);
         if (end >= (start + twobythird))
             stooge_sort(arr, start + twobythird, end);
         if ((end - twobythird) >= start)
             stooge_sort(arr, start, end - twobythird);
     }
 }
 
 int main()
 {
     int n;
     cout << ""\nHow many numbers do you want to sort? "";
     cin >> n;
     int arr[n];
 
     if (n <= 0)
     {
         cout << ""There are no numbers to sort!!!"";
         return 0;
     }
     // Input the numbers to sort
     cout << ""Enter the numbers: "";
     for (int i = 0; i < n; i++)
         cin >> arr[i];
 
     //Call the sort function
     stooge_sort(arr, 0, n - 1);
 
     cout << ""The numbers in sorted order is: "";
     // Print the sorted array
     for (int i = 0; i < n; i++)
         cout << arr[i];
     cout << endl;
 
     return 0;
 }
 
 /*
 Time Complexity: O(n^2.7095), slower than bubble sort
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 How many numbers do you want to sort? 5
 Enter the numbers: 1 3 5 2 4
 The numbers in sort",C-Plus-Plus
"/*
 The traversal operation is a frequently used operation on a binary tree. This operation is used to visit each node in the tree exactly once
 A full traversal on a binary tree gives a linear ordering of data in the tree .  This is the iterative postorder tree traversal algorithms
 */
 
 class Stack {
     constructor() {
         this.items = [];
     }
     push(element) {
         this.items.push(element)
     }
     pop() {
         if (this.items.length == 0) {
             return ""Underflow"";
         }
         return this.items.pop();
     }
     peek() {
         return this.items[this.items.length - 1]
     }
     isEmpty() {
         return this.items.length == 0;
     }
 }
 
 
 
 
 class Node {
     constructor(data) {
         this.data = data;
         this.left = null;
         this.right = null;
     }
 }
 
 class BinarySearchTree {
     constructor() {
         this.root = null;
     }
     //insert function inserts a new node into the binary search tree
     insert(value) {
         var New = new Node(value);
         if (this.root === null) {
             this.root = New;
             return this;
         }
         let curr = this.root;
         let prev = null;
         while (curr) {
             if (value < curr.data) {
                 prev = curr;
                 curr = curr.left;
             }
             else if (value > curr.data) {
                 prev = curr;
                 curr = curr.right;
             }
         }
         if (prev.data > value) {
             prev.left = New;
             return this;
         }
         else {
             prev.right = New;
             return this;
         }
 
     }
 
     iterative_postorder(node) {
         let ptr = node;
         let stack1 = new Stack();
         let stack2 = new Stack();
         let s = """";
         stack1.push(ptr);
         while (!stack1.isEmpty()) {
             ptr = stack1.pop();
             if (ptr != null) {
                 stack2.push(ptr)
           ",JavaScript
"# Julia program to implement Circle Sort
 
 # Performs recursive circular swaps and returns true if atleast one swap occurs
 function rec_sort(arr, high, low)
     isSwap = false
 
     # If concerned array is empty, Return False
     if (high == low) 
         return false
     end
 
     # Storing the values of beg, end to later use in the recursive call
     highA = high
     lowA = low
     while( highA < lowA) 
         if (arr[highA] > arr[lowA]) 
             arr[highA], arr[lowA] = arr[lowA], arr[highA] 
             isSwap = true;
         end
         highA = highA + 1
         lowA = lowA - 1
     end
 
     # If the array has odd number of elements
     if (highA == lowA) 
         if (arr[highA] > arr[lowA + 1])     
             arr[high], arr[lowA+1] = arr[lowA+1], arr[high] 
             isSwap = true
         end
     end
 
     mid = (low - high)  2
     isSwapA = rec_sort(arr, high, high+mid)
     isSwapB = rec_sort(arr, high+mid+1, low)
 
     return (isSwap || isSwapA || isSwapB)
 end
 
 
 function circle_sort(arr, n)
     while (rec_sort(arr, 1, n))
     end 
 end
 
 
 print(""How many numbers do you want to sort? "")
 n = readline()
 n = parse(Int64, n)
 if (n <= 0)
     println(""No numbers to sort!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 circle_sort(arr, n)
 print(""The numbers in sorted order is "")
 print(arr)
 
 
 
 """"""
 Time Complexity - O(n * log(n)), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 How many numbers do you want to sort? 6
 Enter the numbers: 76 243 89 25 8337 72
 The numbers in sorted order is [25, 72, 76, 89, 243, 8337]
 
 SAMPLE II
 
 How many numbers do you want to sort? -3
 No numbers to sort!!!
 """"""
",Julia
"/*
 Matrix is a 2-D Array.
 A Symmetric Matrix is a square matrix that is equal to its Transpose.
 The code gives output as it checks whether the matrix is symmetric or not.
 */
 #include<stdio.h>
 #include<stdlib.h>
 //Function to check whether the given matrix is Symmetric or not
 void symmetric(int row,int column){
     	int **matrix,flag = 0;
         matrix = (int **)malloc(row * sizeof(int *));
         for(int i = 0; i < row; i++)
         matrix[i] = (int *)malloc(column * sizeof(int));
         //enter the value of matrices
         printf(""Enter matrix:\n"");
         for(int i = 0; i < row; i++)
             for(int j = 0; j < column; j++)
               scanf(""%d"",&matrix[i][j]);
         for (int i = 0; i < row; i++){
             for (int j = 0; j < column; j++){
       		     if (matrix[i][j] != matrix[j][i]){
       		         flag = 1;
                      break;
       		     }
             }
             if( flag == 1)
                 break;
         }
         if(flag == 1)
             printf(""The matrix isn't symmetric.\n"");
         else
             printf(""The matrix is symmetric.\n"");
     }
 
 int main(){
 	int row,column;
 	printf(""Enter number of rows of matrix:"");
     scanf(""%d"",&row);
     printf(""Enter number of coloumns of matrix:"");
     scanf(""%d"",&column);
     //checking whether the given matrix is square matrix or not
     if(row == column){
         symmetric(row,column);
     }
     else
         printf(""The matrix is not square symmetric.\n"");
   return 0;
 }
 
 /*
 
 Sample Output:
 
 Enter number of rows of matrix:2
 Enter number of coloumns of matrix:2
 
 Enter matrix:
 1  2
 2  1
 
 The matrix is symmetric.
 
 Time Complexity : O(mn)
 Space Complexity : O(mn)
 where,
        m = number of rows
        n = number of columns
 */
",C
"/*
 	creating a goroutine for a small slice or array, and having to wait for
 	the Go runtime to schedule it is way more expensive
 	than calling the sequential implementation in the same goroutine.
 
 */
 package main
 
 import (
 	""fmt""
 	""sync""
 	""time""
 )
 
 // merge(): a simple function which merge the two slices into one slice
 
 func merge(left []int, right []int) []int {
 	result := make([]int, len(left)+len(right))
 
 	leftArrayIndex, rightArrayIndex := 0, 0
 
 	for resultArrayIndex := 0; resultArrayIndex < len(result); resultArrayIndex++ {
 		if leftArrayIndex >= len(left) {
 			result[resultArrayIndex] = right[rightArrayIndex]
 			rightArrayIndex++
 			continue
 
 		} else if rightArrayIndex >= len(right) {
 			result[resultArrayIndex] = left[leftArrayIndex]
 			leftArrayIndex++
 			continue
 
 		}
 
 		if left[leftArrayIndex] < right[rightArrayIndex] {
 			result[resultArrayIndex] = left[leftArrayIndex]
 			leftArrayIndex++
 
 		} else {
 			result[resultArrayIndex] = right[rightArrayIndex]
 			rightArrayIndex++
 
 		}
 
 	}
 
 	return result
 }
 
 // parallel implementation of merge sort with goroutines
 func mergeSortParallel(arr []int) []int {
 	/*
 		 max := 2048
 		 we cand add condition like this
 		 if len(arr) < max{
 			mergeSortSequential(arr)
 		 }
 		 it will use normal mergesort  after array became small
 		 because for that small size, creating gorouting and waiting for scheduler
 		 is became more expansive in parallel mergesort
 
 	*/
 
 	length := len(arr)
 	if length < 2 {
 		return arr
 	}
 
 	// WaitGroup waits for goroutines to finish
 	var waitGroup sync.WaitGroup
 
 	// adding total counts of goroutines to do wait
 	waitGroup.Add(1)
 	left := arr[0 : length/2]
 	right := arr[length/2:]
 
 	// left part of array will be handle by another goroutine
 	go func() {
 		defer waitGroup.Done()
 		left = mergeSortParallel(left)
 	}()
 
 	// right part of array will handle by this main goroutine
 	right = mergeSortParallel(right)
 
 	// wait",Go
"/**
 
 Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:
 
 '?' Matches any single character.
 '*' Matches any sequence of characters (including the empty sequence).
 The matching should cover the entire input string (not partial).
 
 **/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 bool isMatch(string s, string p) {
 
     int rows = p.length()+1, cols = s.length()+1;
     // dp table 
     bool dp[rows][cols];
     dp[0][0] = true;
     
     for(int i = 1; i < cols; i++)
         dp[0][i] = false;
     for(int i = 1; i < rows; i++)
         dp[i][0] = dp[i-1][0] && (p[i-1] == '*');
     
     // populating the dp table
     for(int row = 1; row < rows; row++)
         for(int col = 1; col < cols; col++)
             if(p[row-1] == '*')
                 dp[row][col] = dp[row-1][col] || dp[row-1][col-1] || dp[row][col-1];
             else
                 dp[row][col] = (dp[row-1][col-1] && ((p[row-1] == s[col-1]) || (p[row-1] == '?')));
     
     return dp[rows-1][cols-1];
 }
 
 int main() {
     string str, pattern;
     cin >> str >> pattern;
     cout << (isMatch(str, pattern) ? ""Pattern matches the given string\n"" : ""Pattern does not match the given string\n"");
 }
 
 /**
 
 Input :
 aa *
 Output :
 Pattern matches the given string
 
 Time Complexity : O(mn)
 Space Complexity : O(mn)
 
 where m is length of the string
 and n is length of the pattern
 
 **/",C-Plus-Plus
"/* C code for Heap Sorting*/ 
 
 #include<stdio.h>
 
 void maxHeap(int[], int);
 void minHeap(int[], int);
 
 int temp;
 //function for maxHeap Sort
 void maxHeap(int arr[], int len) {
   int pos, maxH;
   for (int i = 1; i < len; i++) {
     pos = i;
     do {
       maxH = (pos - 1) / 2;
       /* to build MAXHEAP  array */
       if (arr[maxH] < arr[pos]) {
         temp = arr[maxH];
         arr[maxH] = arr[pos];
         arr[pos] = temp;
       }
       pos = maxH;
     } while (pos != 0);
   }
 
   printf(""Heap  array : \n"");
   printf(""Max Heap\n"");
   for (int i = 0; i < len / 2; i++) {
     printf(""Parent : %d Left Child : %d Right Child : %d\n"", arr[i], arr[2 * i + 1], arr[2 * i + 2]);
   }
   for (int j = len - 1; j >= 0; j--) {
     temp = arr[0];
     arr[0] = arr[j];
     arr[j] = temp;
     maxH = 0;
     do {
       pos = 2 * maxH + 1;
       if ((arr[pos] < arr[pos + 1]) && pos < j - 1)
         pos++;
       if (arr[maxH] < arr[pos] && pos < j) {
         temp = arr[maxH];
         arr[maxH] = arr[pos];
         arr[pos] = temp;
       }
       maxH = pos;
     } while (pos < j);
   }
 }
 
 //Function for MinHeap Sort
 void minHeap(int arr[], int len) {
   int pos, minH;
   for (int i = 1; i < len; i++) {
     pos = i;
     do {
       minH = (pos - 1) / 2;
       /* to build MINHEAP  array */
       if (arr[minH] > arr[pos]) {
         temp = arr[minH];
         arr[minH] = arr[pos];
         arr[pos] = temp;
       }
       pos = minH;
     } while (pos != 0);
   }
   printf(""Min Heap\n"");
   for (int i = 0; i < len / 2; i++) {
     printf(""Parent : %d Left Child : %d Right Child : %d\n"", arr[i], arr[2 * i + 1], arr[2 * i + 2]);
   }
   for (int j = len - 1; j >= 0; j--) {
     temp = arr[0];
     arr[0] = arr[j];
     arr[j] = temp;
     minH = 0;
     do {
       pos = 2 * minH + 1;
       if ((arr[pos] > arr[pos + 1]) && pos < j - 1)
         pos++;
       if (arr[minH] > arr[pos] && pos < j) {
         temp = arr[minH];
         arr[minH] = a",C
"/*
 Code Description:
 Following is the implementation of Morris(Inorder) Traversal in a Tree that does not employ the use of recursion or a stack. 
 The basic idea is to link predecessor back to current node so that we can trace back to top of the Tree. 
 */
 #include <stdio.h>
 #include <stdlib.h>
 
 /* Defining The structure of a Tree Node */
 struct Node
 {
     struct Node *left;
     int data;
     struct Node *right;
 };
 
 /* Function for Creation of a Node */
 struct Node *create(int t)
 {
 	struct Node *temp=malloc(sizeof(struct Node));
 	temp->data =t;
 	temp->left = temp->right = NULL;
 	return temp;
 }
 
 /* Function for Inserting Nodes in a Tree */
 struct Node *Insert(struct Node *root,int data)
 {
 	
 	if(root == NULL)
 	{ 
 		root = create(data);
 	}
 	else if(data <= root->data)
 	{
 		root->left = Insert(root->left,data);
 	}
 	else 
 	{
 		root->right = Insert(root->right,data);
 	}
 	
 	return root;
 	
 }
 
 /* Morris Inorder Traversal */
 void Morris(struct Node* temp)
 {
 	struct Node  *q1;
 
 	/* If the Tree is empty */
 	if (temp == NULL)
 	{
 		return;
 	}
 	
 	/* If Tree is not empty */
 	while (temp != NULL)
 	{
 		/* If the tree only has right subtree */
 		if (temp->left == NULL)
 		{
 			/* Print the root data then traverse the right subtree */
 			printf(""-->%d"", temp->data);
 			temp = temp->right;
 		}
 		
 		/*If the left subtree exists */
 		else 
 		{
 			/*Point q1 to left child of current node */
 			q1 = temp->left;
 			
 			/* Traverse till the rightmost node of q1*/
 			while (q1->right != NULL && q1->right != temp)
 				q1 = q1->right;
 				
 			/* If the right child of the rightmost node is NULL */
 			if (q1->right == NULL)
 			{
 				/* Make temp as the right child of q1 i.e. Rightmost Child of Left Child of Current Node */
 				q1->right = temp;
 				temp =temp->left;
 			}	
 			else 
 			{
 				/* Print root data and make temp point to it's right child */
 				q1->right = NULL;
 				printf(""-->%d"",temp->data);
 				tem",C
"'''
 Given an array of n integers where each value represents the number of chocolates in a packet. 
 Each packet can have a variable number of chocolates. There are m students, 
 the task is to distribute chocolate packets such that: 
 
 1.Each student gets one packet.
 2.The difference between the number of chocolates in the packet with maximum chocolates and 
 packet with minimum chocolates given to the students is minimum.
 '''
 def chunks(arr, M):
     """"""Yield sublist of arr of length M.""""""
     for i in range(0, len(arr)):
         r = arr[i:i+M]
         if len(r) == M:
             yield r
 
 def main(arr, M):
     """"""Chocolate Distribution Problem.""""""
     arr = sorted(arr)
     min_ = None
     for x in chunks(arr, M):
         diff = x[-1] - x[0]
         if min_ is None or diff <= min_:
             min_ = diff
     #result
     return min_
 
 
 if __name__ == ""__main__"":
     arr = list(map(int,input(""Enter the Chocolate bars: "").split()))
     M = int(input(""Enter the number student to distribute: ""))
     print(""Minimum Difference is "",main(arr,M))
 
 """"""
 Time complexcity : O(n log n)
 Space Complexcity : O(n log n)
 
 Input:
 Enter the Chocolate bars: 7 3 2 4 9 12 56
 Enter the number student to distribute: 3
 
 Output:
 Minimum Difference is  2
 
 """"""
",Python
"""""""
 Python program to reverse a number.
 The reverse of a number is a number that is obtained when a number is traversed from right to left.
 """"""
 
 # Function to do reverse 
 
 def reverse(n):
     # Initializing rev as 0
 
     rev = 0
     while True:
         if n == 0:
             break
         # Adding the last digit
 
         rev = rev * 10 + n % 10
         # Removing the last digit
 
         n = n // 10
     return rev
 
 if __name__ == '__main__':
     # Taking input from user
 
     n = int(input('Enter the number :'))
     # Printing the output
 
     print (""The reverse of the given number is: {} "".format(reverse(n)))
 
 """"""
 Time Complexity - O(n), where 'n' is the number of digits in the number.
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 SAMPLE I
 
 INPUT
 Enter the number: 1234
 
 OUTPUT
 The reverse of the given number is: 4321
 
 """"""
 
",Python
"/*
 The traversal operation is a frequently used operation on a binary tree. This operation is used to visit each node in the tree exactly once
 A full traversal on a binary tree gives a linear ordering of data in the tree .  This is the iterative preorder tree traversal algorithms
 */
 
 class Stack {
     constructor() {
         this.items = [];
     }
     push(element) {
         this.items.push(element)
     }
     pop() {
         if (this.items.length == 0) {
             return ""Underflow"";
         }
         return this.items.pop();
     }
     peek() {
         return this.items[this.items.length - 1]
     }
     isEmpty() {
         return this.items.length == 0;
     }
 }
 
 
 
 
 class Node {
     constructor(data) {
         this.data = data;
         this.left = null;
         this.right = null;
     }
 }
 
 class BinarySearchTree {
     constructor() {
         this.root = null;
     }
     //insert function inserts a new node into the binary search tree
     insert(value) {
         var New = new Node(value);
         if (this.root === null) {
             this.root = New;
             return this;
         }
         let curr = this.root;
         let prev = null;
         while (curr) {
             if (value < curr.data) {
                 prev = curr;
                 curr = curr.left;
             }
             else if (value > curr.data) {
                 prev = curr;
                 curr = curr.right;
             }
         }
         if (prev.data > value) {
             prev.left = New;
             return this;
         }
         else {
             prev.right = New;
             return this;
         }
 
     }
 
     iterative_preorder(node) {
         let ptr = node;
         let stack = new Stack();
         let s = """"
         stack.push(ptr);
         while (!stack.isEmpty()) {
             ptr = stack.pop();
             if (ptr != null) {
                 s += ptr.data + "" ""
                 stack.push(ptr.right)
           ",JavaScript
"/*
 Given two strings s1 and s2, check if s1 is a subsequence of s2.
 A subsequence of a string is a new string that is formed from the original string
 by deleting some (can be none) of the characters
 without disturbing the relative positions of the remaining characters.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 bool check_is_Subsequence(string s1, string s2)
 {
     int size_1 = s1.size();
     int size_2 = s2.size();
     if(size_1 > size_2)
     {
         /* here string s1 size is greater than string s2 size
         so it can't be a subsequence of string s2.
         */
         return false;
     }
     if(size_1 <= size_2)
     {
         int j = 0;
         for(int i = 0; i < s2.size(); i++)
         {
             if(s1[j] == s2[i])
             {
                 /* if s1[j] is same of s2[i]
                 then we will increment j
                 */
                 j++;
             }
         }
         if(j == size_1)
         {
             /* here string s1 size is equal to j
               so it is a subsequence of string s2.
             */
             return true;
         }
         else
         {
             return false;
         }
 
     }
 }
 int main()
 {
     cout << ""Enter two strings : \n"";
     string s1;
     cin >> s1;
     string s2;
     cin >> s2;
     bool is_Subsequence = check_is_Subsequence(s1, s2);
     if(is_Subsequence)
     {
         cout << ""Yes! string s1 is a subsequence of string s2\n"";
     }
     else
     {
         cout << ""No! string s1 is NOT a subsequence of string s2\n"";
 
     }
 }
 
 /*
 Standard Input and Output
 
 1.
 Enter two strings :
 abc
 ahbgdc
 
 Yes! string s1 is a subsequence of string s2
 
 2.
 Enter two strings :
 sgdtb
 vrdgtrv
 
 No! string s1 is NOT a subsequence of string s2
 
 Time Complexity : O( N )
 Space Complexity : O( 1 )
 
 */
",C-Plus-Plus
"/*
 Description :
         Given an array, you have to re-construct an array.
         The values in array are obtained by doing OR(bitwise or) of consecutive elements in the array.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //fucntion is used to obatin value using OR operator
 int *bit_op(int arr[], int n)
 {
     for (int j = 0; j < n - 1; j++)
     {
         arr[j] = arr[j] | arr[j + 1];
     }
 
     return arr;
 }
 
 int main()
 {
     // size = length of an array
     int size;
     cout << ""Enter the length of array : "" << endl;
     cin >> size;
     int arr[size];
 
     cout << ""Enter the elements in the array : "" << endl;
     for (int i = 0; i < size; i++)
     {
         cin >> arr[i];
     }
     int *arr_2;
     arr_2 = bit_op(arr, size);
 
     cout << ""New array : "" << endl;
     for (int i = 0; i < size; i++)
     {
         cout << arr_2[i] << "" "";
     }
     cout << ""\n"";
 
     return 0;
 }
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Case :
   Input :
   Enter the length of array : 
   5
   Enter the elements in the array : 
   10 11 1 2 3
 
   Output :
   New array : 
   11 11 3 3 3
    
 */
 
",C-Plus-Plus
"/*
 Implementing Stooge Sort by using DART.
 
 Stooge Sort is a recursive sorting algorithm. It is inefficient but interesting 
 sorting algorithm. It divides the array into two overlapping parts (2/3 each). 
 Then it performs sorting in first 2/3 part and then it performs sorting in last 
 2/3 part. After that, sorting is done on first 2/3 part to ensure the array is 
 sorted.
 
 */
 import 'dart:io';
 
 void stoogeSort(var array, int start, int end) {
   // swapping first and last element if start is greater than end
   if (array[start] > array[end]) {
     int temp = array[start];
     array[start] = array[end];
     array[end] = temp;
   }
 
   // If there are more than 2 elements
   if ((end - start + 1) > 2) {
     int two_third = (end - start + 1) ~/ 3;
 
     // Recursively sort first 2/3 elements
     if ((end - two_third) >= start) stoogeSort(array, start, end - two_third);
     // Recursively sort last 2/3 elements
     if (end >= (start + two_third)) stoogeSort(array, start + two_third, end);
     // Recursively sort first 2/3 elements again for conformation
     if ((end - two_third) >= start) stoogeSort(array, start, end - two_third);
   }
 }
 
 void main() {
   var data = [];
 
   // taking input from user and storing it in data array
   var n, ele;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     data.add(ele);
   }
 
   print(""\nInputted array is $data"");
   stoogeSort(data, 0, n - 1);
   print(""\nArray after sorting is $data"");
 }
 /*
 Time Complexity: O(n^2.7095)
 Space Complexity: O(n)
 
 Sample I/O:
 Enter the number of Elements: 
 6
 Enter Element 1: 
 36
 Enter Element 2: 
 2
 Enter Element 3: 
 73
 Enter Element 4: 
 11
 Enter Element 5: 
 95
 Enter Element 6: 
 100
 
 Inputted array is [36, 2, 73, 11, 95, 100]
 
 Array after sorting is [2, 11, 36, 73, 95, 100]
 */
",Dart
"""""""Julia program to find the n'th number in the tribonacci series
 Tribonacci series is a generalization of the Fibonacci sequence, in which the current term
 is the sum of the previous three 
 """"""
 
 function find_tribonacci(n)
     dp = zeros(Int, n + 1)
     dp[1] = 0
     dp[2] = 0
     dp[3] = 1
 
     for i in 4:n
         dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
     end
 
     return dp[n]
 end
 
 
 print(""Enter the value of n?, where you need the n'th number in the tribonacci sequence. "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""The given value of n is invalid."")
     exit()
 end
 res = find_tribonacci(n)
 println(""The $n'th term in the tribonacci series is $res."")
 
 
 """"""
 Time Complexity - O(n)
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 Enter the value of n?, where you need the n'th number in the tribonacci sequence. 12
 The 12'th term in the tribonacci series is 149.
 
 SAMPLE II
 Enter the value of n?, where you need the n'th number in the tribonacci sequence. 1254
 The 1254'th term in the tribonacci series is 4020147461713125140.
 """"""
",Julia
"#!/usr/bin/env python3
 """""" Merge Sort Algorithm for Sort an array of random integers with parallel and sequential apporach is used.""""""
 
 import random
 import math
 import multiprocessing as mp
 
 """""" helper method to merge two sorted subarrays
     array[l..m] and array[m+1..r] into array """"""
 def merge(array, left, mid, right):
     # copy data to temp subarrays to be merged
     left_temp_arr = array[left:mid+1].copy()
     right_temp_arr = array[mid+1:right+1].copy()
     # initial indexes for left, right and merged subarrays
     left_temp_index = 0
     right_temp_index = 0
     merge_index = left
     # merge temp arrays into original
     while (left_temp_index < (mid - left + 1) or right_temp_index < (right - mid)):
         if (left_temp_index < (mid - left + 1) and right_temp_index < (right - mid)):
             if (left_temp_arr[left_temp_index] <= right_temp_arr[right_temp_index]):
                 array[merge_index] = left_temp_arr[left_temp_index]
                 left_temp_index += 1
             else:
                 array[merge_index] = right_temp_arr[right_temp_index]
                 right_temp_index += 1
         elif (left_temp_index < (mid - left + 1)): # copy any remaining on left side
             array[merge_index] = left_temp_arr[left_temp_index]
             left_temp_index += 1
         elif (right_temp_index < (right - mid)): # copy any remaining on right side
             array[merge_index] = right_temp_arr[right_temp_index]
             right_temp_index += 1
         merge_index += 1	
 	
 """""" parallel implementation of merge sort """"""
 def parallel_mergesort(array, *args):
     if not args: # first call
         shared_array = mp.RawArray('i', array)
         parallel_mergesort(shared_array, 0, len(array)-1, 0)
         array[:] = shared_array # insert result into original array
         return array
     else:
         left, right, depth = args
         if (left < right):
             mid = left + ((right - left) // 2)
            ",Python
"""""""Julia program to implement Ternary Search algorithm.
 Ternary Search is a Divide and Conquer strategy based algorithm similar to binary search.
 Here we divide the entire array into three parts and iteratively search for the required element
 """"""
 
 function ternary_search(arr, low, high, ele)
     while (high >= low)
         # FInd the two required midpoints to divide the array into three.
         midA = low + (high - low)  3
         midB = high - (high - low)  3
         # Search, if the element is present in the midpoint indices
         if (arr[midA] == ele)
             return true
         elseif (arr[midB] == ele)
             return true
         end
     
         # Identify the part in which the required element belongs to 
         if (ele < arr[midA])
             high = midA - 1
         elseif (ele > arr[midB])
             low = midB + 1
         else
             low = midA + 1
             high = midB - 1
         end
     end
     return false
 end
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""Array is Empty!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())] 
 print(""Which number do you want to search in the array? "")
 ele = readline()
 ele = parse(Int, ele)
 # Sort the array in ascending order
 arr = sort(arr)
 res = ternary_search(arr, 1, n, ele)
 if (res == 0)
     print(""The number $ele is not present in the array"")
 else
     print(""The number $ele is present in the array."")
 end
 
 
 """"""
 Time Complexity - O(log(n)), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 How many numbers are present in the array? 5 
 Enter the numbers: 1 2 3 4 5
 Which number do you want to search in the array? 6
 The number 6 is not present in the array
 
 SAMPLE II
 
 How many numbers are present in the array? 3
 Enter the numbers: 3 1 2
 Which number do you wan",Julia
"/*Gray code is an ordering of the binary numeral system such that two successive values differ in only one bit (binary digit).
 In gray code, two consecutive values are differed by one bit of binary digits.
 Binary number can be converted to gray code by performing xor of two consecutive bits.
 
 Decimal to Gray code Conversion: Decimal(2) = 0010(Binary)
 0  0  1  0
 |\ /\ /\ /
 0 0  1  1
 Here, 1st bit is taken as it is. Next, xor of 2 consecutive bits is performed[xor of (0,0) , (0,1) , (1,0)]. Therefore, gray
 code for 2 in binary format is 0011.
 
 In this problem, the number in decimal is converted into gray code in decimal format.
 Example:
 I/O : 2
 O/P : 3
 Explanation: 2 in binary format is 0010. When converted into gray code, it is 0011. But decimal equivalent of 0011 is 3.
 */
 
 #include<iostream>
 using namespace std ;
 
 int dec_to_gray_code(int fn_in_decimal)
 {
     /*
     To get gray code, xor has to be performed for consecutive bits. So instead of dealing with only one pair of bits at a
     time, all xor operations are performed at one step by performing xor of input number and number obtained by shifting input
     number to right by 1.
     */
     return fn_in_decimal ^ (fn_in_decimal >> 1);
 }
 
 int main(void)
 {
     int n_in_decimal = 0, n_in_gray = 0 ;
 
     //Take user input as decimal number
     cout << ""Enter the number in decimal : "" << endl ;
     cin >> n_in_decimal ;
 
     //Call to function dec_to_gray_code
     n_in_gray = dec_to_gray_code(n_in_decimal) ;
 
     cout << ""The gray code value for decimal number "" << n_in_decimal << "" is : "" << n_in_gray << endl ;
     return 0 ;
 }
 
 /*
  Sample Example :
  I/O : 7
  O/P : 4
 
  Explanation: 7 in binary is written as 0111. When converted to gray code, it is 0100. 0100 in decimal is 4. Hence code outputs 4.
 
  Time Complexity : O(1)
  Space Complexity : O(1)
 */
 
",C-Plus-Plus
"'''
 Write a program to print all the Lucky Numbers upto the input number.
 
 Approach:
 Lets understand with input of 25 for example.
 Start with a list of numbers beginning with 1:
 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
 
 Every second number (all even numbers) in the list is eliminated, leaving only the odd integers:
 1 3 5 7 9 11 13 15 17 19 21 23 25
 
 The first number remaining in the list after 1 is 3, so every third number which remains in the list 
 (not every multiple of 3) is eliminated. The first of these is 5:
 1 3 7 9 13 15 19 21 25
 
 The next surviving number is now 7, so every seventh remaining number is eliminated. The first of these is 19:
 1 3 7 9 13 15 21 25
 
 The next surviving number after 7 is 9, so every 9th element was meant to be deleted, but as we see 9 is greater
 than size of list , So we got our list of surviving numbers from seive of elimination i.e. LUCKY NUMBERS upto 
 input number.
 
 '''
 def lucky(nos):
         #list of odd numbers
         odds = list(range(1, nos + 1, 2))
         #iterator variable
         j = 1                             
         while j <= len(odds) - 1 and odds[j] <= len(odds):
                 #counting and adding the lucky numbers in the list
                 odds = [Li for i, Li in enumerate(odds) if (i + 1) % odds[j]] 
                 #incrementing the variable
                 j += 1
         #returning list of all the lucky numbers upto 'nos'
         return odds
 #Driver code
 if __name__ == ""__main__"":
         #User input
         number=int(input(""Enter a number :""))
         #Function Call
         LuckyNos=lucky(number)               
         print(""The list of all the lucky numbers upto"",number,"" is :"",LuckyNos)
         
 '''
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1:-
 
 Enter a number :25
 The list of all the lucky numbers upto 25  is : [1, 3, 7, 9, 13, 15, 21, 25]
 
 Time Complexity : O(n^2)
 Space Complexity : O(n)
 '''
",Python
"// C program to implement Maximum Sum Increasing Subsequence
 /*
 In this problem, given an array we have to find the maximum sum an increasing subsequence of that array can make.
 This problem is a slight modification to the Longest Increasing subsequence problem.
 The problem can be solved using Dynamic Programming
 */
 #include <stdio.h>
 
 int max_sum_increasing_subsequence(int arr[], int n)
 {
     int dp[n], max_sum = 0;
 
     /* Initialize the dp array with the array values, as the maximum sum 
        at each point is atleast as the value at that point         */
     for (int i = 0; i < n; i++)
         dp[i] = arr[i];
 
     // Now Lets Fill the dp array in Bottom-Up manner
     /* Compare Each i'th element to its previous elements from 0 to i-1, 
        If arr[i] > arr[j], then it qualifies for increasing subsequence and
        If dp[i] < dp[j] + arr[i], then that subsequence sum qualifies for being the maximum one */
     for (int i = 1; i < n; i++)
         for (int j = 0; j < i; j++)
             if (arr[i] > arr[j] && dp[i] < dp[j] + arr[i])
                 dp[i] = dp[j] + arr[i];
 
     //Now Find the maximum element in the 'dp' array
     //Now Find the maximum element in the 'dp' array
     for (int i = 0; i < n; i++)
     {
         if (dp[i] > max_sum)
             max_sum = dp[i];
     }
 
     return max_sum;
 }
 
 int main()
 {
     int n, max_sum;
     printf(""\nWhat is the length of the array? "");
     scanf(""%d"", &n);
     int arr[n];
     printf(""Enter the numbers: "");
     for (int i = 0; i < n; i++)
     {
         scanf(""%d"", &arr[i]);
     }
     max_sum = max_sum_increasing_subsequence(arr, n);
 
     printf(""The maximum sum of an increasing subsequence of the given array is %d"", max_sum);
     return 0;
 }
 
 /*
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 10
 Enter the numbers: 23 14 5 84 24 222 321 43",C
"'''
 Remove Zero Sum Consecutive Nodes from Linked List:
 
 Explanation:
 An algorithm called as prefix sum or accumalated sum is used.
 Here we start off with sum 0 and  iterate through the linked
 list  accumalate the sum.
 
 Consider an example:
 
     3 -> 4 -> 2 -> -6 -> 1 -> 1 -> 5 -> -6
 its corresponding prefix sum is:
 0 -> 3 -> 7 -> 9 -> 3 -> 4 -> 5 -> 10 -> 4
 
 A dictionary in python is used to store the prefix sum as the
 key and its value will be stored in the corresponding node object.
 
 During the iteration we push the node value(address) in dictionary
 and simultaneously update the prefix sum.
 
 If the prefix sum equates to any key in the dictionary then it
 indicates we have previously accumaleted the sum,indicating
 that all elements between them have net sum as 0.
 
 
 Thus,all the elements in the window can be removed.
 '''
 '''create a node class'''
 
 
 class Node:
     def __init__(self, data):
         self.data = data
         self.next = None
 
 
 '''class for accessing linked lists and its methods'''
 
 
 class LinkedList:
     def __init__(self):
         self.head = None
 
     def insert_node_at_end(self, data):
         new_node = Node(data)
         if self.head:
             current = self.head
             while current.next:
                 current = current.next
             current.next = new_node
         else:
             self.head = new_node
         #print all the nodes of a LinkedList'''
 
     def print_node(self):
         current = self.head
         while current:
             print(current.data, end="" "")
             current = current.next
         #function to remove elements that sum to 0'''
 
     def remove_zero_sum_lists(self):
         current = Node(0)
         #assign a dummy node with value 0'''
         current.next = self.head
 
         prefix_sum = 0
         #finding prefix sum to verify if it already exists'''
 
         dict = {}
         #similar to hashmap,dict can be used to map prefix_sum,node a",Python
"/* 
 CODE DESCRIPTION:
 Following is the implementation to create a new binary tree which is a mirror image of the given binary tree.
 */
 #include <stdio.h>
 #include <stdlib.h>
 /* Defining The structure of a Tree Node */
 struct Node
 {
     struct Node *left;
     int data;
     struct Node *right;
 };
 
 int count = 1;
 
 /* Function for Inserting Nodes in a Tree */
 struct Node* insert(struct Node *root, int value)
 {
 	if (root == NULL)
 	{
 		root = (struct Node*) malloc(sizeof(struct Node));
 		root->left = root->right = NULL;
 		root->data = value;
 		count++;
 	}
 	else if (count % 2 == 0)
 		root->left = insert(root->left, value);
 	else
 		root->right = insert(root->right, value);
 	
 	return root;
 }
 
 /* Function to print Nodes of a Tree */
 void inorder(struct Node *temp)
 {
     if (temp == NULL)
     {
         return;
     }
     inorder(temp->left);
     printf(""--->%d"", temp->data);
     inorder(temp->right);
 }
 
 /* Function to Find Mirror of the Binary Tree */
 void Mirror(struct Node *temp)
 {
 	/* If tree is NULL */
 	if(temp == NULL)
 	{
 		return;
 	}
 	/* If leaf node present */
 	if(temp ->right == NULL && temp->left == NULL)
 	{
 		return;
 	}
 	/* If node has a left child */
 	if(temp->left)
 		Mirror(temp->left);
 	/* If node has a right child */
 	if(temp->right)
 		Mirror(temp->right);
 	/* Interchanging left and right pointers */
 	struct Node *temp1 = temp->left;
 	temp->left = temp->right;
 	temp->right = temp1;
 		
 }
 
 /* Driver Function */
 void main()
 {
     struct Node *root = NULL;
     int value;
     
     printf(""Enter value of node:To quit enter 0\n"");
 	scanf(""%d"", &value);
 	
 	while (value != 0)
 	{
 		root = insert(root, value);
 		scanf(""%d"", &value);
 	}
 
 	printf(""\nBinary Tree\n"");
 	inorder(root);
 	
 	printf(""\nMirror of a Binary Tree\n"");
 	Mirror(root);
 	
 	inorder(root);
 	   
 }
 /*
 COMPLEXITY
 Time complexity : O(n)
 Space complexity : O(n)
 
 OUTPUT:
 Enter value of node:To quit enter 0
 1
 2
 3
 ",C
"# Fibonacci search implementation in Python3
 
 """"""
 Purpose:
 Fibonacci Search is a comparison-based technique that uses Fibonacci numbers to search an element in a sorted array.
 
 Similarities with binary search:
 - worked for sorted arrays
 - a divide a conquer algorithm
 
 Return type:
 Returns the index of a key in a sorted array or returns -1 if it is not contained
 """"""
 
 def FibonacciSearch(arr, x, n):
     """"""
     Inputs-
     arr: A sorted array in which we're going to search for the key
     x: The number to be searched for
     n: Size of the array
     """"""
 
     # initialize fibonacci numbers
     Fibm2 = 0  # (m-2)'th Fibonacci No.
     Fibm1 = 1  # (m-1)'th Fibonacci No.
     Fibm = Fibm2 + Fibm1  # Fibm'th Fibonacci
 
     # Fibm: store the smallest
     # fibonacci Number greater than or equal to n
     while Fibm < n:
         Fibm2 = Fibm1
         Fibm1 = Fibm
         Fibm = Fibm2 + Fibm1
 
     # marks the eliminated range from front
     offset = -1
 
     # while there are elements to be inspected.
     # Note: we compare arr[Fibm2] with x.
     # when Fibm becomes 1, Fibm2 becomes 0
     while Fibm > 1:
 
         # Check if Fibm2 is a valid location
         i = min(offset + Fibm2, n - 1)
 
         # if x is greater than the value at
         # index Fibm2, cut the subarray array
         # from offset to i
         if arr[i] < x:
             Fibm = Fibm1
             Fibm1 = Fibm2
             Fibm2 = Fibm - Fibm1
             offset = i
 
         # if x is less than the value at
         # index Fibm2, cut the subarray
         # after i+1
         elif arr[i] > x:
             Fibm = Fibm2
             Fibm1 = Fibm1 - Fibm2
             Fibm2 = Fibm - Fibm1
 
         # element found, return index
         else:
             return i
 
     # comparing the last element with x
     if Fibm1 and arr[offset + 1] == x:
         return offset + 1
 
     # element not found. return -1
     return -1
 
 # taking dynamic input
 print(""Ente",Python
"/*
 
   Conversion from decimal to Hexadecimal number in dart
 
 */
 
 import ""dart:io"";
 
 void decimalToHexadecimal(int decimalNumber) {
   List<int> ans = [];
 
   int lastDigit = 0, hexCodeLen = 0;
 
   while (decimalNumber != 0) {
     lastDigit = decimalNumber % 16;
     decimalNumber = (decimalNumber / 16).floor();
 
     /*
      If lastDigit is greater than 9 then X will be alphabet(hexadecimal),
      else X will be a number(hexadecimal)
      */
     int hexCharCode;
     if (lastDigit > 9)
       hexCharCode = lastDigit + 'A'.codeUnitAt(0) - 10;
     else
       hexCharCode = lastDigit + '0'.codeUnitAt(0);
 
     ans.add(hexCharCode);
     hexCodeLen++;
   }
 
   //Loop for printing String in Reverse order
   stdout.write(""Hexadecimal Number: "");
   for (int k = hexCodeLen - 1; k >= 0; k--) {
     stdout.write(String.fromCharCode(ans[k]));
   }
 }
 
 int main() {
   stdout.write(""Enter the Decimal Number: "");
 
   int decimalNumber = int.parse(stdin.readLineSync()!);
   decimalToHexadecimal(decimalNumber);
 
   return 0;
 }
 
 /* Testcases:
 
   Test 1
   Enter the Decimal Number: 3452
   Hexadecimal Number: D7C
 
   Test 2
   Enter the Decimal Number:100
   Hexadecimal Number: 64
 
   Test 3
   Enter the Decimal Number: 12341234244333 
   Hexadecimal Number: B396AE21AED
 
   Time Complexity- O(n);
   Space Complexity- O(1);
 
 */
",Dart
"#include <bits/stdc++.h>
 using namespace std;
 
 class node
 {
 public:
     int data;
     node *next;
     //constructor
     node(int d)
     {
         data = d;
         next = NULL;
     }
 };
 
 //Function to insert in circular LinkedList
 void insert(node *&head, int data) //pass by referance
 {
     node *n = new node(data);
     n->next = head; //creating a new node
     node *temp = head;
     if (temp != NULL)
     {
         while (temp->next != head)
         {
             temp = temp->next;
         }
         temp->next = n;
     }
 
     //self loop for single node
     else
     {
         n->next = n;
     }
     head = n;
 }
 
 //Creating a function to get the node to be deleted
 node *getnode(node *head, int data) //pass ny value
 {
     node *temp = head;
     while (temp->next != head)
     {
         if (temp->data == data)
         {
             return temp;
         }
         temp = temp->next;
     }
     if (temp->data == data)
     {
         return temp;
     }
     return NULL;
 }
 
 //Creating the delete function
 void del(node *head, int data)
 {
     node *del = getnode(head, data);
 
     if (del == NULL)
     {
         return;
     }
 
     if (head == del)
     {
         head = head->next;
     }
 
     node *temp = head;
 
     while (temp->next != del)
     {
         temp = temp->next;
     }
     temp->next = del->next;
     delete del;
 }
 
 //function to print circular linkedlist
 void print(node *head)
 {
     node *temp = head;
     while (temp->next != head)
     {
         cout << temp->data << "" -> "";
         temp = temp->next;
     }
     cout << temp->data << endl; //for last node
 }
 
 int main()
 {
     node *head = NULL;
     cout << ""Insertion in circular linkedlist"" << endl;
     int arr[100], arr2[100];
     int n, n2;
     cout << ""enter the number of elements"" << endl;
     cin >> n;
     for (int i = 0; i < n; i++)
     {
         cout << ""enter element number "" << i << ""-"" << endl;
         cin >> ar",C-Plus-Plus
"#include <bits/stdc++.h>
 using namespace std;
 
 /*
  Factorial is calculated using recursive formula : n! = n * (n-1)!
  We will initially save Factorial of 0 and 1 as 1. Then  we will
  recursively call Factorial on the lower numbers and save its data in array
 */
 int fac[100];
 int Factorial(int n)
 {
     if(n == 0)
         return 1;
     if(n == 1)
         return 1;
     if(fac[n] != 0)
         return fac[n];
     return (fac[n] = n * Factorial(n-1));
 }
 
 int main()
 {
     int n;
     cout<<""Enter number : "";
     cin>>n;
     cout<<""Factorial of ""<<n<<"" is : ""<<Factorial(n);
 
     return 0;
 }
 
 /*
     Sample Input-Output:
     Enter number : 5
     Factorial of 5 is : 120
 
     Time Complexity: O(n)
     Space Complexity: O(n)
 */
",C-Plus-Plus
"/*
 This progarm is about finding a pair of element with sum k using hash table in a
 Unsorted array.
 Here user going to give an input of k value based upon the input the code will
 check whether all the possible pair sum from the array
 is equal to k value or not.
 
 Ex:-
 array = {1,7,4,2,3} , K = 5
 
 1 + 7 != 5
 1 + 4  = 5
 1 + 2 != 5
 ...
 ...
 ...
 2 + 3  = 5
 
 The above array is unsorted. The code will take up all the possible pair
 from the array. It will keep on going
 until array becomes empty and it will add up those pair from
 array and check whether the pair of sum and k is equal or not.
 If it is equal then it will show in the output screen else not.
 
 */
 #include <stdio.h>
 #include <stdlib.h>
 // Define a structure for an array.
 struct Array {
   int *A;
   int size;
 };
 void pairwithsumhash(struct Array arr) {
   int i, greatestno = 0, smallestno = 32767;
   int *H;
   int k;
   printf(""Enter the sum of k:"");
   scanf(""%d"", &k);
   for (i = 0; i < arr.size; i++) {
     // Checking for greatestno in the array
     if (arr.A[i] > greatestno)
       greatestno = arr.A[i];
     // Checking for smallestno in the array
     if (arr.A[i] < smallestno)
       smallestno = arr.A[i];
   }
   H = (int *)malloc((greatestno + 1) * sizeof(int));
   // Defining hash table size as per the greatestno
   for (int i = 0; i < greatestno + 1; i++)
     H[i] = 0;
   // Incrementing hash table for every array value.
   for (int i = 0; i < arr.size; i++)
     H[arr.A[i]] = 1;
   for (i = 0; i < arr.size; i++) {
     // Checking whether it is pair or not.
     if ((k - arr.A[i]) >= 0 && H[k - arr.A[i]] != 0) {
       // Printing the result if condition satisfies.
       printf(""%d+%d=%d\n"", arr.A[i], k - arr.A[i], k);
       // Decrementing hash table
       H[arr.A[i]]--;
     }
   }
   free(H);
   H = NULL;
 }
 int main() {
   struct Array arr;
   int ch, i;
   printf(""Enter Size of Array"");
   scanf(""%d"", &arr.size);
   arr.A = (int *)malloc(arr.size * sizeof(int))",C
"import java.util.LinkedList;
 import java.util.Queue;
 import java.util.Scanner;
 /* The diameter of a binary tree is the length of the longest path between any two nodes in a tree. 
  * This path may or may not pass through the root.
  * Time Complexity - O(N) Space Complexity - O(H) 
    where, N is the number of nodes in input binary tree and H is the height of nodes in input binary tree
 */
 /* Wrapping up height and a diameter of a binary tree within a single box */
 class Pair<T1, T2> {
 	public T1 height;
 	public T2 diameter;
 }
 /* Class containing left and right child of current node and key value */
 class BinaryTreeNode<T> {
 	public int data;
 	public BinaryTreeNode<T> left;
 	public BinaryTreeNode<T> right;
 
 	BinaryTreeNode(int data) {
 		this.data = data;
 	}
 }
 public class Diameter_Of_A_BinaryTree {
 	/* Function to find height and diameter of a tree */
 	public static Pair<Integer, Integer> heightDiameter(BinaryTreeNode<Integer> root) {
 
 		/* If root is null then height and diameter of a tree is zero */
 		if (root == null) {
 			Pair<Integer, Integer> output = new Pair<>();
 			output.height = 0;
 			output.diameter = 0;
 			return output;
 		}
 		/* Getting height and diameter of left Subtree */
 		Pair<Integer, Integer> leftSubtree = heightDiameter(root.left);
 
 		/* Getting height and diameter of right Subtree */
 		Pair<Integer, Integer> rightSubtree = heightDiameter(root.right);
 
 		/* Overall height of binary tree */
 		int height = 1 + Math.max(leftSubtree.height, rightSubtree.height);
 
 		/*
 		 * Diameter have 3 options - 1) height of leftSubtree + height of rightSubtree
 		 */
 		int option1 = leftSubtree.height + rightSubtree.height;
 
 		/* 2) Diameter of leftSubtree */
 		int option2 = leftSubtree.diameter;
 
 		/* 3) Diameter of rightSubtree */
 		int option3 = rightSubtree.diameter;
 
 		/* Overall diameter of binary tree */
 		int diameter = Math.max(option1, Math.max(option2, option3));
 
 		Pair<Integer, Integer> output =",Java
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""## LOGISTIC REGRESSION FROM SCRATCH""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""This problem implements logistic regression on university exams of students and predicts if a particular student will pass the exam or not. ""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""The data is taken from a file named 'ex2data1.txt' which contains marks of different students in two exams in first two columns and admission verdict in third coloumn as 0 or 1 (0 == failure and 1 == success).""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 3,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""# importiing important libraries \n"",
     ""%matplotlib notebook\n"",
     ""import numpy as np\n"",
     ""import pandas as pd\n"",
     ""import matplotlib.pyplot as plt\n"",
     ""import scipy.optimize as op # used scipy to implement gradient descent""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 4,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""# function to add a column of ones to the matrix\n"",
     ""def add_ones(X):\n"",
     ""    m = len(X)\n"",
     ""    X = np.c_[np.ones(m), X]\n"",
     ""    return X""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 5,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""# function to perform feature scaling\n"",
     ""def scaling(arr):\n"",
     ""    arr = arr.astype('float64')\n"",
     ""    n = len(arr[0])\n"",
     ""    mu = np.mean(arr, axis=0).reshape(1,n)\n"",
     ""    sigma = np.std(arr, axis=0).reshape(1,n)\n"",
     ""    for x in range(n):\n"",
     ""        arr[:,x]-= mu[0,x]\n"",
     ""        arr[:,x]/= sigma[0,x]\n"",
     ""    return (mu,sigma,arr)""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 6,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""# function to calculat",Python
"/* 
  Problem description:
 
  Given a set of positive numbers, find if we can equally divide
  the set into two subsets such that the sum of elements in both the 
  subsets is equal.
 
 
                           APPROACH
 ---------------------------------------------------------------  
 We will use Dynamic Programming approach to solve this problem.
 Firstly, we will check whether the given array is of even length 
 or not, if not the answer will be always NO, else we will check 
 whether a subset lies in the array such that its sum is equal to 
 half the sum of all the elements of the array, if such subset 
 exists then answer would be YES, else answer is NO.
 
 
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 
 bool EqualPartition(int* array, int array_size ){
     int array_sum=0;
     
     //Finding the sum of all elements of array
     for(int i=0;i<array_size;i++){
         array_sum = array_sum + array[i];
     }
     
     // Checking whether array sum is odd or not, if odd, return false
     if((array_sum % 2) != 0){
         return false;
     }
 
     // Dividing array sum by 2
     array_sum = array_sum / 2;
     bool dp[array_size + 1][array_sum + 1]; //Declaring dp matrix
 
      //Initialising DP matrix with true and false
     for(int i=0; i<=array_size; i++){
         for(int j=0; j<=array_sum; j++){
             if(i==0)
                 dp[i][j]=false;
             if(j==0)
                 dp[i][j]=true;
             
         }
     }
     /*
       Filling DP matrix int dp[][], where dp[i][j] stores whether a given sum = j,
       can be obtained as a sum of elements of a subset, using the first (i+1) elements
       of array.
     */
     for(int i=1; i<=array_size; i++){
         for(int j=1; j<=array_sum; j++){
             if(dp[i][j] <= array_sum){
                 dp[i][j] = ( dp[i][j-array[i-1]] ) || (dp[i-1][j]);
             }
             else{
                 dp[i][j] = dp[i-1][j];
             }
         }
     }
     ",C-Plus-Plus
"'''
 The rob function takes an array as input 
 and returns total amount that can be robbed. 
 
 '''
 
 def rob(nums):
     """"""
     :type nums: List[int]
     :rtype: int
     """"""
     if nums == [] or len(nums) == 0:
         return 0
     elif len(nums) == 1:
         return nums[0]
 
     runningTotal = [-1, -1]
     runningTotal[0] = nums[0]
     runningTotal[1] = max(nums[0], nums[1])
 
     for i in range(2, len(nums)):
         runningTotal.append(max([nums[i] + runningTotal[i - 2],
                             runningTotal[i - 1]]))
 
     return runningTotal[-1]
 
 def main():
     nums = input()
 
     rob(nums)
 
 main()
 
 # Complexity - 
 
 # Time O(N), 
 # Space O(N); N = length of array 
 
 # Sample input/output
 #input: nums = [2, 7, 9, 3, 1]
 #Output: 12
 
 #input: nums = [1, 2, 3, 1]
 #Output: 4
 
",Python
"//This is the pre-order traversal of the binary tree
 /*
 Author - Chaitanya Khinvasara
 */
 
 /*
 Working of the algorithm 
    1. Visit the root.
    2. Traverse the left subtree until you find null
    3. Traverse the right subtree until you find null
 */
 
 
 
 #include <iostream>
 using namespace std;
 
 
 struct node
 {
     int data;
     struct node *left, *right;
 };
 
 //Creation of new node
 struct node *newNode(int item)
 {
     struct node *temp = new node;
     temp->data = item;
     temp->left = temp->right = NULL;
     return temp;
 };
 
 //insertion of the node
 struct node * insert(struct node *root, int element)
 {
     if(root == NULL)
         return newNode(element);
     if(root->data > element)
         root->left = insert(root->left, element);
     else if (root->data < element)
         root->right = insert(root->right, element);
     return root;
 }
 
 //Pre-order traversal
 void preorder(struct node *root)
 {
     if(root == NULL)
         return;
     cout << root->data << "" "";
     preorder(root->left);
     preorder(root->right);
 }
 
 int main()
 {
     struct node *root = NULL;
     root = insert(root, 60);
     insert(root, 40);
     insert(root, 50);
     insert(root, 70);
     insert(root, 80);
     insert(root, 10);
 
 
     cout<<""Pre-order is "" <<endl;
     preorder(root);
     return 0;
 }",C-Plus-Plus
"""""""
 Purpose: Total number of Unique BST's that can be
          made using n keys/nodes.
 Method: Dynamic Programming
 Intution: Total number of Unique BST's with N nodes
             = Catalan(N)
 
 Here function Unique_BST() return the total number of
 diffrent Binary Search Trees that can be made with N distinct nodes
 
 Argument: N (number of distinct nodes)
 return Type: int (Total number of binary tree)
 
 Time Complexity:  O(n)
 Space Complexity: O(n)
 
 Note: Since the number of possible binary search tree will be large
       the answer is given in mod of 10^9+7
       
 """"""
 
 # Catalan_Number (N) = ((2*N)!) / ((N+1)!*N!)
 
 # Global Variables
 MOD = 10**9+7
 facto = [1]  # Factorial Table
 
 # To construct the factorial numbers using DP
 
 
 def factorial(n):
     global facto
     for i in range(1, n+1):
         facto += [(facto[-1]*i) % MOD]
 
 
 # For Modular Inverse of num with respect to 10^9+7
 def Mod_Inv(num):
     return pow(num, MOD-2, MOD)
 
 
 def Catalan_Number(num):
     if num == 0 or num == 1:
         return 1
 
     # Constructing Factorial Table
     factorial(2*num)
     Numerator = facto[2*num]
     Denominator = (facto[num+1]*facto[num]) % MOD
 
     Catalan = (Numerator * Mod_Inv(Denominator)) % MOD
     return Catalan
 
 
 def Unique_BST(N):
     
     # Nth Catalan Number
     Cat = Catalan_Number(N)
     return Cat
 
 # ------------------------DRIVER CODE ------------------------
 
 if __name__ == ""__main__"":
     n = int(input(""Enter the number of distinct nodes: ""))
     print(""Total number of Binary Search Tree = "", Unique_BST(n))
 
 """"""
 SAMPLE INPUT/OUTPUT
 
 Enter the number of distinct nodes: 5
 Total number of Binary  Search Tree =  42
 
 Enter the number of distinct nodes: 10
 Total number of Binary Search Tree =  16796
 
 """"""
",Python
"/**
  * Maximum of Minimum for Every Window Size in an Array
  * Find the maximum of the minimums of every window size in a given 
  * positive integer array of size n. The size of windows in an array 
  * vary from 1 to n. 
  */
 
 import java.io.*;
 import java.util.*; 
 public class MaximumOfMinimumSubarrays {
 
     public static int[] findMaximumOfMinimums(int[] numArray, int n) {
 
         //The next[] and prev[] arrays store the indices of next smaller 
         //and previous smaller integers for each element.  
         int[] next = new int[n]; 
         int[] prev = new int[n];
 
         //If next smaller element is non-existent, then n is stored, if
         //previous smaller element in non-existent, then -1 is stored. 
         for(int i=0; i<n; ++i) {
             next[i] = n; 
             prev[i] = -1; 
         }
 
         //Using stack to get next smaller element
         ArrayDeque<Integer> indices = new ArrayDeque<>(); 
         for(int i=0; i<n; i++) {
             while(indices.peek()!=null && numArray[indices.peek()] > numArray[i]) {
                 next[indices.peek()] = i;
                 indices.pop(); 
             }
             indices.push(i); 
         }
         indices.clear(); 
 
         //Using stack to get previous smaller element
         for(int i=n-1; i>=0; i--) {
             while(indices.peek()!=null && numArray[indices.peek()] > numArray[i]) {
                 prev[indices.peek()] = i;
                 indices.pop(); 
             }
             indices.push(i); 
         }
         
         int[] result = new int[n]; 
         int windowSize = 0; 
         //Here, windowSize stores the window size (length) for which the 
         //concerned element is minimum.
         for(int i=0; i<n; i++) {
             windowSize = next[i] - prev[i] - 1; 
             
             //Since we need the maximum of minimum values for a given windowSize.
             //Since windowSize is from 1 to n, but indices are from 0 to n-1,",Java
"/*The BoyerMoore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space. */
 
 
 import java.util.*;
 
 public class MajorityVote {
 
 	// naive approach
 
 	public static void check(int arr[]) {
 		int count = 0;
 		for (int i = 0; i < arr.length - 1; i++) {
 			count = 1;
 			for (int j = i + 1; j < arr.length; j++) {
 				// Counting the number by matching it with other numbers.
 				if (arr[j] == arr[i]) {
 					count++;
 				}
 			}
 			if (count > arr.length / 2) {
 				System.out.println(""Number Occuring More than 'n/2'="" + arr[i]);
 				System.exit(0);
 			}
 		}
 		System.out.print(""NO majority Elements "");
 	}
 
 	// using The BoyerMoore majority vote algorithm
 	public static int majority(int arr[], int arrsize) {
 
 		int index = 0, count = 1;
 		int i;
 		// finding num to check majority
 		for (i = 1; i < arrsize; i++) {
 			if (arr[index] == arr[i])
 				count++;
 			else
 				count--;
 			if (count == 0) {
 				index = i;
 				count = 1;
 			}
 		}
 		int num = arr[index];
 		for (i = 0; i < arrsize; i++)
 			if (arr[i] == num)
 				count++;
 		// checking for majority
 		if (count > arrsize / 2)
 			return num;
 		else
 			return -1;
 	}
 
 	public static void main(String[] args) {
 		Scanner input = new Scanner(System.in);
 		System.out.println(""Enter Number of elements (Eg. 6) : "");
 		int element_count = input.nextInt();
 		int[] arr = new int[element_count];
 		System.out.println(""Enter "" + element_count + "" Numbers:"");
 		for (int i = 0; i < element_count; i++) {
 			// Giving values to array arr
 			arr[i] = input.nextInt();
 		}
 
 		// Passing array to function
 		check(arr);
 		// using boyer-moore algorithm
 		int result = majority(arr, element_count);
 		if (result != -1)
 			System.out.println(""Majority of a sequence is "" + result);
 
 		else
 			System.out.println(""There is no majority \n"");
 
 
 	}
 
 }
 
 
 /*Enter Number of elements (Eg. 6) : 
 6
 Enter 6 ",Java
"/* This code is an implementation of Hill Cipher. It
    is a polygraphic substitution cipher. It forms a 
    nxn matrix of key and nx1 matrix(s) of the plaintext
    and then multiplies the two matrices to obtains the
    matrix of ciphertext.*/
 
 #include<bits/stdc++.h>
 using namespace std;
 #define SIZE 3
 
 //This function prints the cipher text
 void printciphertext(int cipherMatrix[SIZE][1]){
     
     string output;
     for(int i=0;i<SIZE;i++){
         output += cipherMatrix[i][0]+97;
     }
 
     cout<<""The cipher text is :""<<output;
 }
 
 //This function calculates the matrix multiplication
 void cipher(int cipherMatrix[SIZE][1],int keyMatrix[SIZE][SIZE],int plaintextMatrix[SIZE][1]){
 
       //calculating the multiplication 
       for(int i=0;i<SIZE;i++){
           cipherMatrix[i][0] = 0;
           for(int j=0;j<SIZE;j++){
               cipherMatrix[i][0] += keyMatrix[i][j]*plaintextMatrix[j][0];
           }
 
           cipherMatrix[i][0] = cipherMatrix[i][0]%26;
       }     
 }
 
 //This function builds the key matrix
 void buildkeyMatrix(int keyMatrix[SIZE][SIZE],string key){
  
     int counter =0;
     //storing the key in matrix
     for(int i=0;i<SIZE;i++){
         for(int j=0;j<SIZE;j++){
             keyMatrix[i][j] = key[counter]%97;
             counter++; 
         }
     }
 }
 
 //This function builds the plaintext matrix
 void buildplaintextMatrix(int plaintextMatrix[][1],string plaintext){
 
     //storing the plaintext in matrix form
     for(int i=0;i<SIZE;i++){
         plaintextMatrix[i][0] = (plaintext[i])%97;
     }
 }
 
 //This fuinction helps us in calling all the functions in sequential order
 void hillcipher(string plaintext,string key){
 
     int plaintextMatrix[SIZE][1];
     buildplaintextMatrix(plaintextMatrix,plaintext);
 
     int keyMatrix[SIZE][SIZE];
     buildkeyMatrix(keyMatrix,key);
 
     int cipherMatrix[SIZE][1];
     cipher(cipherMatrix,keyMatrix,plaintextMatrix);
 
     printciphertext(cipherMatrix)",C-Plus-Plus
"/*
 Given a positive integer, count the number of its divisors.
 
 A divisor is a number that divides another number either completely or with a remainder.
 
 Approach used: Extract the prime factors of the given number along with their
 respective contributing powers using the sieve of Eratosthenes and then calculate
 the divisors by applying basic permutation and combination on these powers.
 
 Explanation : Suppose the prime factorization of the number is a^x1+b^x2+c^x3...and so
 on, where a,b,c,etc are its prime factors and x1,x2,x3 their respective powers.
 Then, the divisor count is equal to (x1+1)*(x2+1)*(x3+1)....
 */
 
 #include <iostream>
 #include <vector>
 using namespace std;
 
 vector<int> prime_sieve(int P[], int n)
 {
     P[0] = P[1] = 0;
     P[2] = 1;
     // Mark all odd numbers as prime as even numbers can't be prime.
     for (int i = 3; i < n; i += 2)
     {
         P[i] = 1;
     }
     // Sieve
     for (int i = 3; i < n; i += 2)
     {
         // If the current number is marked 1,it is prime.
         // Hence,its multiples can't be prime.
         if (P[i] == 1)
         {
             // Marking multiples of i, not prime.
             for (int j = i * i; j < n; j += 2 * i)
             {
                 P[j] = 0;
             }
         }
     }
     vector<int> primes;
     primes.push_back(2);
     for (int i = 3; i < n; i += 2)
     {
         if (P[i] == 1)
         {
             primes.push_back(i);
         }
     }
     return primes;
 }
 
 int count_of_divisors(vector<int> primes, int num)
 {
     int i = 0, final_ans = 1;
     int flag = primes[0];
     while (flag * flag <= num)
     {
         if (num % flag == 0)
         {
             // Counting powers of prime factors
             int count = 0;
             while (num % flag == 0)
             {
                 count++;
                 num = num / flag;
             }
             final_ans = final_ans * (count + 1);
         }
         i++;
         flag = primes[i",C-Plus-Plus
"// Checking Armstrong number with Recursion
 
 import java.util.Scanner;
 class ArmStrongRecursion
 {
     static int p;
     public static int armstrong(int i)
     { if(i<10) //base class
         return (int)(Math.pow(i,p));
         else
         return((int)Math.pow(i%10,p)+armstrong(i/10));
     }
     public static void main(String args[])
     {
         Scanner sc=new Scanner(System.in);
         System.out.print(""N = "");
         int n=sc.nextInt();
         p=Integer.toString(n).length(); //calculating the number of digits in the number by converting it into String
 
         if(n==armstrong(n))
         System.out.println(n+"" is an Armstrong number"");
         else
         System.out.println(n+"" is not an Armstrong number"");
     }
 }
 
 /*
 Sample Input and Output :
  N = 153
 153 is an Armstrong number
 Space Complexity: O(1)
 Time Complexity : O(p)
 */
",Java
"#include <bits/stdc++.h>
 using namespace std;
 typedef long long ll;
 typedef vector<ll> vl;
 typedef set<ll> sl;
 #define pb push_back
 
 #define loop(x,n) for(ll x = 1; x <= n; ++x)
 
 //Adjacency List of an Undirected Graph
 vl graph[100001];
 
 bool vis[100001];
 
 ll in[100001], low[100001];
 
 ll timer = 1;
 
 //set to store unique articulation points
 sl cut_vertices;
 sl::iterator itr;
 
 void dfs(ll source, ll parent) {
 	vis[source] = true;
 	in[source] = low[source] = timer;
 	timer++;
 	ll children = 0;
 	for (auto child : graph[source]) {
 
 		//if child equal to parent
 		if (parent == child) continue;
 
 		if (vis[child] == true)
 			//back edge
 			low[source] = min(low[source], in[child]);
 
 		else {
 			dfs(child, source);
 
 			//visited forward edge
 			low[source] = min(low[source], low[child]);
 
 			//condition for having a articulation point
 			if (low[child] >= in[source] && parent != -1)
 				cut_vertices.insert(source);
 
 			children++;
 		}
 	}
 
 	//condition for source vertex for having a cut vertex
 	if (parent == -1 && children > 1 )
 		cut_vertices.insert(source);
 
 }
 
 int main() {
 	ios_base::sync_with_stdio(false);
 	cin.tie(NULL);
 
 	ll n, m, a, b;
 	//n=no. of vertices, m=no. of edges
 	cin >> n >> m;
 
 	loop(i, m) {
 		cin >> a >> b;
 		graph[a].pb(b);
 		graph[b].pb(a);
 	}
 
 	loop(i, n) {
 		//initialise visited array as false;
 		vis[i] = false;
 	}
 
 	loop(i, n) {
 		//dfs call
 		if (vis[i] == false) dfs(i, -1);
 	}
 
 	//print articulation points
 	cout << ""Artciulation points:\n"";
 	for (itr = cut_vertices.begin(); itr != cut_vertices.end(); ++itr)
 		cout << *itr << "" "";
 	return 0;
 }
 
 /*
 Input:
 First line contains two space separated integers,(n,m)
 n- no of vertices, m- no of edges.
 Then m lines follow, each line has 2 space separated integers ui ,vi which denotes edge between vertex ui to vi.
 
 
 TEST CASE
 5 5
 1 2
 1 3
 2 3
 3 4
 4 5
 
 OUTPUT
 Artciulation points:
 3 4
 
 Time- complexity: O(n+m)
",C-Plus-Plus
"// Author : @belikesayantan
 
 package main
 
 import (
 	""bufio""
 	""errors""
 	""fmt""
 	""log""
 	""os""
 	""strconv""
 	""strings""
 	""time""
 )
 
 func main() {
 	var strArray []string
 	var intArray []int
 
 	fmt.Println(""Enter an array with spaces"")
 	reader := bufio.NewReader(os.Stdin)
 	arr, err := reader.ReadString('\n')
 	if err != nil {
 		inputErr := errors.New(""something is wrong with your array input"")
 		log.Fatal(inputErr)
 	}
 	arr = strings.TrimSpace(arr)
 	strArray = strings.Split(arr, "" "")
 
 	for _, val := range strArray {
 		ele, err := strconv.Atoi(val)
 		if err != nil {
 			panic(err)
 		}
 		intArray = append(intArray, ele)
 	}
 
 	start := time.Now() // timer starts and records running time of MergeSort Algorithm
 	fmt.Println(""Sorted Array is: "", MergeSort(intArray))
 	end := time.Now() // timer stops and recording running time of MergeSort Algorithm is completed
 
 	fmt.Println(""\nRunning Time of MergeSort Algorithm is: "", end.Sub(start))
 }
 
 func merge(arr1 []int, arr2 []int) []int {
 	i, j := 0, 0
 
 	arr := make([]int, len(arr1)+len(arr2))
 
 	for i < len(arr1) && j < len(arr2) {
 		if arr1[i] < arr2[j] {
 			arr[i+j] = arr1[i]
 			i++
 		} else {
 			arr[i+j] = arr2[j]
 			j++
 		}
 	}
 
 	for i < len(arr1) {
 		arr[i+j] = arr1[i]
 		i++
 	}
 	for j < len(arr2) {
 		arr[i+j] = arr2[j]
 		j++
 	}
 
 	return arr
 }
 
 // MergeSort Algorithm Time Complexity : O(nlogn) in worst-case
 func MergeSort(arr []int) []int {
 	if len(arr) == 0 {
 		return nil
 	}
 
 	if len(arr) < 2 {
 		return arr
 	}
 	mid := len(arr) / 2
 	left := MergeSort(arr[:mid])
 	right := MergeSort(arr[mid:])
 
 	return merge(left, right)
 }
 
 /*
 	I/O Sample:
 
 	Sample 1:
 	 go run mergeSort.go
 	Enter an array with spaces
 	5 3 2 4 5 84 6 1 54
 	Sorted Array is:  [1 2 3 4 5 5 6 54 84]
 
 	Running Time of MergeSort Algorithm is:  280.029s
 
 
 	Sample 2:
 	 go run mergeSort.go
 	Enter an array with spaces
 	5 8 6 9 1 3 2 7 4
 	Sorted Array is:  [1 2 3 4 5 6 7 8 9]
 
 	R",Go
"/* 
    Find number of subsets with given difference between their sums 
  
    This approach uses dynamic programming and subset sum problem to find the count 
    of subsets whose difference is given. To count the subsets with a given a sum, we need a sum in this problem
    which can be found out by using the formula (diff + sum(arr))/2 explained below.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 int dp[20001][20001];
 
 int countSubsets(int arr[], int n, int sum)
 {
 	if (dp[n][sum] != -1)
 		return dp[n][sum];
 	// base case
 	if (sum == 0)
 		return 1;
 	if (n == 0)
 		return 0;
 	if (arr[n - 1] <= sum)
 		return dp[n][sum] = countSubsets(arr, n - 1, sum - arr[n - 1]) + countSubsets(arr, n - 1, sum);
 		
 	return dp[n][sum] = countSubsets(arr, n - 1, sum);
 }
 
 int subsetsDiff(int arr[], int n, int diff)
 {
 	int arr_sum = 0;
 	// sum of the array
 	for (int i = 0; i < n; i++)
 		arr_sum += arr[i];
     /*
     Let there be two subsets with sum s1 and s2 respectively
 	s1 + s2 = arr_sum
 	s1 - s2 = diff
 	so solving the above equations, we get:
 	s1 = (diff + arr_sum)/2
 	Therefore, we will find number of subsets with sum as s1
     */
 	int sum = (diff + arr_sum) / 2;
 	
 	return countSubsets(arr, n, sum);
 }
 
 int main()
 {
 	// dp table
 	memset(dp, -1, sizeof(dp));
 	int n, diff; 
 	cin >> n >> diff;
 	int arr[n];
 	for (int i = 0; i < n; i++)
 	{
 		cin >> arr[i];
 	}
 
 	cout << subsetsDiff(arr, n, diff);
 	
 	return 0;
 }
 
 /* 
  
  Sample I/O:
  First line contains two integers n and diff denoting size of array 
  and the required difference
  Next line contains n spaced integers
  4 1
  1 1 2 3
 
  Output: 3
 
  Explanation:
  Three pairs of subsets:
  1.[1, 1, 2] and[3]
  2.[1, 2] and[1, 3]
  3.[1, 3] and[1, 2] (Because there are two 1's, so repitition of pairs is there)
 */
 
 /*
  Complexity Analysis: 
  Time Complexity: O(sum*n), where sum is the sum in the function subsetsDiff and n is the size of array.
  Auxiliary Spac",C-Plus-Plus
"/* This code is an implementation of Vernam Cipher in Go. In
 Vernam cipher, also known as the One-Time Pad, the length of
 the plaintext, ciphertext, and key is the same. Basically,
 here the ith letter of the cipher text is fomred by shifting
 the ith letter of the plaintext with the ith letter of key.
 */
 
 package main
 
 import (
 	""fmt""
 	""unicode""
 	""strings""
 	""os""
 )
 
 // This is the encryption function
 func encryption(plaintext, key string) string {
 
 	var encrypted string
 
 	// Shifting the plaintext to generate the ciphertext
 	for i := 0; i < len(plaintext); i++ {
 		var temp int = (int(plaintext[i]) - 97 + int(key[i]) - 97) % 26
 		temp = temp + 97
 		encrypted += string(temp)
 	}
 	// Returns the ciphertext
 	return encrypted
 }
 
 func format(plaintext, ciphertext string) string {
 
 	var enc string
 
 	/* Check wherever the plaintext is capital and
 	then capitalize that character in the ciphertext*/
 	for i := 0; i < len(plaintext); i++ {
 		if(unicode.IsUpper(rune(plaintext[i]))) {
 			enc += strings.ToUpper(string(ciphertext[i]))
 		} else {
 			enc += string(ciphertext[i])
 		}
 	}
 	// Return the final formatted ciphertext
 	return enc
 }
 
 func main() {
 
 	// Taking plaintext as input from the user
 	fmt.Print(""Enter a message to encrypt: "")
 	var plaintext string 
 	fmt.Scan(&plaintext)
 
 	// Taking key as input from the user
 	fmt.Print(""Enter a key of same length: "")
 	var key string
 	fmt.Scan(&key)
 
 	/* If length of key is not equal to length
  	   of plaintext then exit the program.*/
 	if(len(key) != len(plaintext)) {
 		fmt.Print(""\nInvalid key size.\n"")
 		os.Exit(0)
 	}
 
 	// Generating the ciphertext
 	var ciphertext string = encryption(strings.ToLower(plaintext), strings.ToLower(key))
 
 	// Formatting the ciphertext
 	var encrypted string = format(plaintext, ciphertext)
 	fmt.Print(""\nEncrypted plaintext is    : "", encrypted, ""\n"")
 }
 
 /* Sample I/O:
 
 a)
 Enter a message to encrypt: ThisIsAMsg
 Enter a key of same l",Go
"/*
 - Identical_Words :
     We will give 3 Strings as input and we will check if it is possible to make
     second_string and third_string equivalent to first_string by re-arranging characters of
     second_string and third_string any number of times
 
 - Example :
      Input : words ordws rsdow
     Output : They are Identical
 
 - Approach :
   1. After taking the 3-input Strings we will check if their lengths are equal or not, if not then
      they are not equivalent
 
   2. We will use string_sort method to sort the string by converting it to character array and then
      using Arrays.sort() method
 
   3. After all 3 Strings sorted we will check if they are equal or not, if equal then ""They are Identical""
      and if not then ""They are not Identical""
 */
 
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class Identical_Words {
 	//string_sort method
 	public static String string_sort(String s) {
 		//converting string to char array
 		char char_Array[] = s.toCharArray();
 		//sorting char array
 		Arrays.sort(char_Array);
 		//converting char array back to String
 		String sorted_string = new String(char_Array);
 		return sorted_string;
 	}
 	//main method
 	public static void main(String[] args) {
 
 		Scanner sc = new Scanner(System.in);
 		//Enter 3 Strings as input
 		System.out.print(""Enter Strings : "");
 		String first_string = sc.next();
 		String second_string = sc.next();
 		String third_string = sc.next();
 
 		// Checking if length of all Strings are equal or not
 		if(first_string.length() == second_string.length() && first_string.length() == third_string.length()) {
 
 			String s1 = Identical_Words.string_sort(first_string);
 			String s2 = Identical_Words.string_sort(second_string);
 			String s3 = Identical_Words.string_sort(third_string);
 			//Checking if Strings are equal or not
 			if(s1.equals(s2) && s1.equals(s3)) {
 				//if this condition satisfies then print ""They are Identical""
 				System.out.println(""They are Id",Java
"/* Find median in a row wise sorted Matrix in C++.
 
    We are given a row-wise sorted matrix of size r*c,
    we need to find the median of the matrix given.
    It is assumed that r*c is always odd.
 
    Example 1 : 
 
    Input 1 : 1 3 4
              2 6 9
              3 6 9
    
    Output 1 : Median is 4
 
 
    Example 2 : 
 
    Input 2 : 1 3 4
              2 5 6
              7 8 9
    
    Output 2 : Median is 5
   
 
    Formula for calculating the median.
    median = (1 + r * c) / 2
 
    Algorithm :-
    1) First, we need to find the minimum and maximum elements from the matrix.
    2) we can apply binary search on this range.
       The mid element can be calculated and number 
       of elements smaller or equal to mid can be calculated, 
       we have used upper_bound() function for this.
    3) Based on the value of our counter,
       the min and max can be adjusted accordingly based 
       on what we do for binary search.
 */
 
 //CODE :-
 #include<bits/stdc++.h>
 using namespace std;
 
 
 // Function to find median in the matrix
 int solve()
 {
     int r,c;
     cin>>r>>c;
 
     int a[r][c];
     for (int i = 0; i < r; ++i)
     {
         for (int j = 0; j < c; ++j)
         {
             cin>>a[i][j];
         }
     }
 
 
     int min = INT_MAX, max = INT_MIN;
     int desired_count = (1+(r*c)/2);
     for (int i=0; i<r; i++)
     {
         // Find the minimum element
         // and update the minimum element
         if (a[i][0] < min)
             min = a[i][0];
 
         // Find the maximum element
         // and update the maximum element
         if (a[i][c-1] > max)
             max = a[i][c-1];
     }
 
     int counter =0;
     while(min<max)
     {
         counter=0;
         //Find the middle element
         int mid = (max+min)/2;
 
         // Find count of element less then equal to mid
         // Using upper_bound function.
         for(int i= 0;i<r;i++)
         {
             counter += upper_bound(a[i], a[i]+c,",C-Plus-Plus
"#include <iostream>
 #include <algorithm>
 using namespace std;
 
 //Function which returns true if element found in an array, else returns false.
 bool binary_search(int *arr, int search_element, int lb, int ub) {
     while (lb <= ub) {
         int mid = lb + (ub - lb) / 2;
         if (arr[mid] == search_element) {
             return (true);
         } else if (arr[mid] > search_element) {
             ub = mid - 1;
         } else {
             lb = mid + 1;
         }
     }
     return (false);
 }
 
 /** Main function */
 int main() {
     int t, n, search_element;
     int *arr = nullptr;
     cout << ""Enter the number of test cases : "" << std::endl;
     cin >> t;
 
     while (t--) {
         cout << ""Enter the size of an array : "" << std::endl;
         cin >> n;
 
         // dynamic memory allocation
         arr = new int[n];
 
         cout << ""Enter the elements in an array : "" << std::endl;
         for (int i = 0 ; i < n ; i++) {
             cin >> arr[i];
         }
 
         sort(arr, arr + n);
 
         cout << ""Enter the element to search : "" << std::endl;
         cin >> search_element;
 
         // call to binary search function
         bool result = binary_search(arr, search_element, 0, n);
 
         if(result) {
             cout << ""Element found."" << std::endl;
         } else {
             cout << ""Element not found."" << std::endl;
         }
         // free memory after use
         delete[] arr;
     }
     return 0;
 }
",C-Plus-Plus
"/*Take as input N, the size of array. Take N more inputs and store that in an array. Take as input target, a number. Write a function which prints all triplets of numbers which sum to target.
 For example
 input:
 9
 5 7 9 1 2 4 6 8 3
 10
 output:
 1, 2 and 7
 1, 3 and 6
 1, 4 and 5
 2, 3 and 5
 */
 
 #include<stdio.h>
 #include<stdlib.h>
 
 void sort(int a[],int n)
 {
 	//using bubble sort
 	int i,j,temp;
 	for(i=0; i<n; i++)
 	{   	     
 		for(j=0; j<=(n-2)-i; j++)
 		{
 			if(a[j] > a[j+1] ) // if a[j] > a[j+1] then swap them
 			{
 				temp = a[j];
 				a[j] = a[j+1];
 				a[j+1] = temp;
 			}
 		}
 	}
 }
 void tripletSum(int a[],int n,int target)
 {
 	int i=0, j,k;
   for(i=0; i<n; i++ ) // to traverse the whole array we need a foor loop from i to n-1
   {
   	j = i+1; k = n-1; // using 2 iterator approach
   	while(j<k) // loop will stop when j==k
 	{
 		if(a[i] + a[j] + a[k] == target) //if triplet sum is equal to target then print it
 		{
 			printf(""%d, %d and %d\n"",a[i],a[j],a[k]);
 		    j++; k--; //update both iterator as we have find a triplet sum equal to target
 		    
 		}
 		else if(a[i] + a[j] + a[k] > target) // if triplet sum is less than target then decrement the 3 iterator k
 		{
 			k--;
 		}
 		else // increment the 2nd iterator j as triplet sum is greater than target
 		{
 			j++;
 		}
        	   
 	}
 	 
   }
 	
 }
 
 int main()
 {
 	int *a, n,i,target;
 	
 	scanf(""%d"",&n); //input no. of elements in array
 	
 	a = (int*)calloc(n , sizeof(int)); // take dynamic array as they are not of fixed size and are allocated on heap
 	
 	for(i=0; i<n; i++)
 	{
 		scanf(""%d"",&a[i]); //  input elements in array
 	}
 	
 	scanf(""%d"",&target); //input the target number
 	
 	/* We need to sort the array as the output is in sorted form, also it would be easier to check the triplets in forward direction */
 	sort(a,n); // sort the array 
     
 	//the solution is based on 2 pointer approach to find pair sum equal to target	
 	tripletSum(a,n,target); //cal",C
"""""""
 Julia program to check if a number is a pronic number
 Pronic Numbers are those numbers that can be arranged to form a rectangle.
 It is a number which is the product of two consecutive integer
 """"""
 
 function check_pronic(x)
     i = 0
     while(i <= isqrt(x))
         if(x == i * (i + 1))
             return true
         end
         i = i + 1   
     end
     return false 
 end
 
 
 print(""Enter the number: "")
 n = readline()
 n = parse(Int, n)
 res = check_pronic(abs(n))
 if(res)
     print(""The given number $n is a pronic number."")
 else
     print(""The given number $n is not a pronic number."")
 end
 
 
 """"""
 Time Complexity: O(log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number: 154
 The given number 154 is not a pronic number.
 
 SAMPLE 2
 Enter the number: 72
 The given number 72 is a pronic number.
 """"""
",Julia
"/*
 	A neon number is a number where :- 
 	the sum of digits of square of the number is equal to the number. 
 	The task is to check and print neon numbers in a range given by the user.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 //Function that prints the sum of digits of a number
 int sum_of_digits(int y)
 {
     int s = 0,v;
     while (y != 0)
     {
         v=y%10;
         s = s + v;
         y = y / 10;
     }
     return s;
 }
 bool Neon(int n)
 {
     int sq = pow(n,2);
     int result = sum_of_digits(sq);
     //If sum of digits become equal to the number
     if (result == n)
         return true;
     else
         return false;
 }
 
 int main()
 {
     cout << ""Enter the range:"";
     int a, b;
     cin >> a >> b;
 
     // Printing Neon Numbers according to the range
     cout<<""Neon numbers in between ""<<a<<"" to ""<<b<<"" are : "";
     for (int i = a; i <= b; i++)
         if (Neon(i) == true)
             cout << i << "" "";
 }
 /*
    Input: Enter the range:1 10000
    Output: Neon numbers in between 1 to 10000 are : 1 9
 */
 /*
    Time Complexity:O(nlogn) //where n is the range of a to b.
    Space Complexity:O(1)
 */
",C-Plus-Plus
"/* The rail fence cipher (also called a zigzag cipher) is a form of transposition cipher.
    It derives its name from the way in which it is encoded. Given a plain-text message and a numeric key, it cipher the
    given text using Rail Fence algorithm(here key == 2). 
 */
 
 #include<stdio.h>
 #include<string.h>
   
 void cipher(char input[100],int size){
    
   int i = 0;
   int count;
   char string [2][size]; 
   //This is where we cipher the text and store in the 2D array
     while( i < size ) {
     
          for ( count = 0 ; count < 2 ; count++ ) {
               string[count][i] = input[i];
               i++;
          }
     
     }
     //we store the plain text after cipher in this char array 
     char output[size];
     int k = 0;
     int b;
     //Concatenating all the charecters we stored row wise
     while( k < size ) {
   
          for( int a = 0 ; a < 2 ; a++ ) {
               b = a;       
               while( b < size ) { 
                   output[k] = string[a][b];
                   k++;
                   b = b+2;
     
               }
   
          }
   
     }
     printf( ""Cipher :"" );
     //Printing the cipher after the concatenation
     for( int c = 0; c < size ; c++ ) {
   
          if( output[c] != '\n' )  
              printf(""%c"", output[c] );
     
     }
 }
 
 
 int main( void ) {
   
   char input[100];
   printf( ""Enter your plain text here :"" );
   //we take the input here
   fgets( input , 100 , stdin );  
   int size = strlen( input );
     
   cipher(input,size);
   return 0;
 } 
 /*
  Sample I/O : 
    
  Enter your plain text here :Hello World
  Cipher :HloWrdel ol
 
  Time complexity  : O(n)  
  Space complexity : O(n)
  */
",C
"/*
  - Next Greater Element :
   		given an array, we have to find the next greater element for every element in that array
  ALGORITHM:
   * Initialize stack and array
   * If the stack is empty then -1 is printed(no greater element to the right)
   * If not, then if the topmost element is greater than the number, print it
   * If topmost element is less then pop stack until empty or greater number is found
  */
 
 import java.util.Scanner;
 import java.lang.Stack;
 
 public class NextGreaterElement {
 
 	//next_greater_element method
 	public static void next_greater_element(int[] array, int n) 
 	{
 		Stack<Integer> st=new Stack<>();
 		int v[]=new int[n];
 		for(int i=n-1;i>=0;i--)
 		{
 			if(st.empty())
 			v[i]=-1;
 			else if(st.empty()!=true && st.top()>array[i])
 			v[i]=st.top();
 			else if(st.empty()!=true && st.top()<=array[i])
 			{
 				while(st.empty()!=true && st.top()<=array[i])
 				st.pop();
 
 				if(st.empty())
 				v[i]=-1;
 				else
 				v[i]=st.top();
 			}
 			st.push(array[i]);
 		}
 		for(int i=0;i<n;i++)
 		System.out.print(v[i]+"" "");
 	}
 	//main method
 	public static void main(String[] args) {
 
 		Scanner sc = new Scanner(System.in);
 
 		System.out.print(""Enter the number of elements: "");
 		//Input the number of elements you want in the array
 		int n = sc.nextInt();
 
 		//Creating array of n elements
 		int[] array = new int[n];
 
 		System.out.print(""Enter the elements : "");
 		//Putting elements in the array
 		for(int i = 0 ; i < n ; i++) {
 			array[i] = sc.nextInt();
 		}
 		//Calling next_greater_element method
 		NextGreaterElement.next_greater_element(array, n);
 		}
 	}
 }
 /*
  - Test Cases :
       Input : Enter the number of elements: 5
               Enter the elements : 12 34 54 2 62
      Output : 34 54 62 62 -1
 
  - Complexity Analysis :
  *  Time Complexity : O(n)
 
  *  Space Complexity : O(n)
  */
   
",Java
"/*
 There are n vertices and e edges and their weights, 
 you need to construct minimum spanning tree.
 vertex numbers start from 0.
 
 Input:
 first line containes the value of n and e.
 next e lines follow 3 space seperated integers u, v, w, which means
 there is a path between u and v having weight w.
 
 Output:
 First line containing the minimum weight of the tree.
 next n-1 lines containes 2 space seperated integer u, v & w.
 i.e. u and v have a path between them in the formed MST.
 and w denotes the weight.
 
 Efficiency: O(e log e + e alpha e)
 Language: C++17
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 #define MAX_VERTICES 100005
 
 vector <int> parent(MAX_VERTICES);
 vector <int> max_depth(MAX_VERTICES);
 
 //optimised find function
 int findparent(int u)
 {
 	while (u != parent[u])
 	{
 		//path compression technique
 		parent[u] = parent[parent[u]];
 		u = parent[u];
 	}
 	return u;
 }
 
 //union function
 void take_union(int u, int v)
 {
 	u = findparent(u);
 	v = findparent(v);
 	if (max_depth[u] > max_depth[v])
 		parent[v] = parent[u];
 	else if (max_depth[u] < max_depth[v])
 		parent[u] = parent[v];
 	else
 	{
 		max_depth[u]++;
 		parent[v] = u;
 	}
 }
 int main()
 {
 	//decale and read the values of number of
 	//vertices and edges respectively
 	int n, e; 
 	cin >> n >> e;
 	//declare and read the values of edge list 
 	//edge_list.first contains the weight
 	//edge_list.second.first contains the value of u
 	//edge_list.second.second contains the value of v. 
 	vector <pair <int, pair<int, int> > > edges_list(e);
 	for (int i = 0; i < e; i++)
 	{
 		cin >> edges_list[i].second.first >> edges_list[i].second.second;
 		cin >> edges_list[i].first;
 	}
 	//sort the vector in ascending order in order to keep
 	//the edge with weight less first.
 	sort(edges_list.begin(), edges_list.end());
 	//initialize the parent and max_depth vector.
 	for (int i = 0; i <= n; i++)
 		parent[i] = i, max_depth[i] = 0;
 	//check one-by-one whether to add ",C-Plus-Plus
"/* Given n non-negative integers representing an elevation map where the 
 width of each bar is 1, compute how much water it can trap after raining. */
 
 #include<stdio.h>
 #include<stdlib.h>
 #include<math.h>
 
 int trap(int * arr, int n);
 int main() {
   int n, m;
   // accepting the sizes
   printf(""Enter size of array: "");
   scanf(""%d"", & n);
   int * arr = (int *) malloc(sizeof(int) * n);
 
   // accepting the array elements
   printf(""Enter the elements: "");
 
   for (int i = 0; i < n; i++) {
     scanf(""%d "", arr + i);
   }
 
   // print the trapped water value
   printf(""Water trapped is %d"",
          trap(arr, n));
   return 0;
 }
 
 // function to find the water trapped
 int trap(int * arr, int n){
     int Sum = 0, water = 0, top = 0;
     for(int i = 0; i < n; i++)
     {
         // Collect the higher bars //
         if(top < arr[i])
         {
             water += Sum;
             top = arr[i];
             Sum = 0;
         }
         else
             Sum += top - arr[i];
     }
     // resetting the values to zero
     top=0, Sum=0;
     for(int i = n - 1; i > -1; i--)
     {
         // collect both the equal and higher bar
         if(top <= arr[i])
         {
             water += Sum;
             top = arr[i];
             Sum = 0;
         }
         else
             Sum += top - arr[i];
     }
     // return the answer
     return water;
 }
 
 /*
 Time Complexity: O(n)
 Space Complexity: O(n)
 
 Example 1:
 
 Input:
 Enter size of array: 
 12
 Enter the elements: 
 0 1 0 2 1 0 1 3 2 1 2 1
 
 Output:
 Water trapped is: 6
 
 Example 2:
 
 Input:
 Enter size of array:
 5
 Enter the elements: 
 1 4 2 0 1
 
 Output:
 Water trapped is: 1
 
 */
",C
"/**
 Cycle detection in a directed graph
 using DFS. Here, status array shows if the node is in the path that we are currently on. This is used to detect any presence of back edges.
 backedge present <=> cycle present
 **/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 bool cycle;
 
 void dfs_visit(vector<vector<int>>& Graph, int src, vector<bool>& status, vector<bool>& visit) {
 	// mark the node as visited
 	visit[src] = 1;
 	// mark the node saying that it is in the current path
 	status[src] = 1;
 	for (int i = 0; i < Graph[src].size(); i++)
 		if (visit[Graph[src][i]] == 0)
 			dfs_visit(Graph, Graph[src][i], status, visit);
 		else if (status[Graph[src][i]] == 1)
 			cycle = 1;
 	// unmark the node saying the path which contains the node is done
 	status[src] = 0;
 }
 
 void dfs(vector<vector<int>>& Graph, int vertex, vector<bool>& status) {
 	// initially mark all nodes as not visited
 	vector<bool> visit(vertex);
 	// go on visiting each not visited node
 	for (int i = 0; i < vertex; i++)
 		if (visit[i] == 0)
 			dfs_visit(Graph, i, status, visit);
 }
 
 void detect_cycle(vector<vector<int>>& Graph, int vertex) {
 	vector<bool> status(vertex);
 	dfs(Graph, vertex, status);
 	if (cycle == 0)
 		cout << ""No cycle exits in the given graph \n"";
 	else
 		cout << ""Cycle exists in the given graph \n"";
 }
 
 int main() {
 	cycle = 0;
 	int vertex, edge, a, b;
 	// all vertices are labelled from 0 to v-1
 	cin >> vertex >> edge;
 	vector<vector<int>> Graph(vertex);
 	// all directed edges
 	for (int i = 0; i < edge; i++) {
 		cin >> a >> b;
 		// edge a -> b
 		Graph[a].push_back(b);
 	}
 	detect_cycle(Graph, vertex);
 	return 0;
 }
 
 /**
 Input :
 6 8
 0 3
 0 4
 5 0
 1 5
 1 0
 2 1
 3 4
 4 5
 Output :
 Cycle exists in the given graph
 
 Time Complexity : O(vertex+edge)
 Space Complexity : O(vertex)
 **/
",C-Plus-Plus
"# Importing sys module to initalize the maxsize
 import sys
 # Importing collections model to access deque
 from collections import deque
 ''' Knight-Walk '''
 '''Problem Statement :Given a chess board of order N x M and
                       source points (s1, s2) and destination
                       points (d1, d2). The task to find minimum
                       number of moves required by the Knight to
                       go to the destination cell.
                       Note: The chess board consists of rows
                       numbered (1 to N) and columns (1 to M).
 '''
 # Assigning max value a variable can take
 INT_MAX = sys.maxsize - 1
 # Initialize Infinity
 INF = 9999999
 # All the posible moves of the knight
 row = [2, 2, -2, -2, 1, 1, -1, -1]
 col = [-1, 1, 1, -1, 2, -2, 2, -2]
 
 
 # Create the Node
 class Node:
     def __init__(self, x, y, dis=0):  # Distance of self from itself
         self.x = x
         self.y = y
         self.dis = dis
 
     # Since we are using the nodes as a hash we will need a
     # hashtable
     def __hash__(self):
         return hash((self.x, self.y, self.dis))
 
     def __eq__(self, other):
         return (self.x, self.y, self.dis) == (other.x, other.y, other.dis)
 # Enter the number of rows
 print(""Enter the number of matrix : "")
 n = int(input(""Row:""))
 # Taking input of the address of the source and destination
 # as a tuple
 print(""Enter the source:"")
 x = int(input(""src1:""))
 y = int(input(""src2:""))
 src = Node(x, y)
 print(""Enter the source:"")
 x = int(input(""des1:""))
 y = int(input(""des2:""))
 des = Node(x, y)
 # Knight Walk
 
 
 def kinghtwalk(n, src, des):
     # Set to check if the cell is visited or not
     visited = set()
     # Create the queue to check the next reachable cell
     queue = []
     queue.append(src)
     # Loop while the queue is empty
     while queue:
         node = queue.pop(0)
         x = node.x
         y = node.y
         dis = node.dis
         if x == des.x and y == ",Python
"/*
 Description : 
         You are given an array arr[], you have to re-construct an array arr[].
         he values in arr[] are obtained by doing Xor of consecutive elements in the array.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //function performing the Xor opertation on consecutive elements
 int *game_with_no(int arr[], int n)
 {
     for (int i = 0; i < n - 1; i++)
     {
         arr[i] = arr[i] xor arr[i + 1];
     }
     return arr;
 }
 
 int main()
 {
     //size of an array
     int n;
     cout << ""Enter the size of array : "" << endl;
     cin >> n;
     int arr[n];
 
     cout << ""Enter the data in array : "" << endl;
     for (int i = 0; i < n; i++)
     {
         cin >> arr[i];
     }
     //storing the result
     int *arr_2;
     arr_2 = game_with_no(arr, n);
 
     cout << ""After performing Xor of consecutive elements :"" << endl;
     for (int i = 0; i < n; i++)
     {
         cout << arr_2[i] << "" "";
     }
     return 0;
 }
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Case :
  Input : 
  Enter the size of array : 
  5
  Enter the data in array : 
  10
  11
  1
  2
  3
 
  Output ;
  After performing Xor of consecutive elements :
  1 10 3 1 3
 */
 
",C-Plus-Plus
"/*Spiral Matrix
 Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
 */
 #include <stdio.h>
 
 void spiral_matrix(int[][10], int, int);
 int main()
 {
 	int ROW, COLUMN, is_null = 0;
 
 	printf(""Enter Row: "");
 	scanf(""%d"", &ROW);
 
 	printf(""Enter column: "");
 	scanf(""%d"", &COLUMN);
 
 	int matrix[10][10];
 
 	for (int i = 0; i < ROW; i++)
 	{
 		for (int j = 0; j < COLUMN; j++)
 		{
 			scanf(""%d"", &matrix[i][j]);
 			if (matrix[i][j] == 0)
 				is_null++;
 		}
 	}
 
 	if (is_null == ROW *COLUMN)
 	{
 		printf(""\nNull Matrix\n"");
 	}
 	else
 	{
 		printf(""Entered Matrix:\n"");
 		for (int i = 0; i < ROW; i++)
 		{
 			printf(""\n"");
 			for (int j = 0; j < COLUMN; j++)
 			{
 				printf(""%d"", matrix[i][j]);
 				printf(""\t"");
 			}
 		}
 
 		spiral_matrix(matrix, ROW, COLUMN);
 	}
 
 	return 0;
 }
 
 // Prints the spiral matrix of the given matrix
 void spiral_matrix(int matrix[][10], int ROW, int COLUMN)
 {
 	printf(""\n\nSpiral Order Of the Matrix: \t"");
 	int i;
 	int first_row = 0, first_column = 0;
 
 	while (first_row < ROW && first_column < COLUMN)
 	{
 		/*Print the first row from the remaining rows */
 		for (i = first_column; i < COLUMN; ++i)
 		{
 			printf(""%d "", matrix[first_row][i]);
 		}
 
 		first_row++;
 
 		/*Print the last column from the remaining columns */
 		for (i = first_row; i < ROW; ++i)
 		{
 			printf(""%d "", matrix[i][COLUMN - 1]);
 		}
 
 		COLUMN--;
 
 		/*Print the last row from the remaining rows */
 		if (first_row < ROW)
 		{
 			for (i = COLUMN - 1; i >= first_column; --i)
 			{
 				printf(""%d "", matrix[ROW - 1][i]);
 			}
 
 			ROW--;
 		}
 
 		/*Print the first column from the remaining columns */
 		if (first_column < COLUMN)
 		{
 			for (i = ROW - 1; i >= first_row; --i)
 			{
 				printf(""%d "", matrix[i][first_column]);
 			}
 
 			first_column++;
 		}
 	}
 }
 
 /*
 Sample Output
 Enter Rows:2
 Enter Column: 2
 1	2
 3	4
 
 Entered Matrix:
 1	2 
 3 	4
 
 Spiral Order of th",C
"#include <bits/stdc++.h>
 using namespace std;
 typedef long long ll;
 typedef vector<ll> vl;
 #define pb push_back
 
 #define loop(x,n) for(ll x = 0; x < n; ++x)
 
  
 ll capacity[100][100];
 vl adj[100];
 
 ll bfs(ll s, ll t, vl& parent) {
     fill(parent.begin(), parent.end(), -1);
     parent[s] = -2;
     queue<pair<int, int>> q;
     ll inf=INT_MAX;
     q.push({s, inf});
 
     while (!q.empty()) {
         ll cur = q.front().first;
         ll flow = q.front().second;
         q.pop();
 
         for (ll next : adj[cur]) {
             if (parent[next] == -1 && capacity[cur][next]) {
                 parent[next] = cur;
                 ll new_flow = min(flow, capacity[cur][next]);
                 if (next == t)
                     return new_flow;
                 q.push({next, new_flow});
             }
         }
     }
 
     return 0;
 }
 
 ll maxflow(ll s, ll t, ll n) {
     ll flow = 0;
     vl parent(n);
     ll new_flow;
 
     while (new_flow = bfs(s, t, parent)) {
         flow += new_flow;
         ll cur = t;
         while (cur != s) {
             ll prev = parent[cur];
             capacity[prev][cur] -= new_flow;
             capacity[cur][prev] += new_flow;
             cur = prev;
         }
     }
 
     return flow;
 }
 
 
 
 int main() {
 	ios_base::sync_with_stdio(false);
 	cin.tie(NULL);
     ll n,e;
       cout<<""enter the number of nodes and edges\n""; 
     cin>>n>>e; 
     
     ll source, sink,u,v,w;
      cout<<""enter the source and sink\n"";
     cin>>source>>sink;
 
    loop(i,e){
       cin>>u>>v>>w;
       capacity[u][v] = w;
       adj[u].pb(v);
       adj[v].pb(u);
    }
      
    cout<<""Max Flow: ""<<maxflow(source,sink,n);
 	
 	return 0;
 }
 
 /*
 Input:
 First line contains two space separated integers,(n,e) 
 n- no of vertices, e- no of edges.
 Then 2 space separated integers source and sink ie, starting and ending point.
 Then e lines follow, each line has 3 space separated integers u ,v, w which denotes edge from ve",C-Plus-Plus
"/*
 Given a sequence of brackets as a string,
 find maximum possible length of balanced bracket sequence.
 string consists only two characters , one is '(' another is ')'
 */
 
 #include <stdio.h>
 #include <string.h>
 
 //this balanced_bracket_sequence function will calculate maximum possible length of balanced bracket sequence
 int balanced_bracket_sequence(char s[], int string_size)
 {
     int max_possible_balanced_bracket_sequence = 0;
     int first_bracket = 0;
     /* Here if the current character of string is ' ( ' we will increment the first_bracket by 1
     and if the current character of string is ' ) ' we will check
     if first_bracket have value, we will increment max_possible_balanced_bracket_sequence
     by 2 and decrease first_bracket by 1
     */
     for(int i = 0; i < string_size; i++)
     {
         if(s[i] == '(')
         {
             first_bracket++;
         }
         else if(s[i] == ')')
         {
             if(first_bracket)
             {
                 max_possible_balanced_bracket_sequence += 2;
                 first_bracket--;
             }
         }
     }
     return max_possible_balanced_bracket_sequence;
 }
 
 int main()
 {
     printf(""Enter the string : \n"");
     char s[1000];
     scanf(""%s"", &s);
     int string_size = (int)strlen(s);
     int max_balanced_bracket_sequence = balanced_bracket_sequence(s, string_size);
     printf(""Maximum possible length of balanced bracket sequence is : \n"");
     printf(""%d \n"",max_balanced_bracket_sequence);
 }
 
 /*
 Standard Input and Output
 
 Enter the string :
 ((()())
 
 Maximum possible length of balanced bracket sequence is :
 6
 
 Time Complexity : O(N)
 Space Complexity : O(1)
 
 */
",C
"/*
 Celebrity Problem
 
 Problem: In a party, we need to check if there is a celebrity who is known to everyone and he/she knows no one.
 
 Input: A 2D co-relation matrix where rows and columns represent ids of persons present in the party and 
 a value of matrix[i][j] = 1 indicates that the i'th person knows j'th person and a value of 0 indicates that
 i'th person don't know j'th person. The primary diagonal must always be filled with zeroes, as a default value,
 as thier values dont alter the solution logic.
 */
 
 // C++ program to solve the Celebrity Problem
 #include <bits/stdc++.h>
 using namespace std;
 
 /* If a celeb is present in the party, then his/her id'th column would be filled with 1 as values 
    except for the diagonal element and td'th row would be filled with 0s. */
 int find_celebrity(int person[][9000], int n) {
     int low = 0;
     int high = n - 1;
 
     /* While loop to check if there is a column with value as 1 only except the diagonal value. 
        We start checking from the last column indexin the first row. */
     while (1) {
         if (low == high)
             break;
 
         if (person[low][high] == 1)
             low++;
 
         else
             high--;
     }
     for (int i = 0; i < n; i++) {
         if (low == i)
             continue;
         /* Check if low'th index is a celeb or not by checking
            if he/she knows anyone or anyone knows the celeb */
         if (person[low][i] == 1 || person[i][low] == 0)
             return -1;
     }
     return low;
 }
 
 int main() {
     int n;
     cout << ""How many people are present in the party? "";
     cin >> n;
     int person[n][9000];
     cout << ""Enter thier co-relation graph: "";
     // Input the co-relation matrix
     for (int i = 0; i < n; i++) {
         for (int j = 0; j < n; j++) {
             cin >> person[i][j];
         }
     }
     int celeb = find_celebrity(person, n);
     if (celeb >= 0) {
         cout << ""Celebrity is present at the "" << ",C-Plus-Plus
"""""""
 Purpose: Calculate Nth Catalan Number
 
 Argument : Integer
 Return   : Integer ( Nth Catalan Number)
 
 Time Complexity:  O(n)
 Space Complexity: O(n)
 
 Note: The Catalan Number can be to large, hence answer
         is given mod of 10**9.
 """"""
 # Catalan_Number (N) = ((2*N)!) / ((N+1)!*N!)
 
 # Global Variables
 MOD = 10**9+7
 facto = [1]  # Factorial Table
 
 # To construct the factorial numbers using DP
 
 
 def factorial(n):
     global facto
     for i in range(1, n+1):
         facto += [(facto[-1]*i) % MOD]
 
 
 # For Modular Inverse of num with respect to 10^9+7
 def Mod_Inv(num):
     return pow(num, MOD-2, MOD)
 
 
 def Catalan_Number(num):
     if num == 0 or num == 1:
         return 1
     factorial(2*num)
     Numerator = facto[2*num]
     Denominator = (facto[num+1]*facto[num]) % MOD
 
     Catalan = (Numerator * Mod_Inv(Denominator)) % MOD
     return Catalan
 
 # ------------------------DRIVER CODE ------------------------
 
 
 if __name__ == ""__main__"":
     n = int(input(""Enter the number: ""))
     print(n, ""th Catalan Number = "", Catalan_Number(n), sep="""")
 
 """"""
 SAMPLE INPUT/OUTPUT
 
 Enter the number: 5
 5th Catalan Number = 42
 
 Enter the number: 10
 10th Catalan Number = 16796
 """"""
",Python
"/* Hamming Distance
 -----------------
 Problem: 
 For given x and y, return the number of positions where their values differ in their binary representations as a 32-bit integer.
 
 Implementation:
 x = 10 (1010) and y = 6 (0110) if we apply xor to x and y the resultant ans = 12 (1100).
 XOR is 0 when 2 bits are equal and 1 when 2 bits contrasts
 Number of bits in ans = 2
 */
 
 #include<bits/stdc++.h> 
 using namespace std;
 
 // O(N) time complexity
 int solve1(int x, int y) 
 {
     int ans = x^y;
     return __builtin_popcount(ans); 
 }
 
 // O(1) time complexity
 int solve2(int x, int y) 
 {
     int count = 0;
     for (int i = 0; i < 32; i++)
         if ( (x & (1 << i)) != (y & (1 << i)) )
             count++;
     return count;
 }
 int main()
 {
     int x,y; 
     cin>>x>>y;
     cout<<solve2(x,y)<<endl;
 }
 
 /*
 Input:
 x = 10
 y = 6
 Output
 2
 */",C-Plus-Plus
"/*Given the number of nodes and edges of graph check if it's a tree topology*/
 
 #include <iostream>
 #include <vector>
 using namespace std;
 
 int nodes, edges, u, v;
 vector<int> arr[100001];    //Adjacency List storing the graph
 vector<int> vis(100001, 0); //Visited array, it stores wheather the node is visited or not
 
 void dfs(int v)
 {
     /*We mark the node as visited and then 
     recursively visit every unvisited child*/
 
     vis[v] = 1;
     for (auto child : arr[v])
         if (vis[child] == 0)
         {
             dfs(child);
         }
 }
 
 int main()
 {
     cout << ""Enter nodes and number of edges: "";
     cin >> nodes >> edges;
     cout << ""Enter the edges:- \n"";
     for (int i = 1; i <= edges; i++)
     {
         cin >> u >> v;
         arr[u].push_back(v);
         arr[v].push_back(u);
     }
 
     int cc_cnt = 0; //Inititalize the number of connected components
 
     //This loop counts the number of connected components in the graph
     for (int i = 1; i <= nodes; i++)
     {
         if (vis[i] == 0)
         {
             dfs(i);
             cc_cnt++;
         }
     }
 
     //If the number of connected componets is equal to nodes-1 then it is a tree
     if (cc_cnt == 1)
     {
         cout << ""This graph is a tree\n"";
     }
     else
     {
         cout << ""This graph is a tree\n"";
     }
     return 0;
 }
 
 /*
 Sample Input Output :-
 
 Enter nodes and number of edges: 4 3
 Enter the edges:- 
 1 2
 2 3
 1 4
 This graph is a tree
 
 Time Complexity : O( N+E) // Nodes and Edges
 Space Complexity : O( N )
 
 */",C-Plus-Plus
"/*Problem Statement:
 A binary tree is given, there are two players. We are given the root of this binary tree,
 and the number of nodes n in the tree. n is odd, and each node has distinct values.
 Initially, player1 has a color x and player 2 has a color y. 
 Player1 colors the node with value x in red and player2 colors the node with value y in blue.
 Then the players take turns, in each turn the player choses a node of their color and colors
 the uncolored neighbour of the chosen node.
 If a player cannot choose such a node this way, they must pass their turn. 
 If both players pass their turn, the game ends and the winner with more colored nodes wins.
 If you are a player. If it is possible to choose such a y to ensure you win the game, print 1
 else print 0 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 class Node
 {
 public:
     int data;
     Node*left;
     Node*right;
 
     Node(int d)
     {
         data = d;
         left = right = NULL;
     }
 
 };
 
 Node* buildTree(Node*root){
     int d;
     cin>>d;
     if(d==-1)
     {
         return NULL;
     }
     root = new Node(d);
     root->left = buildTree(root->left);
     root->right = buildTree(root->right);
     return root;
 }
 
 void preorder(Node*root)
 {
     if(root==NULL)
     {
         return;
     }
     cout<<root->data<<"" "";
     preorder(root->left);
     preorder(root->right);
 
 }
 
 Node* findNode(Node* root,int first_node)
 {
     if(root==NULL)
     {
         return NULL;
     }
     if(root->data==first_node)
     {
         return root;
     }
     Node* left=findNode(root->left,first_node);
     Node* right=findNode(root->right,first_node);
 
     return (left==NULL?right:left);
 }
 
 int countNodes(Node* root)
 {
     if(root==NULL)
     {
         return 0;
     }
     int Left_nodes=countNodes(root->left);
     int Right_nodes=countNodes(root->right);
 
     return 1+Left_nodes+Right_nodes;
 }
 
 int color(Node* root,int first_node,int actual_nodes)
 {
     Node* t=",C-Plus-Plus
"/*
 Description :
         Given an array and an integer target, traverse the array (from the beginning) 
         and if the element in array is target, double the tagret and continue traversal.
         Find the value of B after the complete traversal.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Solution
 {
 public:
     //function for finding the value after complete traversal
     long long sol(int n, long long arr[], long long target)
     {
         sort(arr, arr + n);
         long long maxi = arr[n - 1];
         while (target <= maxi)
         {
             //in-built method
             if (binary_search(arr, arr + n, target))
             {
                 target = target * 2;
             }
             else
             {
                 return target;
             }
         }
         return target;
     }
 };
 
 int main()
 {
     // size of an array
     int size;
     cout << ""Enter the size of an array : "" << endl;
     cin >> size;
     //element to be searched and then traversed
     int target;
     cout << ""Enter the target element : "" << endl;
     cin >> target;
     long long arr[size];
     cout << ""Enter the data in the array : "" << endl;
 
     for (int i = 0; i < size; i++)
     {
         cin >> arr[i];
     }
     Solution obj;
     long long result = obj.sol(size, arr, target);
     cout << ""Value of target after complete traversal : "" << endl;
     //output
     cout << result << endl;
     return 0;
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Case: 
  Input :
  ""Enter the size of an array : 
  5
  Enter the target element : 
  2
  Enter the data in the array : 
  1 2 3 4 8
 
  Output :
  Value of target after complete traversal : 
  16
 */
 
",C-Plus-Plus
"/*
 
 In mathematics, the Fibonacci numbers, commonly denoted Fn, form a sequence, called the Fibonacci sequence,
 such that each number is the sum of the two preceding ones, starting from 0 and 1
 
 Fibonacci Series - 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ....
 Below is the program for implementing fibonacci series in 3 different ways 
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Number of steps required to complete fora given fibonacci function
 let iterativeCount = 0; // iterative function count
 let recursiveCount = 0; // recursive function count
 let memoizedCount = 0; // memoized function count
 
 // Iterative function ( Looping )
 function fibonacciIterative(n) {
   let array = [0, 1];
 
   for (let i = 2; i < n + 1; i++) {
     iterativeCount++;
     array.push(array[i - 2] + array[i - 1]);
   }
 
   return array[n];
 }
 
 // Recursive function
 function fibonacciRecursive(n) {
   recursiveCount++;
   if (n < 2) {
     return n;
   }
 
   return fibonacciRecursive(n - 1) + fibonacciRecursive(n - 2);
 }
 
 // Memoization ( a technique which attempts to increase function's performance by caching its previously computed results)
 function fibonacciMemoized() {
   let cache = {}; // store previously computed results
 
   return function fib(n) {
     memoizedCount++;
     if (n in cache) {
       return cache[n];
     } else {
       if (n < 2) {
         return n;
       } else {
         cache[n] = fib(n - 1) + fib(n - 2);
         return cache[n];
       }
     }
   };
 }
 
 /* Workflow of user input */
 
 // Take the fibonacci number as input
 let fibKey = +prompt(""Enter number to find fibonacci series value - "");
 
 // Check whether the entered value is number or not
 if (isNaN(fibKey)) return console.log(""Only numbers are allowed"");
 
 // Iterative Result
 let result = fibonacciIterative(fibKey);
 console.log(
   `Fibonacci Iterative result in ${iterativeCount} steps - ${result}`
 );
 ",JavaScript
"/* Q Kth smallest element 
 
 Given an array a[] and a number K where K is smaller than size of array, 
 the task is to find the Kth smallest element in the given array.
 It is given that all array elements are distinct. */
 
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //find the kth samllest Element
 void kthSmallestElement(int arr[], int size, int k){
 
     priority_queue <int> maxHeap;
     
     for(int i = 0; i < size; i++){
         maxHeap.push(arr[i]);
         
         if(maxHeap.size() > k){
             maxHeap.pop();
         }
     }
     cout<< ""Kth smallest element in the array is: ""<< maxHeap.top();
 }
 
 int main()
 {
     int size, k;
      
     cout << ""Enter the size of an Array : "";
     cin >> size;
 
     cout << ""Enter the value of k : "";
     cin>> k;
 
     cout<< ""Enter the elements of the array: "" << endl;
 
     int arr[size];
     
 
     for (int i = 0; i < size; i++){
         cin >> arr[i];
     }
 
     kthSmallestElement(arr, size, k);  
     
     return 0;
 }
 
 /*
 Input 
 Enter the size of an Array : 7                                                                                                                
 Enter the value of k : 3                                                                                                                      
 Enter the elements of the array:                                                                                                              
 7 5 9 8 4 6 10      
 
 Output
 Kth smallest element in the array is: 6 
 
 Space complexity => O(k)
 Time complexity => O(nlogk)
 */",C-Plus-Plus
"/*
 Given a sorted array A, size of N ( N elements) and a target value X,
 find if there exists any pair of elements in the Array such that their total sum is equal to X.
 we can solve this by using Two pointers Method.
 Two pointers Method is a method where one pointer starts from beginning
 and other from the end and they proceed towards each other simultaneously.
 */
 
 #include <stdio.h>
 
 // this Pair_exist_by_Two_Pointer_Method will tell us whether pair exists or not
 int Pair_exist_by_Two_Pointer_Method(int ar[], int N, int X)
 {
     int i = 0, j = N - 1, cur_sum = 0;
     while(i < j)
     {
         cur_sum = ar[i] + ar[j];
         if(cur_sum == X)
         {
             // means you got our expected pair
             return 1;
         }
         else if(cur_sum < X)
         {
             // we will move in right direction
             i++;
         }
         else if (cur_sum > X )
         {
             // we will move in left direction
             j--;
         }
     }
     // we don't get our pair
     return 0;
 }
 
 int main()
 {
     int N, X;
     printf(""Enter array size and target value\n"");
     scanf(""%d %d"", &N, &X);
     int ar[N + 1];
     printf(""Enter array elements \n"");
     int i;
     for(i = 0; i < N; i++)
     {
         scanf(""%d"", &ar[i]);
     }
     int solve = Pair_exist_by_Two_Pointer_Method(ar , N , X);
     if(solve)
     {
         printf(""Pair found and their total sum is equal to target value\n"");
     }
     else
     {
        printf(""Pair doesn't exist in the array\n"");
     }
 }
 
 /*
 Standard Input and Output
 
 Enter array size and target value
 6 70
 10 20 35 50 75 80
 Pair found and their total sum is equal to target value
 
 Time Complexity : O(N)
 Space Complexity : O(1)
 
 */
",C
"'''
 Given an array of positive and negative numbers, find if there is a subarray (of size at-least one) with 0 sum.
 
 Examples : 
 
 Input: {4, 2, -3, 1, 6}
 Output: true 
 Explanation:
 There is a subarray with zero sum from index 1 to 3.
 
 Input: {4, 2, 0, 1, 6}
 Output: true 
 Explanation:
 There is a subarray with zero sum from index 2 to 2.
 
 Input: {-3, 2, 3, 1, 6}
 Output: false
 '''
 def print0S(arr):      #cumulative sum
         d = {0: -1};  
         s = 0
         for i in range(len(arr)):
             s+=arr[i]
             if s in d:  
                 return ""Found a sunbarray with 0 sum"" #  print arr[d[s]+1:i+1]  
             d[s] = i      #key will cumulative sum
         return ""No Such sub array with 0 sum exits!""
 
 if __name__ == ""__main__"":
     arr = list(map(int,input(""Enter the list: "").split()))
     print(print0S(arr))
 
 """"""
 Time Complexity: O(n)
 Space Complexity : O(1)
 
 INPUT: 
 Enter the list: 4 2 -3 1 6
 
 
 OUTPUT:
 Found a sunbarray with 0 sum
 
 """"""
",Python
"/*
 Vernam Cipher is a symmetric key cryptographic algorithm and is one of the 
 transposition technique that converts plain text into ciphertext.
 In this algorithm the size of the key and plain text must be same.
 */
 
 import 'dart:io';
 
 // Function to encrypt plain text using the key provided by user
 String encrypt(String plain, String key) {
   int length = plain.length;
   List<int> encrypt = [];
 
   //Iterate through whole string and replace letters
   for (int index = 0; index < length; index++) {
     int plain_char = plain[index].codeUnitAt(0);
     int key_char = key[index].codeUnitAt(0);
     int encrypted_char = plain_char + key_char - 130;
 
     if (encrypted_char >= 26) {
       encrypted_char -= 26;
     }
     encrypted_char += 65;
     encrypt.add(encrypted_char);
   }
   String encrypted_string = String.fromCharCodes(encrypt);
   return encrypted_string;
 }
 
 // Function to decrypt message using key provided by the user
 String decrypt(String encrypted, String key) {
   int length = encrypted.length;
   List<int> decrypt = [];
 
   //Iterate through whole string and replace letters
   for (int index = 0; index < length; index++) {
     int encrypted_char = encrypted[index].codeUnitAt(0);
     int key_char = key[index].codeUnitAt(0);
     int decrypted_char;
 
     if (encrypted_char >= key_char) {
       decrypted_char = encrypted_char - key_char + 65;
     } else {
       decrypted_char = encrypted_char - key_char + 91;
     }
     decrypt.add(decrypted_char);
   }
   String decrypted_string = String.fromCharCodes(decrypt);
   return decrypted_string;
 }
 
 // Main function with driver code
 void main() {
   print(""Enter 1 to ENCRYPT and 2 to DECRYPT : "");
   int choice = int.parse(stdin.readLineSync()!);
   print(""USE UPPER CASE LETTERS ONLY"");
   if (choice == 1) {
     print(""Enter message to ENCRYPT : "");
     String toEncrypt = stdin.readLineSync()!;
 
     print(""Enter KEY of same length as message :"");
     String key = stdin.readLin",Dart
"/* Sliding Window Maximum is a famous problem where we are given a list of integers
  nums and an integer k, return the maximum values of each sublist of length k. */
 
 
 /* Function to get the maximum element of each sliding window of size k */
 const slidingWindowMaximum = (nums, k) => {
 
     /* Sliding window */
     let window = [];
 
     /* Generating the initial window */
     for(let i=0; i<k; i++){
         
         /* Pushing the index to the window if there are no elements */
         if(window.length == 0){
             window.push(i);
             continue;
         }
 
         /* Getting the last index of our sliding window */
         let index = window[window.length-1];
 
         /* Arranging the elements in the window in descending order by removing the smaller ones */
         while(nums[i] > nums[index] && window.length > 0){
             window.pop();
             if(window.length > 0)
             index = window[window.length-1];
         }
 
         /* Pushing the current element to the window */
         window.push(i);
     }
 
     /* Answer array */
     let array = [];
 
     /* Storing the first maximum element in the array */
     array[0] = nums[window[0]];
 
     /* Generating k-1 windows */
     for(let i=k; i<nums.length; i++){
 
         let index = window[0];
 
         /* Removing indices which are out of bound */
         while(index <= i-k && window.length > 0){
             window.shift();
             if(window.length > 0)
             index = window[0];
         }
 
         if(window.length > 0)
         index = window[window.length-1];
 
         /* Arranging the elements in the window in ascending order by removing the ones which are smaller */
         while(nums[i] > nums[index] && window.length > 0){
             window.pop();
             if(window.length > 0)
             index = window[window.length-1];
         }
 
         window.push(i);
 
         /* Pushing the new maximum to the array */
         array[i",JavaScript
"// C program to find the Length of Longest Decreasing Subsequence
 /*
 In this problem, given an array we have to find the length of the longest decreasing subsequence that array can make.
 The problem can be solved using Dynamic Programming
 */
 #include <stdio.h>
 #include <string.h>
 
 int length_longest_decreasing_subsequence(int arr[], int n)
 {
     int dp[n], max_len = 0;
 
     /* Initialize the dp array with the 1 as value, as the maximum length
        at each point is atleast 1, by including that value in the sequence  */
     for (int i = 0; i < n; ++i)
         dp[i] = 1;
 
     /* Now Lets Fill the dp array in Bottom-Up manner
        Compare Each i'th element to its previous elements from 0 to i-1, 
        If arr[i] < arr[j](where j = 0 to i-1), then it qualifies for decreasing subsequence and
        If dp[i] < dp[j] + 1, then that subsequence  qualifies for being the longest one */
     for (int i = 1; i < n; i++)
     {
         for (int j = 0; j < i; j++)
         {
             if (arr[i] < arr[j] && dp[i] < dp[j] + 1)
                 dp[i] = dp[j] + 1;
         }
     }
 
     //Now Find the maximum element in the 'dp' array
     for (int i = 0; i < n; i++)
     {
         if (dp[i] > max_len)
             max_len = dp[i];
     }
 
     return max_len;
 }
 
 int main()
 {
     int n, max_len;
     printf(""\nWhat is the length of the array? "");
     scanf(""%d"", &n);
     int arr[n];
     printf(""Enter the numbers: "");
     for (int i = 0; i < n; i++)
     {
         scanf(""%d"", &arr[i]);
     }
     max_len = length_longest_decreasing_subsequence(arr, n);
 
     printf(""The length of the longest decreasing subsequence of the given array is %d"", max_len);
     return 0;
 }
 
 /*
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 5
 Enter the numbers: 1 2 3 4 3
 The length of the longest decreasing subsequence of the given ar",C
"""""""
 Python program to check if the number is Neon number or not.
 We can Say that the number is Neon number if its sum of digits
 of square is equal to the number.
 
 """"""
 def Neon_number(number) :
     # Calculating the square of the number
     square_number = pow(number,2)
     # Calculating the sum of digits of the square of the number
     sum_of_digits = 0
     while square_number != 0 :
         digit = square_number % 10
         sum_of_digits += digit
         square_number = square_number // 10
     if sum_of_digits == number :
         print(number,""is a Neon number"")
     else :
         print(number,""is not a Neon number"")
 
 number = int(input(""Enter a number:""))
 Neon_number(number)
 
 """"""
 Sample of input/output:
 
 Example 1:
 Input:
 Enter a Number: 9
 Output:
 9 is a Neon number
 
 Example 2:
 Input:
 Enter Number: 5
 Output:
 5 is not a Neon number
 
 Example 3:
 Input:
 Enter a Number: 0
 Output:
 0 is a Neon number
 
 Space Complexity O(1)
 Time Complexity  O(log(n))
 """"""
 
",Python
"'''
 Backtracking: Backtracking is a general algorithm for finding all (or some) solutions to some computational problems, notably constraint satisfaction problems.
 
 Problem statement: Given a set of n integers, divide the set into 2 halves such a way that the difference of sum of 2 sets is minimum.
 
 Input formate:
 Line1: Number of test casses 
 Line2: The length of the array 
 Line3: space seperated array elements 
 
 Output formate: 
 The 2 array subsets
 
 Method:
 Backtracking 
 
 Intuition: As there can be any possibility we try to check all the possible chances of forming subarrays according to the given possibility.
 We intent to form one subset and push the rest of the elements to the other subset.
 For every element that we iterate through there are 2 possibilities
 1) Belongs to first subset 
 2) Dosent belong to first subset 
 While iterating we also check for the best solution so far and update it.
 
 Argument: int,Array
 return: Array 
 
 '''
 
 def utilfun(arr,n,curr,num,sol,min_diff,sumn,curr_sum,pos):
     '''
     Here the arr is the input and n is its size
     curr is an arr containing curr elements in first subset and num is the length
     sol is the final boolean arr; true means the element is in the first subset
     sumn is tracking the sum of the first subset 
     '''
     #Base Case1 :check if the array is out of bound 
     if(pos==n):
         return
     #Base Case2 :check if the number of elements is not less than the number of elements int he solution 
     if ((int(n/2)-num)>(n-pos)):
         return 
     #case1: when current element is not in the solution 
     utilfun(arr,n,curr,num,sol,min_diff,sumn,curr_sum,pos+1)
     #case2: when the current element belongs to first subset
     num+=1
     curr_sum+=arr[pos]
     curr[pos]=True
     #checking if we got the desired subset array length
     if(num==int(n/2)):
         #checking if the solution is better or not so far 
         if(abs(int(sumn/2)-curr_sum)<min_diff[0]):
    ",Python
"#include <iostream>
 using namespace std;
 
 // Problem Statement:
 // Given a string, write a recursive function, to print the occurrences of string p in the string s(Overlap is allowed)
 // Example :
 // 1. Input: p = ""aaa"", s = ""aaaaaa""
 //   Output: 4
 // 2. Input: p = ""hi"", s = ""hihihithi""
 //   Output: 4
 
 void check_p_in_s(string p, string s, int stri, int count){ 
     if(stri == s.size()){ //When all the characters in string s are checked, print the count
         cout << count;
         return;
     }
     if(p == s.substr(stri, p.size())){ //When we find string p in string s, we increase the count and increment string index by 1
         return check_p_in_s(p, s, stri + 1, count + 1);
     }
     else{ //When string p does not match the substring in s, we just move to the next character without increasing the count
         return check_p_in_s(p, s, stri + 1, count); 
     }
 }
 
 int main(){
     string p, s;
     cout << ""Enter the main string"";
     cin >> s;
     cout << ""Enter the string that you want to count in the main string"";
     cin >> p;
     check_p_in_s(p, s, 0, 0);
     return 0;
 }
",C-Plus-Plus
"# Depth First Search for graphs
 
 
 class Graph:
     def __init__(self, vertices):
         self.vertices = vertices
         self.adjMatrix = [[0 for j in range(vertices)]for i in range(vertices)]
 
     def addEdge(self, v1, v2):
         self.adjMatrix[v1][v2] = 1
         self.adjMatrix[v2][v1] = 1
 
     def removeEdge(self, v1, v2):
         if self.containsEdge(v1, v2):
             self.adjMatrix[v1][v2] = 0
             self.adjMatrix[v2][v1] = 0
 
     def containsEdge(self, v1, v2):
         '''
         Summary line:
         Helps us to check whether a particular edge is present in a graph or not.
 
         Args:
         v1- first vertex from which that edge passes
         v2- second vertex from which that edge passes
 
         Returns-
         Boolean value indicating whether that edge is present or not.
         '''
         if self.adjMatrix[v1][v2] != 0:
             return True
         else:
             return False
 
     def getPathDFShelper(self, sv, ev, visited):
         '''
         Summary line:
         Helps us to perform depth first search in the graph using a stack and adjacency matrix.
 
         Working:
         We use the visited list to mark `True` for every vertex we visit.
         After being visited, we push the next element of the vertex
         into the stack and continue untill we reach a point where
         the next element is also marked `True` for visited.
 
         Args:
         sv- Starting vertex
         ev- Ending vertex
         visited- array containing boolean value
         to indicate if that node has been visited before.
 
         Return:
         Boolean value and a list of nodes
         obtained after DFS traversal.
         '''
         if sv == ev:
             path = [ev]
             return True, path
         visited[sv] = True
         for i in range(self.vertices):
             if self.adjMatrix[sv][i] == 1 and visited[i] == False:
                 hasPath, path = self.getPathDFShelper(i,",Python
"/*
 A very popular problem asked in interviews medium difficulty
 Apoorvaa has created an elevated roof. She wants to know how much water can she save during rain.
 
 Given n non negative integers representing the elevation map where width of every bar is 1, Find the maximum water that she can save.
 
 Explanation for the Sample input Testcase: 
 ![image](https://user-images.githubusercontent.com/44130067/94519631-84921880-0248-11eb-8515-416d81534168.png)
 So the total units of water she can save is 5 units
 
 **Input Format**
 First line contains an integer n. Second line contains n space separated integers representing the elevation map.
 
 **Constraints**
 1 <= N <= 10^6
 
 **Output Format**
 Print a single integer containing the maximum unit of waters she can save.
 
 **Sample Input**
 10
 0 2 1 3 0 1 2 1 2 1
 **Sample Output**
 5
 **Explanation**
 Refer to the image for explanation. Count the number of cells having water in them.
 */
 #include<iostream>
 using namespace std;
 int maxWater_optimized(int arr[], int n)
 {
     int water = 0; // To store the final ans
 
     int left_max = 0;  // Which stores the current max height of the left side
     int right_max = 0; // Which stores the current max height of the right side
 
     int lo = 0;     // Counter to traverse from the left_side
     int hi = n - 1; // Counter to traverse from the right_side
 
     while (lo <= hi)
     {
 
         if (arr[lo] < arr[hi])
         {
 
             if (arr[lo] > left_max)
             {
                 left_max = arr[lo]; // Updating left_max
             }
             else
             {
 
                 water += left_max - arr[lo]; // Calculating the ans
             }
             lo++;
         }
         else
         {
 
             if (arr[hi] > right_max)
             {
                 right_max = arr[hi]; // Updating right_max
             }
             else
             {
                 water += right_max - arr[hi]; // Calculating the ans
            ",C-Plus-Plus
"/*
    This is a simple program written in go language.
    This program takes in a number as an input an 
    returns the Fnth term in the fibonacci sequence.
 
    Here the base case is Fo =1 and F1 =1
    Formula goes as : Fn = Fn-1 + Fn-2
 
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 /* This function takes the given number and 
    returns the fibonacci number*/
 func fibonacci(n int) int{
 
    // base case as Fo =1 and F1 =1
    if(n == 0 || n == 1){
 
         return n
 
     }else {
 
         // Fn = Fn-1 + Fn-2
         return fibonacci(n-1) + fibonacci(n-2)
 
     }
 
 }
 
 //driver function
 func main() {
 
    var number int
    fmt.Print(""Enter the number :"")
    //taking the input from here
    fmt.Scan(&number)
 
    var res int
    res = 0
 
    /* calling the fibonacci functuion to return 
       the value and printing it out*/
    res = fibonacci(number)
    fmt.Print(""The number is : "",res)
 
 }
 
 /*
    Sample I/O :
 
    a) Base Case :   
 
    Enter the number :0
    The number is : 0 
 
    Enter the number :1
    The number is : 1   
 
    b) At random number n : 
 
    Output-1:
 
    Enter the number :20
    The number is : 6765      
 
    Output-2:
 
    Enter the number :40
    The number is : 102334155   
 
 */
 
",Go
"""""""
 Find the area of various geometric shapes
 """"""
 
 import math
 
 
 def area_rectangle(base, height):
     """"""
     Calculate the area of a rectangle
     >> area_rectangle(10,20)
     200
     """"""
     return base * height
 
 
 def area_square(side_length):
     """"""
     Calculate the area of a square
     >>> area_square(10)
     100
     """"""
     return side_length * side_length
 
 
 def area_triangle(length, breadth):
     """"""
     Calculate the area of a triangle
     >>> area_triangle(10,10)
     50.0
     """"""
     return 1 / 2 * length * breadth
 
 
 def area_parallelogram(base, height):
     """"""
     Calculate the area of a parallelogram
     >> area_parallelogram(10,20)
     200
     """"""
     return base * height
 
 
 def area_trapezium(base1, base2, height):
     """"""
     Calculate the area of a trapezium
     >> area_trapezium(10,20,30)
     450
     """"""
     return 1 / 2 * (base1 + base2) * height
 
 
 def area_circle(radius):
     """"""
     Calculate the area of a circle
     >> area_circle(20)
     1256.6370614359173
     """"""
     return math.pi * radius * radius
 
 
 def main():
     print(""Areas of various geometric shapes: \n"")
     print(""enter the shape of your choice:"")
     again = True
 
     while(again):
         print(""menu:"")
         print(""1. Rectangle"")
         print(""2. Square"")
         print(""3. Triangle"")
         print(""4. Parallelogram"")
         print(""5. Trapezium"")
         print(""6. Circle"")
         choice = int(input())
         if(choice == 1):
             print(""Enter sides of rectangle:"", end="" "")
             l, b = input().split()
             l = int(l)
             b = int(b)
             print(""Rectangle with sides ""+str(l)+"" and ""+str(b)+"" is:"", end="""")
             print(str(area_rectangle(l, b)))
             print(""you wnat to continue (1/0)"", end="" "")
             again_choice = int(input())
             if(again_choice):
                 again = True
             else:
                 again = False
       ",Python
"/*
 Introduction -
 Given the root of a binary tree where each node has a value 0 or 1.
 Each root-to-leaf path represents a binary number starting with the most significant bit.
 For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.
 Find the sum of these numbers.  
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //Define Node as structure
 struct TreeNode
 {
 	int data;
 	TreeNode *left;
 	TreeNode *right;
 };
 
 //Function to allocate new node with given data
 TreeNode *newNode(int data)
 {
 	TreeNode *node = new TreeNode();
 	node->data = data;
 	node->left = node->right = NULL;
 	return (node);
 }
 
 //Function to create Binary Tree from preorder traversal
 TreeNode *buildTree()
 {
 
 	//Input
 	int d;
 	cin >> d;
 
 	//If d is -1 then return NULL
 	if (d == -1)
 		return NULL;
 
 	//Place data at current node
 	TreeNode *root = newNode(d);
 
 	//recursively build Left and Right Subtrees
 	root->left = buildTree();
 	root->right = buildTree();
 
 	return root;
 }
 //This stores the ans ie sum of binary numbers from root to leaf
 int total_sum = 0;
 //This stores the ans of single path from root to leaf
 int curr_sum = 0;
 
 //Function for preorder traversal of binary tree
 void preorder(TreeNode *root, int curr_sum)
 {
 	//Base Condition
 	if (root == NULL)
 		return;
 	//converting base 2 to base 10
 	curr_sum = curr_sum * 2 + root->data;
 	//When we encounter leaf node
 	if (root->left == NULL && root->right == NULL)
 		//Path found
 		total_sum += curr_sum;
 	preorder(root->left, curr_sum);
 	preorder(root->right, curr_sum);
 }
 
 //Function to find sum of root to leaf
 int sumOfRootToLeaf(TreeNode *root)
 {
 
 	//Base Condition
 	if (root == NULL)
 		return 0;
 	//Root to left traversal is DFS preorder traversal Root->left->right
 	preorder(root, 0);
 	return total_sum;
 }
 
 int main()
 {
 
 	//Create the Tree
 	cout << ""Enter the binary tree elements preorder wise and enter -1 ",C-Plus-Plus
"import numpy as num
 #Author @anushkrishnav
 #Implementation of Strassen Matrix MUl algorithm.
 class Strassen_Matrix(object):
     def __init__(self,a=[],b=[]):
         self.A=a
         self.B=b
         self.C=None
     def MatMul(self):
         self.StrassenMethod(self.A,self.B)
         return self.C
     def BruteForce(self):
         C=[]
         '''Brute Force T(n)=O(n^3)'''
         lent=len(self.A)
         for i in range(lent):
             C.append([0,0,0])
             for j in range(lent):
                 for k in range(lent):
                     C[i][j]+=A[i][k]*B[k][j]
         self.C=C
         return self.C
     def StrassenMethod(self,x,v):
         '''T(N)=7T(N/2)+O(N^2)'''
         if len(x)==1:
             return x*v
         a,b,c,d=self.SplitMat(x)# Splitting matrix x and v into  quadrants
         e,f,g,h=self.SplitMat(v)#Splits Recursivly
 
         #Computing the  products Using Strassen's formula
         P1=self.StrassenMethod(a,f-h)
         P2=self.StrassenMethod(a+d,h)
         P3=self.StrassenMethod(c+d,e)
         P4=self.StrassenMethod(d,g-e)
         P5=self.StrassenMethod(a+d,e+h)
         P6=self.StrassenMethod(b-d,e+h)
         P7=self.StrassenMethod(a-c,e+f)
         ij11=P5+P4+P6-P2
         ij12=P1+P2
         ij21=P3+P4
         ij22=P1+P5-P3-P7
         self.C=num.vstack((num.hstack((ij11,ij12)),num.hstack((ij21,ij22))))
     @staticmethod
     def SplitMat(Matrix):
         ''' 
         Splits a given matrix''' 
         row_len,col_len=Matrix.shape
         row,col=row_len//2,col_len//2
         return Matrix[:row, :col], Matrix[:row, col:], Matrix[row:, :col], Matrix[row:, col:]
     
 
 
 if __name__ == ""__main__"":
     A=num.matrix('1 2;3 4')
     B=num.matrix('1 1;1 1')
     rs=Strassen_Matrix(A,B)
     print(rs.MatMul())
",Python
"/*Code for maximum number formed from the given array of two digit numbers
 Given: An array of two digit numbers
 Objective: Form the maximum number
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 int myCompare(string X, string Y)
 {
     string XY = X.append(Y);
     string YX = Y.append(X);
     return XY.compare(YX) > 0 ? 1 : 0;
 }
 int printLargest(vector<string> str)
 {
     sort(str.begin(), str.end(), myCompare);
     for (int i = 0; i < str.size(); i++)
         cout << str[i];
 }
 int main()
 {
     vector<string> str;
     long long int n;
     cin >> n;
     string s;
     for (int i = 0; i < n; i++)
     {
         cin >> s;
         str.push_back(s);
     }
     printLargest(str);
 }
 /* 
 Time Complexity:O(n)
 Example:
 Input:
 5
 12 34 22 45 20
 Output:
 4534222012
 */
",C-Plus-Plus
"/* Bead sort, also called as gravity sort, is a natural sorting algorithm since this algorithm was inspired
 from natural phenomenons and was designed keeping in mind objects(or beads) falling under the influence of gravity.
 The bead sort operation can be compared to the manner in which beads slide on parallel poles, such as on an abacus.
 However, each pole may have a distinct number of beads. */
 
 #include <stdio.h>
 #include <stdlib.h>
 #define BEAD(i, k) beads[i * max + k]
 
 void bead_sort(int *arr, int n){
     int max=arr[0],sum,i,k;
 	for (i = 1; i < n; i++)
 		if (arr[i] > max)
 		    max = arr[i];
 
 	// pointer to the first character of string beads
 	unsigned char *beads;
 
 	// allocate one block of memory of size (max*n) to first char beads and initialize it to 0
 	beads = calloc(1, max * n);
 
 	for (i = 0; i < n; i++){
 	    for (k = 0; k < arr[i]; k++){
 	        BEAD(i, k) = 1;
 	    }
 
 	}
 
 	for (k = 0; k < max; k++) {
 		sum=0;
 		for (i = 0; i < n; i++) {
 			sum = sum + BEAD(i, k);
 			BEAD(i, k) = 0;
 		}
 		for (i = n - sum; i < n; i++)
 		    BEAD(i, k) = 1;
 	}
 
 	for (i = 0; i < n; i++) {
 		for (k = 0; k < max && BEAD(i, k); k++);
 		arr[i] = k;
 	}
 
 	//deallocate the memory allocated to beads
 	free(beads);
 }
 
 int main(void) {
 
 	int n, i, k;
 	printf(""Enter the number of elements in the array : "");
 	scanf(""%d"",&n);
 
 	int nums[n];
 	printf(""Enter the elements of the array : "");
 	for(i = 0; i < n; i++){
 	    scanf(""%d"",&nums[i]);
 	}
         bead_sort(nums, n);
 
 	printf(""The array elements after sorting are : "");
 	for (i = 0; i < n; i++)
 		printf(""%d\n"", nums[i]);
 
 	return 0;
 }
 
 /*
 
 Input:
 Enter the number of elements in the array : 5
 Enter the elements of the array : 14 26 43 92 18
 
 Output:
 The array elements after sorting are : 14
 18
 26
 43
 92
 
 Time Complexities:
 Bead sort can be implemented with four general levels of complexity, among others:
 O(n): in best case
 O(S): in worst case, where S is ",C
"'''
 Stack implementation using List in Python
 '''
 
 stack = []
 
 # For the stack to be dynamic it has been put in a loop
 # While the loop is true the user gets 5 options:
 # 1 to push  element in stack
 # 2 to pop element from stack
 # 3 to display elements in stack
 # 4 To peek
 # 5 To exit
 
 
 try:  # try except so that the program does not crash[optional]
 
     while True:
         op = int(input('''
 Press-->
 1 to push into stack
 2 to pop from stack
 3 to diplay elements of stack
 4 to peek top most element
 5 to exit
 
 '''))
 
         if op == 1:  # To push into stack
 
             ele = int(input(""\nenter element  to push ""))
             stack.append(ele)
 
         elif op == 2:  # To pop from stack.
 
             if len(stack) == 0:
                 print(""\nStack is empty "")
             else:
                 ele = stack.pop()
                 print(""\npopped element "", ele)
 
         elif op == 3:  # To display stack elements
 
             if len(stack) == 0:
                 print(""\nStack is empty "")
             else:
                 print(stack)
 
         elif op == 4:  # To peek stack top.
 
             if len(stack) == 0:
                 print(""\nStack is empty "")
             else:
                 print(""\nTop most element in stack is "", stack[-1])
 
         elif op == 5:  # To exit from loop
 
             break
 
         else:
 
             print(""\ninvalid option"")
 
 
 except ValueError:
 
     print(""Please enter integer only"")
 
 except:
 
     print(""There's been some issue please check the data you've entered"")
 
 
 """"""
 Sample Input- Output
 Press-->
 1 to push into stack
 2 to pop from stack
 3 to diplay elements of stack
 4 to peek top most element
 5 to exit
 1
 enter element  to push 2
 Press-->
 1 to push into stack
 2 to pop from stack
 3 to diplay elements of stack
 4 to peek top most element
 5 to exit
 1
 enter element  to push 3
 Press-->
 1 to push into stack
 2 to pop from stack
 3 to diplay elements of ",Python
"/*
 Introduction 
 You are a professional robber planning to rob houses along a street.
 Each house has a certain amount of money stashed, 
 the only constraint stopping you from robbing each of them is that 
 adjacent houses have security systems connected and it will automatically contact the police 
 if two adjacent houses were broken into on the same night.
 
 Argument/Return Type
 Given an integer array nums representing the amount of money of each house,
 return the maximum amount of money you can rob tonight without alerting the police.
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Function to find the maximum amount of money you can rob tonight without alerting the police
 int MaxMoney(vector<int>&nums) 
 {
     int n=nums.size();
 
     //If there are 0 houses , return 0
     if(n==0) 
         return 0;
 
     //If there is only one house , return its money
     if(n==1) 
         return nums[0];
 
     /* If there are atleast 2 houses ,create a dp vector and 
     calculate the maximum amount of money you can rob 
     without alerting the police till that particular house */
     vector<int>dp(n);
     dp[0]=nums[0];
     dp[1]=max(nums[1],dp[0]);
     for(int i=2;i<n;i++)    
     {
         /* At each i th house 
         either ( houses upto i-2 ) + ( i th house )
         or ( houses upto i-1 ) can be robbed */
         dp[i]=max(nums[i]+dp[i-2],dp[i-1]);
     }
 
     //Return the required answer which is the maximum amount of money that can be robbed till last house
     return dp[n-1];
 }
 
 
 // Driver code
 int main()
 {
     //Take input for size of nums vector
     int n;
     cout<<""Enter total no.of houses : "";
     cin>>n;
 
     //create a vector to take input and store them
     vector<int>nums;
 
     cout<<""Enter money in each house, with spaces between them : "";
 
     for(int index=0;index<n;index++)
     {
         //Take the input of each value and push it into the vector
         int value;
         cin>>value;
      ",C-Plus-Plus
"    /*
     Given a string, we need to reverse it without reversing any word in it.
     We can reverse each word of a string.
     In other words, Reverse text without reversing individual word in a String.
     */
     import java.util.Scanner;
 
     public class Reverse_String 
     {
     /*
     This is an constructor called from main function
     */
     public Reverse_String(String in[],int n)
     {
          System.out.println(); 
         
 	   for (int i = n - 1; i >= 0; i--) 
            {
                System.out.print(in[i] + "" "");
            }
     }
     public static void main(String[] args) 
     {
 
        Scanner scan = new Scanner(System.in);
        System.out.println(""Please Enter the number of words your String have...."");
        int n = scan.nextInt();
        String in[] = new String[n];
        System.out.println(""Please enter your String here..."");
            for (int i = 0; i <= n-1; i++) 
 	   {
               in[i] = scan.next();
            }
        Reverse_String r1=new Reverse_String(in,n);
     }
     }   
     /*
     Time complexity is O(n-1)
     Space complexity is O(1)
     Input :
     Please Enter the number of words your String have....
     6
     Please enter your String here...
     i like this program very much
     Output:
     much very program this like i
     */
",Java
"/*
 A stack is an Abstract Data Type (ADT), commonly used in most programming languages.This feature makes it LIFO data structure. LIFO stands for Last-in-first-out. Here, the element which is placed (inserted or added) last, is accessed first.
 The Basic operation in Stack are:
 1.push()  Pushing (storing) an element on the stack.
 2.pop()  Removing (accessing) an element from the stack.
 3.peek()  get the top data element of the stack, without removing it.
 4.display() - used to display the elements
 */
 
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
 #define SIZE 10
 
 void push(int);
 void pop();
 void peek();
 void display();
 
 int stack[SIZE], top = -1;
 
 void main()
 {
 	int s;
         printf(""Enter the array size: "");
         scanf(""%d"", &s);
         int a[s];
 	int value, choice;
 	while (1)
 	{
 		printf(""\n\n*****MENU *****\n"");
 		printf(""1. Push\n2. Pop\n3. Display\n4. Peek\n5. Exit"");
 		printf(""\nEnter your choice: "");
 		scanf(""%d"", &choice);
 		switch (choice)
 		{
 			case 1:
 				printf(""Enter the value to be insert: "");
 				scanf(""%d"", &value);
 				push(value);
 				break;
 			case 2:
 				pop();
 				break;
 			case 3:
 				display();
 				break;
 			case 4:
 				peek();
 				break;
 			case 5:
 				exit(0);
 			default:
 				printf(""\nWrong selection!!! Try again!!!"");
 		}
 	}
 }
 void push(int value)
 {
 	if (top == SIZE - 1)
 		printf(""\nStack is Full!!! Insertion is not possible!!!"");
 	else
 	{
 		top++;
 		stack[top] = value;
 		printf(""\nInsertion success!!!"");
 	}
 }
 void pop()
 {
 	if (top == -1)
 		printf(""\nStack is Empty!!! Deletion is not possible!!!"");
 	else
 	{
 		printf(""\nDeleted Element : %d"", stack[top]);
 		top--;
 	}
 }
 void display()
 {
 	if (top == -1)
 		printf(""\nStack is Empty!!!"");
 	else
 	{
 		int i;
 		printf(""\nStack elements are:\n"");
 		for (i = top; i >= 0; i--)
 			printf(""%d\n"", stack[i]);
 	}
 }
 void peek()
 {
 	if (top == -1)
 		printf(""\nstack is empty!!!"");
 	else
 	{
 ",C
"'''
 Rotation of the list means that each elementis shifted right by one index, and the last element of the list is moved to the first place. This is done N number of times,
 where N is user-defined
 '''
 
 def Rotate(list, N):
     for i in range(N):
         a = list.pop()
         list.insert(0, a)
     return list
 
 try:
 
     # For the list rotation to be dynamic it has been put in a loop
     # While the loop is true the user gets 4 options
 
     while True:
         op = int(input('''
 Press-->
 1 to insert elements in the list
 2 to rotate list cyclically
 3 to display list
 4 to add an element in the list
 5 to exit
 '''))
 
         if op == 1:
             list = list(map(int, input(""Enter the numbers: "").split()))
 
         elif op == 2:
             if len(list) == 0:
                 print(""The list is empty, insert values if required"")
             else:
                 N = int(input(""By how much would you like to rotate ""))
                 print(""list before rotating by "", N, "" "", list)
                 list = Rotate(list, N)
                 print(""list after rotating by "", N, "" "", list)
 
         elif op == 3:
             if len(list) == 0:
                 print(""The list is empty, insert values if required"")
             else:
                 print(list)
 
         elif op == 4:
             ele = int(input(""Enter element to put in list ""))
             list.append(ele)
 
         elif op == 5:
             break
 
         else:
             print(""Invalid option"")
 
 except ValueError:
     print(""Please enter integer only"")
 
 except:
     print(""There's been some issue please check the data you've entered"")
 
 '''
 Sample Input-output:
 
 >Cyclically_rotate.py
 Press-->
 1 to insert elements in the list
 2 to rotate list cyclically
 3 to display list
 4 to add an element in the list
 5 to exit
 1
 Enter the numbers: 2 3 4 5
 
 Press-->
 1 to insert elements in the list
 2 to rotate list cyclically
 3 to display list
 4 to add an elem",Python
"/*
 Implementation of Quotient-Remainder Sorting algorithm (non-negative numbers only) in C++
 */
 
 #include <bits/stdc++.h>
 #include <vector>
 #include <list>
 #include <utility>
 
 using namespace std;
 
 // Function for QR-Sort Algorithm implementation.
 vector < int64_t > func(vector < int64_t > a, int64_t n) {
     vector < int64_t > ans;
     // Vector (v) of list of pair of type { arr[i] / n , arr[i]}.
     //  The index of vector represents remainder.
     vector < list < pair < int64_t, int64_t >>> v(n);
     for (int64_t i = 0; i < n; i++) {
         int64_t r = a[i] % n;
         v[r].push_back(make_pair(a[i] / n, a[i]));
     }
     // Add delimiter {-1,-1} for each index in the vector
     for (int64_t i = 0; i < n; i++) {
         v[i].push_back(make_pair(-1, -1));
     }
     // Run the loop until the size of output array is not equal to input array.
     while (ans.size() != n) {
         for (int64_t i = 0; i < n; i++) {
             while (!v[i].empty()) {
                 pair < int64_t, int64_t > p = v[i].front();
                 v[i].pop_front();
                 if (p.first == -1) {
                     // Delimiter found break the loop
                     break;
                 } else {
                     if (p.first == 0) {
                         // Add the array element in the output array
                         ans.push_back(p.second);
                     } else {
                         int64_t r1 = p.first % n;
                         int64_t q1 = p.first / n;
                         v[r1].push_back(make_pair(q1, p.second));
                     }
                 }
             }
         }
         // Adding delimiter for next pass.
         for (int64_t i = 0; i < n; i++) {
             v[i].push_back(make_pair(-1, -1));
         }
     }
     return ans;
 }
 
 int main() {
     int64_t n;
     cout << ""Enter input size"" << ""\n"";
     cin >> n;
     vector < int64_t > a(n);
     vector < int64_t > ans;
     cout << ""Ente",C-Plus-Plus
"def kadane(arr, start, finish, n): 
       
     Sum = 0
     maxSum = -999999999999
     i = None
    
     finish[0] = -1
   
    
     local_start = 0
       
     for i in range(n): 
         Sum += arr[i]  
         if Sum < 0: 
             Sum = 0
             local_start = i + 1
         elif Sum > maxSum: 
             maxSum = Sum
             start[0] = local_start  
             finish[0] = i 
   
      
     if finish[0] != -1:  
         return maxSum  
   
    
     maxSum = arr[0]  
     start[0] = finish[0] = 0
   
     
     for i in range(1, n): 
         if arr[i] > maxSum: 
             maxSum = arr[i]  
             start[0] = finish[0] = i 
     return maxSum 
   
 
 def findMaxSum(M): 
     global ROW, COL 
     # Variables to store the final output  
     maxSum, finalLeft = -999999999999, None
     finalRight, finalTop, finalBottom = None, None, None
     left, right, i = None, None, None
       
     temp = [None] * ROW 
     Sum = 0
     start = [0] 
     finish = [0]  
   
     
     for left in range(COL): 
           
        
         temp = [0] * ROW  
   
         # Set the right column for the left  
         # column set by outer loop  
         for right in range(left, COL): 
               
             # Calculate sum between current left  
             # and right for every row 'i' 
             for i in range(ROW): 
                 temp[i] += M[i][right]  
   
            
             Sum = kadane(temp, start, finish, ROW)  
   
            
             if Sum > maxSum: 
                 maxSum = Sum
                 finalLeft = left  
                 finalRight = right  
                 finalTop = start[0]  
                 finalBottom = finish[0] 
   
     
     print(""(Top, Left)"", ""("", finalTop,  
                               finalLeft, "")"")  
     print(""(Bottom, Right)"", ""("", finalBottom,  
                                   finalRight, "")"")  
     print(""Max sum is:"", maxSum)
 if __name__ == '__main__':
     RO",Python
"//C++ Program to convert a positive decimal number into its equivalent binary number
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //Function to convert a positive decimal number into a binary number
 
 long long convertDecimalToBinary(int n) {
 	long long binaryNumber = 0;
 	int remainder, i = 1;
 
 	while (n != 0) {
 		remainder = n % 2;
 		n /= 2;
 		binaryNumber += remainder * i;
 		i *= 10;
 	}
 	return binaryNumber;
 }
 
 //Driver function
 int main() {
 	int decimal;
 	//Prompts user for input
 	cout << ""Enter a decimal number to be converted into binary: "";
 	cin >> decimal;
 
 	//Display the resultant binary number
 	cout << ""Binary number: "" << convertDecimalToBinary(decimal) << ""\n"";
 
 	return 0;
 }
 
 /*
 Input:
 Enter a decimal number to be converted into binary: 13
 Output:
 Binary number: 1101
 
 Input:
 Enter a decimal number to be converted into binary: 57
 Output:
 Binary number: 111001
 
 Input:
 Enter a decimal number to be converted into binary: 100
 Output:
 Binary number: 1100100
 
 Time complexity: O(N)
 Space complexity: O(1)
 */
",C-Plus-Plus
"/*
  Exponential Search Algorithm is an optimized Binary Search to search an element in sorted array.
  It is specifically used when the size of array is infinite.
 */
 
 
 #include <iostream>
 
 using namespace std;
 
 int BinarySearch(int arr[], int left, int right, int key)
 {
         if (right >= left)
         {
                 int mid = left + (right - left) / 2;
 
                 if (arr[mid] == key) {
                         return mid;
                 }
 
                 // if element is present on left side i.e. smaller than mid
                 if (arr[mid] > key) {
                         return BinarySearch(arr, left, mid - 1, key);
                 }
 
                 // else element is definitely on the right side
                 return BinarySearch(arr, mid+1, right, key);
         }
 
         return -1;
 }
 
 int ExponentialSearch(int *arr, int n, int key)
 {
 
         if (arr[0] == key) {
                 return 0;
         }
 
         // repeated doubling method to find range for binary search
         int i = 1;
         while (i < n && arr[i] <= key) {
                 i = i * 2;
         }
 
         int mini = i < (n-1) ? i : (n-1);
 
         // BinarySearch called
         return BinarySearch(arr, i / 2, mini, key);
 }
 
 int main()
 {
         int n;
         cout<<""Enter the size of array""<<endl;
         cin>>n;
         int arr[n];
         cout<<""Enter the sorted array""<<endl;
 
         // inputs the array
         for(int i = 0; i < n; i++){
                 cin>>arr[i];
         }
 
         int key;
         cout<<""Enter the element to search""<<endl;
         cin >> key;
 
         int search_result = ExponentialSearch(arr, n, key);
 
         if (search_result != -1) {
                 cout << ""Element is present at position "" << search_result << endl;
         } else {
                 cout << ""Element is not present in the array"" << endl;
         }
 
         return 0;
 
 }
 
 /*
  Time Complexity : O(log n)
  Space ",C-Plus-Plus
"import java.util.Arrays;
 
 class PGraph {
 
   public void Prim(int G[][], int V) {
 
     int INF = 9999999;
 
     int no_edge; // number of edge
 
     // create a array to track selected vertex
     // selected will become true otherwise false
     boolean[] selected = new boolean[V];
 
     // set selected false initially
     Arrays.fill(selected, false);
 
     // set number of edge to 0
     no_edge = 0;
 
     // the number of egde in minimum spanning tree will be
     // always less than (V -1), where V is number of vertices in
     // graph
 
     // choose 0th vertex and make it true
     selected[0] = true;
 
     // print for edge and weight
     System.out.println(""Edge : Weight"");
 
     while (no_edge < V - 1) {
       // For every vertex in the set S, find the all adjacent vertices
       // , calculate the distance from the vertex selected at step 1.
       // if the vertex is already in the set S, discard it otherwise
       // choose another vertex nearest to selected vertex at step 1.
 
       int min = INF;
       int x = 0; // row number
       int y = 0; // col number
 
       for (int i = 0; i < V; i++) {
         if (selected[i] == true) {
           for (int j = 0; j < V; j++) {
             // not in selected and there is an edge
             if (!selected[j] && G[i][j] != 0) {
               if (min > G[i][j]) {
                 min = G[i][j];
                 x = i;
                 y = j;
               }
             }
           }
         }
       }
       System.out.println(x + "" - "" + y + "" :  "" + G[x][y]);
       selected[y] = true;
       no_edge++;
     }
   }
 
   public static void main(String[] args) {
     PGraph g = new PGraph();
 
     // number of vertices in grapj
     int V = 5;
 
     // create a 2d array of size 5x5
     // for adjacency matrix to represent graph
     int[][] G = { { 0, 9, 75, 0, 0 }, { 9, 0, 95, 19, 42 }, { 75, 95, 0, 51, 66 }, { 0, 19, 51, 0, 31 },
         { 0, 42, 66, 31, 0 } };
 
     g.Prim(G",Java
"/**
 The program will generate all the possible
 combinations of n pairs of parentheses.
 */
 
 import java.util.Scanner;
 
 public class GenerateParentheses {
 
     static void parantheses(int i, int j, int n, String s) {
 		if (i==n && j==n) {
 			// n opening and n closing brackets
 			// have been included
 			System.out.println (s);
 			
 		} else if (i==n) {
 			// n opening brackets have been included
 			// now just need to add only closing ones
 			parantheses (i, j+1, n, s+')');
 			
 		} else if (j==n || j>i) {
 			// condition of failure when closing brackets 
 			// are more than the opening ones.
 			return;
 			
 		} else {
 			// adding closing bracket to string
 			parantheses (i, j+1, n, s+')');
 			// adding opening bracket to string
 			parantheses (i+1, j, n, s+'(');
 		}
 	}
 
 	public static void main(String[] args) {
 
 		Scanner sc=new Scanner (System.in);
 		
 		System.out.print (""Enter value of n- "");
 		int n=sc.nextInt();
 
 		System.out.println(""Possible pairs - "");
 		parantheses (0, 0, n, """");
     }
 }
 
 /**
 Time Complexity : O(2^2n)
 Space Complexity : O(1)
 
 Input :
 
 Enter value of n- 3
 
 Output :
 
 Possible pairs - 
 ()()()
 ()(())
 (())()
 (()())
 ((()))
 
 */
 
",Java
"/**
 A backtracking algorithm to solve 9X9 suduko
 0's in the input are treated empty cells
 Assumption : Given configuration is correct
 **/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 #define N 9
 
 void display(int board[N][N]){
   for(int i = 0; i < N; i++){
     for(int j = 0; j < N; j++){
       cout << board[i][j] << ' ';
     }
     cout << '\n';
   }
 }
 
 // backtracking soln
 bool solve(int board[N][N], int i, int j, 
   bool rows[N][N], bool cols[N][N], bool boxes[N][3][3]) {
     
     if(i == 9)
       return true;
       
     if(board[i][j] == 0) {
         
       for(int k=0; k<9; k++) {
           
         if(rows[k][i] == false && cols[k][j] == false
           && boxes[k][i/3][j/3] == false) {
             board[i][j] = k+1;
             rows[k][i] = true;
             cols[k][j] = true;
             boxes[k][i/3][j/3] = true;
               
             if(solve(board, i+j/8, (j+1)%9, rows, cols, boxes))
               return true;
               
             board[i][j] = 0;
             rows[k][i] = false;
             cols[k][j] = false;
             boxes[k][i/3][j/3] = false;
           }
       }
       
       return false;
     } else
       return solve(board, i+j/8, (j+1)%9, rows, cols, boxes);
   }
 
 void solveSudoku(int board[N][N], int x, int y) {
   // write yopur code here
   bool rows[N][N], cols[N][N], boxes[9][3][3];
 
   // intialization
   for(int i=0; i<N; i++)
     for(int j=0; j<N; j++) {
       rows[i][j] = false;
       cols[i][j] = false;
     }
 
   // intialization
   for(int i=0; i<N; i++)
     for(int j=0; j<3; j++)
       for(int k=0; k<3; k++)
         boxes[i][j][k] = false;
   
   for(int i=0; i<9; i++)
     for(int j=0; j<9; j++)
       if(board[i][j] != 0) {
         int num = board[i][j]-1;
         rows[num][i] = true;
         cols[num][j] = true;
         boxes[num][i/3][j/3] = true;
       }
       
   solve(board,0,0,rows,cols,boxes);
   display(board);
 }
 
 int main() {
   int arr[N][N];
",C-Plus-Plus
"/**
 Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal 
 to the other number. (A proper divisor of a number is a positive factor of that number other than the number 
 itself. Given two Numbers A and B, find whether they are Amicable Numbers or not. Print 1 if they are Amicable 
 else 0.
  */
 
 import java.io.*;
 import java.util.*;
 
 class Code{
     public static void main(String args[]) throws IOException{
         // taking input 
         BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
         System.out.println(""Enter the  a and b"")
         // reading input
         String S[] = read.readLine().split("" "")
         int A = Integer.parseInt(S[0]);
         int B = Integer.parseInt(S[1]);
         Sol obj = new Sol();
         // printing the output 
         System.out.println(""The  Ampicable pair : "")
         System.out.println(obj.isAicable(A,B));
     }
 } 
 
 
 class Sol {
     //  to get the sum of all proper divisors of a number.
     static long divsum(int n)
     {
         long result = 0;
         for (int i = 2; i <= (int)Math.sqrt(n); i++)
         {
             if (n % i == 0)
             {
                 if (i == (n / i))
                     result += i;
                 else
                     result += (i + n/i);
             }
         }
         return (result + 1);
     }
     
     static int isAmicable(int A , int B) {
         
         // If and only if sum of proper divisors of A is equal to B 
 
         if(A!=B && divsum(A)==B && divsum(B)==A)    
             return 1;
         else
             return 0;
     }
 };
 
 /*
 Time complexity : O(sqrt(A,B))
 Space complexity : O(1)
 */
 
 /*
 Test Case : 
      Test case 1 :
      Enter the a and b
       220  284
     Test case 2 : 
     Amicable Pair : 
     1
 */
 
",Java
"""""""
 Author: Guru Charan
 
 Problem statement:
 Given a list of integers ""nums"" and an integer k, return the maximum values
 of each sublist of length k.
 
 Constraints:
 1  n  100,000 where n is the length of ""nums"".
 1  k  100,000.
 
 """"""
 
 from collections import deque
 
 
 def findMaxInSubarray(nums, n , k) :
 
     '''
     paramaters:
     nums: input array
     n: size of the array
     k: window size
     output:
     returns a list (ans) containing the maximum of each window of size k
 
     '''
     ans = []
 
     # indices are stored in 'window'
     # with the maximum element at the front
     window = deque()
 
     # first k elements
     for i in range(k):
 
         # pop all the elements that are smaller than the current
         # element which are present towards its left (lower indices)
         while (window and (nums[i] >= nums[window[-1]])):
             window.pop()
         # adding the current element
         window.append(i)
 
     # storing the current answer
     ans.append(nums[window[0]])
 
     # getting the answer for rest of he array
 
     for i in range(k, n):
 
         # checking the window bounds
         if window[0] <= i-k:
             # remove an element from front
             window.popleft()
         while (window and nums[window[-1]] <= nums[i]):
             window.pop()
         window.append(i)
         # storing answer for current window
         ans.append(nums[window[0]])
     # returning the answer
     return ans
 
 
 # DRIVER CODE
 
 if __name__ == ""__main__"":
 
     size = int(input('enter the size of the array : '))
 
     numsArr = [int(i) for i in input('enter the elements of the array : ').split()]
 
     windowLen = int(input('enter the size of the window : '))
 
     print('The maximum values of each subarray of length k : ')
     print(*findMaxInSubarray(numsArr, size, windowLen))
 
 ProblemDetails = '''Time Complexity
 O(n) is the overall time complexity of the algorithm
 O(k) is the ove",Python
"import java.util.*;
 
 public class CatalanNumber {
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.print(""Enter number: "");
         int num = sc.nextInt();
         System.out.println();
         int[] arr = new int[num + 2];
         arr[0] = 1;
         arr[1] = 1;
         for (int i = 1; i <= num; i++) {
             for (int j = i; j > 1; j--)
                 arr[j] = arr[j] + arr[j - 1];
             arr[i + 1] = arr[i];
             for (int j = i + 1; j > 1; j--)
                 arr[j] = arr[j] + arr[j - 1];
             System.out.printf(""%d "", arr[i + 1] - arr[i]);
         }
     }
 }
 
 /*
 Sample input and output
 Enter number: 7
 
 1 2 5 14 42 132 429 
 
 time complexity: O(n^2)
 space complexity: O(n)
 */
",Java
"/*  Given two strings word and text, return the number of 
 substrings where text contains any anagram of word. */
 
 
 /* Function to count the number of anagrams */
 const countAnagrams = (word, text) => {
     let alpha = new Array(26);
 
     for(let i = 0; i<alpha.length; i++){
         alpha[i] = 0;
     }
 
     /* Calculating the frequency of each character in the given word */
     for(let c in word){
         alpha[word.charCodeAt(c)-97]++;
     }
 
     let window = [];
     let ans = 0;
 
     /* Checking the occurrences of anagrams of the given word*/
     for(let i=0; i<text.length; i++){
         let c = text.charCodeAt(i);
 
         /* Adding the current character to the window if the word contains it*/
         if(alpha[c-97] > 0){
             /* Subtracting the given word as we have added it to the window */
             alpha[c-97]--;
             window.push(i);
         }else{
 
             /* Decrementing the window until it is feasible to accommodate the current character */
             while(window.length > 0 && alpha[c-97] <= 0){
                 alpha[text.charCodeAt(window.shift()) - 97]++;
             }
 
             /* Adding the current character to the window if the word contains it */
             if(alpha[c-97] > 0){
                 alpha[c-97]--;
                 window.push(i);
             }
         }
 
         /* Increasing the answer if the window size = word size */
         if(window.length == word.length){
             ans++;
             /* Removing the first character of the window */
             alpha[text.charCodeAt(window.shift()) - 97]++;
         }
     }
 
     return ans;
 }
 
 
 console.log(""Enter the word to be found and the text in which the word needs to be searched"");
 
 /* List stores the word and the text */
 let list = readline()
     .split("" "")
     .map((element) => element);
 
 /* Only two elements are present in the list, the first one 
 represents the word to be searched and the second one 
 r",JavaScript
"/*
 Add two binary numbers
 
 For given two binary numbers,
 your task is to add the two binary numbers and return their sum.
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 //function to revers the binary numbers
 //which will then be added 
 int reverseNumber(int num)
 {
     int lastBit, result = 0;
     while(num > 0)
     {
         lastBit = num % 10;
         result = result * 10 + lastBit;
         num = num / 10;
     }
     return result;
 }
 
 //function to add the binary numbers
 //there are three cases-->
 //0 + 0 = 0, 0 + 1 = 1, 1 + 1 = 0 (carry=1)
 int binarySum(int num1, int num2)
 {
     int result = 0;
     int previousCarry = 0;
     //only for positive numbers
     while(num1 > 0 && num2 > 0)
     {
         if(num1 % 2 == 0 && num2 % 2 == 0)
         {
             result = result * 10 + previousCarry;
             previousCarry = 0;//no previous carry will be generated
         }
         else if((num1 % 2 == 0 && num2 % 2 == 1) || (num1 % 2 == 1 && num2 % 2 == 0))
         {
             if(previousCarry == 1)
             {
                 result = result * 10 + 0;
                 previousCarry = 1;//further carry generated
             }
             else 
             {
                 result = result * 10 + 1;
                 previousCarry = 0;//no previous carry will be generated
             }
         }
         else
         {
             result = result * 10 + previousCarry;
             previousCarry = 1;//carry will be generated in both the cases
         }
         num1 = num1 / 10;
         num2 = num2 / 10;
     }
     while(num1 > 0)
     {
         if(previousCarry == 1)
         {
             if(num1 % 2 == 1)
             {
                 result = result * 10 + 0;
                 previousCarry = 1;
             }
             else
             {
                 result = result * 10 + 1;
                 previousCarry = 0;
             }
         }
         else
         {
             result = result * 10",C-Plus-Plus
"/*
 
 Check for balanced parenthesis
 ==============================
 Given an expression containing parenthesis, check if it is well-formed or balanced.
 Example of balanced parenthesis are: (), ((())), (a+b), (a/b)*(b/a)
 
 */
 
 import java.util.*; 
 import java.io.*;
 
 public class BalancedParenthesis {
 	private static boolean isBalanced(String str) {
 		// Size of the string
 		int n = str.length();
 
 		// Stack to store open parenthesis
 		Stack<Integer> s = new Stack<Integer>();
 		// Open parenthesis -> 1
 
 		// Loop through characters in the string
 		for (int i = 0; i < n; i++) {
 			// Open parenthesis is always pushed into the stack
 			if (str.charAt(i) == '(') {
 				s.push(1);
 			} else if (str.charAt(i) == ')') {
 				// Closed parenthesis encountered must be balanced by an open parenthesis already
 				// present in the stack
 				if (!s.empty())
 					// Stack contains open parenthesis, one of which has been balanced
 					// Pop one parenthesis out
 					s.pop();
 				else
 					// Stack contains no open parenthesis. So closed parenthesis cannot be balanced
 					return false;
 			}
 		}
 
 		// Check if we have open parenthesis remaining
 		return (s.size() == 0);
 	}
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 		String str = sc.nextLine();
 		System.out.println((isBalanced(str) ? ""YES"" : ""NO""));
 	} 
 }
 
 /*
 
 Input:
 ((a+b)+(c-d+f))
 Output:
 YES
 
 Application: Stack data structure
 Time Complexity: O(n)
 Space Complexity: O(n)
 
 */
 
",Java
"/*
 Introduction 
 Given a Binary Search Tree ,Find the shortest distance between given two nodes , which exist in the tree
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to insert a node with given value to the root
 struct Node* insert(struct Node* root,int element) 
 {
     //If the root is NULL , create a node with given element and assign it to root
     //else if the root itself is the node with given data , return 
     //else recursively insert it in one of the subtrees accordingly
     if(root==NULL)
         root = newNode(element);
     else if(root->key < element)
         root->right = insert(root->right,element);
     else if(root->key > element)
         root->left = insert(root->left,element);
     
     return root;
 }
 
 //Function to find least common ancestor
 struct Node* leastCommonAncestor(struct Node* root,int node_1_value,int node_2_value)
 {
    //If both the given value nodes lie in left subtree of the root
    //Find LCA in left subtree recursively 
    if(node_1_value<root->key && node_2_value<root->key)
       return leastCommonAncestor(root->left,node_1_value,node_2_value);
 
   //Else If both the given value nodes lie in right subtree of the root
   //Find LCA in right subtree recursively 
    if(node_1_value>root->key && node_2_value>root->key)
       return leastCommonAncestor(root->right,node_1_value,node_2_value);
 
   //Else it means that one node is in left subtree and one node is in right sub tree
   //return root
    return root;",C-Plus-Plus
"/*
     Given a binary tree with unique values, a target node in the binary tree, and an integer value k, print all the nodes
     that are at a distance k from the given target node.
 
     Sample input :
         Enter the size of preorder and inorder arrays   :  8
         Enter the elements of preorder traversal array  :  1 2 3 4 8 5 6 7
         Enter the elements of inorder traversal array   :  3 2 8 4 1 6 7 5
         Enter the target node in the binary tree        :  2
         Enter the value of distance K                   :  1
 
     Sample output :
         Nodes at a distance K are                       :  3 4 1
 
     @author : shankhanil007
     @created : 16-08-2020
 
 */
 
 
 #include <iostream>
 using namespace std;
 
 // Basic definition of a node in binary tree
 class node{
     public:
         int data;
         node* left;
         node* right;
 
         node(int d)
         {
             data = d;
             left = NULL;
             right = NULL;
         }
 };
 
 node* buildTree(int *preorder, int *inorder, int start, int end)
 {
 	static int i = 0;
 
 	//Base Case
 	if(start >  end){
 		return NULL;
 	}
 
 	//Recursive Case
 	node* newnode = new node(preorder[i]);
 
 	int index = -1;
 
 	for(int j = start; start <= end; j++)
 	{
 		if(preorder[i] == inorder[j])
 		{
 			index = j;
 			break;
 		}
 	}
 
 	i++;
 
 	newnode->left = buildTree(preorder, inorder, start, index-1);
 	newnode->right = buildTree(preorder, inorder, index+1, end);
 
 	return newnode;
 }
 
 // Function to print the Kth level of the tree starting from a given node
 void printKthLevel(node* root, int k)
 {
     if(root == NULL)
         return;
 
     if(k == 0)
     {
         cout<<root->data<<"" "";
         return;
     }
 
     printKthLevel(root->left, k-1);
     printKthLevel(root->right, k-1);
 
     return;
 }
 
 // Function to find the nodes at a distance K from a given node
 int printAtDistanceK(node* root, int target, int k)
 {
     // base case
     if(roo",C-Plus-Plus
"/*Problem Statement: 
 Given a Binary Tree, 
 write a program that returns the size of the largest subtree which is also a Binary Search Tree (BST) */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class node
 {
   public:
     int data;
   node * left;
   node * right;
 
   node(int d)
   {
     data = d;
     left = NULL;
     right = NULL;
   }
 };
 node* build(int *preorder_tree, int *postorder_tree, int s, int e)
 {
   static int i = 0;
   int index = -1;
   if (s > e)
   {
     return NULL;
   }
 
   //making the root node as the first node of the preorder form
   node *root = new node(preorder_tree[i++]);
   if (s == e)
   {
     return root;
   }
 
   for (int j = s; s <= e; j++)
   {
     if (postorder_tree[j] == root->data)
     {
       index = j;
       break;
     }
   }
 
   root->left = build(preorder_tree, postorder_tree, s, index - 1);
   root->right = build(preorder_tree, postorder_tree, index + 1, e);
   return root;
 
 }
 
 bool isbst(node *root, int min, int max)
 {
   if (root == NULL)
   {
     return true;
   }
 
   /*If the left subtree is small in value and the right subtree is big in value than the root,
   then it is a BST */
   if (root->data >= min && root->data <= max && isbst(root->left, min, root->data) && isbst(root->right, root->data, max))
   {
     return true;
   }
 
   return false;
 
 }
 
 int nodes(node *root)
 {
   if (root == NULL)
   {
     return 0;
   }
 
   return nodes(root->left) + nodes(root->right) + 1;
 }
 
 int isvalidbst(node *root)
 {
   if (root == NULL)
   {
     return NULL;
   }
 
   if (isbst(root, INT_MIN, INT_MAX))
   {
     return nodes(root);
   }
 
   return max(isvalidbst(root->left), isvalidbst(root->right));
 }
 
 int main()
 {
   int total_nodes;
   cout << ""Total nodes in binary tree: "" << endl;
   cin >> total_nodes;
   int preorder_tree[total_nodes];
   cout << ""Enter preorder form: "" << endl;
   for (int i = 0; i < total_nodes; i++)
   {
     cin >> preorder_tree[i];
   }
 
   cout << ""En",C-Plus-Plus
"/*
 Double factorial of a non-negative integer n, is the product
 of all the integers from 1 to n that have the same parity (odd or even) as n.
 It is also called as semifactorial of a number and is denoted by !!
 */
 // Time complexity for both the approaches(Iterative and Recursive) is O(n)
 
 // Iterative approach
 DoubleFactIter = (num) => {
   let ans = 1;
   for (let i = num; i >= 0; i -= 2) {
     // checking for 1 and 0
     if (i <= 1) return ans;
     else ans *= i;
   }
 };
 
 // Recursive approach
 DoubleFactRecur = (num) => {
   // checking for 1 and 0
   if (num <= 1) return 1;
   // Recursively calling Function
   else return num * DoubleFactRecur(num - 2);
 };
 
 console.log(DoubleFactIter(0)); // 1
 console.log(DoubleFactRecur(0)); // 1
 
 console.log(DoubleFactIter(1)); // 1
 console.log(DoubleFactRecur(1)); // 1
 
 console.log(DoubleFactIter(2)); // 2
 console.log(DoubleFactRecur(2)); // 2
 
 console.log(DoubleFactIter(3)); // 3
 console.log(DoubleFactRecur(3)); // 3
 
 console.log(DoubleFactIter(4)); // 4
 console.log(DoubleFactRecur(4)); // 4
 
 console.log(DoubleFactIter(9)); // 945
 console.log(DoubleFactRecur(13)); // 135135
",JavaScript
"/*
 
   Double factorial  of a number n (denoted by n!!) is the product
   of all the integers from 1 up to n that have the same parity(odd or even) as n
 
 */
 
 import 'dart:io';
 
 // Iterative approach
 int Iterative(int num) {
   int ans = 1;
   for (int i = num; i >= 0; i = i - 2) {
     if (i == 0 || i == 1) {
       return ans;
     } else {
       ans *= i;
     }
   }
   return ans;
 }
 
 
 // Recursive approach
 int Recursive(int num) {
   if (num == 0 || num == 1) {
     return 1;
   }
   return num * Recursive(num - 2);
 }
 
 int main() {
   //taking input from the user
   stdout.write(""Enter a number: "");
   int num = int.parse(stdin.readLineSync()!);
 
   print(""Select a method you want to use to find Double Factorial"");
   print(""1. Iterative"");
   print(""2. Recursive"");
   stdout.write(""choice ( 1 or 2 )? : "");
   int choice = int.parse(stdin.readLineSync()!);
 
   if (choice == 1) {
     stdout.write(""Double Factorial of $num: "");
     print(Iterative(num));
   } else if (choice == 2) {
     stdout.write(""Double Factorial of $num: "");
     print(Recursive(num));
   } else {
     print(""Invalid choice"");
   }
   print("" "");
 
   return 0;
 }
 
 /*
 
   Time complexity: O(n) 
   Space complexity: O(1)
 
   Sample input/output
  
   SAMPLE 1
   (Trying Iterative method)
   Enter a number: 32
   Select a method you want to use to find Double Factorial
   1. Iterative
   2. Recursive
   choice ( 1 or 2 )? : 1
   Double Factorial of 32: 1371195958099968000
 
   (Trying Recursive method)
   Enter a number: 32
   Select a method you want to use to find Double Factorial
   1. Iterative
   2. Recursive
   choice ( 1 or 2 )? : 2
   Double Factorial of 32: 1371195958099968000
   
   SAMPLE 2
   Enter a number: 10
   Select a method you want to use to find Double Factorial
   1. Iterative
   2. Recursive
   choice ( 1 or 2 )? : 1
   Double Factorial of 10: 3840
 
   Enter a number: 10
   Select a method you want to use to find Double Factorial
   1. Iterative
 ",Dart
"//Program to find the Unique numbers in an array out of which two numbers occur exactly once and are distinct.
 // You need to find the other two numbers and print them in ascending order.
 
 // Also Taken help from geeksforgeeks
 
 #include <stdio.h> 
 
 void findUniquePair(int arr[], int size) 
 { 
 	// XOR each element and get XOR of two unique elements(ans) 
 	int XOR = arr[0]; 
 	for (int i = 1; i < size; i++) 
 		XOR = XOR ^ arr[i]; 
 
 	// Get a set bit of XOR (We get the rightmost set bit) 
 	int set_bit = XOR & ~(XOR-1); 
 
 	// Now divide elements in two sets by comparing rightmost 
 	int x = 0, y = 0; // Initialize missing numbers 
 	for (int i = 0; i < size; i++) 
 	{ 
 		if (arr[i] & set_bit)
 			x = x ^ arr[i]; //first unique number in arr[]
 		else
 			y = y ^ arr[i]; //second unique number in arr[]
 	} 
 	if(x>y)
 		printf(""Distinct Numbers are %d and  %d"", y, x);
 	else
 		printf(""Distinct Numbers are %d and %d"", x, y);
 	
 } 
 
 int main() 
 { 
 	
 	int size;
 	printf(""Enter Size:"");
 	scanf(""%d"", &size);
 	int arr[size];
 	printf(""Enter elements:\n"");
 	for(int i = 0; i < size; i++)
 	{
 		scanf(""%d"", &arr[i]);
 	}
 	findUniquePair(arr, size); 
 	return 0; 
 } 
 /*
 Sample I/O:
 Input:
 	Enter Size:6
 	Enter elements:
 	1 2 3 2 1 4
 
 Output:
 	Distinct Numbers are 3 and 4
 
 Time Complexity: O(size)
 Space Complexity: O(1)
 */",C
"'''
 A Derangement is a permutation of n elements, such that no element appears in its original position.
 
 Problem statement: Given a number n, find total number of Derangements of a set of n elements.
 
 Input format
 Line1: Number of test cases
 Line2: Give the value of n
 
 Output format
 The total number of derangement
 
 Basic idea is to use dynamic programming and identify a pattern: 
 base case : n=1 answer 0
             n=2 answer 1
 for other values of n: 
     eg: 0 can be placed in a position with given conditions in (n-1) ways
     now has 2 possiblities:
         either 0 can be placed in ith position implies (n-2) elements should be placed  
         else 0 neednt be placed in ith position  implies (n-1) elements should be placed in some position 
 hence we come to a relation as follows: 
 count_derangement(n) = (n - 1) * [count_derangement(n - 1) + count_derangement(n - 2)]
 
 argument: integer (value of n)
 return: integer (total number of derangements)
 
 '''
 def derangements(n):
     #dynamic programming table 
     d=[0 for i in range(n+1)]
     #base casses 
     d[1]=0
     d[2]=1
     for i in range(3,n+1):
         d[i]=(i-1)*(d[i-1]+d[i-2])
     return d[n]
 #Driver code 
 def main():
     for _ in range(int(input())):
         n=int(input())
         print(derangements(n))
 if __name__=='__main__':
     main()
 '''
 Sample Input
 1
 4
 
 Sample Output
 9
 
 Sample Explanation
 As n=4 we have original array, a=[0,1,2,3] Now we can have different derangements as:
 [1, 0, 3, 2], [1, 2, 3, 0], [1, 3, 0, 2],[2, 3, 0, 1], [2, 0, 3, 1], [2, 3,1, 0], [3, 0, 1, 2], [3, 2, 0, 1] and [3, 2, 1, 0]
 
 Time complexity : O(n)
 Space Complexity : O(n)
 
 '''
",Python
"/**
 This algorithm is an improvement over Binary Search. In this case we use linear
 interpolation from graphical methods and try to find the position of the item,
 as if the array elements are on a straight line. 
  */
 import 'dart:io';
 
 // function that runs the interpolation
 int interpolationSearch(List arr, int item, int first, int last) {
   // checking if the item is present in array range
   if (last >= first && item >= arr[first] && item <= arr[last]) {
     // finding value of position by interpolation
     int position = first +
             ((item - arr[first]) * ((last - first) ~/ (arr[last] - arr[first])))
         as int;
 
     // checking if this is corect position
     if (arr[position] == item) {
       return position;
     }
 
     // if item is greater its in right portion
     if (arr[position] < item) {
       return interpolationSearch(arr, item, position + 1, last);
     }
 
     // if item is smaller then its in the left portion
     if (arr[position] > item) {
       return interpolationSearch(arr, item, first, position - 1);
     }
   }
   return -1;
 }
 
 // main function, entry point of program
 void main() {
   print(""Enter the size of list:"");
   int size = int.parse(stdin.readLineSync()!);
   List arr = [];
   print(""Enter the sorted list:"");
   for (int i = 0; i < size; i++) {
     arr.add(int.parse(stdin.readLineSync()!));
   }
   print(""Enter the number to be searched:"");
   int item = int.parse(stdin.readLineSync()!);
   // sorting
   int result = interpolationSearch(arr, item, 0, size - 1);
   if (result != -1) {
     print(""$item found at position: ${result + 1}"");
   } else {
     print(""$item not found in the list."");
   }
 }
 
 /*
 
 Sample Output:
 
 Enter the size of list:
 6
 Enter the sorted list:
 12
 25
 32
 47
 56
 68
 Enter the number to be searched:
 47
 47 found at position: 4
 
 Time complexity: O(log(log n))
 Space complexity: O(1)
 */
",Dart
"/*Problem Name: Maximum Topology Short
 
 First of all Lets Understand what is topology : 
 The arrangement of a network that comprises nodes and connecting lines via sender and receiver is referred to as network topology.
 
 Here is Problem statemet :
 Lets assume a Boy  has a tree  named that tree G with N nodes (numbered 1 through N) and N1 undirected edges.
  For each node (u) in the tree, he can assign directions to the edges in such a way that (u) is reachable from all the other nodes.
  Let C(u) be the number of valid topological orderings in the resulting directed acyclic graph.
 we have to find the maximum sorted pairs .
 */
 /*To Include All Pre Required Liabries*/
 #include <bits/stdc++.h>
 using namespace std;
 #define int long long int
 #define mod 1000000007 
 
 
 int n;
 const int Limit = (int)5e5 + 5;
 int Factorial_Number_Inverse[Limit + 1];
 
 int Natural_Number_Inverse[Limit + 1];
 int Factorial[Limit + 1];
 //Function to Find Inverse of A Number
 void Inverse_of_Number(int p)
 { 
     Natural_Number_Inverse[0] = Natural_Number_Inverse[1] = 1;
     for (int i = 2; i <= Limit; i++)
         Natural_Number_Inverse[i] = Natural_Number_Inverse[p % i] * (p - p / i) % p;
 }
 
 /* Function to Find Inverse of factorial*/
 void Inverse_of_Factorial(int p)
 {
     Factorial_Number_Inverse[0] = Factorial_Number_Inverse[1] = 1;
     for (int i = 2; i <= Limit; i++)
         Factorial_Number_Inverse[i] = (Natural_Number_Inverse[i] * Factorial_Number_Inverse[i - 1]) % p;
 }
 
 // To find factorial of a given number
 void factorial(int p)
 { 
     Factorial[0] = 1;
     for (int i = 1; i <= Limit; i++)
     {
         Factorial[i] = (Factorial[i - 1] * i) % p;
     }
 }
 
 /*Function to Find Bionominal of A given Number*/
 int Binomial(int Limit, int R, int p)
 {
     if (R > Limit)
         return 0;
     if (R == Limit)
         return 1;
     int ans = ((Factorial[Limit] * Factorial_Number_Inverse[R]) % p * Factorial_Number_Inverse[Limit - R]) % p;
     re",C-Plus-Plus
"/*
 Sum up root to the leaf number
 
 You are provided with the roots of the binary tree
 that contains digits from 0 to 9 only.
 Each root to leaf path in the tree represents a number.
 For example :-
   1
  / \
 2   3
 has 12 and 13, as numbers forming from the tree.
 Your task is to return the total sum of all root to leaf numbers. 
 */
 
 import java.io.*;
 import java.until.*;
 
 //defining a class for storing nodes of tree
 class BTNode 
 {
     int value;
     BTNode left;
     BTNode right;
     BTNode() 
     {}
     BTNode(int value) 
     {
         this.value = value; 
     }
     BTNode(int value, BTNode left, BTNode right) 
     {
         this.value = value;
         this.left = left;
         this.right = right;
     }
 }
 
 public class SumRootToLeaf
 {
     //initializing a variable named result to store the final result
     int result;
 
     //function that sums up the root-to-leaf numbers 
     public int sumNumb(BTNode root)
     {
         //if the root is empty the result returned is  zero
         if(root == null)
         {
             return 0;
         }
         result = 0;
         findSum(root, 0);
         return result;
     }
 
     //function to find sum
     public void findSum(BTNode root, int value)
     {
         int currentval = value * 10 + root.value;
         //if both the sides of the tree are containing null then 
         //current number formed is added to the result and is simply 
         //returned 
         if(root.left == null && root.right == null)
         {
             result = result + currentval;
             return;
         }
 
         if(root.left != null)
         {
             findSum(root.left, currentval);
         }
 
         if(root.right != null)
         {
             findSum(root.right, currentval);
         }
     }
 
     //driver code
     public static void main()
     {
         // Taking input
 	    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
         Sys",Java
"/*
 Euler's totient function, also known as phi-function (n), counts the
 numberof integers between 1 and n inclusive, which are coprime to n.
 */
 import java.util.Scanner;
 
 public class Euler_Totient {
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 		System.out.println(""Enter an integer: "");
 		int n = sc.nextInt();
 
 		int temp = n;
 		//This gives euler totient function for N
 		// Time Complexity: O(N*root(N))
 		int ans = n;
 		for (int i = 2; i <= n; ++i) {
 			if (n % i == 0) {
 				ans = ans - ans / i;
 				while (n % i == 0)
 					n /= i;
 			}
 		}
 		if (n > 1) {
 			ans = ans - ans / n;
 		}
 		n = temp;
 		System.out.println(""\nThe euler totient function for "" + n + "" is "" + ans);
 
 		//This gives euler totient function from 1 to N
 		// Time Complexity: O(N loglogN) - same as Sieve of Eratosthenes
 		int phi[] = new int[n + 1];
 		for (int i = 0; i <= n; ++i) {
 			phi[i] = i;
 		}
 		for (int i = 2; i <= n; ++i) {
 			if (phi[i] == i) {
 				for (int j = i; j <= n; j += i) {
 					phi[j] = phi[j] - phi[j] / i;
 				}
 			}
 		}
 		System.out.println(""\nThe euler totient function for all integers from 1 to "" + n + "" is:\n"");
 		for (int i = 1; i <= n; ++i) {
 			System.out.println(i + "" "" + phi[i]);
 		}
 	}
 }
 
 /*
 OUTPUT
 Enter an integer: 10
 The euler totient function for 10 is: 4
 The euler totient function for all integers from 1 to 10 is:
 1: 1
 2: 1
 3: 2
 4: 2
 5: 4
 6: 2
 7: 6
 8: 4
 9: 6
 10: 4
 -----
 (1,3,7,9) are coprime to 10
 */
",Java
"""""""
 Julia program to find the number of derangements of a set of n elements.
 A Derangement is a permutation of n elements, such that no element appears in its original position.
 Here, given a number n, find total number of derangements of a set of n elements
 """"""
 
 function count_derangements(n)
     
     # Build the dp table in Bottom Up manner
     dp = zeros(Int, n + 1)
     # Assign base cases
     dp[2] = 0
     dp[3] = 1
     for i in 4:n+1
         dp[i] = (i-2) * (dp[i-1] + dp[i-2])
     end
     return dp[n+1]
 end
 
 
 print(""Enter a number: "")
 n = readline()
 n = parse(Int, n)
 res = count_derangements(n)
 print(""The number of derangements in a set of $n numbers is $res."")
 
 
 
 """"""
 Time Complexity - O(n)
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 Enter a number: 4
 The number of derangements in a set of 4 numbers is 9.
 
 SAMPLE II
 Enter a number: 16
 The number of derangements in a set of 16 numbers is 7697064251745.
 """"""
",Julia
"/*
 Largest rectangular area under histogram
 =========================================
 Given the heights of the bars of a histogram, find out the largest
 rectangular area under the histogram. Width of each bar is 1 unit.
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // Prints largest rectangular area under histogram
 void largestAreaUnderHistogram(int height[], int n)
 {
 
 	// Stores index of the bars
 	stack<int> s;
 	int ans = 0;
 	int l = 0, r = 0;
 	for (int i = 0; i < n; i++)
 	{
 
 		// If stack is empty, push the bar
 		if (s.empty())
 		{
 			s.push(i);
 			continue;
 		}
 
 		// If height[i] is greater then push the bar
 		if (height[i] > height[s.top()])
 		{
 			s.push(i);
 		}
 		else
 		{
 			// I have encountered a height that is less than my last height
 
 			// Pop out all bars whose height is greater than height[i],
 			// Simulataneously calculate the new area
 			while (!s.empty() && height[i] < height[s.top()])
 			{
 				int toBeRemoved = s.top();
 				s.pop();
 				int area;
 				if (s.empty())
 				{
 					area = height[toBeRemoved] * i;
 				}
 				else
 				{
 					area = height[toBeRemoved] * (i - s.top() - 1);
 				}
 				//cout << toBeRemoved << "" "" << area << endl;
 				if (area > ans)
 				{
 					ans = area;
 					l = (!s.empty()) ? s.top() : 0;
 					r = i;
 				}
 				ans = max(ans, area);
 			}
 			s.push(i);
 		}
 	}
 	cout << ""Largest area = "" << ans << "" between bars "" << l << "" and "" << r;
 }
 
 int main()
 {
 
 	// Input number of bars
 	cout << ""Enter number of bars: "";
 	int n;
 	cin >> n;
 	// Input heights
 	cout << ""Enter height of each bar: "";
 	int height[n];
 	for (int i = 0; i < n; i++)
 		cin >> height[i];
 
 	largestAreaUnderHistogram(height, n);
 }
 
 /*
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
 /*
 Console:
 Enter number of bars: 7
 Enter height of each bar: 6 2 5 4 5 1 6
 Largest area = 12 between bars 1 and 5
 */
",C-Plus-Plus
"import java.util.Scanner;
 
 public class CoinChangeUsingDp {
 	
 	public static int coinChange(int[] coins, int amount) {
 		
         if(amount==0) {
             return 0;
         }
         
         int n = coins.length;
         int t [][] = new int [n+1][amount+1];
         
         for(int i=0; i<amount+1; i++) {
             t[0][i] = Integer.MAX_VALUE-1;
         }
         
         for(int i=1; i<n+1; i++) {
             t[i][0] = 0;
         }
         
         for(int i=1; i<amount+1; i++) {
         	
             if(i%coins[0] == 0) {
                 t[1][i] = i/coins[0];
             }
             else {
                 t[1][i] = Integer.MAX_VALUE-1;
             }
         }
         
         for(int i=2; i<n+1; i++) {
         	
             for(int j=1; j<amount+1; j++) {
             	
                 if(coins[i-1] <= j) {
                     t[i][j] = (1 + t[i][j-coins[i-1]]) < t[i-1][j] ? (1 + t[i][j-coins[i-1]]) : t[i-1][j];
                 }
                 else
                     t[i][j] = t[i-1][j];
             }
         }
         
         if(t[n][amount] == Integer.MAX_VALUE-1) {
             return -1;
         }
         else {
             return t[n][amount];
         }
     }
 
 	public static void main(String[] args) {
 		
 		Scanner sc = new Scanner(System.in);
 		System.out.println(""Please input the length of the array "");
 		int size = sc.nextInt();
 		int array[] = new int [size];
 		System.out.println(""Please input the "" + size + "" elements of the array "");
 		for(int i=0; i<size; i++) {
 			array[i] = sc.nextInt();
 		}
 		System.out.println(""Please input the required sum "");
 		int sum = sc.nextInt();
 		
 		System.out.println(coinChange(array, sum));
 	}
 
 }
 
 /* 
 Sample Input
 5
 1 2 15 25 27
 30
 Output
 2
 Explanation
 Here, by using greedy algorithm, the minimum number of coins would have been 27+2+1 but using dynamic programming, the answer comes out to be 2 i.e, 15+15
 */
",Java
"/* Given n number of words and an incomplete word w. You need to auto-complete that word w.
 That means, find and print all the possible words which can be formed using the incomplete word w.
 Note : Order of words does not matter. */
 
 #include <iostream>
 #include <string>
 #include <vector>
 using namespace std;
 
 class TrieNode {
   public:
   char data;
   TrieNode ** children;
   bool isTerminal;
 
   TrieNode(char data) {
     this -> data = data;
     children = new TrieNode * [26];
     for (int i = 0; i < 26; i++) {
       children[i] = NULL;
     }
     isTerminal = false;
   }
 };
 
 class Trie {
   TrieNode * root;
 
   public:
     int count;
 
   Trie() {
     this -> count = 0;
     root = new TrieNode('\0');
   }
 
   bool insertWord(TrieNode * root, string word) {
 
     // Base case
 
     if (word.size() == 0) {
       if (!root -> isTerminal) {
         root -> isTerminal = true;
         return true;
       } else {
         return false;
       }
     }
 
     // Small Calculation
 
     int index = word[0] - 'a';
     TrieNode * child;
     if (root -> children[index] != NULL) {
       child = root -> children[index];
     } else {
       child = new TrieNode(word[0]);
       root -> children[index] = child;
     }
 
     // Recursive call
 
     return insertWord(child, word.substr(1));
   }
 
   // For user
 
   void insertWord(string word) {
     if (insertWord(root, word)) {
       this -> count++;
     }
   }
 
   TrieNode * complete(TrieNode * root, string s, string pattern) {
     if (s.size() == 0) {
       if (root -> isTerminal == true) {
         cout << pattern << endl;
       }
       return root;
     }
 
     TrieNode * child;
     int index = s[0] - 'a';
 
     if (root -> children[index] != NULL) {
       child = root -> children[index];
     } else {
       return NULL;
     }
 
     TrieNode * ans = complete(child, s.substr(1), pattern);
     return ans;
 
   }
 
   void print(TrieNode * root, string s) {
     for (int i ",C-Plus-Plus
"""""""
 The best fit strategy will not allocate a block of size > N , as it is found in the first-fit method;
 instead it will continue searching to find a suitable block so that the block size is closer to the block size of request.
 The below program is an implementation of best fit algorithm using array data structure.
 """"""
 
 # Block class is used as the fixed memory blocks for allocation
 class Block:
     def __init__(self):
         self.size = 0
         self.ID = 0
         self.fragment = 0
 
 
 # process class is used for allocating memory for the requesting processes
 class process:
     def __init__(self):
         self.Num = 0
         self.size = 0
         self.block = None
 
 
 # initialiseBlocks function initializes all the blocks with sizes and id
 def initialiseBlocks(arr, sizes, n):
     for i in range(n):
         arr[i].size = sizes[i]
         arr[i].fragment = sizes[i]
         arr[i].ID = i + 1
 
 
 # printResult function prints the result of the memory allocation strategy
 def printResult(arr2, numOfProcess):
     print(
         ""Process No            Process Size          Block ID          Block Size         Block Fragment""
     )
     for i in range(numOfProcess):
         print(
             str(arr2[i].Num)
             + ""                     ""
             + str(arr2[i].size)
             + ""                     ""
             + str(arr2[i].block.ID)
             + ""                     ""
             + str(arr2[i].block.size)
             + ""                     ""
             + str(arr2[i].block.fragment)
         )
 
 
 # bestfit function allocates memory to processes using bestfit allocation algorithm
 def bestfit(arr, sizes, n, arr2, numOfProcess):
     minBlock = Block()
     for i in range(numOfProcess):
         min = 100
         for j in range(n):
             if arr2[i].size <= arr[j].fragment and arr[j].fragment < min:
                 min = arr[j].fragment
                 minBlock = arr[j]
         minBlock.fragment = min",Python
"// C program to implement Stooge  Sort
 /*
 The function of the stooge sort function is to check if the value at index 0 is 
 greater than the value at last index, if YES then to swap those values.
 
 Call the Stooge sort function recursively on initial 2/3rd of the array, last 2/3rd
 and again initial 2/3rd to get the given array sorted
 */
 #include <stdio.h>
 
 // Helper function to swap two values
 void swap(int *a, int *b)
 {
     int temp = *a;
     *a = *b;
     *b = temp;
 }
 
 void stooge_sort(int arr[], int start, int end)
 {
     // If the value at last index is smaller than the value at index 0, Swap them.
     if (arr[start] > arr[end])
         swap(&arr[start], &arr[end]);
 
     // For finding the first and last two by third elements in the array
     if (end - start + 1 > 2)
     {
         int twobythird = (end - start + 1) / 3;
 
         //Recursively call the function on the initial two by third, last two by third followed by the initial two by third
         if ((end - twobythird) >= start)
             stooge_sort(arr, start, end - twobythird);
         if (end >= (start + twobythird))
             stooge_sort(arr, start + twobythird, end);
         if ((end - twobythird) >= start)
             stooge_sort(arr, start, end - twobythird);
     }
 }
 
 int main()
 {
     int n;
     printf(""\nHow many numbers do you want to sort? "");
     scanf(""%d"", &n);
     int arr[n];
 
     if (n <= 0)
     {
         printf(""There are no numbers to sort!!!"");
         return 0;
     }
     // Input the numbers to sort
     printf(""Enter the numbers: "");
     for (int i = 0; i < n; i++)
         scanf(""%d"", &arr[i]);
 
     //Call the sort function
     stooge_sort(arr, 0, n - 1);
 
     printf(""The numbers in sorted order is: "");
     // Print the sorted array
     for (int i = 0; i < n; i++)
         printf(""%d "", arr[i]);
     printf(""\n"");
 
     return 0;
 }
 
 /*
 Time Complexity: O(n^2.7095), slower than bubble sort
 Space Complexity: O(n)
 
 SAMPLE I",C
"/* Reversing the first K elements of a Queue */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function for Reversing the first K elements of a Queue */
 void solve()
 {
     /* Input n = size of array */
     int n;
     cin >> n;
 
     int a[n];
     
     /* Declear the empty queue */
     queue<int> q;
 
     /* Input values in an array and
        push array element into the queue */
     for (int i = 0; i < n; ++i)
     {
         cin >> a[i];
         q.push(a[i]);
     }
 
     /* Input k*/
     int k;
     cin >> k;
 
     /* Declear a empty Stack */
     stack<int> s;
 
     /* Push k element in the Stack
        from queue */
     for (int i = 0; i < k; ++i)
     {
          s.push(q.front());
          q.pop();
     } 
 
     /* Enqueue the contents of stack
        at the back of the queue */
     while (!s.empty())
     {
         q.push(s.top());
         s.pop();
     }
  
     /* Remove the remaining elements and
        enqueue them at the end of the queue */
     for (int i = 0; i < q.size() - k; i++)
     {
         q.push(q.front());
         q.pop();
     }
 
     /* Print the queue */
     cout << ""After Reversing : "";
     while (!q.empty()) {
         cout << q.front() << "" "";
         q.pop();
     }    
 }
 
 int main()
 {
     solve();
     return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
         
         10
         10 20 30 40 50 60 70 80 90 100
         5
 
     Output 1 :
 
         After Reversing : 50 40 30 20 10 60 70 80 90 100 
 
     Input 2 :
 
         6
         1 2 3 4 5 6
         4
     
     Output 2 :
     
         After Reversing : 4 3 2 1 5 6 
     
     Time complexity: O(n)
     Space Complexity: O(n)
 */
",C-Plus-Plus
"/*
 *   Author: Davide Pollicino
 *   Date: 27/06/2020
 *   Summary: Inorder traversal of a tree;
 */
 
 #include <iostream>
 using namespace std;
 
 
 /*
 *   Create structure of a node
 */
 struct node 
 { 
     int data; 
     struct node *left, *right; 
 }; 
    
 /*
 *   A utility function to create a new node
 */
 struct node *newNode(int item) 
 { 
     struct node *temp = new node; 
     temp->data = item; 
     temp->left = temp->right = NULL; 
     return temp; 
 };
 
 /*
 *   Add a new node in the tree
 */
 struct node * insert(struct node *root, int element)
 {
     if(root == NULL)
         return newNode(element);
     if(root->data > element)
         root->left = insert(root->left, element);
     else if (root->data < element)
         root->right = insert(root->right, element); 
     return root;
 }
 
 /*
 *   Make inorder traverse of the tree
 */
 void inorder(struct node *root)
 {
     if(root == NULL)
         return; 
     inorder(root->left);
     cout <<root->data << "" "";
     inorder(root->right);
 }
 
 
 /*
 *   Entry point of the application
 */
 int main()
 {
     struct node *root = NULL;
     root = insert(root, 50);
     insert(root, 40);
     insert(root, 26);
     insert(root, 35);
     insert(root, 67);
     insert(root, 89);
     insert(root, 1);
 
    
     inorder(root);
     return 0;
 }",C-Plus-Plus
"'''
 TIC-TAC-TOE GAME USING MINIMAX ALGORITHM
 
 Minimax is a kind of backtracking algorithm. It searches, recursively, the 
 best move that leads the Max player to win or not lose (draw). It considers 
 the current state of the game and the available moves at that state, then 
 for each valid move, it plays (alternating min and max) until it finds a 
 terminal state (win, draw or lose).
 
 '''
 
 #Import the necessary libraries
 import numpy as np
 from math import inf as infinity
 
 #Set the Empty Board
 game_state = [[' ',' ',' '],
               [' ',' ',' '],
               [' ',' ',' ']]
 #Create the Two Players as 'X'/'O'
 players = ['X','O']
 
 #Method for checking the correct move on Tic-Tac-Toe
 def play_move(state, player, block_num):
     if state[int((block_num-1)/3)][(block_num-1)%3] is ' ':
         
         state[int((block_num-1)/3)][(block_num-1)%3] = player
     else:
         block_num = int(input(""Block is not empty, ya blockhead! Choose again: ""))
         play_move(state, player, block_num)
         
 #Method to copy the current game state to new_state of Tic-Tac-Toe
 def copy_game_state(state):
     new_state = [[' ',' ',' '],[' ',' ',' '],[' ',' ',' ']]
     for i in range(3):
         for j in range(3):
             new_state[i][j] = state[i][j]
     return new_state
 
 #Method to check the current state of the Tic-Tac-Toe
 def check_current_state(game_state):
     
     # Check horizontals in first row
     if (game_state[0][0] == game_state[0][1] and game_state[0][1] == game_state[0][2] and game_state[0][0] is not ' '):
         return game_state[0][0], ""Done""
     # Check horizontals in second row
     if (game_state[1][0] == game_state[1][1] and game_state[1][1] == game_state[1][2] and game_state[1][0] is not ' '):
         return game_state[1][0], ""Done""
     # Check horizontals in third row
     if (game_state[2][0] == game_state[2][1] and game_state[2][1] == game_state[2][2] and game_state[2][0] is not ' '):
         return game_sta",Python
"/*
 PROBLEM STATEMENT:
 Given a binary tree, the task is to print its top view. Top view of a binary tree is defined 
 as the nodes which will be visible if the tree is viewed from the top.
 The input for the binary tree is in the form of preorder and entering '-1' denotes a null node.
 For example:
 Input: 3 4 -1 6 -1 -1 5 1 -1 -1 -1
 The above input will have the following structure:
     3
    / \
   4   5
   \   /
    6  1
 Output: The top view is: 4 3 5, as these are the nodes that will be visible from the top.
 */
 
 import java.util.*;
 import java.lang.*;
 import java.io.*;
 
 // A class to create a node
 class Node{
 	// hor represents the horizonatal distance, root node has 0 hor
 	int data, hor;
 	Node left, right;
 	public Node(int d){
 		data = d;
 		hor = 0;
 		left = null;
 		right = null;
 	}
 }
 
 class BinaryTree {
 
     Scanner sc = new Scanner(System.in);  
     public BinaryTree(){ 
     	Node root = null; 
     }
     // A function that creates the binary tree and return its root
     public Node BuildTree(){
 		int d = sc.nextInt();
 		if(d == -1)
 			return null;
 		Node root = new Node(d);
 		root.left = BuildTree();
 		root.right = BuildTree();
 		return root;
 	}
  	// A function to print the top view of the binary tree
     private void TopView(Node root)
     {
         int hor = 0;
         Queue<Node> q = new LinkedList<Node>();
         Map<Integer, Integer> mp = new TreeMap<Integer, Integer>();
  
         if (root == null) {
             return;
         }
         else {
         	root.hor = hor;
             q.add(root);
         }
  
         while (!q.isEmpty()) {
             hor = root.hor;
             if (!mp.containsKey(root.hor)) {
                 mp.put(hor, root.data);
             }
  			// On moving left, horizontal distance decrements
             if (root.left != null) {
             	root.left.hor = hor - 1;
                 q.add(root.left);
                                   
             }
             // On mo",Java
"#include<stdio.h>
 #include<stdlib.h>
 #include<unistd.h>
 
 #define size 20
 #define TRUE 1
 #define FALSE 0
 
 int g[size][size];
 int visit[size];
 int Q[size];
 int n;
 
 void main()
 {
     int v1, v2;
     char ans = 'y';
     void create(), bfs();
     create();
     printf(""The Adjacency Matrix for the graph is \n"");
     for (v1 = 0; v1 < n; v1++)
     {
         for (v2 = 0; v2 < n; v2++)
             printf(""%d"", g[v1][v2]);
         printf(""\n"");
     }
     getchar();
     do
     {
         for (v1 = 0; v1 < n; v1++)
             visit[v1] = FALSE;
 
 
         printf(""Enter the Vertex from which you want to traverse "");
         scanf(""%d"", &v1);
         if (v1 >= n)
             printf(""Invalid Vertex\n"");
         else
         {
             printf(""The Breadth First Search of the Graph is\n"");
             bfs(v1);
             getchar();
         }
         printf(""\nDo you want to traverse from any other node?"");
         ans = getchar();
     } while (ans == 'y');
     exit(0);
 }
 void create()
 {
     int v1, v2;
     char ans = 'y';
     printf(""\n\t\t This is a program to create a Graph"");
     printf(""\n\t\t The Dispaly Is In Breadth First Manner"");
     printf(""\nEnter no. of nodes"");
     scanf(""%d"", &n);
     for (v1 = 0; v1 < n; v1++)
         for (v2 = 0; v2 < n; v2++)
             g[v1][v2] = FALSE;
     printf(""\nEnter the vertices no. starting from 0"");
     do
     {
         printf(""\nEnter the vertices v1 & v2"");
         scanf(""%d%d"", &v1, &v2);
         if (v1 >= n || v2 >= n)
             printf(""Invalid Vertex Value\n"");
         else
         {
             g[v1][v2] = TRUE;
             g[v2][v1] = TRUE;
         }
         printf(""\n\nAdd more edges??(y/n)"");
         ans = getchar();
     } while (ans == 'y');
 }
 void bfs(int v1)
 {
     int v2, front, rear;
     visit[v1] = TRUE;
     front = rear = -1;
     Q[++rear] = v1;
     while (front != rear)
     {
         v1 = Q[++front];
         printf(""%d\n"", v1);
      ",C
"/*
 Given an array find the next smallest element to the right
 ALGORITHM:
 *Initialise a stack and array
 *Traverse the given array from the left
 *If the stack is empty, then push -1 to array
 *If the stack is not empty and topmost element is smaller than th element then push topmost element to array
 *If not then pop elements from the stack till it is empty or topmost element is smaller
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void nextSmallestToLeft (int a[],int n)
 {
     stack <int> s;
     vector <int> v;
 
     for(int i = 0 ; i < n ; i++)
     {
         if (s.empty())
         v.push_back(-1);
         else if (s.empty() != true && s.top() < a[i])
         v.push_back(s.top());
         else if (s.empty() != true && s.top() > a[i])
         {
             while (s.empty() != true && s.top() > a[i])
             {
                 s.pop();
             }
             if (s.empty())
             v.push_back (-1);
             else if (s.top() < a[i])
             v.push_back(s.top());            
         }
         s.push(a[i]);
     }
 
     for(int i = 0 ; i < n ; i++)
     cout << v[i] << "" "";
 }
 
 //Driver function
 int main()
 {
     int n;
     cout << ""Enter number of elements: "";
     cin >> n;
     int a[n];
     cout << ""Enter the elements:\n"";
     for(int i = 0 ; i < n ; i++)
     cin >> a[i];
     nextSmallestToLeft(a,n);
 }
 
 /*
 Time Complexity: O(n^2)
 
 Space Complexity: O(n)
 
 Input:
 
 Enter number of elements: 4
 Enter the elements:
 1 2 4 5 
 
 Output:
 
 -1 1 2 4
 */
",C-Plus-Plus
"/*
 ___Paint Fence Algorithm___
 
 Problem:
 Given a fence with n posts and k colors
 Find out the number of ways of painting the fence
 such that at most 2 adjacent posts have the same color.
 
 Input:
 n : number of posts
 k : number of colors
 
 Output:
 result: number of ways of painting
         considering the condition above
 
 */
 
 #include <iostream>
 using namespace std;
 
 //function uses permutation logic to output number of possible ways of painting
 
 int paint_fence(int n, int k){          
     if(n<2 || k<(n/2)){
         return -1;
     }
     int total[n-1],same[n-1],diff[n-1];
     same[0]=k;
     diff[0]=k*(k-1);
     total[0]=k*k;
     for(int i=1;i<n-1;++i){
         same[i] = diff[i-1];
         diff[i] = total[i-1]*(k-1);
         total[i] = same[i]+diff[i];
     }
     return total[n-2];
 }
 
 int main(){
     int post,color;
     cout<<""Enter n,Number of Posts\n"";
     cin>>post;
     cout<<""Enter k,Number of Colors\n"";
     cin>>color;
     int result = paint_fence(post,color);
     if(result==-1){
         cout<<""Painting is not possible following the condition\n"";
     }
     else{
         cout<<""Number of Possiblities: ""<<result<<""\n"";
     }
     return 0;
 }
 
 
 /*Sample Input/Output
 
 Enter n,Number of Posts
 3
 Enter k,Number of Colors
 5
 Number of Possiblities: 120
 
 Enter n,Number of Posts
 10
 Enter k,Number of Colors
 4
 Painting is not possible following the condition
 
 Enter n,Number of Posts
 5
 Enter k,Number of Colors
 3
 Number of Possiblities: 180
 
 Time Complexity  O(n)
 Space Complexity O(n) 
 */
",C-Plus-Plus
"/*Sieve_of_eratosthenes
   Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to any given limit.
   It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with
   the first prime number, 2. The multiples of a given prime are generated as a sequence of numbers starting from that prime,
   with constant difference between them that is equal to that prime.*/
 
 //Header files
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdbool.h>
 
 void Sieve_of_eratosthenes(int n)
 {
     // Creating an array for storing prime factors.
     // and if the i is not prime, mark it as 0 else 1
     int prime[n + 1];
 
     // Initialising all elements as 1
     for (int i = 2; i <= n; i++)
         prime[i] = 1;
 
     for (int i = 2; i * i <= n; i++)
     {
         // If prime[i] is marked 1, then it is a prime.
         if (prime[i] == 1) 
         {
             // Marking all multiples of i as 0
             for (int j = i * i; j <= n; j += i)
                 prime[j] = 0;
         }
     }
 
     // Printing all the prime numbers
     for (int i = 2; i <= n; i++)
         if (prime[i])
         {
             printf(""%d "", i);
         }
 }
 /**
  * Optimized version of Sieve of Eratosthenes using Dynamic Memory Allocation and using Boolean.
  */
 void sieve(int N, bool * isprime) 
 {
     isprime[0] = true;
     isprime[1] = true;
   
     // eliminating multiples of i 
     for (int i = 2; i * i <= N; ++i)
     {
         if (!isprime[i]) 
         {
             for (int j = i * i; j <= N; j = j + i) 
             {
                 isprime[j] = true;
             }
         }
     }
     // Printing all the prime numbers
     for (int i = 1; i <= N; i++) 
     {
         if (!isprime[i]) 
         {
             printf(""%d "", i);
         }
     }
     printf(""\n "");
 }
 
 // Driver Function
 int main() {
     int num;
     printf(""Enter the number: \n"");
     scanf(""%d"", & num);
     printf(""",C
"/*
 -In Round-robin scheduling, each ready task runs turn by turn only in a cyclic queue 
 for a limited time slice. 
 -This algorithm also offers starvation free execution of processes.
 -It is preemptive as processes are assigned CPU only for a fixed slice of time at most.
 */
 
 import java.util.*;
 
 class Procces {
     float ArrivalTime, BurstTime, FinishTime, WaitingTime, TurnAroundTime, BT;
     int flag, id;
 
     public Procces(float BurstTime, int id) {
         this.ArrivalTime = 0;
         this.BurstTime = BurstTime;
         WaitingTime = 0;
         BT = BurstTime;
         this.id = id;
         flag = 0;
     }
 }
 
 class ManagingQueue {
     Procces P[] = new Procces[20];
     int SizeOfCircularQueue, TotalProcessesFinished;
     int front, rear;
     float Timer, AWT, ATT;
 
     ManagingQueue(int SizeOfCircularQueue) {
         front = -1;
         rear = -1;
         this.SizeOfCircularQueue = SizeOfCircularQueue;
         Timer = 0;
         TotalProcessesFinished = 0;
     }
 
     int IsQueueEmpty() { // Checking whether queue is empty
         if ((front == 0 && rear == -1) || (front == (rear + 1))) {
             return 1;
         } else {
             return 0;
         }
     }
 
     int IsQueueFull() { // checking queue is full or not
         if ((front == 0 && rear == (SizeOfCircularQueue - 1)) || front == (rear + 1) % SizeOfCircularQueue) {
             return 1;
         } else {
             return 0;
         }
     }
 
     void ManageProcessQueue() {
         float BurstTime;
         int id, i, QuantumTime;
         Scanner sc = new Scanner(System.in);
         Procces CircularQueue[] = new Procces[SizeOfCircularQueue];
         System.out.println(""Enter Quantum time :"");
         QuantumTime = sc.nextInt();
         for (i = 0; i < SizeOfCircularQueue; i++) {
             System.out.println(""Enter Process ID :"");
             id = sc.nextInt();
             System.out.println(""Enter Burst time :"");
             BurstTime =",Java
"//Swap Even and Odd Bits
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int main()
 {
 	unsigned int x;
 	cout << ""Enter number \n"";
 	cin >> x;
 
 	// Get all even bits of x
 	unsigned int even_bits = x & 0xAAAAAAAA;
 
 	// Get all odd bits of x
 	unsigned int odd_bits = x & 0x55555555;
 	// Right shift even bits
 	even_bits >>= 1;
 	// Left shift odd bits
 	odd_bits <<= 1;
 	// Combine even and odd bits
 	cout << (even_bits | odd_bits);
 }
 
 /*
 Time Complexity: O(1)
 Space Complexity: O(1)
 */
 
 /*Sample Input:
 Example 1:- 
 Enter number
 50
 Example 2:-
 Enter number
 994
 
 Sample Output:
 Example 1:- 
 49
 Example 2:-
 997
 */
 
",C-Plus-Plus
"//Find the pair of adjacent elements that have the largest product in a given array and return that product.
 #include <stdio.h>
 
 void prod_elements(int *, int *, int);
 int largest_product(int *, int);
 int main()
 {
 	int num, i, arr[1000], prod[1000];
 	printf(""Enter the number of elements:"");
 	scanf(""%d"", &num);
 	printf(""Enter the elements:"");
 	for (i = 0; i < num; i++)
 	{
 		scanf(""%d"", &arr[i]);
 	}
 
 	printf(""Array="");
 	for (i = 0; i < num; i++)
 	{
 		printf(""%d "", arr[i]);
 	}
 
 	printf(""\n"");
 	prod_elements(prod, arr, num);
 	printf(""Largest Adjacent Product in the Array=%d"", largest_product(prod, num));
 	return 0;
 }
 
 // Putting the product of adjacent elements in a new array
 void prod_elements(int *prod, int *arr, int num)
 {
 	int i;
 	for (i = 0; i < num - 1; i++)
 	{*(prod + i) = (*(arr + i)) * (*(arr + i + 1));
 	}
 }
 
 // Taking out the largest product from the prod array
 int largest_product(int *prod, int num)
 {
 	int i, big;
 	big = *prod;
 	for (i = 0; i < num - 1; i++)
 	{
 		if (big<*(prod + i))
 			big = *(prod + i);
 	}
 
 	return (big);
 }
 
 /*Sample Output
 Enter the number of elements:6
 Enter the elements:3 6 -2 -5 7 3
 Array=3 6 -2 -5 7 3
 Largest Adjacent Product in the Array=21
 */
 
",C
"""""""
 First fit is the simplest of all the storage allocation strategies.
 Here the list of storages is searched and as soon as a free storage block of size >= N is found ,
 the pointer of that block is sent to the calling program after retaining the residue space.Thus, for example,
 for a block of size 5k , 2k memory will be sent to the caller . The below program is a simulation of the first fit strategy
 using array data structure.
 """"""
 
 # Block class is used as the fixed memory blocks for allocation
 class Block:
     def __init__(self):
         self.size = 0
         self.ID = 0
         self.fragment = 0
 
 
 # process class is used for allocating memory for the requesting processes
 class process:
     def __init__(self):
         self.Num = 0
         self.size = 0
         self.block = None
 
 
 # initialiseBlocks function initializes all the blocks with sizes and id
 def initialiseBlocks(arr, sizes, n):
     for i in range(n):
         arr[i].size = sizes[i]
         arr[i].fragment = sizes[i]
         arr[i].ID = i + 1
 
 
 # printResult function prints the result of the memory allocation strategy
 def printResult(arr2, numOfProcess):
     print(
         ""Process No            Process Size          Block ID          Block Size         Block Fragment""
     )
     for i in range(numOfProcess):
         print(
             str(arr2[i].Num)
             + ""                     ""
             + str(arr2[i].size)
             + ""                     ""
             + str(arr2[i].block.ID)
             + ""                     ""
             + str(arr2[i].block.size)
             + ""                     ""
             + str(arr2[i].block.fragment)
         )
 
 
 # firstfit function allocates memory to processes using firstfit allocation algorithm
 def firstfit(arr, sizes, n, arr2, numOfProcess):
     initialiseBlocks(arr, sizes, n)
     for i in range(numOfProcess):
         for j in range(n):
             if arr2[i].size <= arr[j].fragment:
                 ar",Python
"/*
 C# Program to Perform a Selection Sort
 
 Selection sort is an algorithm of sorting an array where it loop from the start 
 of the loop, and check through other elements to find the minimum value.
 After the end of the first iteration, the minimum value is swapped with the current element.
 The iteration then continues from the 2nd element and so on.
 */
 using System;
 
 class SelectionSort
 {
     static void Main(string[] args)
     {
         //Take array size input
         Console.Write(""Enter array size: "");
         int array_size = Convert.ToInt32(Console.ReadLine());
         
         int[] array = new int[array_size]; 
         
         //Take array elements input
         for(int i=0; i<array_size; i++){
             Console.Write(""Element {0} : "", i);
             array[i] = Convert.ToInt32(Console.ReadLine());
         }
         
         //Print array before Selection sort
         Console.Write(""\nThe Array Before Selection Sort is: "");
         for(int i=0; i<array_size; i++)
         {
             Console.Write(array[i]+ "" "");
         }
         
         int MinIndex = 0;//current index of the current minimum wwe are looking for
         int temp = 0; //temparory variable for swapping the value of the current min index
  
         //MainIndex is the pointer for each lowest we need to find
         for(int MainIndex=0; MainIndex<array_size-1; MainIndex++)
         {
             //MinIndex is now the current spot in the main list
             MinIndex = MainIndex;
             
             //remaining goes threw the remainder of the list finding the index of the next lowest value
             for(int RemainingIndex=MainIndex+1; RemainingIndex<array_size; RemainingIndex++)
             {
                 //if the Remaining element is the less then the MinIndex we move the index to that spot
                 //will swap values after going through the entire list
                 if (array[RemainingIndex] < array[MinIndex])
                 ",C-Sharp
"// C++ program to implement Three Way Merge Sort
 
 #include <bits/stdc++.h>
 using namespace std;
 
 
 // Merge the three sections in ascending order
 void merge(int arr[], int beg, int midA, int midB, int end, int temp[])  
 {  
     int i, j, k, l;
     i = beg;
     j = midA; 
     k = midB; 
     l = beg;  
   
     // Find the smallest element among the three sections 
     while ((i < midA) && (j < midB) && (k < end))  
     {  
         if(arr[i] < arr[j]) 
         { 
             if(arr[i] < arr[k]) 
             { 
                 temp[l++] = arr[i++]; 
             } 
             else
             { 
                 temp[l++] = arr[k++]; 
             } 
         } 
         else
         { 
             if(arr[j] < arr[k]) 
             { 
                 temp[l++] = arr[j++]; 
             } 
             else
             { 
                 temp[l++] = arr[k++]; 
             } 
         } 
     }  
   
     /*
     Now any two arrays would have remaining values that are yet to be merged,
     We have to identify those two arrays and merge the elements.  
     */
  
     while ((i < midA) && (j < midB))  
     {  
         if(arr[i] < arr[j]) 
         { 
             temp[l++] = arr[i++]; 
         } 
         else
         { 
             temp[l++] = arr[j++]; 
         } 
     }  
   
    
     while ((j < midB) && (k < end))  
     {  
         if(arr[j] < arr[k]) 
         { 
             temp[l++] = arr[j++]; 
         } 
         else
         { 
             temp[l++] = arr[k++]; 
         }  
     }  
   
     while ((i < midA) && (k < end))  
     {  
         if(arr[i] < arr[k]) 
         { 
             temp[l++] = arr[i++]; 
         } 
         else
         { 
             temp[l++] = arr[k++]; 
         }  
     }  
   
   /*
     Now a single array would have remaining values that are yet to be merged,
     We have identify that array and copy its remaining elements.  
   */
     
     while (i < midA)  
         temp[l++] = arr[",C-Plus-Plus
"// Given a number n, print all primes smaller than or
 // equal to n. It is also given that n is a small number.
 
 package main
 
 import ""fmt""
 
 // function to print all prime numbers
 // till n
 func Sieve(n int) {
 	// creating prime slice of bool type
 	prime := make([]bool, n+1)
 
 	// initializing prime slice with true
 	for itr := 0; itr <= n; itr++ {
 		prime[itr] = true
 	}
 
 	for p := 2; p*p <= n; p++ {
 		// if prime[p] is true then
 		// it is prime
 		if prime[p] == true {
 			for x := p * p; x <= n; x += p {
 				prime[x] = false
 			}
 		}
 	}
 
 	// printing all prime numbers
 	for p := 2; p <= n; p++ {
 		if prime[p] == true {
 			fmt.Print(p, "" "")
 		}
 	}
 }
 
 func main() {
 	var num int
 
 	fmt.Print(""Enter the range: "")
 	fmt.Scan(&num)
 
 	// calling Sieve function to print
 	// all prime numbers till num
 	Sieve(num)
 }
 
 // TIME COMPLEXITY: O(n*log(log(n)))
 // SPACE COMPLEXITY: O(n)
 
 // TEST CASE 1:
 // Enter the range: 50
 // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47
 
 // TEST CASE 2:
 // Enter the range: 100
 // 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
",Go
"/* Problem Statement =>
     Given a 2 x n board and tiles of size 2 x 1, count the number of ways to
    tile the given board using the 2 x 1 tiles.
     A tile can either be placed horizontally i.e., as a 1 x 2 tile or vertically
    i.e., as 2 x 1 tile. */
 
 #include <iostream>
 #include <climits>
 #include <vector>
 #include <algorithm>
 using namespace std;
 
 long long numberOfWays(long long length){
     int mod = 1000000007;
     vector<long long> dp(length + 1, 0);
 
     // Case 1: if n == 1 , only 1 configuration of tile is possible
     dp[1] = 1;
 
     // Case 2: if n == 2 , only 2 configurations are possible
     dp[2] = 2;
     
     /* Case 3: if n > 2, then we got 2 possible subcases:
         Subcase 1: if we place length wise, call dp[i-2];
         Subcase 2: if we place width wise, call dp[i-1];  */
     for (int i = 3; i <= length; i++){
         dp[i] = ((dp[i - 2] % mod) + (dp[i - 1] % mod)) % mod;
     }
     return dp[length];
 }
 
 int main(){
     long long length;
     cout << ""Enter the length of the floor: "" << endl;
     cin >> length;
     cout << ""Number of ways to tile floor of length 2 x "" << length << "" are: "" << numberOfWays(length) << endl;
 }
 
 /*  Sample Input:
         n=3
     Sample Output:
         3
     Expected Time Complexity:
         O(n)
     Expected Space Complexity:
         O(n)
 */
",C-Plus-Plus
"""""""Length of Longest Common Substring problem in Julia
 
 Given two strings, we have to find the longest common substring in Julia
 
 The problem can be solved using Dynamic Programming
 """"""
 
 function lengthoflongestcommonsubstring(S1, S2)
     # Build a 2D matrix in Bottom-Up manner. Every element
     # dp[i][j] contains the length of the longest common substring
     # of S1[0 .. i] and S2[0 .. j].
     n = length(S1)
     m = length(S2)
     ans = 0
     # Fill every element of the 2D matrix with 0 as value
     dp = zeros(Int, n+1, m+1)
 
     for i in 1:(n+1)
         for j in 1:(m+1)
 
             # length of LCS when one of the string is empty is zero
             if i == 1 || j == 1
                 dp[i,j] = 0
 
             # If the elements of both the strings match, then
             # the value of LCS increments by one.
             # Also Check if the value of lcs has reached the max till now.
             elseif S1[i-1] == S2[j-1]
                 dp[i,j] = dp[(i - 1),(j - 1)] + 1
                 ans = max(ans, dp[i,j])
             else
                 dp[i,j] = 0
             end
         end
     end
     return ans
 end
 
 
 print(""Enter the first string: "")
 s1 = readline()
 print(""Enter the second string: "")
 s2 = readline()
 res = lengthoflongestcommonsubstring(s1, s2)
 print(""The length of the longest common substring is "")
 print(res)
 
 
 # Time Complexity: O(n * m), where n, m are the size of the given strings
 # Space Complexity: O(n * m)
 
 # SAMPLE INPUT AND OUTPUT
 
 # Enter the first string: runner
 # Enter the second string: run
 # The length of the longest common substring is 3
",Julia
"/*
 This approach uses Dynamic Programming and Prefix Sum to find out maximum
 subarray sum in Linear time. Alternate approach could be to use Kadane's
 algorithm using O(1) extra space.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int main() {
 	long long int t, n, i, j;                    //t -> no. of testcases, n -> size of array
 	cin >> t;
 	while (t--) {
 		cin >> n;
 		long long int a[n];
 		for (i = 0; i < n; i++)                  //input array
 			cin >> a[i];
 
 		long long int pre_sum[n];
 		pre_sum[0] = a[0];
 		for (i = 1; i < n; i++)                  //array that stores prefix sum of input array
 			pre_sum[i] = pre_sum[i - 1] + a[i];
 
 		long long int res = INT_MIN, min_pre_sum = 0;
 		for (i = 0; i < n; i++) {
 			res = max(res, pre_sum[i] - min_pre_sum);               //loop through array while keeping track of minimum prefix sum so far and maximum subarray sum
 			min_pre_sum = min(min_pre_sum, pre_sum[i]);
 		}
 		cout << res << ""\n"";
 	}
 	return 0;
 }
 
 /*
 Time Complexity : O(n)
 Space Complexity: O(n)
 
 Sample Input:
 2                        //no. of testcases
 8                        //size of array
 4 -8 9 -4 1 -8 -1 6
 9                        //size of array
 -2 1 -3 4 -1 2 1 -5 4
 Sample Output:
 9
 6
 */
",C-Plus-Plus
"/*
 This code is for Rotating an NxN 2D array in 90 degrees anticlockwise direction.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //function to rotate the user  matrix anticlockwise
 void rotatematrix(int a[][10], int n)
 {
   //reversing each row
   for (int row = 0; row < n; row++)
   {
     int start_col = 0;
     int end_col = n - 1;
     while (start_col < end_col)
     {
       swap(a[row][start_col], a[row][end_col]);
       start_col++;
       end_col--;
     }
   }
   //taking transpose
   for (int i = 0; i < n; i++)
   {
     for (int j = 0; j < n; j++)
     {
       if (i < j)
       {
         swap(a[i][j], a[j][i]);
       }
     }
   }
 }
 //function for displaying the rotated 2darray/matrix
 void display(int a[10][10], int n)
 {
   for (int i = 0; i < n; i++)
   {
     for (int j = 0; j < n; j++)
     {
       cout << a[i][j]<<"" "";
     }
     cout<<endl;
   }
 }
 
 //driver function
 int main()
 {
   int a[10][10];
   //'n' here is declared for the order of your matrix
   int n;
   //taking input for the order of matrix
   cout << ""enter the order for your square matrix:"" << endl;
   cin >> n;
 
   //taking input for the matrix data
   cout << ""please enter the elements of your matrix to be Rotated:"" << endl;
   for (int i = 0; i < n; i++)
   {
     for (int j = 0; j < n; j++)
     {
       cin >> a[i][j];
     }
   }
 
   cout << ""the matrix to be rotated:"" << endl;
   //calling the function for displaying the initial matrix
   display(a, n);
   //calling the function for rotating the matrix
   rotatematrix(a, n);
   cout << ""the matrix after rotation:"" << endl;
   //calling the function for displaying the rotated matrix
   display(a, n);
 }
 /*EXECUTION:-
 
 SAMPLE OUTPUT-1:
 enter the order for your square matrix:
 2
 please enter the elements of your matrix to be Rotated:
 1
 2
 3
 4
 the matrix to be rotated:
 1 2
 3 4
 the matrix after rotation:
 2 4
 1 3
 
 SAMPLE OUTPUT-2:
 enter the order for your square matrix:
 3
 please enter ",C-Plus-Plus
"'''
 Burrows Wheeler Transform(BWT): BWT is a string compression algorithm
 that can be used to simply encrypt strings just by cyclic operations.
 It is used in zip format files, Linux, Internet Protocols to even research.
 
 Motivation:
 https://www.youtube.com/watch?v=4WRANhDiSHM&list=TLPQMjcxMjIwMjCzl4040phelQ&index=2
 Method: There are numerous ways of implementing this algorithm.
 Here simple array operations are used, so that the idea of algorithm
 can be easily conveyed and understood.
 
 N = length of input string
 Time Complexity:  O(N2Log(N))(NLog(N) for sorting and N for iteration)
 Space Complexity: O(N)(for cyclic rotations of orignal string)
 Argument: String (Orignal string)
 Return : String (BWT compressed string)
 '''
 
 
 def bwt(orignal_string):
 
     # Add '$' to denote end of the orignal string, which is needed to invert
     # and obtain the orignal string
     orignal_string += ""$""
 
     # Roatating orignal string letter by letter and storing cyclic rotations
     bwt_rotations = sorted(orignal_string[i:] + orignal_string[:i]
                            for i in range(len(orignal_string)))
 
     # Last column letters of the bwt_rotations has a special charecteristic
     # which is used to get back orignal string.
     last_column = [row[-1:] for row in bwt_rotations]
 
     # Return last_column as compressed bwt_string
     bwt_string = """".join(last_column)
     return bwt_string
 
 
 def invert_bwt(compressed_string):
 
     # Store length of compressed_string
     length = len(compressed_string)
 
     # Intialise bwt_rotations as empty strings
     bwt_rotations = [""""] * length
 
     # Looping length times to get all the cyclic rotations(permutations)
     # Roatating compressed_string letter by letter and storing cyclic rotations
     for i in range(length):
         bwt_rotations = sorted(
             compressed_string[i] + bwt_rotations[i] for i in range(length))
 
     # Finding the orignal string, knowing it ends with '$'
     fo",Python
"/* This algorithm will represent a number n(>1) as product of prime numbers.
  For example, if the input is 12 then output will be 2 2 3 , if input is 28 then output will be (2,2,7).
  Two concepts are used here. Firstly , through sieve of erathosthenes we will find all the prime numbers till n.
  Then we will check which prime numbers can divide n and for how many times*/
 
 #include<iostream>
 #include <cmath>
 using namespace std;
 
 void prime_factors(int n)
 {
     //Applying sieve of erathosthenes to store the prime numbers till n
     int arr[n+1]={0};
     arr[1]=1;
     for(int i=2;i<=sqrt(n);i++)
     {
         if(arr[i]==0)
         {
             for(int j=i*i;j<=n;j+=i)
             {
                 arr[j]=1;
             }
         }
     }
     for(int i=1;i<=n;i++)
     {
         if(arr[i]==0)    //checking if i is prime
         {
          while(n%i==0)   //while i divides n, print i and keep on dividing n by i
          {
             cout<<i<<"" "";
             n=n/i;
          }
         }
     }  
      return;
 }
 //Driver Code
 int main()
 {
     int num;
     cin>>num;
     prime_factors(num);
      return 0;
 }
 /* sample input: 12
    sample output: 2 2 3
 
    sample input: 24
    sample output: 2 2 2 3
 
    Time Complexity: O(n*log(log(n)) + log(n) + n)
    for sieve of erathrosthenes => O(n*log(log(n)))
    for printing the prime factors => O(n+ log(n))
    Space Complexity: O(n) */
",C-Plus-Plus
"/*Iterative:*/
 import java.util.Scanner;
 
 public class CountDigits {
 
 	public static void countdigit(int n) {
 	        int count=0;
 		while(n!=0){
                 count=count+1;
                 n=n/10;
               }
              System.out.println(count);   
 
 	}
 	
 	public static void main(String[] args) {
 
 		Scanner sc=new Scanner(System.in);
 		
 		System.out.print(""Enter a number : "");
 		int n=sc.nextInt();
 		
 		System.out.println(""Number of digits in a number are : "");
 		countdigit(n);
 				
 	}
 /*	
  	Sample Input : 
 	Enter a number : 24567
  	
 	Sample Output : 5
 	 	
 */
",Java
"/*
 Given an ab rectangle, your task is to cut it into squares. On each move you can select a rectangle and cut it into two
 rectangles in such a way that all side lengths remain integers. What is the minimum possible number of moves?
 
 Input
 
 The only input line has two integers a and b.
 
 Output
 
 Print one integer: the minimum number of moves.
 
 Constraints
 
 1a,b500
 
 Example
 
 Input:
 3 5
 
 Output:
 3
 
 */
 
 /*
                                 APPROACH
             ----------------------------------------------------
             We will make all the horizontal cuts and try to find 
             after which move we have to make minimum moves to make 
             all squares,
             Similarly,
             We do the same with vertical moves,
             We will divide the recetanle in two parts and add the 
             result for both parts and find minimum among all moves
             which will be our ans.
 
             Time Complexity : O(a*b)
             Space Complexity : O(a*b) due to the 2d array of size (a+1) by (b+1)
 */
 import java.util.Scanner;
 
 class Rectangle_cutting {
     static int dp[][]; // declaring dp array for memorization.
 
     static int cutting(int a, int b) {
         // if side lengths are equal then no move required.
         if (a == b)
             return 0;
         // for a by 1 or 1 by b rectangle we have to make a-1 and b-1 cuts respectively.
         if (a == 1 || b == 1)
             return Math.max(a, b) - 1;
 
         // if the result is stored already return it.
         if (dp[a][b] != -1)
             return dp[a][b];
 
         int ans = Integer.MAX_VALUE;
 
         // recursivly making cuts.
         // loop to make all the horizontal cuts
         /*
          * iterate upto a/2 only wwwww
          */
         for (int i = 1; i <= a / 2; i++) {
             // making every position move and taking the minimum out of it.
             ans = Math.min(ans, cutting(i, b) + cutting(a - i",Java
"'''
 Given three arrays sorted in increasing order. Find the elements that are common in all three arrays.
 
 Input:
 A = {1, 5, 10, 20, 40, 80}
 B = {6, 7, 20, 80, 100}
 C = {3, 4, 15, 20, 30, 70, 80, 120}
 
 Output: [20, 80]
 
 Explanation: 20 and 80 are the only
 common elements in A, B and C.
 
 '''
 
 def common_elements(arr1,arr2,arr3):
         #Take the lists in set 
         setofarr1 = set(arr1)
         setofarr2 = set(arr2)
         setofarr3 = set(arr3)
         #using the intersection method  we can find out common elements between arr1 and arr2   
         t = setofarr1.intersection(setofarr2)   
         #using the intersection method  we can find out common elements between arr1 and arr2 and arr3  
         Total = list(t.intersection(setofarr3))
         #sort the Total array 
         Total.sort()
         #print out the result 
         return Total
 
 if __name__ == ""__main__"":
     arr1 = list(map(int,input(""Enter the list 1: "").split()))
     arr2 = list(map(int,input(""Enter the list 2: "").split()))
     arr3 = list(map(int,input(""Enter the list 3: "").split()))
     print(""Common elements from all the three lists are "",common_elements(arr1, arr2, arr3))
     
 '''
 Time Complexity: O(n1 + n2 + n3)
 Space Complexity : O(n1 + n2 + n3)
 
 INPUT: 
 Enter the list 1: 1 5 10 20 40 80
 Enter the list 2: 6 7 20 80 100
 Enter the list 3: 3 4 15 20 30 70 80 120 
 
 OUTPUT:
 Common elements from all the three lists are  [20, 80]
 
 '''
",Python
"/*
 Radix Sort in Dart.
 
 Radix sort is a sorting algorithm that sorts the elements by first grouping 
 the individual digits of the same place value. Then, sort the elements 
 according to their increasing/decreasing order.
 */
 
 import 'dart:io';
 
 void counting_sort(var arr, int size, int place) {
   int max = 10;
   List out = new List.filled(size, null, growable: false);
   List count = new List.filled(max, null, growable: false);
 
   for (int i = 0; i < max; ++i) count[i] = 0;
 
   // Calculate count of elements
   for (int i = 0; i < size; i++) {
     int places = (arr[i] ~/ place) % 10;
     count[places]++;
   }
 
   // Calculate cummulative count
   for (int i = 1; i < max; i++) count[i] += count[i - 1];
 
   // Place the elements in sorted order
   for (int i = size - 1; i >= 0; i--) {
     int places = (arr[i] ~/ place) % 10;
     int pos = count[places] - 1;
     out[pos] = arr[i];
     count[places]--;
   }
 
   // changing position based on places sorting
   for (int i = 0; i < size; i++) arr[i] = out[i];
 }
 
 void radix_sort(var arr, int size) {
   // max element to calculate significant digits
   int max = arr[0];
   for (int i = 1; i < size; i++) {
     if (arr[i] > max) max == arr[i];
   }
 
   // place
   for (int place = 1; max / place > 0; place *= 10) {
     counting_sort(arr, size, place);
   }
 }
 
 void main() {
   var arr = [];
 
   // User inputs
   var n, each;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     each = stdin.readLineSync();
     each = int.parse(each);
     arr.add(each);
   }
 
   // Applying Radix Sort
   radix_sort(arr, n);
 
   print(arr);
 }
 
 /*
 Time Complexity : O(n*k/d)
 Space Complexity : O(n+2^d)
 where, 
     k = maximum possible value
     d = no. of digits 
 
 SAMPLE I/O:
 Enter the number of Elements:
 6
 Enter Element 1: 
 12
 Enter Element 2: 
 33
 Enter Element 3: 
 4
 Enter Element",Dart
""""""" Julia program to Check if a number is an Armstrong Number or not.
 An armstrong number is a number such that the sum of its digits each 
 raised to the power of the number of digits.
 """"""
 
 function check_armstrong(num)
     temp = num
     sum = 0
     cnt = floor(log10(num) + 1)
     while (temp > 0)
         rem = temp % 10
         sum = sum + (rem ^ cnt)
         temp = temp  10;
     end
     if(num == sum)
         return true
     else
         return false
     end
 end
 
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 if(num < 0)
     println(""The given number $num is not a Armstrong Number."")
     exit()
 end
 res = check_armstrong(num)
 if res
     println(""The given number $num is a Armstrong Number."")
 else
     println(""The given number $num is not a Armstrong Number."")
 end
 
 
 """"""
 Time Complexity: O(log(num)), where 'num' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 371
 The given number 371 is a Armstrong Number.
 
 SAMPLE 2
 Enter the number: 1234
 The given number 1234 is not a Armstrong Number.
 
 """"""
",Julia
"/* C++ program to solve Trapping Rainwater problem.An array of non-negative integers are given which
 represent an elevation height each of width 1, the
 goal is to compute total water trapped after raining*/
 
 #include<bits/stdc++.h>
 using namespace std;
 
 class Trapwater {
 public:
     int trap(vector<int>& height){
     	int n = height.size();
     	int left = 0 , right = n-1;
     	// Initialize output
     	int res = 0;
     	// Maximum element on left and right
         int max_left = 0, max_right = 0;
 
         while(left <= right){
 
         	if(height[left] <= height[right]){
 
         		if(height[left] >= max_left)
         			// Update max in left
         			max_left = height[left];
         		else
         			// Water trapped on current index is max - current height
         			res += max_left - height[left];
         		left++;
         	}
         	else{
 
         		if(height[right] >= max_right)
         			// Update max in right
         			max_right = height[right];
         		else
         			res += max_right - height[right];
         		right--;
         	}
         	return res;
     }
 };
 
 int main(){
 	int n,h;
 	vector<int> height;
 	// Taking input of number of buildings
 	cin >> n;
 	while(n--){
 		// input the height of each building
 		cin >> val;
 		height.push_back(h);
 	}
 	Trapwater t;
 	int result = t.trap(height);
 	// display the amount of water trapped
 	cout << result;
 }
 
 /*
 
 Input -
 
 n = 5
 arr[n] = {2,3,1,0,5}
 
 Sample Output -
 
 5
 
 Explanation -
 
 Two units of water can be stored at index 2 and 
 3 units at index 3
 
 Time Complexity : O(n)
 Space Complexity : O(1) 
 
 */
",C-Plus-Plus
"'''
 Top view of binary tree
 
 Given a binary tree, print the nodes in left to right manner as visible from
 above the tree.Input is given in order of root node, left child then
 right child(preorder).
 For e.g. 1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 -1
 Tree looks like
               1
           /      \
       2           3
     /     \       /
   4       5     6
 
 nodes '5' and '6' will be overlapped by '1' as seen from above,
 so when viewed from the top , we would see the nodes 4, 2, 1 and 3.
 '''
 
 
 # A class to create a node
 class Node:
     # Constructor to initialize node
     def __init__(self, key):
         self.key = key
         self.left = None
         self.right = None
 
 
 # A function to build the tree in preorder manner
 def MakeTree():
     val = int(input())
     if val == -1:
         return None
     root = Node(val)
     root.left = MakeTree()
     root.right = MakeTree()
     return root
 
 
 # A function to print the left side of the binary tree
 def LeftView(root):
     # base case
     if root is None:
         return
     # Recursive case
     LeftView(root.left)
     print(root.key, end="" "")
 
 
 # A function to print the right side of the binary tree
 def RightView(root):
     # base case
     if root is None:
         return
     # Recursive case
     print(root.key, end="" "")
     RightView(root.right)
 
 
 print(""Enter values in a binary tree: "")
 # A function call to build the tree and return root node
 root = MakeTree()
 # Calling the below two functions for printing the top view
 print(""Top view of the binary tree is: "")
 LeftView(root)
 RightView(root.right)
 
 '''
 Sample Input:
 Enter values in a binary tree:
 1
 2
 4
 -1
 -1
 5
 -1
 -1
 3
 6
 -1
 -1
 -1
 Sample Output:
 Top view of the binary tree is: 4 2 1 3
 
 Time Complexity:  O(n), for traversing the 'n' nodes
 
 Space Complexity: O(1), since no extra space is used
 '''
",Python
"/* Problem Description
 
 You are given a two-dimensional list of integers intervals where each list 
 contains three values [start, end, profit]. Given you can only perform one
 task at a time, return the maximum profit you can gain. */
 
 
 import java.util.*;
 
 public class JobSequencingToMaximizeProfit
 {
 
     /* Creating a Job Class which stores the start time, end time and profit for that particular job */
     static class Job{
         int start;
         int end;
         int profit;
         Job(int start, int end, int profit){
             this.start = start;
             this.end = end;
             this.profit = profit;
         }
     }
     
     /* Defining a Comparator which sorts the Jobs based on end time in ascending order */
     static class SortByEndTime implements Comparator<Job>{
         
         public int compare(Job A, Job B){
             return A.end - B.end;
         }
     }
 
     /* Function created to get maximum profit in the intervals provided */
     public static int getMaxProfit(int[][] intervals) {
 
         /* Creating an Jobs array to easily sort the jobs */
         ArrayList<Job> array = new ArrayList<>();
         int n = intervals.length;
 
         /* Adding the jobs to the jobs array */
         for(int i=0; i<n; i++){
             int start = intervals[i][0];
             int end = intervals[i][1];
             int profit = intervals[i][2];
             array.add(new Job(start, end, profit));
         }
         
         /* Sorting the jobs based on End time */
         Collections.sort(array, new SortByEndTime());
         
         /* Initializing a dp array to store the max profit for i particular jobs i.e 
          It stores the maximum profit gained when only i jobs are present */
         int dp[] = new int[n];
 
         /* When we are including only one job, we can have a maximum profit of that particular job */
         dp[0] = array.get(0).profit;
 
         /* Filling the dp array */
         for(i",Java
"//A program to check if a given singly linked list is a palindrome or not in linear time and no extra space
 //The idea is to reverse the second half of the linked list, and then compare the two halfs for palindrome checking
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class ListNode {
 public:
     int val;
     ListNode* next;
 };
 
 //return if the linked list is a palindrome or not
 bool is_palindrome(ListNode* head)
 {
 
     ListNode* A = head;
     int cnt = 0;
 
     //Count the number of nodes in the linked list
     while (A != NULL) {
         cnt++;
         A = A->next;
     }
 
     //If there is only one node, then its clearly a palindrome
     if (cnt == 1) {
         return 1;
     }
 
     //Traverse upto the node(half_end) after which we need to reverse the linked list
     int half = (cnt + 1) / 2;
     half--;
 
     ListNode* half_end = head;
     while (half > 0) {
         half_end = half_end->next;
         half--;
     }
 
     //Take 2 pointers to reverse the linked list after node half_end
     ListNode* p1 = half_end;
     ListNode* p2 = half_end->next;
 
     ListNode* temp = p2->next;
     p2->next = NULL;
     p1 = p2;
     p2 = temp;
 
     while (p2) {
         temp = p2->next;
         p2->next = p1;
         p1 = p2;
         p2 = temp;
     }
 
     //Join the head of the reversed linked list to the current endthat is, half_end
     half_end->next = p1;
 
     //Take 2 pointers and compare the 2 parts
     p2 = head;
     p1 = half_end->next;
 
     while (p1) {
         //If any one value is different, return 0
         if ((p2->val) != (p1->val)) {
             return 0;
         }
         else {
             p2 = p2->next;
             p1 = p1->next;
         }
     }
 
     return 1;
 }
 
 int main()
 {
     int nodes;
     cin >> nodes;
 
     int node_val;
     cin >> node_val;
 
     ListNode* head = new ListNode();
     head->val = node_val;
     head->next = NULL;
 
     ListNode* temp = head;
 
     for (int i ",C-Plus-Plus
"""""""A valid Binary Search Tree is defined as follows:
 
 The left subtree of a node contains only nodes with keys less than the node's key.
 The right subtree of a node contains only nodes with keys greater than the node's key.
 Both the left and right subtrees must also be binary search trees.
 
 """"""
 
 import math
 
 
 class TreeNode:
     """"""
     Definition of binary tree node
     """"""
 
     def __init__(self, val=0, left=None, right=None):
         self.val = val
         self.left = left
         self.right = right
 
 
 def createTree(i: int, arr: list) -> TreeNode:
     node = TreeNode(arr[i])
     left_child = 2 * i + 1
     right_child = 2 * i + 2
     if left_child < len(arr) and arr[left_child] is not None:
         node.left = createTree(left_child, arr)
     if right_child < len(arr) and arr[right_child] is not None:
         node.right = createTree(right_child, arr)
     return node
 
 
 def isValidBST(root: TreeNode) -> bool:
     return explore(root, -math.inf, math.inf)
 
 
 def explore(node: TreeNode, mini: int, maxi: int) -> bool:
     """"""
     Explores the tree (Depth First Search)
     - Returns False when the node that doesn't satisfy any of the BST properties
     is encountered.
     - Returns True when all the nodes in tree are satisfying BST properties
     and the entire tree has been explored.
 
     # Time complexity : O(N) since we visit each node exactly once.
     # Space complexity : O(N) since we keep up to the entire tree.
     """"""
     if node:
         if node.val <= mini or node.val >= maxi:
             return False
         if not explore(node.left, mini, node.val):
             return False
         if not explore(node.right, node.val, maxi):
             return False
     return True
 
 
 if __name__ == ""__main__"":
     data = []
     for element in input().split():
         if element == 'None':
             data.append(None)
         else:
             data.append(int(element))
     tree = createTree(0, data)
     print(is",Python
"// C++ Program to find Maximum Width of Binary Tree
 
 #include <bits/stdc++.h>
 #include <string.h>
 using namespace std;
 
 struct Node
 {
     int data;
     Node* left;
     Node* right;
 };
 
 // function to create a new Tree Node
 Node* newNode(int val)
 {
     Node* temp = new Node;
     temp->data = val;
     temp->left = NULL;
     temp->right = NULL;
     
     return temp;
 }
 
 // Function to Build Tree
 Node* buildTree(string str)
 {   
     // Corner Case
     if(str.length() == 0 || str[0] == 'N')
             return NULL;
     
     // Creating vector of strings from input 
     // string after spliting by space
     vector<string> v;
     istringstream iss(str);
     for(string str; iss >> str; )
         v.push_back(str);
         
     // Create the root of the tree
     Node* root = newNode(stoi(v[0]));
         
     // Push the root to the queue
     queue<Node*> queue;
     queue.push(root);
         
     // Starting from the second element
     int i = 1;
     while(!queue.empty() && i < v.size()) {
         
         // Get and remove the front of the queue
         Node* currNode = queue.front();
         queue.pop();
             
         // Get the current node's value from the string
         string currVal = v[i];
             
         // If the left child is not null
         if(currVal != ""N"") {
          
             // Create the left child for the current node
             currNode->left = newNode(stoi(currVal));
                 
             // Push it to the queue
             queue.push(currNode->left);
         }
             
         // For the right child
         i++;
         if(i >= v.size())
             break;
         currVal = v[i];
             
         // If the right child is not null
         if(currVal != ""N"") {
                 
             // Create the right child for the current node
             currNode->right = newNode(stoi(currVal));
                 
             // Push it to the queue
          ",C-Plus-Plus
"// C program to find the number of bits to be flipped to convert one number to another
 #include <stdio.h>
 
 /*
 Inorder to compare the individual bits of given the numbers, we can compute the number of
 set bits in thier XOR, as we know that XOR operation yields set bits, only when two same
 bits are XORed.
 */
 int get_num_flips(int n1, int n2)
 {
     int count = 0, n = n1 ^ n2;
 
     // Loop till 'n' becomes zero
     while (n)
     {
         // If the lsb is set, increase the count by 1
         if (n & 1)
             count++;
         // Shift the bits to right by 1.
         n = n >> 1;
     }
 
     return count;
 }
 
 int main()
 {
     int n1, n2;
     printf(""\nEnter the two numbers: "");
     scanf(""%d %d"", &n1, &n2);
 
     printf(""Number of flips required to inter-convert the given numbers is "");
     printf(""%d"", get_num_flips(n1, n2));
     return 0;
 }
 
 /*
 Time Complexity: O(log(n)), where n is the greater of the input number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the two numbers: 12 24
 Number of flips required to inter-convert the given numbers is 2
 */
",C
"/*  DOUBLE ENDED QUEUE
     Double ended queue or dequeue is a special type of queue
     wherein elements can be inserted or deleted from both ends
     i.e front and rear
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 //Declare dequeue with an array arr, front and rear as members
 typedef struct
 {
     int arr[10];
     int front, rear;
 } dequeue;
 dequeue dq;
 
 //to insert an element to the front of double ended queue
 void enqueue_front(int n)
 {
     //If dequeue is not full
     if ((dq.rear + 1) % 10 != dq.front)
     {
         //If dequeue is empty insert as first element
         if (dq.front == -1)
         {
             dq.front = 0;
             dq.rear = 0;
         }
         //decrement front in circular manner and insert
         else
             dq.front = (dq.front + 9) % 10;
         dq.arr[dq.front] = n;
     }
 }
 
 //to insert an element to the rear of double ended queue
 void enqueue_rear(int n)
 {
     if ((dq.rear + 1) % 10 != dq.front)
     {
         if (dq.rear == -1)
         {
             dq.front = 0;
             dq.rear = 0;
         }
         //increment rear in circular manner and insert
         else
             dq.rear = (dq.rear + 1) % 10;
         dq.arr[dq.rear] = n;
     }
 }
 
 //to delete an element and return it from the front of dequeue
 int delete_front()
 {
     int item;
     //If dequeue is empty
     if (dq.front == -1)
         return -1;
     else
     {
         item = dq.arr[dq.front];
         //if there is only one element
         if (dq.front == dq.rear)
         {
             dq.front = -1;
             dq.rear = -1;
         }
         else
             dq.front = (dq.front + 1) % 10;
     }
     return item;
 }
 
 //to delete an element and return it from the rear of dequeue
 int delete_rear()
 {
     int item;
     if (dq.rear == -1)
         return -1;
     else
     {
         item = dq.arr[dq.rear];
         if (dq.front == dq.rear)
         {
             dq.front = -1;
             ",C-Plus-Plus
"/* 
 This program finds the number of binary trees given the length of the preorder sequence = n.
 A tree is an acyclic graph . A binary tree is a tree where each node has 0, 1 or 2 children. 
 Preorder traversal means traversing a tree in the following order : Root - Left child - Right child.  
     
 We use the dynamic programming approach where our root is fixed and the rest of the n-1 nodes
 are split as left and right children. Hence, we calculate the number of binary trees possible
 while exploring splits varying from 0 to n-1.
     
 Time Complexity - O(n^2)
 Space Complexity - O(n)
     
 Note:- The approach is similar to finding the nth catalan number.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 typedef long long int lli;
 
 lli PossibleBinaryTrees(int number)
 {
     lli *table=(lli *)malloc((number+1)*sizeof(lli));
     
     //Since number of trees that can be formed for n=0/1 is 1
     table[0]=1,table[1]=1;    
     
     //Calculating possible number of binary trees for all i<=n and storing them for future use-Tabulation Method
     for(int loop1=2;loop1<=number;loop1++)                      
     {
         table[loop1]=0;
         
         //We loop over the possible splits from 0 to i-1
         for(int loop2=0;loop2<loop1;loop2++)                       
         {
             table[loop1]+=(table[loop2]*table[loop1-loop2-1]);
         }
     }
     
     lli answer=table[number];
     free(table);
     return answer;
 }
 
 //Driver function
 int main()                                                      
 {
     //Enter length of preorder sequence
     int number;                                                 
     cin>>number;
     cout<<PossibleBinaryTrees(number)<<endl;
     return 0;
 }
 /* 
 Sample input:-
 n = 5;
 Output = 42;
 */
",C-Plus-Plus
"/*
 Find the maximum element in Bitonic array
 ==========================================
 A bitonic array is an array of integers which is initially
 increasing and then decreasing.
 An efficient solution to find the maximum element 
 in bitonic array is by using binary search.
 Given an array of integers which is initially increasing
 and then decreasing, find the maximum value in the array.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* This function is used to find maximum 
 element in bitonic array
 */
 int findMax(int arr[],int low,int high){
 	/* Base Case: Only one element is present in arr[low..high]*/
    if (low == high) 
      return arr[low]; 
      
     /* If there are two elements and first is greater then 
       the first element is maximum */
    if ((high == low + 1) && arr[low] >= arr[high]) 
       return arr[low];
 	  
 	/* If there are two elements and second is greater then 
       the second element is maximum */
    if ((high == low + 1) && arr[low] < arr[high]) 
       return arr[high];
 	  
 	int mid = (low + high)/2;   /*low + (high - low)/2;*/
 	/* If we reach a point where arr[mid] is greater than both of 
      its adjacent elements arr[mid-1] and arr[mid+1], then arr[mid] 
      is the maximum element*/
    if ( arr[mid] > arr[mid + 1] && arr[mid] > arr[mid - 1]) 
       return arr[mid]; 
   
     /* If arr[mid] is greater than the next element and smaller than the previous  
     element then maximum lies on left side of mid */
    if (arr[mid] > arr[mid + 1] && arr[mid] < arr[mid - 1]) 
       return findMax(arr, low, mid-1); 
    else /* when arr[mid] is greater than arr[mid-1] and smaller than arr[mid+1] */
       return findMax(arr, mid + 1, high);   
 }
 
 
 //Drivers' Code
 int main()
 {
 	int size;
    cout<<""Enter the size of the Array:"";
 	cin>>size;
 	int arr[size]; //declaring the array 
 	cout<<""Enter the elements of the Array:"";
 	for(int i=0;i<size;i++)
 	  cin>>arr[i];
 	cout<<""The maximum element is: ""<<",C-Plus-Plus
"# Cocktail sort in python
 
 
 def cocktailSort(arr):
     isSwapped = True
     First = 0
     Last = len(arr)-1
     while isSwapped is True:
         # reset isSwapped so that we can use it for this iteration
         isSwapped = False
         # traversing from first to last element
         for i in range(First, Last):
             if arr[i] > arr[i+1]:
                 arr[i], arr[i+1] = arr[i+1], arr[i]
                 isSwapped = True
 
         # if array is already sorted, break the loop
         if isSwapped is False:
             break
 
         isSwapped = False
         # last element is largest so we'll reduce last by one position.
         Last = Last-1
         # iteration from last to first element
         for i in range(Last-1, First-1, -1):
             if arr[i] > arr[i+1]:
                 arr[i], arr[i+1] = arr[i+1], arr[i]
                 isSwapped = True
         # first element is smallest so moving a first one position ahead
         First = First+1
 
 
 # number of elements
 n = int(input(""Enter number of elements : ""))
 arr = list(map(int, input(""\nEnter the numbers : "").strip().split()))[:n]
 cocktailSort(arr)
 print(""Sorted array is: "")
 print(arr)
 
 
 '''output:
 
 Time complexity: O(n*n)
 Space: O(1)
 
 Enter number of elements : 5
 Enter the numbers : 12 4 5 34 2
 Sorted array is:
 [2, 4, 5, 12, 34]
 
 Enter number of elements : 3
 Enter the numbers : 20 14 34
 Sorted array is:
 [14, 20, 34]
 '''
 
",Python
"// check whether a number is Prime or not without recursion
 
 import java.util.Scanner;
 class Prime
 {
     public static void main(String args[])
     {
         Scanner sc=new Scanner(System.in);
         System.out.print(""Enter a number : "");
         int n=(int)Math.abs(sc.nextInt());
         int c=0;
         for(int i=2;i<n;i++)
         if (n%i==0)
         c++;
         System.out.println(n+((c==0)?"" is a Prime Number."" :"" is not a Prime Number.""));
     }
 }
 
 // Contributed By ErzaTitani-2001
 
 /*
 Sample Input and Output :
 Input :
 Enter a number : 13
 Output :
 13 is a Prime Number.
 Space  Complexity : O(1)
 Time Complexity : O(n)
 */
",Java
"/**
 Sorting algorithm that is also called Gravity Sort. It can be visualised as
 beads of an abacus falling under the influence fo gravity with the row having
 the most beads is at the bottom and least is at top.
  */
 import 'dart:io';
 
 enum SortStatus { BEAD, BLANK, NULL }
 // function that implements bead sort
 List beadSort(List arr) {
   // finding max item to decide width of the abacus
   int max = 0;
   for (int item in arr) {
     if (item > max) {
       max = item;
     }
   }
 
   // setting the abacus
   List abacus = List.generate(arr.length, (index) => new List.filled(max, SortStatus.NULL),
       growable: false);
   List level = [];
   for (int i = 0; i < max; i++) {
     level.add(0);
     for (int j = 0; j < arr.length; j++) {
       abacus[j][i] = SortStatus.BLANK;
     }
   }
 
   // adding the beads
   for (int item in arr) {
     for (int j = 0; item > 0; j++, item--) {
       abacus[level[j]++][j] = SortStatus.BEAD;
     }
   }
 
   // counting beads
   for (int i = 0; i < arr.length; i++) {
     int number = 0;
     for (int j = 0;
         j < max && abacus[arr.length - 1 - i][j] == SortStatus.BEAD;
         j++) {
       number++;
     }
     arr[i] = number;
   }
   return arr;
 }
 
 // main function, entry point of the program
 void main() {
   print(""Enter the size of list:"");
   int size = int.parse(stdin.readLineSync()!);
   List arr = [];
   print(""Enter the numbers:"");
   for (int i = 0; i < size; i++) {
     arr.add(int.parse(stdin.readLineSync()!));
   }
   // sorting
   arr = beadSort(arr);
   print(""Sorted list:"");
   for (int i = 0; i < size; i++) {
     print(arr[i]);
   }
 }
 
 /**
 Enter the size of list:
 6
 Enter the numbers:
 5
 0
 2
 1
 4
 3
 Enter number of buckets:
 5
 Sorted list:
 0
 1
 2
 3
 4
 5
 
 Time Complexity: O(n)
 Space Complexity: O(n^2)
  */
",Dart
"/*
 A magic number is a number that reduces to 1 after a sequential operation wherein each step we
 replace the original number by the sum of its digits until the sum reaches a single digit.
 */
 
 import 'dart:io';
 
 // Function to check if number is a Magic Number
 bool isMagicNumber(int num) {
   int sum = num;
 
   // iterate until sum is reduces to single digit
   while(sum > 9){
     int copy = sum;
     sum = 0;
 
     // calculating sum of all  digits
     while(copy > 0){
       int digit = copy % 10;
       sum += digit;
       copy ~/= 10;
     }
   }
   
   if(sum == 1){
     return true;
   }
   return false;
 }
 
 void main() {
   print(""Enter a number :"");
   int num = int.parse(stdin.readLineSync()!);
 
   // Call function to check if number is a Magic number
   if (isMagicNumber(num)) {
     print(""$num is a Magic Number"");
   } else {
     print(""$num is not a Magic Number"");
   }
 }
 
 /**
 Space Complexity O(1)
 Time Complexity  O(nlog(n))
 
 Sample input/output:
 
 Enter a number :
 532
 532 is a Magic Number
 
 Enter a number :
 123
 123 is not a Magic Number
 */
 
",Dart
"/*
    This is a simple program in java language in lucas theorem. Lucas' 
    theorem is a result about binomial coefficients modulo a prime p.
    We will be given three numbers n, r and p and we need to compute 
    value of nCr mod p.
 
 */
 
 import java.util.*;
 
 class lucastheorem{
 
    // minimum return function
    static int min(int x,int y){
 
      if(x<y)
        return x;
      else
        return y;
 
    } 
 
    //computes the nCr % p value
    static int mod(int n,int r,int p){
 
      int[] array = new int[r+1];
      array[0] = 1;
      for(int i=1;i<r+1;i++){
          array[i] = 0;
      }
 
      for(int i=1;i<n+1;i++){
         int j = min(i,r);
         while(j>0){
            array[j] = (array[j]+array[j-1] )%p;
            j--;
         }
      }
 
      return array[r];
 
    }
 
    // lucas theoreme function
    static int lucastheorem(int n,int r,int p){
 
       if(r == 0){
          return 1;
       }  
       int n1 = n % p; 
       int r1 = r % p;            
       return(lucastheorem(n/p,r/p,p) * mod(n1,r1,p)) % p;  
 
    }
 
    // driver method
    public static void main(String[] args){
    
       // taking the input from user from here
       Scanner scan = new Scanner(System.in);
       System.out.print(""Enter The Value of n : ""); 
       int n = scan.nextInt();
    
       System.out.print(""Enter The Value of r : "");
       int r = scan.nextInt();
    
       System.out.print(""Enter The Value of p : "");
       int p  = scan.nextInt();
    
       System.out.print(""Value of nCr % p is "");
       // calling lucastheorem
       System.out.print(lucastheorem(n,r,p));
    }
 
 }
 /*
    Sample I/O :
 
     Enter The Value of n : 10
     Enter The Value of r : 2
     Enter The Value of p : 13
     Value of nCr % p is 6
 
 */
 
",Java
"/*
 Introduction 
 Given an array of strings strs, group the anagrams together. 
 You can return the answer in any order.
 
 An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, 
 typically using all the original letters exactly once.
 
 Argument/Return Type
 Given a vector of strings as input
 return answer as vector of vectors and print the result
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Function to print all the groups of anagrams
 void printGroups(vector<vector<string>>& Groups)
 {
     //Print each group in a new line
     for(auto group : Groups)
     {
         for(auto str : group)
         {
             cout<<str<<"" "";
         }
         cout<<endl;
     }
 }
 
 //Function to group anagrams together and return the result
 vector<vector<string>> groupAnagrams(vector<string>& strings) 
 {
     //Create a vector to store all groups of anagrams
     vector<vector<string>>Groups;
     //Create a map to store group number of each string
     map<string,int>groupNumber;
     
     //Keep count of number of groups
     int NumberOfGroups=0;
     
     //Visit all strings
     for(auto str : strings)
     {
         /* Create a temp string and sort it
         without disturbing original string */
         string temp=str;
         sort(temp.begin(),temp.end());
 
         //If the sorted string doesnot have a group already
         if(groupNumber[temp]==0)
         {
             /* Create a new group of strings
              push the string to the group and 
              push this group to the other groups */ 
             vector<string>group;
             group.push_back(str);
             Groups.push_back(group);
 
             //Increase no.of groups as new group is created
             NumberOfGroups++;
             //Store the group number of this sorted string
             groupNumber[temp]=NumberOfGroups;
         }
         else
         {
             /* If the group which this string belong",C-Plus-Plus
"/*  Trie is also called as 'Prefix Tree'. It is a tree data structure which is commonly used to store the strings/words. 
     The popoular applications of this data stucture are autocomplete and spellcheck.
 
     Problem Statement: 
     Designing a data structure which supports addition of new words and finds if a string matches any previously added string.
         
     Solution:
     1. Define a TrieNode class using a HashMap.
     2. Initialization of root node in Trie Class.
     3. void insert(String word) takes word from user and adds into the Trie.
     4. boolean search(String word) checks if the word entered by user matches to the previously added strings.
 */
 
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Scanner;
 
 //Class to define Trie node operations
 class Trie{
     private TrieNode root;
     public Trie(){
         root = new TrieNode(false);
     }
     //Insertion of word into Trie
     public void insert(String word){
         TrieNode currentnode = root;
         for(char c :word.toCharArray()){
             if(currentnode!=null && !currentnode.nodes.containsKey(c)){
                 TrieNode node = new TrieNode(false);
                 currentnode.nodes.put(c, node);
             }
             currentnode.nodes.get(c);
         }
         currentnode.isEnd = true;
     }
 
     //Searching word in a Trie
     public boolean search(String word){
         TrieNode currentnode = root;
         for(char c : word.toCharArray()){
             if(currentnode!=null && currentnode.nodes.containsKey(c)){
                 currentnode.nodes.get(c);
             } else{
                 return false;
             }
         }
         return currentnode.isEnd;
     }
 
     //Creation of node using Hashmap (stores elements in key/value pairs).
     class TrieNode{
         Map<Character,TrieNode> nodes = new HashMap<>();
         boolean isEnd = false;
         TrieNode(boolean isEnd){
             this.isEnd = isEnd;
         ",Java
"/*
 
 Exponential search is aka doubling or galloping search works on same concept as of Binary Search i.e for a sorted array.
 Algorithm - To find the specific range ( with power of 2 ) & then using binary search technique to find location of search key.
 
 Time Complexity - a) Best Case : O(1) b) Worst Case : O(logi)
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 function exponentialSearch(key) {
   // return it the key is first element of the array
   if (array[0] === key) {
     return console.log(""Found"", array[0]);
   }
 
   // Find range by increasing the power(2) i.e. jumping by 2^i for every iteration
   let i = 1; // as 2^0 = 1
   while (i < array.length && array[i] <= key) i *= 2;
 
   // Pass the range to binary search
   return binarySearch(i / 2, Math.min(i, array.length), key);
 }
 
 // Binary search to find the key in specified range
 function binarySearch(start, end, key) {
   if (start <= end) {
     // Find mid of given range
     let mid = Math.floor(start + (end - start) / 2);
     if (array[mid] === key) return console.log(""Found"", array[mid]);
 
     // Recursively call binary search by changing start/end points of range
     if (array[mid] > key) {
       return binarySearch(start, mid - 1, key);
     } else {
       return binarySearch(mid + 1, end, key);
     }
   } else {
     return console.log(""Not found"");
   }
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered value is number or not
   if (array.includes(NaN)) return console.log(""Only numbers are allowed"");
 }
 
 console.log(""Your ar",JavaScript
"/*
 Quicksort is an efficient sorting algorithm based on divide and conquer strategy.
 Quicksort is an inplace sorting algorithm.
 It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays,
 according to whether they are less than or greater than the pivot.
 The program below is an implementation of quicksort on strings
 */
 
 import java.util.Scanner;
 class quickSort {
     // swap function swaps the elements in arr at position a and b
     void swap(String arr[], int a, int b) {
         String temp = arr[a];
         arr[a] = arr[b];
         arr[b] = temp;
     }
     // divide function partitions the array according to the pivot element
     int divide(String arr[], int left, int right) {
         int loc = left;
         while (left < right) {
             while (arr[loc].compareTo(arr[right]) <= 0 && loc < right) {
                 right = right - 1;
             }
             if (arr[loc].compareTo(arr[right]) > 0) {
                 swap(arr, loc, right);
                 loc = right;
                 left = left + 1;
             }
             while (arr[loc].compareTo(arr[left]) >= 0 && loc > left) {
                 left = left + 1;
             }
             if (arr[loc].compareTo(arr[left]) < 0) {
                 swap(arr, loc, left);
                 loc = left;
                 right = right - 1;
             }
         }
         return loc;
     }
     // QuickSort function sorts the array in lexicographical order
     void QuickSort(String arr[], int first, int last) {
         if (first < last) {
             int p = divide(arr, first, last);
             QuickSort(arr, first, p - 1);
             QuickSort(arr, p + 1, last);
         }
     }
 }
 // Driver Code
 class code {
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""[*] Enter the number of Names in the Array"");
         int n =  sc.nextInt();
         System.ou",Java
"/*
 A Queue is a linear structure which follows a particular order in which the operations are performed.
 The order is First In First Out. The below program reverses a queue using stack data structure.
 Here stack and queue are implemented using linked list.
 */
 
 import java.util.Scanner;
 
 class Stack
 {
     int data;
     Stack next;
 }
 class Queue
 {
     int data;
     Queue next;
 }
 
 class Code{
     static Stack top = null;
     static Queue front = null;
     static Queue rear = null;
     static void push(int n)
     {
         Stack New = new Stack();
         if (top == null)
         {
             top = New;
             top.data = n;
             top.next = null;
         }
         else
         {
             New.next = top;
             top = New;
             top.data = n;
         }
     }
     static int pop()
     {
         if (top != null)
         {
             Stack ptr = top;
             top = top.next;
             return ptr.data;
         }
         return 0;
     }
     static boolean isStackEmpty()
     {
         if (top == null)
         {
             return true;
         }
         return false;
     }
     static boolean isQueueEmpty()
     {
         if (front == null)
         {
             return true;
         }
         return false;
     }
     static void enqueue(int n)
     {
         Queue New = new Queue();
         if (front == null)
         {
             front = New;
             rear = front;
             front.data = n;
             rear.next = null;
         }
         else
         {
             rear.next = New;
             New.data = n;
             rear = New;
             rear.next = null;
         }
     }
     static int dequeue()
     {
         if (front != null)
         {
             Queue ptr = front;
             front = front.next;
             return ptr.data;
         }
         return 0;
     }
     static void printQueue()
     {
         Queue ptr = front;
         while (ptr != nul",Java
"/*
 A subsequence is a sequence that can be derived from another sequence by removing zero or more elements, without 
 changing the order of the remaining elements.
 Example - If we have a string ""Subsequence"" - 
           Then some of the subsequences can be - ""Sbsqnce"" 
                                                  ""bseqen""
                                                  ""quene""
 
 If we have two strings, then a common subsequence is the subsequence which is present in both of the strings
 and the longest among all of them is called Longest Common Subsequence.
 
 In this code we will know how to print the longest common subsequence using dp approach.
 Example - for ""QWERTYHU"" and ""WROPYHUI"" , the output will be ""WRYHU"".
             
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 string longest_common_sub(string str_1, string str_2)
 {
     string s;
     int len_1, len_2; // length of the strings
     len_1 = str_1.length();
     len_2 = str_2.length();
     int dp[len_1 + 1][len_2 + 1]; //dp matrix
 
     //initializing the matrix
     for (int i = 0; i <= len_1; i++)
     {
         dp[i][0] = 0;
     }
     for (int i = 0; i <= len_2; i++)
     {
         dp[0][i] = 0;
     }
 
     /* Filling the matrix int dp[] , where dp[i][j] contains the value of longest common subsequence of the
       strings s1 and s2, where length of s1 is 'i' and that of s2 is 'j';
     */
     for (int i = 1; i <= len_1; i++)
     {
         for (int j = 1; j <= len_2; j++)
         {
             if (str_1[i-1] == str_2[j-1])
             {
                 dp[i][j] = 1 + dp[i - 1][j - 1];
             }
             else
             {
                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
             }
         }
     }
 
     int i, j;
     i = len_1;
     j = len_2;
     /* In this loop, we are traversing the matrix in backward direction and tracing the longest common
     subsequence. 
     */
     while (i >= 1 && j >= 1)
     {
         if (str_1[i-1]",C-Plus-Plus
"/* Monoalphabetic substitution cipher basically replaces each letter of a plaintext by another letter or symbol, depending only on the letter.
    The same plaintext letter is always replaced by the same ciphertext letter and the same letter can be replaced by letter itself.
    Example if a is there we replace it with B to Z and so on for the others.*/
 
 #include<stdio.h>
 #include<string.h>
 
 //this is the encription function
 void monoalphebaticcipher(char input[100],int size){
      
      char output[size-1]; 
      char cipherer[26] = {'Z','Y','X','W','V','U','T','S','R','Q','P','O','N','M','L','K','J','I','H','G','F','E','D','C','B','A'};     
      char list[26] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o','p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};  
      char space = ' ';
      //iterate through input and cipher the plane text as output
      for(int i=0;i<size-1;i++){     
          for(int j=0;j<26;j++){
              if(input[i]==list[j])
                 output[i] = cipherer[j];
              else if( input[i] == space)
                 output[i] = space;    
          } 
      } 
   
      printf(""The Cipher text :"");
      for(int j=0;j<size-1;j++)
          printf(""%c"",output[j]);  
 }
 
 int main(void){
 
      char input[100];
      printf(""Give the plain text here in small letters :"");
      //Taking input from user
      fgets(input,100,stdin);
      int size = strlen(input);
      //calling monoalphabeticcipher
      monoalphebaticcipher(input,size);
      return 0;
 }
 /*
   Sample I/O :
   Give the plain text here in small letters :hello world
   The Cipher text :SVOOL DLIOW
 */
",C
"/*
 Each cell is represented by either
 
 0: Empty cell
 1: Cells have fresh oranges
 2: Cells have rotten oranges
 
 Only a fresh orange adjacent to a rotten one will get rotten after 1 second.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // A struct data type for storing each and every cell index pairs
 struct cell
 {
 	int x, y;
 };
 
 // Checks if the index in consideration is valid or not
 bool isValid(int x, int y, int R, int C)
 {
 	return (x >= 0 && x < R && y >= 0 && y < C);
 }
 
 // Checks if there are still some fresh oranges left
 bool checkall(vector <int> arr[], int R)
 {
 	int C = arr[0].size();
 	for (int i = 0; i < R; i++)
 		for (int j = 0; j < C; j++)
 			if (arr[i][j] == 1)
 				return true;
 	return false;
 }
 
 // A checker to take care of all corner case. In case the matrix is all zero then this checker takes care of such cases
 bool checkzero(vector <int> arr[], int R)
 {
 	int C = arr[0].size();
     for (int i = 0; i < R; i++)
         for (int j = 0; j < C; j++)
             if (arr[i][j] != 0)
                 return false;
     return true;
 }
 
 int rotOranges(vector <int> arr[], int R)
 {
 	queue <cell> q;
 	cell curr;
 	int time = -1, lsize, x, y, i, j;
 	int xindex[] = {1, -1, 0, 0};
 	int yindex[] = {0, 0, 1, -1};
 	int C = arr[0].size();
 	
 	for (i=0; i < R; i++)
 		for (j=0; j < C; j++)
 			if (arr[i][j] == 2)
 				q.push({i, j});
 
 	while (!q.empty())
 	{
 		time++;
 		lsize = q.size();
 		
 		while (lsize--)
 		{
 			curr = q.front();
 			q.pop();
 			
 			for (int i=0; i < 4; i++)
 			{
 				x = curr.x + xindex[i];
 				y = curr.y + yindex[i];
 				
 				if (!isValid(x, y, R, C))
 					continue;
 				
 				if (arr[x][y] == 1)
 				{
 					arr[x][y] = 2;
 					q.push({x, y});
 				}
 			}
 		}
 	}
 	
 	if (checkzero(arr, R))
 		return 0;
 	
 	if (checkall(arr, R))
 		return -1;
 	return time;
 }
 
 int main()
 {
 	int R, C, num;
 	
 	cout << ""Enter number of rows and columns: "";
 	cin >> R >> C;
 	
 	vector <int> a",C-Plus-Plus
"#=Given a posititve number n find all the numbers from 2 to n which 
 are prime and print them. Sieve of Eratosthenes is an optimal approach
 to find the prime numbers.We get an array of length n and if the value
 of array at index i is zero the number i is prime.=#
 
 ## Function 
 
 function primeSieve(n)
     a = zeros(Int64, n + 5)
     for i = 2:n
         if (a[i] == 0)
             for j = (i*i):i:n
                 a[j] = 1
             end
         end
     end
     for i = 2:n
         if (a[i] == 0)
             print(""$(i) "")
         end
     end
 end
 
 ##Input
 
 n = readline()
 n = parse(Int64, n)
 
 #Calling the function
 
 primeSieve(n)
 
 #=
 Sample test case:
 Input:
     n = 20
 Output:
     2 3 5 7 11 13 17 19 
     
 Time complexity: O( N * log(log(N)) )
 =#",Julia
"/* Max Rectangle = finding Max Area Rectangle in Binary Matrix
 
   ALGORITHM:
 * First create a 2D matrix
 * For finding max rectangle 1st find maximum area of histogram
   * maximum area of histogram(MAH):- 1. 1st find nearest smaller element to left(nsl) and nearest smaller element to right(nsr)
                                      2. for width = nsr-nsl-1
                                      3. for area = multiply each element of array with each element of width
                                      4. then find maximum area and return it
 * find max_Rectangle =  for every row find MAH and updated the row every time with add the previous row,
                         if any element of the array is zero then dont add for this specific element and 
                         again find MAH for this updated row and everytime compare previous MAH and updated MAH 
                         which is maximum and stored it.
                           When completed the traverse then we will get the Max Area Rectangle in Binary Matrix.  
 */
 
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //finding Maximum Area of Histogram
 int MAH(int a[], int n)
 {
     int i, ans = 0;
     stack<int> s;
     vector<int> nsl(n), nsr(n);
 
     //finding nearest smaller to left
     for (i = 0; i < n; i++)
     {
         if (s.empty())
             nsl[i] = -1;
         else if (a[s.top()] < a[i])
             nsl[i] = s.top();
         else
         {
             while (!s.empty() && a[s.top()] >= a[i])
                 s.pop();
             if (s.empty())
                 nsl[i] = -1;
             else
                 nsl[i] = s.top();
         }
         s.push(i);
     }
 
     while (!s.empty())
         s.pop();
 
     // finding nearest smaller element to right
     for (i = n - 1; i >= 0; i--)
     {
         if (s.empty())
             nsr[i] = n;
         else if (a[s.top()] < a[i])
             nsr[i] = s.top();
         else
         {
             while (!s.empty(",C-Plus-Plus
"/*
   This program will print Right view of tree by 
   using the concept of level order traversal  
   with some modification
     
 */
 #include <bits/stdc++.h>
 
 using namespace std;
 
 struct node {
   node(int x): data(x), left_child(NULL),
     right_child(NULL) {}
   int data;
   node * left_child;
   node * right_child;
 };
 
 class bin_tree {
   node * root;
   int n = 0;
   public:
     // constructor of tree
     bin_tree() {
       root = NULL;
       n = 0;
     }
   void insert_data(int x) {
     //incrase number of element
     n++;
     //if tree is empty
     if (!root) {
       node * tnode = new node(x);
       root = tnode;
     }
     //if tree if not empty
     else {
       node * temp = root;
       while (1) {
         //if data to be inserted is less then the
         //data of current node
         if (x < temp -> data) {
           //if left child of current node is not 
           //present we simple add new node with 
           //the data to be inserted
           if (!temp -> left_child) {
             node * tnode = new node(x);
             temp -> left_child = tnode;
             break;
           }
           //else we change the current node 
           //pointer with pointer of left child 
           //node pointer
           else
             temp = temp -> left_child;
         }
         //if data to be inserted is grater then 
         //or equal to the data of current node
         else {
           //if right child of current node is not
           //present we simple add new node with 
           //the data to be inserted
           if (!temp -> right_child) {
             node * tnode = new node(x);
             temp -> right_child = tnode;
             break;
           }
           //else we change the current node 
           //pointer with pointer of left child 
           //node pointer
           else
             temp = temp -> right_child;
         }
       }
     }
   }
   int size() {
     return n;
   }
 
   v",C-Plus-Plus
"
 class Queue {
 
         int front, rear;
 	int arr[] = new int[100005];
 
     Queue()
         {
 		front=0;
 		rear=0;
 	}
 	
 	void push(int x)
 	{
 	   arr[rear]=x;
 	   rear++;
 	} 
 
 	int pop()
 	{
 	    if(front==rear){
 	        return -1;
 	    }
 	    int curr=arr[front];
 	    front++;
 	    return curr;
 	}
 
 	int pop()
 	{
 	    if(front==rear){
 	        return -1;
 	    }
 	    int curr=arr[front];
 	    front++;
 	    return curr;
 	} 
         
         int peek()
 	{
 	    if(front==rear){
 	        return arr[front];
 	    }
 	    int curr=arr[rear];
 	    return arr[rear];
 	} 
 }
",Java
"/*
 Matrix is a 2-D Array.
 The transpose of a matrix is formed by turning all the rows of a given matrix into column and vice-versa.
 The code gives output as Transpose of a given matrix.
 */
 #include <stdio.h>
 //Function that computes Transpose of a Matrix
 void transpose(int row, int column, int matrix[row][column])
 {
     //Taking input as number of rows and columns
     printf(""Enter the values in matrix  -->\n"");
     for(int i = 0; i < row; i++)
     for(int j = 0; j < column; j++)
     scanf(""%d"", &matrix[i][j]);
     printf(""Transpose of a matrix is -->\n"");
     for(int i = 0; i < column; i++)
     {   for(int j = 0; j < row; j++)
         {
             //Taking the transpose of a matrix
             printf(""%d\t"", matrix[j][i]);
         }
             printf(""\n"");
     }
 }
 int main()
 {
     int row, column;
     printf(""\nEnter the number of rows in matrix = "");
     scanf(""%d"", &row);
     printf(""\nEnter the number of columns in matrix = "");
     scanf(""%d"", &column);
     int matrix[row][column];
     //call the function that computes the Transpose
     transpose(row, column, matrix);
     }
 
 /*
 
 Sample Output:
 
 Enter the number of rows in matrix = 3
 Enter the number of columns in matrix = 3
 
 Enter the values in matrix  -->
 1   2   3
 4   5   6
 7   8   9
 
 Transpose of a matrix is -->
 1       4       7
 2       5       8
 3       6       9
 
 Time Complexity : O(mn)
 Space Complexity : O(mn)
 where,
        m = number of rows
        n = number of columns
 */
",C
"/**
  * Longest Subarray Having Sum k
  * Given an array of integers, find the length of the longest sub-array 
  * having sum equal to the given value k.
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int LongestSubarraySum(int len, int arr[], int k)
 {
     //Variable to store length of longest subarray with sum k
     int length = INT_MIN;
     //2 pointers indicating current window
     int start = 0, end = 0;
     //store cumulative sum as we traverse the array
     long long sum = 0;
     while (end < len) {
         sum = sum + arr[end];
         //If k is greater than sum then increase the size of current window
         if (sum < k)
             end++;
         //Checking if sum equals k then update length as max of window size and length
         //then increase window size
         else if (sum == k) {
             length = max(length, end - start + 1);
             end++;
         }
         //Check if cumulative sum is more than k then remove element
         //at start of current window until it is greater than k
         else if (sum > k) {
             while (sum > k) {
                 sum = sum - arr[start];
                 start++;
             }
             end++;
         }
     }
 
     return length;
 }
 
 int main()
 {
     //Taking input from user
     int len;
     cout << ""Enter length of array of integers: "";
     cin >> len;
     int arr[len];
     cout << ""Enter array of integers: "";
     for (int i = 0; i < len; i++)
         cin >> arr[i];
     int k;
     cout << ""Enter sum: "";
     cin >> k;
     cout << ""Length of Longest Subarray having Sum "" << k << "": "";
     cout << LongestSubarraySum(len, arr, k);
 }
 
 /*
 	Test Cases:
 
     INPUT:
 	Enter length of array of integers: 8
 	Enter array of integers: 5 4 1 1 1 2 3 1
 	Enter sum: 5
 	OUTPUT:
     Length of Longest Subarray having Sum 5: 4
 
 	INPUT:
 	Enter length of array of integers: 6
     Enter array of integers: -5 8 -14 2 4 12
     Enter sum: -5
 	OUTPUT:
 	Len",C-Plus-Plus
"/*
 
 Author: Mohim Singla
 
 
 C++ program to merge alternate nodes two linked lists.
 */
 
 #include <iostream>
 #include <stdlib.h>
 using namespace std;
 
 //Creating a struct
 struct node{
 int data;
 node *next;
 };
 
 //Function to create linked list
 struct node* create(int n)
 {
 
     struct node* head=NULL;
     struct node* tail=NULL;
     while(n!=0)
     {
         int x;
         cin>>x;
         if (head==NULL)
         {
             node* temp=new node;
             temp->data=x;
             temp->next=NULL;
             head=temp;
             tail=head;
         }
         else
         {
             node* temp=new node;
             temp->data=x;
             temp->next=NULL;
             tail->next=temp;
             tail=temp;
         }
         n--;
     }
     return head;
 }
 struct node* head=NULL;
 struct node* tail=NULL;
 
 //Function to create linked list
 struct node* new_list(int x)
 {
 
         if (head==NULL)
         {
             node* temp=new node;
             temp->data=x;
             temp->next=NULL;
             head=temp;
             tail=head;
         }
         else
         {
             node* temp=new node;
             temp->data=x;
             temp->next=NULL;
             tail->next=temp;
             tail=temp;
         }
 
     return head;
 };
 
 //Create Merged linked list function
 struct node* merge_list(struct node* list1, struct node* list2,int y)
 {
     node* list3=NULL;
     node* temp1=list1;
     node* temp2=list2;
     while(y!=0)
     {
         list3=new_list(temp1->data);
         list3=new_list(temp2->data);
         temp1=temp1->next;
         temp2=temp2->next;
         y--;
     }
     return list3;
 }
 
 //display function to print the linked lists
 void display(struct node* head)
 {
     node* temp=head;
     while(temp!=NULL)
     {
         cout<<temp->data<<""->"";
         temp=temp->next;
     }
     cout<<""NULL""<<endl;
 }
 
 //main starts
 int main()
 {
     cout<<""Enter no. of no",C-Plus-Plus
"{
   ""nbformat"": 4,
   ""nbformat_minor"": 0,
   ""metadata"": {
     ""kernelspec"": {
       ""display_name"": ""Python 3"",
       ""language"": ""python"",
       ""name"": ""python3""
     },
     ""language_info"": {
       ""codemirror_mode"": {
         ""name"": ""ipython"",
         ""version"": 3
       },
       ""file_extension"": "".py"",
       ""mimetype"": ""text/x-python"",
       ""name"": ""python"",
       ""nbconvert_exporter"": ""python"",
       ""pygments_lexer"": ""ipython3"",
       ""version"": ""3.6.8""
     },
     ""colab"": {
       ""name"": ""PCA_example.ipynb"",
       ""provenance"": []
     }
   },
   ""cells"": [
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""ijPhIQgyuE5V"",
         ""colab_type"": ""text""
       },
       ""source"": [
         ""<h2 align=center> Principal Component Analysis</h2>""
       ]
     },
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""5jRnJxNBuE5Y"",
         ""colab_type"": ""text""
       },
       ""source"": [
         ""## IMPORTS and LOADING""
       ]
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""vZ5WqEs8uE5Z"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""%matplotlib inline\n"",
         ""import pandas as pd\n"",
         ""import matplotlib.pyplot as plt\n"",
         ""import numpy as np\n"",
         ""import seaborn as sns""
       ],
       ""execution_count"": null,
       ""outputs"": []
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""k9YifIuNuE5c"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""plt.style.use(\""ggplot\"")\n"",
         ""plt.rcParams[\""figure.figsize\""] = (12,8)""
       ],
       ""execution_count"": null,
       ""outputs"": []
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""P7CvCFf1uE5e"",
         ""colab_type"": ""code"",
         ""colab"": {},
         ""outputId"": ""d7bf5da5-3caf-4fe2-9895-debda083029c""
       },
       ""sour",Python
"/*
 	Question link :https://leetcode.com/problems/cheapest-flights-within-k-stops/
 	
 	There are n cities connected by m flights. 
 	Each flight starts from city u and arrives at v with a price w.
 	Now given all the cities and flights, together with starting city src
  	and the destination dst, 
 	your task is to find the cheapest price from src to dst with up to k stops. 
 	If there is no such route, output -1.
 
 	Example :
 	Input: 
 	n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
 	src = 0, dst = 2, k = 1
 	Output: 200
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int findCheapestPrice(int n, vector<vector<int>> &flights, int src, int dst, int K)
 {
 
     vector<vector<pair<int, int>>> a(n);
     for (vector<int> &f : flights)
         a[f[0]].push_back({f[1], f[2]});
 
     priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
     //We push the distance,source and the number of edges
     pq.push({0, src, K + 1});
 
     while (!pq.empty())
     {
         vector<int> t = pq.top();
         pq.pop();
 
         //get the distance,vertex and number of edges
 
         int u = t[1];
         int distance = t[0];
         int edges = t[2];
 
         //if the destination becomes equal to the vertex we return the  distance
         if (dst == u)
             return distance;
 
         //If we can add any edges
         if (edges > 0)
         {
             //We search all the neighbours and push the distance and vertex level of the neighbour
             for (pair<int, int> &v : a[u])
                 pq.push({distance + v.second, v.first, edges - 1});
         }
     }
     return -1;
 }
 
 int main()
 {
     int n, src, dst, k, temp;
     cin >> n >> src >> dst >> k;
 
     vector<vector<int>> edges(n, vector<int>(3));
 
     for (int i = 0; i < n; i++)
     {
 
         for (int j = 0; j < 3; j++)
         {
             cin >> edges[i][j];
         }
     }
     int price = findCheapestPrice(n, edges, src, dst, k);
     /",C-Plus-Plus
"/**
  * @author omkarlanghe
  * Given a String of length S, reverse the whole string without reversing the individual words in it.
  * Words are separated by dots.
  * 
  * Input:
  * The first line contains T denoting the number of testcases. 
  * T testcases follow. Each case contains a string S containing characters.
  * 
  * Output:
  * For each test case, in a new line, output a single line containing the reversed String.
  * 
  * Example:
  * Input:
  * 2
  * i.like.this.program.very.much
  * pqr.mno
  * 
  * Output:
  * much.very.program.this.like.i
  * mno.pqr
 */
 #include <iostream>
 #include <stack>
 
 int main() {
     int t;
     std::cout << ""Enter test cases : "" << std::endl;
     std::cin >> t;
     while (t--) {
         std::stack<std::string> str_stack;
         std::string str, stack_string;
 
         std::cout << ""Enter the string : "" << std::endl;
         std::cin >> str;
 
         for (int i = 0 ; i < str.size() ; i++) {
             if (str[i] != '.') {
                 stack_string += str[i];
             } else {
                 str_stack.push(stack_string);
                 str_stack.push(""."");
                 stack_string = """";
             }
         }
         str_stack.push(stack_string);
         str = """";
         while (!str_stack.empty()) {
             str += str_stack.top();
             str_stack.pop();
         }
         std::cout << str << std::endl;
     }
     return (0);
 }
",C-Plus-Plus
"/* Stack search is a method to search an element in a stack and return the index at which its found. */
 
 import java.util.*;
 
 public class stack_search{
     
 	public static void main(String[] args) {
 	    
 	    Scanner sc = new Scanner(System.in);
 	    //enter the no of elemnts to be there inside stack
 	    int n = sc.nextInt();
 	    int no;
         Stack <Integer> st = new Stack <Integer> (); 
         for(int i = 1; i <= n; i++) {
         	no = sc.nextInt();
         	st.push(no);
         }
         // Displaying the Stack 
         System.out.println(""The stack is: "" + st); 
          //enter the element to be searched
             int item = sc.nextInt();
         // Checking for the element
             int search = st.search(item);
            System.out.println(item+"" is seached at index=""+(n-search+1));     
     } 
 }
",Java
"""""""Julia program to implement Linear Search algorithm.
 Given an array, Linear Search searches for an element by traversing the entire array once
 and comparing each element with the element to be found out.
 """"""
 
 function linear_search(arr, n, ele)
     # Traverse the entire array once
     for i in 1:n
         if(arr[i] == ele)
             return true
         end
     end
     return false
 end
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""Array is Empty!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())] 
 print(""Which number do you want to search in the array? "")
 ele = readline()
 ele = parse(Int, ele)
 res = linear_search(arr, n, ele)
 if res
     print(""The number $ele is present in the array."")
 else
     print(""The number $ele is not present in the array"")
 end
 
 
 """"""
 Time Complexity - O(n), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 How many numbers are present in the array? 5 
 Enter the numbers: 1 2 3 4 5
 Which number do you want to search in the array? 6
 The number 6 is not present in the array
 
 SAMPLE II
 
 How many numbers are present in the array? 3
 Enter the numbers: 3 1 2
 Which number do you want to search in the array? 2
 The number 2 is present in the array.
 
 """"""
",Julia
"/*KnuthMorrisPratt string-searching algorithm 
 Searches for occurrences of a word W within a main text string S 
 */
 #include <stdio.h>
 #include <string.h>
 
 int Knutt_Morris_Prat(char[], char[]);
 int main()
 {
 	char string[20], matchcase[20];
 	printf(""Enter string: "");
 	gets(string);
 	printf(""Enter substring: "");
 	gets(matchcase);
 	Knutt_Morris_Prat(string, matchcase);
 	return 0;
 }
 
 int Knutt_Morris_Prat(char string[], char matchcase[])
 {
 	int i, j = 0, index;
 	for (i = 0; i < strlen(string) - strlen(matchcase) + 1; i++)
 	{
 		index = i;
 		if (string[i] == matchcase[j]) /*Check if characters match*/
 		{
 			/*Continue checking until the characters match or the end of pattern string is reached*/
 			do {
 				i++;
 				j++;
 			} while (j != strlen(matchcase) && string[i] == matchcase[j]);
 			if (j == strlen(matchcase)) /*if j is equal to pattern length, pattern is found.*/
 			{
 				printf(""Match found from position %d to %d.\n"", index + 1, i);
 				return 0;
 			}
 			else /*if j is not equal to pattern length, move to next character and continue the same steps.*/
 			{
 				i = index + 1;
 				j = 0;
 			}
 		}
 	}
 
 	printf(""No substring match found in the string.\n"");
 	return 0;
 }
 
 /*
 Time Complexity: O(n + m)  - n is the length of string and m is the length of substring
 Space Complexity: O(m) - m is the length of substring
 
 Sample Output
 Enter string: ABCABAABCABAC
 Enter subsring: CAB 
 Match found from position 3 to 5.
 */
 
",C
"/**
  * Count Occurences of Anagrams
  * Cpp Program to find the count of anagrams
  * of an entered word, in an entered text (given that 
  * length of word <= length of text).
  */
 
 #include<bits/stdc++.h>
 
 using namespace std;
 
 //function to count no. of occurences of anagram
 int countAnagrams(string text, string word) {
   //To keep count of anagrams
   int anagramCount = 0;
   int lenOfText = text.length();
   int lenOfWord = word.length();
   //Map to store frequency of each character in word
   map < char, int > wordCharCount;
   for (int i = 0; i < lenOfWord; i++)
     wordCharCount[word[i]]++;
   //To count number of distict character
   int count = wordCharCount.size();
   //To denote 2 pointers one pointing to start of window and other to the end
   int start = 0, end = 0;
   //To obtain value of difference for each subsequent window of size lenOfWord
   while (end < lenOfText) {
 
     wordCharCount[text[end]]--;
     //if occurence of any character reduces to zero then decrease count of distinct character
     if (wordCharCount[text[end]] == 0)
       count--;
     //Window size less than lenOfWord then increase the window size
     if (end - start + 1 < lenOfWord)
       end++;
     //on reaching the window size ,if number of distinct characters equals zero then increment count of anagram
     else if (end - start + 1 == lenOfWord) {
       if (count == 0)
         anagramCount++;
       //compute if character is present in map
       //add last character of current window
       if (wordCharCount.find(text[start]) != wordCharCount.end())
         wordCharCount[text[start]]++;
       //check if only one occurence of a character is present then
       //increment the count for distict characters
       if (wordCharCount[text[start]] == 1)
         count++;
       //slide the window
       start++;
       end++;
     }
   }
   return anagramCount;
 }
 
 int main() {
   //take input from user
   string text, word;
   cout << ""Enter the text string:",C-Plus-Plus
"//C++ Program to calculate Fibonacci numbers without using recursion
 /*
  As we know, Fibonacci(n) = Fibonacci(n-1) + Fibonacci(n-2). Rather than
  storing each value, we will only store the last and second
  last number of the Fibonacci series.
  Initially we will store first and second value
  and run the loop from third place till the number given.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 int Fibonacci(int n)
 {
     int a=1, b=1, sum=0;
 
     for(int i=2; i<n; i++)
     {
         sum = a + b;
         a = b;
         b = sum;
     }
     return sum;
 }
 
 int main()
 {
     int n;
     cout<<""Enter number : "";
     cin>>n;
     cout<<""Fibonacci : ""<<Fibonacci(n);
     return 0;
 }
 
 /*
     Time Complexity : O(n)
     Space Complexity : O(1)
 
     Sample Outputs:
     
     Test Case - 1:
     Enter number : 5
     Fibonacci : 5
 
     Test Case - 2:
     Enter number : 9
     Fibonacci : 34
 
 */
",C-Plus-Plus
"/*
 Minimum Depth Binary Tree
 
 You are provided a binary tree, your task is
 to find the minimum depth of tree, which is the 
 number of nodes along the shortest path from the
 root node down to the nearest leaf node.
 Note that the path must end on a leaf node.
 */
 
 import java.io.*;
 import java.until.*;
  
 //defining a class for storing nodes of tree
 class BTNode 
 {
     int value;
     BTNode left;
     BTNode right;
     BTNode() 
     {}
     BTNode(int value) 
     {
         this.value = value; 
     }
     BTNode(int value, BTNode left, BTNode right) 
     {
         this.value = value;
         this.left = left;
         this.right = right;
     }
 }
 
 class MinimumDepthBT
 {
     //function that calculates the minimum depth
     int minDepth(BTNode root)
     {
         //for no root obviously the depth is zero 
         //because no root
         if(root == null){
             return 0;
         }
 
         //for just leaf node, the depth will be obviously 1,
         //because just one node is present which is the leaf node
         if(root.left == null && root.right)
         {
             return 1;
         }
 
         //if left node is not null, recursively call minDepth to 
         // get leftDepth, else set leftDepth to MAX_VALUE
         int leftDepth = root.left != null ? minDepth(root.left) : Integers.MAX_VALUE;
         
         //if left node is not null, recursively call minDepth to 
         // get leftDepth, else set rightDepth to MAX_VALUE
         int rightDepth = root.right != null ? minDepth(root.right) : Integers.MAX_VALUE;
 
         return 1 + Math.min(leftDepth, rightDepth);
     }
 
     //drivers code.
     public static void main (String[] args) throws IOException
     {
         // Taking input
 	    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
         System.out.println(""Enter the values of nodes for tree : "");
 	    String str = br.readLine();
 
         String ip[] = str.split("" "");
",Java
"// C++ program to find index of zero
 // to be replaced by one to get longest
 // continuous sequence of ones.
 #include <bits/stdc++.h>
 using namespace std;
 
 // Returns index of 0 to be replaced
 // with 1 to get longest continuous
 // sequence of 1s. If there is no 0
 // in array, then it returns -1.
 int maxOnesIndex(bool arr[], int n)
 {
 
 	// To store starting point of
 	// sliding window.
 	int start = 0;
 
 	// To store ending point of
 	// sliding window.
 	int end = 0;
 
 	// Index of zero with maximum number
 	// of ones around it.
 	int maxIndex = -1;
 
 	// Index of last zero element seen
 	int lastInd = -1;
 
 	// Count of ones if zero at index
 	// maxInd is replaced by one.
 	int maxCnt = 0;
 
 	while (end < n) {
 
 		// Keep increasing ending point
 		// of sliding window until one is
 		// present in input array.
 		while (end < n && arr[end]) {
 			end++;
 		}
 
 		// If this is not first zero element
 		// then number of ones obtained by
 		// replacing zero at lastInd is
 		// equal to length of window.
 		// Compare this with maximum number
 		// of ones in a previous window so far.
 		if (maxCnt < end - start && lastInd != -1) {
 			maxCnt = end - start;
 			maxIndex = lastInd;
 		}
 
 		// The new starting point of next window
 		// is from index position next to last
 		// zero which is stored in lastInd.
 		start = lastInd + 1;
 		lastInd = end;
 		end++;
 	}
 
 	// For the case when only one zero is
 	// present in input array and is at
 	// last position.
 	if (maxCnt < end - start && lastInd != -1) {
 		maxCnt = end - start;
 		maxIndex = lastInd;
 	}
 
 	return maxIndex;
 }
 
 // Driver function
 int main()
 {
 	// bool arr[] = {1, 1, 1, 1, 0};
     int i,NoOfElements;
 	int *arr;
 	cout<<""How many elements? Enter the size: "";
 	cin>>NoOfElements;
     if (arr==NULL)
     {
         cout<<""Array is empty"";
         return 1;
     }
     //  store input from user to array
     cout<<""Enter numbers\n"";
     for (int i = 0; i < NoOfElem",C-Plus-Plus
"// Author: Prasad V Patil
 
 /*
    C++ code for Conversion of infix expression to post fix expression.
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 //Function declarations
 
 // Function to convert Infix expression to postfix
 string InfixToPostfix(string expression);
 
 // Function to verify whether an operator has higher precedence over other
 int HasHigherPrecedence(char operator1, char operator2);
 
 // Function to verify whether a character is operator symbol or not.
 bool IsOperator(char C);
 
 // Function to verify whether a character is alphanumeric chanaracter
 //(letter or numeric digit) or not.
 bool IsOperand(char C);
 
 // Function to check whether a char is an opening parenthesis i.e '(' or '{' or '['
 bool IsOpeningParentheses(char C);
 
 // Function to check whether a char is an closing parenthesis i.e ')' or '}' or ']'
 bool IsClosingParentheses(char C);
 
 int main()
 {
 	string expression;
 	cout<<""Enter Infix Expression \n"";
 	getline(cin,expression);
 	string postfix = InfixToPostfix(expression);
 	cout<<""Output = ""<<postfix<<""\n"";
 }
 
 // Function to evaluate Postfix expression and return output
 string InfixToPostfix(string expression)
 {
 	// Declaring a Stack from Standard template library in C++.
 	stack<char> S;
 	string postfix = """"; // Initialize postfix as empty string.
 	for(int i = 0;i< expression.length();i++) {
 
 		// Scanning each character from left.
 		// If character is a delimiter, move on.
 		if(expression[i] == ' ' || expression[i] == ',') continue;
 
 		// Else if character is an operand then just append it in res string
 		else if(IsOperand(expression[i]))
 		{
 			postfix +=expression[i];
 		}
 
 		//If character is operator, check for Higher precedence operator in Stack top
 		//till first opening bracket and pop all such operators
 		//Finally push the current operator on the Stack
 		else if(IsOperator(expression[i]))
 		{
 			while(!S.empty() && !IsOpeningParentheses(S.top())
             		&& HasHighe",C-Plus-Plus
"/* 
 AIM :: To implement Priority Queue (PQ) using Linked List (LL).
 
             WHAT IS PRIORITY QUEUE ?
 A priority queue is an abstract data type that behaves similarly to the normal queue except that each element has some priority, 
 i.e., the element with the highest priority would come first in a priority queue. 
 The priority of the elements in a priority queue will determine the order in which elements are removed from the priority queue.
 
 */
 
 #include <iostream>
 #include <stdlib.h> // for using malloc (DMA)
 using namespace std;
 
 struct node
 {
     int data;          // to store data
     int prior;         // to store priority of data
     struct node *next; // to store next node's pointer
 } * front;             // front pointer of PQ
 typedef struct node PQ;
 
 // prototypes
 void enq();     // for insertion
 void deq();     // for deletion
 void display(); // for display
 
 int main()
 {
     int choice; //for storing the choice of user after viewing the options
     cout << ""\n\t\tPQ IMPLEMENTATION"" << endl;
 
     while (true)
     {
         // give the menu to user
         cout << ""\n1. ENQ\n2. DEQ\n3. DISPLAY\n4. EXIT"" << endl;
         cout << ""Enter your choice :: "";
         cin >> choice;
 
         switch (choice)
         {
         case 1:
             enq();
             break;
 
         case 2:
             deq();
             break;
 
         case 3:
             display();
             break;
 
         case 4:
             cout << ""Exiting..."";
             exit(0);
             break;
 
         default:
             cout << ""Invalid choice :("" << endl;
         }
     }
     return 0;
 }
 
 void enq()
 {
     //creating new node
     PQ *new_node = (PQ *)malloc(sizeof(PQ));
     new_node->next = NULL;
 
     //ask user to enter the data and priority of that data
     cout << ""Enter the data :: "";
     cin >> new_node->data; // storing data into data field of newly created node
 
     cout << ""Enter priority of "" << new_n",C-Plus-Plus
"/*Problem Statement: 
 Two chopsticks in a pair of chopsticks need not be of the same length. 
 A pair of sticks can be used to eat as long as the difference in their length is at most D. 
 The Chef has N sticks in which the ith stick is L[i] units long. 
 A stick can't be part of more than one pair of chopsticks. 
 Help the Chef in pairing up the sticks to form the maximum number of usable pairs of chopsticks. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int pairs(vector<int> v,int diff,int total)
 {
     int res=0;
     for(int i=0;i<total-1;)
     {
         if(v[i+1]-v[i]<=diff)
         {
             res++;
             i+=2;
         }
         else
         {
             i++;
         }
     }
     return res;
 }
 
 int main()
 {
     int total,diff,len;
     vector<int> v;
     cout<<""Enter number of chopsticks and difference respectively: ""<<endl;
     cin>>total>>diff;
     cout<<""Enter length: ""<<endl;
     for(int i=0;i<total;i++)
     {
         cin>>len;
         v.push_back(len);
     }
     sort(v.begin(),v.end());
     cout<<""Maximum pairs of chopsticks: ""<<pairs(v,diff,total)<<endl;
     return 0;
 }
 
 /*
 Example:-
 
 Input:-
 Enter number of chopsticks and diffifference respectively:
 5 2
 Enter length:
 1 3 3 9 4
 
 Output:-
 Maximum pairs of chopsticks: 2
 
 Time Complexity: O(n)
 Space Compplexity: O(n)
 */
 
",C-Plus-Plus
"import 'dart:io';
 
 // Area of a Square
 double square(double a) {
   return a * a;
 }
 
 // Area of a Reactangle
 double rectangle(double l, double b) {
     return l * b;
 }
 
 // Area of a Circle
 double circle(double r, [double PI = 3.14]) {
     return PI * r * r;
 }
 
 // Area of a Triangle
 double triangle(double b, double h) {
     return b * h/2.0;
 }
 
 // Area of a Parallelogram
 double parallelogram(double b, double h) {
     return b * h;
 }
 
 // Area of a Trapezium
 
 double trapezium(double a, double b, double h) {
     return (a+b)*h/2.0;
 }
 
 void main() {
   print(""Enter side of square:"");
   double squareSide = double.parse(stdin.readLineSync()!);
 	print(square(squareSide));
 
   print(""Enter length of rectangle:"");
   double rectL = double.parse(stdin.readLineSync()!);
   print(""Enter breadth of rectangle:"");
   double rectB = double.parse(stdin.readLineSync()!);
   print(rectangle(rectL, rectB));
 
   print(""Enter radius of circle:"");
   double rad = double.parse(stdin.readLineSync()!);
   print(circle(rad));
 
   print(""Enter base of triangle:"");
   double triB = double.parse(stdin.readLineSync()!);
   print(""Enter height of triangle:"");
   double triH = double.parse(stdin.readLineSync()!);
   print(triangle(triB, triH));
 
   print(""Enter base of parallelogram:"");
   double paraB = double.parse(stdin.readLineSync()!);
   print(""Enter height of parallelogram:"");
   double paraH = double.parse(stdin.readLineSync()!);
   print(parallelogram(paraB, paraH));
 
   print(""Enter length of 1st parallel side of trapezium:"");
   double a = double.parse(stdin.readLineSync()!);
   print(""Enter length of 2nd parallel side of trapezium:"");
   double b = double.parse(stdin.readLineSync()!);
   print(""Enter height of trapezium:"");
   double h = double.parse(stdin.readLineSync()!);
   print(trapezium(a, b, h));
 }
 /**
 Time complexity = O(n)
 Space complexity = O(n)
 Sample input/output:-
 Enter side of square:
 2.0
 4.0
 Enter length of rectangle:
 4.1
 E",Dart
"/*
 Vertical order print of binary tree
 ====================================
 Given a binary tree, print it in vertical manner
 eg:
            1
         /    \
        2      3
       / \   /   \
      4   5  6   7
                /  \
               8   9
 Vertical Print:
 4
 2
 1 5 6
 3 8
 7
 9
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 #include <iostream>
 #include<map>
 #include <vector>
 using namespace std;
 
 // Node class
 class node {
 public:
 	int data;
 	node *left = NULL;
 	node *right = NULL;
 
 	node(int d) {
 		data = d;
 	}
 };
 
 // builds tree for pre-order input
 node* buildTree() {
 	int d; cin >> d;
 
 	//  Base Case
 	if (d == -1) {
 		return NULL;
 	}
 
 	node *root = new node(d);
 	root->left = buildTree();
 	root->right = buildTree();
 	return root;
 }
 
 // Recursive function to mark position of nodes
 void markNodes(node* root, int pos, map<int, vector<int>> &mp) {
 
 	if (root == NULL) {
 		return;
 	}
 
 	mp[pos].push_back(root->data);
 	markNodes(root->left, pos - 1, mp);
 	markNodes(root->right, pos + 1, mp);
 }
 
 // prints vertical order
 void verticalPrint(node* root) {
 	map<int, vector<int>> mp;
 	markNodes(root, 0, mp);
 
 	for (auto it : mp) {
 		for (auto x : it.second) {
 			cout << x << "" "";
 		} cout << endl;
 	}
 
 }
 
 // Driver code
 int main() {
 
 	node *root = buildTree();
 	verticalPrint(root);
 }
 
 /*
 Sample Input:
 8 10 1 -1 -1 6 9 -1 -1 7 -1 -1 3 -1 14 -1 13 -1 -1
 
 Sample Output:
 1
 10 9
 8 6
 7 3
 14
 13
 */",C-Plus-Plus
"""""""
 Unbounded Knapsack problem using dp (Unbounded means all the given weights are available in infinite quantity)
 Given weights and their corresponding values,
 We fill knapsack of capacity W to obtain maximum possible value(or profit). We can pick same weight more than once.
 N: Number of (items)weight elements
 W: Capacity of knapsack
 Time Complexity: O(N*W) (Optimizing knapsack at capacities from 0 to W gradually using all N items)
 Space Complexity: O(W) (knapsack array)
 """"""
 
 
 def unbounded_knapsack(capacity, weights, values):
 
     # 'items' variable represents number of weight elements
     items = len(values)
 
     # Initializing 1-d array knapsack values as 0
     knapsack = [0 for x in range(capacity + 1)]
 
     # Iterating to given capacity from 0
     for current_capacity in range(capacity + 1):
 
         # Iterating through all the items
         for i in range(items):
 
             # If the weight of item is less then current_capacity, it can be used in knapsack
             if (weights[i] <= current_capacity):
 
                 knapsack[current_capacity] = max(
                     # Current item is not utilised
                     knapsack[current_capacity],
                     knapsack[current_capacity - weights[i]] + values[i])
                 # Current item is utilised, so knapsack value for current_capacity changes to
                 # value of current item + knapsack value when capacity is current_capacity-weight of utilised item
 
     return knapsack[capacity]
 
 
 if __name__ == '__main__':
 
     print(""Enter capacity:"")
     capacity = int(input())
     print(""Enter weights:"")
     weights = list(map(int, input().split()))
     print(""Enter values:"")
     values = list(map(int, input().split()))
 
     print(unbounded_knapsack(capacity, weights, values))
 
 """"""
 Sample Input:
 capacity = 50
 weights = 1 5 10
 values = 10 50 100
 
 Sample Output:
 500
 """"""
",Python
"/*
 Code to reverse individual words in a sentence without using stacks
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void reverseWord(string s[],int n)
 {
     for(int i=0;i<n;i++)
     {
         reverse(s[i].begin(),s[i].end());
         cout<<s[i]<<"" "";
     }    
 }
 
 //Driver code
 int main()
 {
     int n;
     cout<<""Enter the number of words in a sentence: "";
     cin>>n;
     cout<<""Enter the sentence: "";
     string st[n];
     for(int i=0;i<n;i++)
     {
         cin>>st[i];
     }
     cout<<""\nSentence with each word reversed: "";
     reverseWord(st,n);
 }
 
 /*
 Input:
 Enter the number of words in a sentence: 4
 Enter the sentence: India is my country
 
 Output:
 Sentence with each word reversed: aidnI si ym yrtnuoc
 
 Time Complexity: O(n)
 
 Space Complexity:O(n)
 */
",C-Plus-Plus
"# =============================================================================
 # Complexity of this algortihm is O(log i)
 # where, i is the position where the element lies or is supposed to lie.
 # This is better than O(log n)
 # where, n is the number of elements in the array.
 # Hence, this is better than Binary Search.
 # =============================================================================
 
 def exponential_search(search_list, left, right, target):
     # just checking for the 0th index individually
     if search_list[0] == target: 
         return ""Found at 0""
     
     # initializing the index to start searching for elements
     i = 1 
     
     # we only check until the index is greater than equal to the element to be found or until it goes beyond the length of the list
     while i < len(search_list) and search_list[i] <= target:
         i *= 2 # index is doubled in each iteration
     index = binary_search(search_list, i//2, min(i, len(search_list)-1), target) 
     return index
     
 # applying binary search within the range where the element could be
 def binary_search(search_list, left, right, target):
     if left > right:
         return ""Not Found!""
     middle = (left + right) // 2
     if search_list[middle] == target:
         return ""Found at "" + str(middle)
     elif search_list[middle] > target:
         return binary_search(search_list, left, middle - 1, target)
     else:
         return binary_search(search_list, middle + 1, right, target)
     
 
 def main():
     search_list = list(map(int, input(""Enter space separated numbers for the list\n"").split()))
     search_value = int(input(""Enter value to search\n""))
     
     print(""Sorted list:"", sorted(search_list))
     print(exponential_search(sorted(search_list), 0, len(search_list)-1, search_value))
     
 main() 
",Python
"'''
 Python Program to get the next nth palindrome of a given number.
 An integer is a palindrome if the reverse of that number is
 equal to the original number.
 '''
 
 
 def isPalindrome(num):
     return str(num) == str(num)[::-1]
 
 
 def getNthPalindrome(n, start):
     if n < 1:
         return start
 
     while not isPalindrome(start + 1):
         start += 1
 
     return getNthPalindrome(n - 1, start + 1)
 
 
 if __name__ == '__main__':
     num = int(input('Enter a Number: '))
     n = int(input('Enter nth position: '))
     print(getNthPalindrome(n, num))
 
 
 '''
 Sample Case:
 Example 1:
 Enter a number: 12021
 Enter nth position: 10
 13031
 
 Example 2:
 Enter a number: 141
 Enter nth position: 5
 191
 
 Time Complexity: O(10^k)
 Space Complexity: O(1)
 where k = no of digits in given number
 '''
",Python
"/*Problem Statement: 
 All the people living in our imaginary world Bitworld are very religious.
 There are N cities in Bitworld numbered from 1 to N.
 Due to a storm, every road in Bitworld was destroyed and now no temples are left.
 There are 2 types of operations :
 
 You can construct a temple by giving away A dollars in ith city.
 You can repair an already existing road by giving away B dollars.
 
 Your goal is to make temples such that people of every city have access to some temple.
 People of the ith city can visit the temple only if :
 A temple exists in that city.
 OR
 There is a path from that city to a city which contains a temple. 
 You have to minimize the total cost such that people in every city can go to a temple and output this minimum cost. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class graph
 {
     public :
     int e,v,cost_temple,cost_road;
     map<int,list<int>> m;
     graph(int edge,int vert, int a , int b)
     {
         e=edge;
         v=vert;
         cost_temple=a;
         cost_road=b;
     } 
     void add(int u,int v)
     {
         m[u].push_back(v);
         m[v].push_back(u);
 
     }
     int dfshelper(int src,bool visited[])
     {
         visited[(int)src]=true;
         int count=1;
         for(auto i : m[(int)src])
         {
             if(!visited[i])
             {
               count+= dfshelper(i,visited);
             }
         }
        return count;
     }
     
     int dfs()
     {
         bool visited[(int)v]={false};
         int count=0;
         int sum=0;
         for(auto i:m)
         {
             /* If cost of making road is less than the temple,
             then make the road */
             if(!visited[(int)i.first])
             {
                 count=dfshelper(i.first,visited);
                 count--;
                 sum+=(count*cost_road + cost_temple);
 
             }
         }
         return sum;
     }
 
 };
 int main() 
 {
     int vertices,edges,cost_temple,cost_",C-Plus-Plus
"class Trienode:
     """"""
     Each node in the Trie will contain the following structure
     """"""
 
     def __init__(self, char):
         self.char = char
         self.wordend = 0
         self.children = [None for i in range(26)]
 
 
 class Trie:
     """"""
     The Trie data structure
     """"""
 
     def __init__(self):
         """"""
         The root will contain a '/' character.
         We may also keep it an empty string, it won't matter.
         """"""
         self.root = Trienode('/')
 
     def insert(self, word):
         """"""
         To insert word in Trie
         """"""
         ptr = self.root
 
         for c in word:
             # This is done for relative indexing of the children array
             idx = ord(c) - ord('a')
 
             if ptr.children[idx] is not None:
                 ptr = ptr.children[idx]
 
             else:
                 ptr.children[idx] = Trienode(c)
                 ptr = ptr.children[idx]
 
         ptr.wordend = 1
 
     def _search(self, word):
         """"""
         Searches if a word is present in the Trie.
         Basically a private function that can be used
         to query or delete results
         """"""
         ptr = self.root
         self.exists = True
 
         for c in word:
             idx = ord(c) - ord('a')
 
             if ptr.children[idx] is not None:
                 ptr = ptr.children[idx]
 
             # Note: In the following lines of code, specific numbers and
             # a pointer is returned just for the convinience to map
             # the types of results returned from the Trie. We may use other
             # numbers or approach as well.
 
             else:
                 # not exists as ptr has no child in that idx, i.e, it's value
                 # is None
                 self.exists = False
                 return (-1, None)
 
         if self.exists:
 
             if ptr.wordend == 1:
                 # exists
                 return (0, ptr)
             else:
             ",Python
"/*Problem Statement:
 You are actually very busy man. You have a big schedule of activities. 
 Your aim is to do as much as activities as possible.
 It is given that, if you go to date with crush, 
 you cannot participate in the coding contest and you cant watch the movie. 
 Also if you play DotA, you cant study for the exam. 
 If you study for the exam you cant sleep peacefully. 
 The maximum number of activities that you can do for this schedule is 3. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 bool compare(pair<int, int> p1, pair<int, int> p2)
 {
     return p1.second < p2.second;
 }
 
 int main()
 {
     int n, s, e;
     vector<pair<int, int> > v;
     cout<<""Enter total number of activities: ""<<endl;
     cin >> n;
     for (int i = 0; i < n; i++)
     {
         cout<<""Enter starting and finishing time of each activity: ""<<endl;
         cin >> s >> e;
         v.push_back(make_pair(s, e));
     }
 
     sort(v.begin(), v.end(), compare);
     int res = 1;
     int fin = v[0].second;
     for (int i = 1; i < n; i++)
     {
         /*If the start time ig greater or equal to the finsh time 
         of the previous activity time */
         if (v[i].first >= fin)
         {
             fin += v[i].second;
             res++;
         }
     }
 
     cout <<""the maximum number of activities you can do are: ""<< res << endl;
     return 0;
 }
 /*Example:
 1)Input:
 Enter total number of activities:
 3
 Enter starting and finishing time of each activity:
 3 9
 Enter starting and finishing time of each activity:
 2 8
 Enter starting and finishing time of each activity:
 6 9
 Output:
 the maximum number of activities you can do are: 1
 Time Complexity: O(nlogn)
 Space Complexity: O(n) 
 */
 
",C-Plus-Plus
"/*
 An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
 
 For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.
 Given an integer array nums, return the number of arithmetic subarrays of nums.
 */
 
 #include<iostream>
 #include<vector>
 
 using namespace std;
 
 //Function takes array and the size of the array as an input, it returns the number of arthemetic slices present in the input array//
 int numberOfArithmeticSlices(int A[],int size) {
     if(size<3) return 0;
     vector<int> res (size,0);
     
     /*
     -> Starting the loop from 2nd element in the array and check for an AP between 1st 2nd and 3rd element.
     -> If AP exists between these elements we check if there is a continuation of this AP from before by checking the previous index of the result Array.
     -> If the previous index is not zero that means it is a coninuation and hence we add the value of the previous index with one.
     -> We make the current value in the result index equal to the previous value + 1.
     -> In case it is not a continuation and the previous value is 0 in the result array we simple add 1 to the current value(0) and the current value becomes 1.
     */
     for(int i = 2;i<size;i++)
     {
         if(A[i]-A[i-1] == A[i-1]-A[i-2])
         {
             if(res[i-1]>0)
             {
                 res[i] = res[i-1]+1;
             }
             else
             {
             res[i]++;
             }
         }
     }
     int ans = 0;
     
     /* Adding the values at all the indices we get the total number of arthemetic slices. */
     for(int i = 0;i<res.size();i++)
     {
         ans = ans+res[i];
     }
     return ans;
 }
 
 
 int main(){
 
     int size = 0;
     
     cout<<""Enter the size of the array- ""<<endl;
     cin>>size;
     int arr[size];
     cout<<""Enter the values inside the array""<<endl;
     for(int i = 0; i<siz",C-Plus-Plus
"/*
 
 A doubly linked list is a linked data structure that consists of a set of sequentially linked records called nodes. Each node contains three fields: two link fields (references to the previous and to the next node in the sequence of nodes) and one data field. 
 The beginning and ending nodes' previous and next links, respectively, point to some kind of terminator, typically a sentinel node or null, to facilitate traversal of the list.
 
 Below, is the implementation of doubly linked list. In this program, user can provide a choice to perform operations on a Doubly Linked List. It is created using a ES6 class syntax. 
 prompt & colors are node packages for taking user input and displaying text in different colors respectively. 
 
 */
 
 const prompt = require(""prompt-sync"")({ sigint: true });
 const colors = require(""colors"");
 
 // Setting the Color schema
 colors.setTheme({
   display: ""green"",
   insert: ""white"",
   delete: ""red"",
   leave: ""yellow"",
   end: ""rainbow"",
   wrong: ""america"",
 });
 
 // Creating the node class to create nodes
 class Node {
   constructor(value, next = null, prev = null) {
     this.value = value, 
     this.next = next, 
     this.prev = prev
   }
 }
 
 // Creating Doubly Linked List class to perform operations 
 class DoublyLinkedList {
   constructor(value) {
     this.head = {
       value: value,
       prev: null,
       next: null,
     };
 
     this.tail = this.head;
     this.length = 1;
   }
 
    // Looping to a given index in doubly Linked List
   traverseToIndex(index) {
     let counter = 1;
     let currentNode = this.head;
 
     while (counter !== index) {
       currentNode = currentNode.next;
       counter++;
     }
 
     return currentNode;
   }
 
   // Case : The very ""first node"" insertion in doubly linked list
   firstNode(value) {
     let newNode = new Node(value);
 
     this.head = newNode;
     this.head.next = null;
     this.head.prev = null;
     this.tail = this.head;
 
     this.length++;
    ",JavaScript
"/*
 SUBLIST SEARCH
     to search if a given sublist is present in a mainList using LinkedList.
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //A linkedlist Node
 typedef struct Node{
 	int data;
 	struct Node* next;
 }Node;
 
 
 Node* getNode(int data){
 	Node* n = new Node;
 	n->data = data;
 	n->next = NULL;
 	return n;
 }
 
 //returns true if the given sublist is found in MainList.
 bool searchSublist(Node* mainList,Node* subList){
 	Node *main = mainList, *sub = subList;
 	//if both the lists are empty, return true.
 	if(main == NULL && sub == NULL)
 		return true;
 	//if one list is empty and other is not return false
 	else if(main == NULL ||(main != NULL && sub == NULL))
 		return false;
 	
 	while(mainList != NULL){
 		main = mainList;
 		//searching for the sublist in mainlist.
 		while(sub != NULL){
 			if(main == NULL)
 				return false;
 			else if(main->data == sub->data){
 				main = main->next;
 				sub = sub->next;
 			}else
 				break;
 		}
 
 		//if the sub list is completely found in Main list, succesful search.
 		if(sub == NULL)
 			return true;
 		sub = subList;
 		mainList = mainList->next;
 	}
 	return false;
 }
 
 Node* insertToList(Node* head,int data){
 	if(head == NULL){
 		head = getNode(data);
 	}else{
 		Node *ptr = head;
 		while(ptr->next != NULL){
 			ptr = ptr->next;
 		}
 		ptr->next = getNode(data);
 	}
 	return head;
 }
 
 int main(){
 	Node *mainHead = NULL,*subHead = NULL;
 	int data,sizeMainlist,sizeSublist;
 	//Input MainList in which search is to be done
 	cout<<""Enter number of elements in Main List: "";
 	cin>>sizeMainlist;
 	cout<<""Enter Main List: "";
 	for(int i=0;i<sizeMainlist;i++){
 		cin>>data;
 		mainHead = insertToList(mainHead,data);
 	}
 	//Input sublist which is to searched for
 	cout<<""Enter number of elements in Sub List: "";
 	cin>>sizeSublist;
 	cout<<""Enter Sub List: "";
 	for(int i=0;i<sizeSublist;i++){
 		cin>>data;
 		subHead = insertToList(subHead,data);
 	}
 
 	//Printing the search result
 ",C-Plus-Plus
"/*
    This program will print ZigZag traversal of tree by using concept of Depth First Search with some modification
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 struct node {
 	node(int x): data(x), left_child(NULL), right_child(NULL) {}
 	int data;
 	node *left_child;
 	node *right_child;
 };
 
 class bin_tree {
 	node *root;
   public:
 	// constructor of tree
 	bin_tree() {
 		root = NULL;
 	}
 	void insert_data(int x) {
 		//if tree is empty
 		if (!root) {
 			node *tnode = new node(x);
 			root = tnode;
 		}
 		//if tree if not empty
 		else {
 			node *temp = root;
 			while (1) {
 				//if data to be inserted is less then the data of current node
 				if (x < temp->data ) {
 					//if left child of current node is node present
 					///we simple add new node with the data to be inserted
 					if (!temp->left_child) {
 						node *tnode = new node(x);
 						temp->left_child = tnode;
 						break;
 					}
 					//else we change the current node pointer 
 					//with pointer of left child node pointer
 					else
 						temp = temp->left_child;
 				}
 				//if data to be inserted is grater then 
 				//or equal to the data of current node
 				else {
 					//if right child of current node is node present 
 					//we simple add new node with the data to be inserted
 					if (!temp->right_child) {
 						node *tnode = new node(x);
 						temp->right_child = tnode;
 						break;
 					}
 					//else we change the current node pointer 
 					//with pointer of left child node pointer
 					else
 						temp = temp->right_child;
 				}
 			}
 		}
 	}
 	void zigzag(node*);
 	void zigzag_traversal_of_tree();
 };
 
 void bin_tree :: zigzag_traversal_of_tree() {
 	zigzag(root);
 }
 
 void bin_tree :: zigzag(node* r) {
 	//if no node is found
 	if (!r)
 		return;
     // declare two stacks to store nodes at current level and next level
 	stack<struct node*> currentlevel; 
     stack<node*> nextlevel; 
   
     // push the root 
     currentlevel.push(root);",C-Plus-Plus
"# Count all triplets such that sum of two elements equals the third element.
 def find_triplets(arr):
     arr.sort()
     count = 0
     ptr_1 = len(arr) - 1
     while ptr_1 >= 2:
         ptr_2 = 0
         ptr_3 = ptr_1 - 1
         while ptr_2 < ptr_3:
             if arr[ptr_1] == arr[ptr_2] + arr[ptr_3]:
                 count += 1
                 ptr_2 += 1
                 ptr_3 -= 1
             elif arr[ptr_1] > arr[ptr_2] + arr[ptr_3]:
                 ptr_2 += 1
             else:
                 ptr_3 -= 1
         ptr_1 -= 1
     return count
 
 # Driver code
 arr = [int(item) for item in input(""Enter the list elements : "").split()]
 print('Total number of found triplets : {}'.format(find_triplets(arr)))
 
 '''
 SAMPLE I/O:
 
 Input: Enter the array elements : 1 4 3 5 7
 Output: Total number of found triplets : 3
 
 Time Complexity : O(n^2)
 '''
",Python
"""""""
 Julia program to find the N'th Lucas Number.
 Lucas Numbers is a sequence similar to Fibonacci numbers and is defined 
 as the sum of its two immediately previous terms.
 The first and second numbers in Lucas sequence are 2 and 1 respectively.
 """"""
 
 function lucas_num(n)
     l1 = 2
     l2 = 1
     if(n == 0)
         return l1
     end
 
     for i in (2:n)
         next = l1 + l2
         l1 = l2
         l2 = next
     end
     return l2
 end
 
 
 print(""Enter the value of n(where you need the nth lucas number): "")
 n = readline()
 n = parse(Int, n)
 if(n < 0)
     print(""Invalid Value of n !!!"")
     exit()
 end
 res = lucas_num(n)
 print(""The $n'th Lucas Number is $res."")
 
 
 """"""
 Time Complexity - O(n), where `n` is the given number.
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the value of n(where you need the nth lucas number): 25
 The 25'th Lucas Number is 167761.
 """"""
",Julia
"public class QuickSort
 {
     private static int partition(int[] array, int low, int high)
     {
         int pivot = array[high];
 
         // index of smaller element 
         int i = (low - 1);
 
         for (int j = low; j < high; j++)
         {
             if (array[j] < pivot)
             {
                 i++;
                 (array[i], array[j]) = (array[j], array[i]);
             }
         }
 
         (array[i + 1], array[high]) = (array[high], array[i + 1]);
 
         return i + 1;
     }
 
     public static void quickSort(int[] array, int low, int high)
     {
         if (low < high)
         {
             int partitioningIndex = partition(array, low, high);
             quickSort(array, low, partitioningIndex - 1);
             quickSort(array, partitioningIndex + 1, high);
         }
     }
 
 
     public static void Sort(int[] array)
     {
         quickSort(array, 0, array.Length - 1);
     }
 }
 
",C-Sharp
"/* C Program to check whether a number is Neon or not.
  A neon number is a number where the sum of digits of square of the number is equal to the number. 
  */
 
 #include <stdio.h>
 #include <math.h>
 void neon(int n)
 {
 	int i, sum = 0, t = 1;
 	t = pow(n, 2);
 	while (t != 0)
 	{
 		sum = sum + (t % 10);
 		t = t / 10;
 	}
 	if (sum == n)
 	{
 		printf(""Neon number.\n"");
 	}
 	else
 	{
 		printf(""Not a neon number\n"");
 	}
 }
 int main()
 {
 	int n;
 	printf(""Enter a number "");
 	scanf(""%d"", &n);
 	neon(n);
 }
 /* Sample Input/output
 Example 1-
 Enter a number 9
 Neon number.
 Example 2-
 Enter a number 144
 Not a neon number
 
 Space Complexity O(1)
 Time Complexity  O(log(n))
 */
",C
"/*
 
  * Dart program to check if a number is a palindrome or not
 
  * A palindromic number is a number that remains the same when its digits are reversed.
 
  */
 
 import 'dart:io';
 
 int isPallindrome(int num) {
   int temp = num;
   int rev = 0;
   /*First reverse the number and then compare it with the given number to check pallindrome*/
   while (temp != 0) {
     int rem = temp % 10;
     rev = rev * 10 + rem;
     temp = (temp / 10).floor();
   }
 
   if (rev == num) {
     print(""The given number is a palindrome number"");
   } else {
     print(""The given number is not a palindrome number"");
   }
 
   return 0;
 }
 
 int main() {
   stdout.write(""Enter the number:  "");
   int num = int.parse(stdin.readLineSync()!);
 
   isPallindrome(num);
 
   return 0;
 }
 
 /*
 
 Time Complexity: O(log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number:  24324
 The given number is not a palindrome number
 
 SAMPLE 2
 
 Enter the number:  73137
 The given number is a palindrome number
 
 */
",Dart
"// C Code for Activity Selection
 //Greedy Algorithm approach
 #include <stdio.h>
 #include <conio.h>
 #include <stdlib.h>
 
 //swap function to check and swap values
 void swap(int *x,int *y)
 {
 	int temp;
 	temp=*x;
 	*x=*y;
 	*y=temp;
 }
 
 //Main function start
 int main()
 {
 	int num,i,j,prev=0,count=1;
 	int *start,*finish;
 	//Dynamic Memory Allocation for arrays
 	start = (int*) malloc(num * sizeof(int));
 	finish = (int*) malloc(num * sizeof(int));
 	//Take number of activites as a input
 	printf(""Enter the number of activities :"");
 	scanf(""%d"",&num);
 	//Take start and finish time as a input
 	printf(""\nEnter the start and finish time of activities :\n"");
 	for(i=0;i<num;i++)
 	{
 		scanf(""%d"",&start[i]);
 		scanf(""%d"",&finish[i]);
 	}
 	//sorting starts here
 	//Bubble sort - compare adjacent element and swap it
 	for(i=0;i<num;i++)
 	{
 		/*In bubble sort, 
 		maximum value is placed at last index
 		In each pass we left the last index i.e num-1-i
                 */
 		for(j=0;j<num-1-i;j++)
 		{
 			if(finish[j]>finish[j+1])
 			{
 				//call swap function
 				//pass by address
 				swap(&finish[j],&finish[j+1]);
 				swap(&start[j],&start[j+1]);
 			}
 		}
 	}
 	/*condition for Activity selection
 	update prev each time
 	with current of start i.e i
 	count variable will see
 	number of activites possible
         */
 	for(i=1;i<num;i++)
 	{
 		if(start[i]>=finish[prev])
 		{
 			count++;
 			prev=i;
 		}
 	}
 	//print the output
 	printf(""\tOUTPUT\n"");
 	printf(""\nTotal number of activities person can perform at a time is -> %d \n"",count);
 	return 0;
 }
 //Main function end 
 
 /*Sample Input Output
 Enter the number of activities : 6
 Enter the start and finish time of activities :
 1 2
 3 4
 2 6
 5 7
 8 9
 5 9
 	OUTPUT
 Total number of activities person can perform at a time is -> 4
 */
 
 /*
 Time Complexity :
 The complexity of this problem is O(n log n) when the list is not sorted.
 When the sorted list is provided the complexity will be O(",C
"#include <bits/stdc++.h>
 using namespace std;
 
 /*
  Factorial is calculated using recursive formula : n! = n * (n-1)!
  Iteratively, it can be calculated by multiplying the current product
  by the next number. Initially current product will be 1.
 */
 int Factorial(int n)
 {
     int prod = 1;
     for(int i=2 ; i<=n ; i++)
     {
         prod *= i;
     }
     return prod;
 }
 
 int main()
 {
     int n;
     cout<<""Enter number : "";
     cin>>n;
     cout<<""Factorial of ""<<n<<"" is : ""<<Factorial(n);
 
     return 0;
 }
 
 /*
     Sample Input-Output:
     Enter number : 5
     Factorial of 5 is : 120
 
     Time Complexity: O(n)
     Space Complexity: O(1)
 */
",C-Plus-Plus
"// C program to reverse the bits of a number
 /*
 Given an integer, reverse its bits in its binary equivalent and 
 print the new number obtained in its decimal form
 */
 
 #include <stdio.h>
 
 /* The code first stores the lsb of the given number in a variable and then left shifts
 the given number and gives this number to the lsb of the answer variable and then right
 shifts it */
 int reverse_bits(int n)
 {
 
     int rev = 0, rem;
 
     // Traverse while there exist bits for the given number
     while (n)
     {
         // Shift the bit of the reversed(answer) number to the right
         rev = rev << 1;
         //Stores the temporary lsb of the given number
         rem = n & 1;
         //Set the lsb of the answer variable with the stored value
         rev = rem | rev;
         //Drops the already processed lsb of the given number
         n = n >> 1;
     }
     return rev;
 }
 
 int main()
 {
     int n, ans;
     printf(""\nEnter the number? "");
     scanf(""%d"", &n);
 
     //Call the function
     ans = reverse_bits(n);
     printf(""The bits-reversed number is: %d"", ans);
     return 0;
 }
 
 /*
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 39
 The bits-reversed number is: 57
 */
",C
"""""""
 Python program to implement Maximum Sum Decreasing Subsequence
 In this problem, given an array we have to find the maximum sum an decreasing subsequence of that array can make.
 This problem is a slight modification to the Longest Decreasing subsequence problem.
 The problem can be solved using Dynamic Programming
 """"""
 
 
 def maximum_sum_decreasing_subsequence(arr, n):
     max_sum = 0
     dp = [0 for i in range(n)]
 
    # Initialize the dp array with the array values, as the maximum sum
    # at each point is atleast as the value at that point
     for i in range(n):
         dp[i] = arr[i]
 
     for i in range(1, n):
         for j in range(i):
             if(arr[i] < arr[j] and dp[i] < dp[j] + arr[i]):
                 dp[i] = dp[j] + arr[i]
 
     # Now Find the maximum element in the dp array
     max_sum = max(dp)
     return max_sum
 
 
 if __name__ == '__main__':
     print(""What is the length of the array? "", end="""")
     n = int(input())
     if (n <= 0):
         print(""No numbers present in the array!!!"")
         exit()
     print(""Enter the numbers: "", end="""")
     arr = [int(x) for x in input().split(' ')]
     res = maximum_sum_decreasing_subsequence(arr, n)
     print(""The maximum sum of an  decreasing subsequence of the given array is {}"".format(res))
 
 
 """"""
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 10
 Enter the numbers: 23 14 5 84 24 222 321 43 123 432
 The maximum sum of an  decreasing subsequence of the given array is 444
 
 SAMPLE 2
 
 What is the length of the array? 5
 Enter the numbers: 5 4 3 2 1
 The maximum sum of an  decreasing subsequence of the given array is 15
 """"""
",Python
"/*
 Given a Number. Find it's Sum of Divisors.
 The Number can be big such as 10^6 to 10^9
 So, If we do this in O(N) we will get Time Limit Exceeded [TLE]
 Better Approach is run a loop till sqrt(Number)
 Example square root of 10^9 is 31622 (approx), so iteration optimized a lot.
 */
 
 #include <stdio.h>
 #include <math.h>
 
 // this get_sum_of_divisors will count the sum of divisors of the number
 long long int get_sum_of_divisors(int Number)
 {
     /* Sum of Divisors may not fit in int range
     so better take long long int */
     long long int sum_of_divisors = 0, i = 0;
     int limit = (int) sqrt(Number);
     for(i = 1; i < limit; i++)
     {
         if(Number % i == 0)
         {
             /* Here i is a divisor of that number
             ( Number / i ) is also a divisor
             */
             sum_of_divisors += i;
             sum_of_divisors += (Number / i);
         }
     }
 
     if(Number % limit == 0)
     {
         if(limit * limit == Number)
         {
             //means perfect square number
             sum_of_divisors += limit;
         }
         else
         {
             sum_of_divisors += limit;
             sum_of_divisors += (Number / limit);
         }
     }
     return sum_of_divisors;
 }
 
 int main()
 {
     printf(""Enter the number : \n"");
     int Number;
     scanf(""%lld"", &Number);
     long long int sum_of_divisors = get_sum_of_divisors(Number);
     printf(""Sum of Divisors of this Number is : "");
     printf(""%lld\n"", sum_of_divisors);
 }
 
 /*
 
 Standard Input and Output
 Enter the number :
 1000000000
 
 Sum of Divisors of this Number is : 2497558338
 
 Enter the number :
 456723
 Sum of Divisors of this Number is : 681408
 
 Time Complexity : O( sqrt(N) )
 Space Complexity : O( 1 )
 
 */
",C
"""""""
 code for unbounded_binary_search Algorithm:
     Given a function int f(unsigned int x) which takes a non-negative integer x
     as input and returns an integer as output. The function is monotonically increasing
     with respect to value of x, i.e., the value of f(x+1) is greater than f(x) for
     every input x. Find the value n where f() becomes positive for the first time.
     Since f() is monotonically increasing, values of f(n+1), f(n+2),
     must be positive and values of f(n-2), f(n-3), .. must be negative.
 """"""
 
 
 def fun(x):
     if sign_b == '+':
         if sign_c == '+':
             return a * x * x + b * x + c
         else:
             return a * x * x + b * x - c
 
     else:
         if sign_c == '+':
             return a * x * x - b * x + c
         else:
             return a * x * x - b * x - c
 
 
 def findFirstPositive():
     # if first value itself is positive
     if fun(0) > 0:
         return 0
 
     # to get 'high_index' for binary search
     i = 1
     while fun(i) <= 0:
         i = i * 2
 
     # Call binary search
     return binarySearch(i // 2, i)
 
 
 def binarySearch(low_index, high_index):
 
     if high_index >= low_index:
         midPoint = low_index + (high_index - low_index) // 2
 
         if fun(midPoint) > 0 and (midPoint == low_index or fun(midPoint - 1) <= 0):
             return midPoint
 
         if fun(midPoint) <= 0:
             return binarySearch((midPoint + 1), high_index)
 
         else:
             return binarySearch(low_index, (midPoint - 1))
 
     # Return None if there is no positive value in given range
     return None
 
 
 # the main code
 # take the input from user : a, b, c of the equation and signs of b & c
 a, b, c = map(int, input(""please enter three parameters of the equation in order a, b, c : "").split())
 sign_b, sign_c = input(""please enter the signs of the equation + or - in order sign_b, sign_c : "").split()
 
 # calculate the output
 out = findFirstPos",Python
"package main
 
 import (
 	""fmt""
 	""strconv""
 )
 
 // Finds the largest number in an array
 func findLargestNum(array []int) int {
 	largestNum := 0
 
 	for i := 0; i < len(array); i++ {
 		if array[i] > largestNum {
 			largestNum = array[i]
 		}
 	}
 	return largestNum
 }
 
 func radixSort(array []int) []int {
 	largestNum := findLargestNum(array)
 	size := len(array)
 	significantDigit := 1
 	unSorted := make([]int, size, size)
 
 	// Loop until the largest significant digit is reached
 	for largestNum/significantDigit > 0 {
 		strconv.Itoa(significantDigit)
 
 		bucket := [10]int{0}
 
 		for i := 0; i < size; i++ {
 			bucket[(array[i]/significantDigit)%10]++
 		}
 
 		for i := 1; i < 10; i++ {
 			bucket[i] += bucket[i-1]
 		}
 
 		for i := size - 1; i >= 0; i-- {
 			bucket[(array[i]/significantDigit)%10]--
 			unSorted[bucket[(array[i]/significantDigit)%10]] = array[i]
 		}
 
 		for i := 0; i < size; i++ {
 			array[i] = unSorted[i]
 		}
 
 		significantDigit *= 10
 	}
 
 	return array
 }
 
 func main() {
 	unsortedList := []int{14, 10, 9, 18, 20, 5, 2, 7}
 
 	sortedList := radixSort(unsortedList)
 
 	fmt.Println(""\nSorted List:"", sortedList, ""\n"")
 }
 
 /*
 Output -
 Sorted List: [2 5 7 9 10 14 18 20]
 
 Time Complexity:
 	1. O(n*k) in best case
 	2. O(n*k) in average case
 	3. O(n*k) in worst case
 	where n is the number of elements and k is the number of bits required to represent largest element in the array
 
 Space Complexity: O(n+k)
 */
",Go
"class Queue:
     """"""
     Queue implementation using a list. Front of the queue is the first
     elememt and back of the queue is the last element.
     """"""
 
     def __init__(self):
         self._items = []
 
     def __str__(self):
         return f""front --> {self._items} <-- rear""
 
     def __len__(self):
         return len(self._items)
 
     def get_front(self):
         return self._items[0]
 
     def get_rear(self):
         return self._items[-1]
 
     def is_empty(self):
         return len(self._items) == 0
 
     def enqueue(self, item):
         """"""
         Add an element to the rear of the queue.
         """"""
         self._items.append(item)
 
     def dequeue(self):
         """"""
         Remove the element at the end of the front of the queue and return it.
 
         Raises:
             IndexError: If queue is empty.
         """"""
         return self._items.pop(0)
 
 
 if __name__ == ""__main__"":
     q = Queue()
 
     print(f""Initialized : {q}"")
 
     for elm in range(5):
         q.enqueue(elm)
         print(f""Enqueued '{elm}': {q}"")
 
     for _ in range(3):
         q.dequeue()
         print(f""Dequeued    : {q}"")
",Python
"""""""
 Julia program to check if a number is a Strong number or not.
 Strong Number is a number whose sum of the factorial of digits
 is equal to the number itself.
 """"""
 
 # Helper function to return the factorial of a number
 function factorial(num)
     if ( num == 1 || num == 0 )
         return 1
     end
     return num * factorial( num - 1)
 end
 
 """""" Extract each digit of the given number and calculate the sum of the
     factorial of each digit present in the given number""""""
 function strong_number(num)
     temp = num
     sum = 0
     while(temp > 0)
         rem = temp % 10
         sum = sum + factorial(rem)
         temp = temp  10
     end
     return sum
 end
 
 
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 sum = strong_number(num)
 if sum == num
     println(""The given number $num is a Strong Number."")
 else
     println(""The given number $num is not a Strong Number."")
 end
 
 
 """"""
 Time Complexity: O(n*log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 3124
 The given number 3124 is not a Strong Number.
 
 SAMPLE 2
 Enter the number: 145
 The given number 145 is a Strong Number.
 """"""
",Julia
"""""""
 Gnome Sort algorithm implementation in Python3
 
 Introduction:
 
 It is a simple exchange sorting algorithm similar to insertion sort,
 except that it moves an element to its proper place by a series of swaps,
 as in bubble sort. In each iteration the algorithm finds the first place,
 where two adjacent elements are in the wrong order and swaps them.
 Afterwards it compares the swapped element with previous elements and
 swaps them if they are in the wrong order. If adjacent elements are in
 proper order or the end is reached, it starts a new iteration.
 """"""
 
 def gnomeSort(nums):
     for i in range(1, len(nums)):
         while (i != 0 and nums[i] < nums[i - 1]):
             nums[i - 1], nums[i] = nums[i], nums[i - 1]
             i -= 1
 
 user_input = input(""Enter the numbers separated by a comma: "").strip()
 
 # in one line: nums = [int(item) for item in user_input.split(',')]
 nums = user_input.split(',')
 sequence = []
 for item in nums:
     sequence.append(int(item))
 
 gnomeSort(nums)
 
 print(""Sorted nums of numbers using gnome sort method:"", nums)
 
 """"""
 Sample input:
 Enter the numbers separated by a comma: 78,45,67,21,90
 
 Sample output:
 Sorted nums of numbers using gnome sort method: [21, 45, 67, 78, 90]
 
 Best case time complexity: O(n)
 Worst case time complexity: O(n^2)
 Space complexity: O(1)
 """"""
",Python
"/*
 Given a number. find it's smallest prime factor.
 we have to get the smallest factor of that number and
 the smallest factor has to be a prime number.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 bool check_prime(int number)
 {
     /* check whether number is prime or not */
     for(int i = 3; i * i <= number; i += 2)
     {
         if(number % i == 0)
             return false;
     }
     return true;
 }
 
 int get_smallest_prime_factor(int number)
 {
     int get_factor = 0;
     /*
     loop runs till sqrt( number )
     for not getting precision errors
     use i * i <= number
     */
     for(int i = 3 ; i * i <= number; i += 2)
     {
         if(number % i == 0)
         {
             get_factor = 1;
             int prime = check_prime(i);
             if(prime)
             {
                 /* that means the number is smallest prime factor */
                 return i;
             }
         }
     }
     if(!get_factor)
     {
         /*
         that means the number itself it's smallest prime factor.
         Ex : 17
         so we can return the number.
         */
         return number;
     }
 }
 
 int main()
 {
     cout << ""Enter the number : \n"";
     int number;
     cin >> number;
     /*
     if the number is even, we can say that the smallest prime factor
     is 2 for any even number.
     because 2 is prime and it's a factor of
     every even number.
     */
     if(! (number & 1) )
     {
         cout << ""Smallest prime factor for this number is : "" << ""2"" << endl;
     }
     else if(number & 1)
     {
         int smallest_prime_factor = get_smallest_prime_factor(number);
         cout << ""Smallest prime factor for this number is : "" << endl;
         cout << smallest_prime_factor << endl;
     }
 }
 
 /*
 Standard Input and Output
 
 1. Even number
 Enter the number :
 435346
 Smallest prime factor for this number is : 2
 
 2. Odd Number
 Enter the number :
 35345
 Smallest prime factor for this number is :
 5
 ",C-Plus-Plus
"//merge sort using divide and conquer and recursion
 import java.util.Scanner;
 class MergeSortRecursion 
 {
     
     public static void sort(int arr[], int start, int end)
     {
         if(start==end) //base case
         return;
         else
              {
             // Find the mid of the array
            int mid = start + ((end - start) / 2);
  
             // Sort first and second halves
             sort(arr, start, mid);
             sort(arr, mid + 1, end);
             merge(arr,start, mid, end); // Merge the sorted halves
         }
     }
     public static void merge(int arr[], int start, int mid, int end)
     {
         // Find sizes of two subarrays to be merged
         int nL = mid - start + 1; //left size
         int nR = end - mid;     //right size
  
         /* Create temporary arrays */
         int L[] = new int[nL];  //left array
         int R[] = new int[nR]; //right array
  
         /*Copy data to temporary arrays*/
         for (int i = 0; i < nL; ++i)
             L[i] = arr[start + i];
         for (int j = 0; j < nR; ++j)
             R[j] = arr[mid + 1 + j];
         int i = 0, j = 0;
  
         // Initial index of merged subarry array
         int k = start;
         while (i < nL && j < nR) {
             if (L[i] <= R[j]) {
                 arr[k] = L[i];
                 i++;
             }
             else {
                 arr[k] = R[j];
                 j++;
             }
             k++;
         }
  
         /* Copy remaining elements of L[] */
         while (i < nL) {
             arr[k] = L[i];
             i++;
             k++;
         }
  
         /* Copy remaining elements of R[] */
         while (j < nR) {
             arr[k] = R[j];
             j++;
             k++;
         }
     }
     public static void printArray(int arr[])
     {
         int n = arr.length;
         for (int i = 0; i < n; ++i)
             System.out.print(arr[i] + "" "");
         System.out.println();
     }
     public ",Java
"/*
 Binary exponentiation (also known as exponentiation by squaring) is a trick which allows to calculate an using only O(logn) multiplications (instead of O(n) multiplications required by the naive approach).
 */
 
 function binary_expo(a,b,mod)
 {
     //End Result Store Here
     let ans=1;
     while(b>0)
     {
         if(b%2!=0)
         {
             //Making the power even
             ans=((ans%mod)*(a%mod))%mod;
             //Decrease the power by 1
             b--;
         }
         else
         {
             //performing sqaure to reduce the power by 2
             a=((a%mod)*(a%mod))%mod;
             //reducing the power by 2.
             b=b/2;
         }
     }
     return ans;
 }
 console.log(binary_expo(2,3,10000));
 //binary_expo(number 1,number 2, mod) (a^b)%mod
 //Time Complexity = O (log b)",JavaScript
"import java.util.Scanner;
 
 public class RemoveDuplicateElementWithoutExtraSpace{
 
     // Function to remove duplicate elements
     // This function returns new size of modified
     // array.
     static int removeDuplicates(int arr[], int n)
     {
         if (n == 0 || n == 1)
             return n;
 
         // To store index of next unique element
         int j = 0;
 
         // Doing same as done in Method 1
         // Just maintaining another updated index i.e. j
         for (int i = 0; i < n-1; i++)
             if (arr[i] != arr[i+1])
                 arr[j++] = arr[i];
 
         arr[j++] = arr[n-1];
 
         return j;
     }
 
     public static void main (String[] args)
     {
         // taking the input from the user
         Scanner sc = new Scanner(System.in);
         System.out.print(""Enter the length of the array : "");
         int n = sc.nextInt();
         
         int arr[] = new int[n];
         System.out.println(""Enter the values for the array elements : "");
         // taking the values for the array from the user
         for(int i=0; i<n; i++)
         {
             arr[i] = sc.nextInt();
         }
 
         n = removeDuplicates(arr, n);
 
         // Print updated array
         for (int i=0; i<n; i++)
             System.out.print(arr[i]+"" "");
     }
 
 }
 
 /*
 
 Example:
 
 Input: 
 Enter the length of the array : 5
 Enter the values for the array elements : 
 1 1 1 3 4
 
 Output:
 1 3 4
 
 */
",Java
"/**
 Function to sort a list of inputs using Insertion sort technique.
 In every iteration we choose one value and put it at a position after
 comparing it with all the other elements before it in the list.
  */
 import 'dart:io';
 
 // function that implements insertion sort
 List insertionSort(List arr) {
   // this loop runs from 2nd element
   for (int i = 1; i < arr.length; i++) {
     int k = i - 1;
     int temp = arr[i];
     // this loop compares all elements before temp with temp
     // and changes positions
     while (k >= 0 && arr[k] > temp) {
       arr[k + 1] = arr[k];
       k--;
     }
     // after shifting we have one spot for temp, so we place it there
     // and close the loop
     arr[k + 1] = temp;
   }
   return arr;
 }
 
 // main function, entry point of the program
 void main() {
   print(""Enter the size of list:"");
   int size = int.parse(stdin.readLineSync()!);
   List arr = [];
   print(""Enter the numbers:"");
   for (int i = 0; i < size; i++) {
     arr.add(int.parse(stdin.readLineSync()!));
   }
   // sorting
   arr = insertionSort(arr);
   print(""Sorted list:"");
   for (int i = 0; i < size; i++) {
     print(arr[i]);
   }
 }
 
 /**
 Enter the size of list:
 6
 Enter the numbers:
 5
 0
 2
 1
 4
 3
 Sorted list:
 0
 1
 2
 3
 4
 5
 
 Time Complexity: O(n*2)
 Space Complexity: O(1)
  */
",Dart
"/*Problem Statement: 
 You are given a sequence of integers A1,A2,,AN. 
 You may change any number of its elements (possibly zero), 
 obtaining a new sequence of positive integers B1,B2,,BN. 
 Each element of B must be an integer between 2 and 50 (both inclusive).
 Let's define an undirected graph G with N vertices (numbered 1 through N).
 For each pair of different vertices i and j, there is an edge between i and j if and only if Bi and Bj are coprime.
 You should choose the sequence B in such a way that G is a connected graph. 
 The number of elements which need to be changed to obtain B from A should be minimum possible. 
 Find one such sequence B and the minimum required number of changes.
 It can be proven that a solution always exists  
 it is always possible to modify sequence A in such a way that G is connected. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int gcd(int a,int b)
 {
     if(b==0)
     {
         return a;
     }
     else
     {
         return gcd(b,a%b);
     }
 }
 
 bool checkequal(int *arr,int n)
 {
     for(int i=0;i<n;i++)
     {
         if(arr[i]!=arr[i-1])
         {
             return false;
         }
     }
     return true;
 }
 
 int main()
 {
     int vertices;
     cout<<""Enter the total number of vertices in the graph: ""<<endl;
     cin>>vertices;
     int arr[100];
     cout<<""Enter edges: ""<<endl;
     for(int i=0;i<vertices;i++)
     {
         cin>>arr[i];
     }
     list<int> list1;
     for(int i=0;i<vertices;i++)
     {
         list1.push_back(arr[i]);
     }
     vector<int> numbers;
     list<int> list2;
     int ans=0;
     while(!list1.empty())
     {
         numbers.push_back(list1.front());
         list1.pop_front();
         for(int i=0;i<numbers.size();i++)
         {
             while(!list1.empty())
             {
                 int m=list1.front();
                 list1.pop_front();
                 if(gcd(m,numbers[i])==1)
                 {
                     numbers.push_back(m)",C-Plus-Plus
"/*
 Given a Number. Find it's Sum of Divisors.
 The Number can be big such as 10^6 to 10^9
 So, If we do this in O(N) we will get Time Limit Exceeded [TLE]
 Better Approach is run a loop till sqrt(Number)
 Example square root of 10^9 is 31622 (approx), so iteration optimized a lot.
 */
 
 import java.util.Scanner;
 import java.lang.*;
 import java.math.*;
 
 public class SumofDivisors
 {
    //this get_sum_of_divisors will count the sum of divisors of the number
    static long get_sum_of_divisors(long number)
    {
     /* Sum of Divisors may not fit in int range
        so better take long long int */
       long sum_of_divisors = 0, i = 0;
       int limit = (int) Math.sqrt(number);
       for(i = 1; i < limit; i++)
       {
          if(number % i == 0)
          {
             /* Here i is a divisor of that number
             ( Number / i ) is also a divisor
             */
             sum_of_divisors += i;
             sum_of_divisors += (number / i);
          }
       }
 	
 
     if(number % limit == 0)
     {
         if(limit * limit == number)
         {
             //means perfect square number
             sum_of_divisors += limit;
         }
         else
         {
             sum_of_divisors += limit;
             sum_of_divisors += (number / limit);
         }
     }
     return sum_of_divisors;
 	   
    }
 
     public static void main(String args[])  
     {
         Scanner scan = new Scanner(System.in);
 	System.out.print(""Enter the number : \n"");
 	long number = scan.nextLong();
         long sum_of_divisors = get_sum_of_divisors(number);
         
         System.out.print(""Sum of Divisors of this Number is : "");
         System.out.print(sum_of_divisors);
         scan.close();
     }
 }
 /*
 
 Standard Input and Output
 
 Enter the number :
 1000000000
 Sum of Divisors of this Number is : 2497558338
 
 Enter the number :
 456723
 Sum of Divisors of this Number is : 681408
 
 Time Complexity : O( sqrt(N) )
 Space Complexity : O( 1 )
 
 *",Java
"// Golang Program to check whether a given number is an Armstrong number or not
 
 /*
   In recreational number theory, an Armstrong number (also known as narcissistic number)
   is a number that is equal to the sum of its own digits, each raised to the power of
   the total number of digits.
   For example, in the case of 3 digit numbers,
   153 is an Armstrong number as 153 = 1*1*1 + 5*5*5 + 3*3*3
 */
 
 package main
 
 import (
 	""fmt""
 	""strconv""
 )
 
 func main() {
 	// taking an 'n' digit number as input
 	var number int
 	fmt.Print(""\n Enter a number : "")
 	fmt.Scan(&number)
 	// displaying results after calling isArmstrong()
 	if isArmstrong(number) {
 		fmt.Printf("" %d is an Armstrong number"", number)
 	} else {
 		fmt.Printf("" %d is NOT an Armstrong number"", number)
 	}
 }
 
 // function to check whether a number is Armstrong or not
 func isArmstrong(number int) bool {
 	sum := 0
 	digit := 0
 	copyNum := number
 	/* getting the number of digits of the integer by
 	   converting it to a string and finding its length */
 	numberOfDigits := len(strconv.Itoa(number))
 	for {
 		// discarding negative integers
 		if copyNum <= 0 {
 			break
 		}
 		temp := 1
 		// extracting last digit
 		digit = copyNum % 10
 		// raising it to the power of number of digits
 		for i := 0; i < numberOfDigits; i++ {
 			temp = temp * digit
 		}
 		// storing the resulting number in sum
 		sum += temp
 		copyNum = copyNum / 10
 	}
 	// returning true if the number is equal to sum
 	return number == sum
 }
 
 /*
 	Time Complexity = O(log(n))
 	Space Complexity = O(1)
 
 	Sample inputs and outputs:
 
 	i/o 1 -
 	 Enter a number: 153
 	 153 is an Armstrong number.
 
 	i/o 1 -
 	 Enter a number: 369
 	 369 is NOT an Armstrong number.
 
 	i/o 3 -
 	 Enter a number: 370
 	 370 is an Armstrong number.
 */
",Go
"/*
 Depth of tree :- we can define depth of tree as total number of levels present in whole tree  tree.
 
 Time Complexity: O(n)
 
 Space Complexity: if tree is perfectly balanced tree O(log n)
 		  if it is not perfectly balanced tree O(n)
 
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 struct node {
     node(int x): data(x), left_child(NULL), right_child(NULL) {}
     int data;
     node *left_child;
     node *right_child;
 };
 
 class bin_tree{
     node *root;
 public:
    // constructor of tree
     bin_tree()
     {
         root = NULL;
     }
     void insert_data(int x){
         //if tree is empty
         if(!root)
         {
             node *tnode = new node(x);
             root = tnode;
         }
         //if tree if not empty
         else
         {
             node *temp =root;
             while(1)
             {
                 //if data to be inserted is less then the data of current node
                 if(x < temp->data )
                 {
                     //if left child of current node is node present we simple add new node with the data to be inserted
                     if(!temp->left_child)
                         {
                             node *tnode = new node(x);
                             temp->left_child = tnode;
                             break;
                         }
                     //else we change the current node pointer with pointer of left child node pointer
                     else
                         temp = temp->left_child;
                 }
                 //if data to be inserted is grater then or equal to the data of current node
                 else
                 {
                     //if right child of current node is node present we simple add new node with the data to be inserted
                     if(!temp->right_child)
                         {
                             node *tnode = new node(x);
                             temp->right_child = tnode;
  ",C-Plus-Plus
"/*
 The traversal operation is a frequently used operation on a binary tree. This operation is used to visit each node in the tree exactly once
 A full traversal on a binary tree gives a linear ordering of data in the tree .  This is the iterative inorder tree traversal algorithms
 */
 #include <bits/stdc++.h>
 
 using namespace std;
 //structure for the binary tree node
 class TreeNode
 {
 public:
     char data;
     TreeNode *left;
     TreeNode *right;
 };
 //structure for stack which is used for the iterative traversal algorithms
 //stack is implemented using linked list
 class Stack
 {
 public:
     TreeNode *node;
     Stack *next;
 };
 //push operation for the stack
 void push(Stack **s, TreeNode *node)
 {
     Stack *New = new Stack();
     New->node = node;
     New->next = (*s);
     (*s) = New;
 }
 // pop operation for the stack
 TreeNode *pop(Stack **s)
 {
     if ((*s) != NULL)
     {
         TreeNode *ptr = (*s)->node;
         (*s) = (*s)->next;
         return ptr;
     }
 }
 //checks whether the stack is empty or not
 int isEmpty(Stack **s)
 {
     if ((*s) == NULL)
     {
         return 1;
     }
     return 0;
 }
 //iterative inorder traversal
 void inorder(TreeNode *root)
 {
     TreeNode *ptr = root;
     Stack *s = NULL;
     while (!isEmpty(&s) || ptr != NULL)
     {
         if (ptr != NULL)
         {
             push(&s, ptr);
             ptr = ptr->left;
         }
         else
         {
             ptr = pop(&s);
             cout << ptr->data << "" "";
             ptr = ptr->right;
         }
     }
 }
 //search function returns the pointer to the node which contains the value key , it is used in the insertion operation
 TreeNode *search(TreeNode *root, int k)
 {
     if (root == NULL)
     {
         return NULL;
     }
     else if (root->data == k)
     {
         return root;
     }
     else
     {
         TreeNode *x = search(root->left, k);
         if (x)
             return x; //if we find in left subtree, return result
",C-Plus-Plus
"/*
 POLYNOMIAL MULTIPLICATION
 Two polynomials are accepted as input from the user
 Each coefficient of first polynomial is multiplied
 with all the terms of second polynomial and
 corresponding exponents are added
 The product so obtained is traversed again
 to find repeating power terms .These terms are
 added and repeating terms are removed to get
 the final product
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 //linked list to store polynomial
 typedef struct Polynomial{
     int coef;
     int exp;
     struct Polynomial* link;
 }Polynomial;
 Polynomial* poly1,*poly2;
 
 //to insert the terms of a polynomial
 Polynomial* insertAtBeginning(Polynomial* list,int co,int ex){
     Polynomial* temp;
     temp=malloc(sizeof(Polynomial));
     temp->coef=co;
     temp->exp=ex;
     temp->link=list->link;
     list->link=temp;
     return list;
 }
 
 //to print the polynomial
 void display(Polynomial* list){
     while(list->link!=NULL){
        list=list->link;
        printf(""%dx^%d"",list->coef,list->exp);
        if(list->link!=NULL)
           printf(""+"");
     }
 }
 
 //to multiply 2 polynomials
 Polynomial* product(Polynomial*a,Polynomial*b){
     Polynomial *pro=malloc(sizeof(Polynomial));
     Polynomial*ptr1=a->link,*ptr2=b->link,*p=pro,*new;
     //to multiply each term of first polynomial with all terms
     //of second polynomial
     while(ptr1!=NULL){
         while(ptr2!=NULL){
             new=malloc(sizeof(Polynomial));
             new->coef=ptr1->coef * ptr2->coef;
             new->exp=ptr1->exp+ptr2->exp;
             p->link=new;
             p=new;
             ptr2=ptr2->link;
         }
         ptr1=ptr1->link;
         ptr2=b->link;
     }
     ptr1=pro->link;
     //to remove repeating terms
     while(ptr1!=NULL){
         ptr2=ptr1;
         while(ptr2->link!=NULL){
             if(ptr1->exp==ptr2->link->exp){
                 p=ptr2->link;
                 ptr1->coef+=ptr2->link->coef;
                 ptr2->link=p->link;
             ",C
"/*
 Boruvkas Algorithm is a greedy algorithm used for finding Minimum Spanning Tree (MST) for
 a connected, weighted, and undirected graph.
 
 The goal of the algorithm is to connect components using the shortest or cheapest edge between
 the components. It begins with all of the vertices considered as separate components.
 Boruvkas algorithm is parallel in nature. It operates in phases. In each phase, it selects
 the cheapest edge from each component, adds all of these to the MST at once, and then contracts
 each connected component into a single component.
 
 We make use of a Union-Find data structure to keep track of the components.
 
 This program takes a connected, weighted, and undirected graph as input and prints the total weight of edges in MST.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 typedef long long ll;
 
 const int N = (int)1e5 + 7;
 
 //a structure which represents a weighted graph edge
 struct edge {
     int v, u, cost;
 };
 
 //global declaration of number of nodes
 int n;
 
 //global declaration of number of edges
 int m;
 
 //global declaration of parent array
 int p[N];
 
 //Array to store the minimum or cheapest outgoing edge for each component of graph
 int min_edge[N];
 
 //Array to store all edges
 edge g[N];
 
 // Function to find root of a certain component for union find algorithm
 int root(int v)
 {
     if (p[v] == v)
         return v;
 
     return (p[v] = root(p[v]));
 }
 
 // Function to perform union two components
 bool merge(int v, int u)
 {
     v = root(v), u = root(u);
     if (v == u)
         return 0;
 
     p[v] = u;
     return 1;
 }
 
 // Function to initialize DSU
 // Initially, all vertices are their own parents
 void init_div()
 {
     for (int i = 1; i <= n; i++) {
         p[i] = i;
     }
 }
 
 //Main function to find MST using Boruvka's algorithm
 void boruvkaAlgorithm()
 {
 
     //Function call to initialize DSU
     init_div();
 
     // No. of components
     int cnt_cmp = n;
 
     //",C-Plus-Plus
"#= This is one of the famous Interview Problems. You are given 
 an array of numbers, treat this array as stone heights. When the rainfalls
 the water get's filled inside the stone gaps. You need to calculate the amount
 of water which will get trapped inside the stones. 
 The code calculates the answer in the best time complexity.
 =#
 
 ## Function
 
 function rainWater(n, array)
     left = zeros(n)
     left[1] = array[1]
     for i = 2:n
         left[i] = max(left[i-1], array[i])
     end
     right = zeros(n)
     right[n] = array[n]
     for i = n-1:-1:1
         right[i] = max(right[i+1], array[i])
     end
     total = 0
     for i = 1:n
         total += min(left[i], right[i]) - array[i]
     end
     return total
 end
 
 ## Input
 
 println(""Enter the length of array!"")
 n = readline()
 n = parse(Int64, n)
 array = Int64[]
 println(""Enter the array !"")
 for i = 1:n
     temp = readline()
     temp = parse(Int64, temp)
     push!(array, temp)
 end
 
 ## Calling the function
 
 rainWater(n, array)
 
 #=
 Sample Test Case:
 Input:
     n = 3
     array = 2 0 2
 Output:
     2
 
 Time complexity: O ( N )
 =#
",Julia
"/* This code is an implementation of Hill Cipher in Go. It
 is a polygraphic substitution cipher. It forms a nxn matrix
 of key and nx1 matrix(s) of the plaintext and then multiplies
 the two matrices to obtains the matrix of ciphertext.*/
 
 package main
 
 import (
 	""fmt""
 	""os""
 	""unicode""
 	""strings""
 )
 
 // Define the size of the n (Globally)
 var n int = 3
 
 /* This function forms the nxn matrix of keyword.
 The value of n can be changed using the global var.*/
 func gen_key_matrix(key string, keymatrix [][]int) {
 
 	var count int = 0
 	for i := 0; i < n; i++ {
 		for j := 0; j < n; j++ {
 			/*Converting ascii to decimal. Here, 
 			a = 97, b = 98 and so on. We want a = 0,
 			b = 1 and so on. So, we subtract 97.*/
 			keymatrix[i][j] = int(key[count]) - 97
 			count += 1
 		}
 	}
 }
 
 /* This function forms the nx1 matrix of the plaintext.
 Value of n can be changed using the global var.*/
 func gen_message_matrix(plaintext string, messagematrix [][]int) {
 
 	var count int = 0
 	for i := 0; i < n; i++ {
 		for j := 0; j < 1; j++ {
 			/*Converting ascii to decimal. As we did above,
 			similarly, we subtract 97 from the decimal value
 			to start indexing from 0.*/
 			messagematrix[i][j] = int(plaintext[count]) - 97
 			count += 1
 		}
 	}
 }
 
 /* This function forms the nx1 ciphertext matrix. The matrix of decimal
 is then converted to ascii value and combined and then returned.*/
 func gen_ciphertext(plaintext, key string, ciphermatrix [][]int) string {
 
 	// Forming the keyword matrix
 	var keymatrix = make([][]int, n)
 	for i := range keymatrix {
 		keymatrix[i] = make([]int, n)
 	}
 	// Calling the keyord matrix function
 	gen_key_matrix(key, keymatrix)
 
 	// Forming the plaintext matrix
 	var messagematrix = make([][]int, n)
 	for i := range messagematrix {
 		messagematrix[i] = make([]int, 1)
 	}
 	// Calling the plaintext matrix function
 	gen_message_matrix(plaintext, messagematrix)
 
 	/* Initializing the ciphertext matrix values to
 	zer",Go
"#include <stdio.h>
 #include <malloc.h>
 
 typedef struct node
 {
     int value;
     struct node *next;
 }node;
 
 node* create_node(int);
 void insert_node_first();
 void insert_node_last();
 void insert_node_pos();
 void count();
 void delete_pos();
 void search();
 void empty();
 void display();
 
 node *newnode, *ptr, *prev, *temp;
 node *first = NULL, *last = NULL;
 
  int main()
  {
     int ch;
     char ans = 'Y';
 
     while (ans == 'Y'||ans == 'y')
     {
         printf(""\n---------------------------------\n"");
         printf(""\nOperations on singly linked list\n"");
         printf(""\n---------------------------------\n"");
         printf(""\n1-Insert node at first"");
         printf(""\n2-Insert node at last"");
         printf(""\n3-Insert node at position"");
         printf(""\n4-Display the total number of nodes"");
         printf(""\n5-Delete Node from any Position"");
         printf(""\n6-Check if list is empty or not"");
         printf(""\n7-Search Element in the linked list"");
         printf(""\n8-Display List from Beginning to end"");
         printf(""\n9-Exit\n"");
         printf(""\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n"");
         printf(""\nEnter your choice : "");
         scanf(""%d"", &ch);
 
         switch (ch)
         {
         case 1:
             printf(""\nInserting node at first :\n"");
             insert_node_first();
             break;
         case 2:
             printf(""\nInserting node at last :\n"");
             insert_node_last();
             break;
         case 3:
             printf(""\nInserting node at position :\n"");
             insert_node_pos();
             break;
         case 4:
             count();
             break;
         case 5:
             delete_pos();
             break;
         case 6:
             printf(""\nchecking the list :\n"");
             empty();
             break;
         case 7:
             printf(""\nSearching Element in the List :\n"");
             search();
             break;
         case 8",C
"/*
 A stack is an Abstract Data Type (ADT), commonly used in most programming languages.This feature makes it LIFO data structure.
 LIFO stands for Last-in-first-out. Here, the element which is placed (inserted or added) last, is accessed first.
 
 The Basic operation in Stack are:
 1.push()  Pushing (storing) an element on the stack.
 2.pop()  Removing (accessing) an element from the stack.
 3.peek()  get the top data element of the stack, without removing it.
 4.display() - used to display the elements
 */
 
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>
 
 struct node
 {
     int data;
     struct node *link;
 };
 
 struct node *top = NULL;
 void push();
 void pop();
 void display();
 
 void push()
 {
     struct node *temp;
     temp = (struct node *)malloc(sizeof(struct node));
     printf(""\n Enter node data:"");
     scanf(""%d"", &temp->data);
     temp->link = top;
     top = temp;
 }
 
 void pop()
 {
     struct node *temp;
     if (top == NULL)
         printf(""No element"");
     else
     {
         temp = top;
         printf(""The deleted element is %d"", temp->data);
         top = top->link;
         temp->link = NULL;
         free(temp);
     }
 }
 
 void display()
 {
     struct node *temp;
     if (top == NULL)
         printf(""\n Stack is empty"");
     else
     {
         temp = top;
         printf(""\nData is"");
         while (temp != NULL)
         {
             printf(""%d "", temp->data);
             temp = temp->link;
         }
     }
 }
 
 void main()
 {
     int choice;
     do
     {
         printf(""\n*****Menu*****\n"");
 	printf(""\n1.Push\n2.Pop\n3.Display\n4.Exit\n""); 
         printf(""Enter your choice:""); 
         scanf(""%d"", &choice);
 	switch (choice)
 	{
 		case 1:
 			push();
 			break;
 		case 2:
 			pop();
 			break;
 		case 3:
 			display();
 			break;
 		case 4:
 			exit(0);
 		default:
 			printf(""Invalid choice"");
 	}
 	}
         while (choice < 5);
         getchar();
 }
 
 /*
 *****MENU****** 
 1.",C
"package main
 
 import (
 	""errors""
 	""fmt""
 	""math/rand""
 )
 
 // A linked list node
 type node struct {
 	data interface{}
 	next *node
 }
 
 type stack struct {
 	top  *node
 	size int
 }
 
 func (obj *stack) isEmpty() bool {
 	return obj.size == 0
 }
 
 // Adds the given element to the beginning of the stack
 func (obj *stack) Push(value interface{}) {
 	obj.top = &node{
 		data: value,
 		next: obj.top,
 	}
 	obj.size++
 }
 
 // Removes the element at the beginning of the stack
 // and returns the element along with an error message
 // if the stack is empty else 'nil'
 func (obj *stack) Pop() (interface{}, error) {
 	if obj.top == nil {
 		return nil, errors.New(""Empty stack"")
 	}
 
 	var data interface{}
 	data, obj.top = obj.top.data, obj.top.next
 	obj.size--
 
 	return data, nil
 }
 
 // Returns a random element to insert in the Stack
 func getElement() interface{} {
 	var temp interface{} = rand.Intn(100)
 	fmt.Println(""Element: "", temp)
 
 	return temp
 }
 
 // Returns the value at the beginning of the stack
 // along with the error message
 func (obj *stack) Peek() (interface{}, error) {
 	if obj.top == nil {
 		return nil, errors.New(""Empty stack"")
 	}
 
 	return obj.top.data, nil
 }
 
 func main() {
 	var object stack
 	var flag bool = true
 	var choice int
 
 	for flag {
 		fmt.Print(""Menu\n1. Push element\n2. Pop element\n3. Peek element\n4. Count of elements\n5. Exit\nEnter your choice: "")
 		fmt.Scan(&choice)
 
 		switch choice {
 		case 1:
 			element := getElement()
 			object.Push(element)
 		case 2:
 			element, err := object.Pop()
 			fmt.Println(""Element: "", element)
 			fmt.Println(""Error: "", err)
 		case 3:
 			element, err := object.Peek()
 			fmt.Println(""Element: "", element)
 			fmt.Println(""Error: "", err)
 		case 4:
 			fmt.Println(""The total number of elements present in the Stack are: "", object.size)
 		case 5:
 			flag = false
 		default:
 			fmt.Println(""Please enter valid choice."")
 		}
 	}
 }
",Go
"/*Check if a given string is a
 palindrome or not using stacks*/
 
 #include<iostream>
 #include<string>
 #include<stack>
 using namespace std;
 
 void CheckPalindrome(string s){
     stack<char> st;
     /*Push each string character onto the stack.
     This stack will have string characters in reverse order
     from top to bottom*/
     for(int i=0; i<s.length(); i++){
         st.push(s[i]);
     }
     bool flag = true;
     /*While traversing the string, take the top element
     from the stack(which will be the last element
     of string) and compare it with string's characters
     starting from s[0].*/
     for(int i=0; i<s.length(); i++){
         char x = st.top();
         /*if characters from stack and string don't match
         then mark flag as false*/
         if(x!=s[i]){
             flag = false;
             break;
         }
         //pop to got the next element of stack
         st.pop();
     }
     if(flag){
         cout<<""'""<<s<<""'""<<"" is a palindrome string""<<endl;
     }
     else{
         cout<<""'""<<s<<""'""<<"" is not a palindrome string""<<endl;
     }
 }
 
 int main(){
    string s;
    cout<<""Enter a string : "";
    cin>>s;
    CheckPalindrome(s);
    return 0;
 }
 
 /* SAMPLE TEST CASES :
 -----------------------------------
 Test 1:
 
 Enter a string : Hello
 'Hello' is not a palindrome string
 -----------------------------------
 Test 2:
 
 Enter a string : abaCaba
 'abaCaba' is a palindrome string
 -----------------------------------
 Time complexity : O(n)
 Space complexity : O(n)
 */
",C-Plus-Plus
"//Given a byte, swap the two nibbles in it. For example 100 is be represented as 01100100 in a byte (or 8 bits).
 //The two nibbles are (0110) and (0100). If we swap the two nibbles, we get 01000110 which is 70 in decimal.
 
 #include <iostream>
 using namespace std;
 int main()
 {
     int swapNibbles(int n);
     int n, result;
     cout << ""Enter a number: "";
     cin >> n;
     result = swapNibbles(n);
     cout << result;
 
     return 0;
 }
 
 int swapNibbles(int n)
 {
     return (((n & 0x0F) << 4) | ((n & 0xF0) >> 4));
 }
 
 /*
 Input:
 Enter a number: 100
 
 Output: 
 70
 
 Time complexity: O(1)
 */",C-Plus-Plus
"/*
 The Catalan numbers form a sequence of natural numbers that occur in various 
 counting problems, often involving recursively-defined objects.
 
 Application in some combinatorial problems:
 1.Number of correct bracket sequence consisting of n opening and n closing brackets.
 2.The number of rooted full binary trees with n+1 leaves (vertices are not numbered). A rooted binary tree is full if every vertex has either two children or no children.
 3.The number of ways to completely parenthesize n+1 factors. 
 */
 
 #include <stdio.h>
 
 int catalan(int num)
 {
 	if (num <= 1)
 	{
 		return 1;
 	}
 
 	int res = 0;
 	for (int i = 0; i < num; i++)
 		res += catalan(i) *catalan(num - i - 1);
 	return res;
 }
 
 int main()
 {
 	int num;
 	printf(""Enter Number: "");
 	scanf(""%d"", &num);
 	printf(""\n"");
 	for (int i = 1; i <= num; i++)
 	{
 		printf(""%d "", catalan(i));
 	}
 
 	return 0;
 }
 
 /*
 Sample input and output
 Enter number: 7
 1 2 5 14 42 132 429
 
 time complexity: O(n^2)
 space complexity: O(n)
 */ 
",C
"/*C code to find the majority element in a given set of string by Boyer-Moore voting algorithm */
 #include <stdio.h>
 #include <stdlib.h>
 #define MAX 100
 struct boyerMajorityCheck
 {
     int majority_number, majority_check;
 }; //declaring a structure for returning two integers in a function
 
 typedef struct boyerMajorityCheck Struct;
 
 //function to find the boyer-moore majority element
 Struct boyerMooreVote(int ar[], int len)
 {
     Struct bmv;
     int i, count = 1;
     int temp = ar[0];
     for (i = 1; i < len - 1; i++)
     {
         if (count == 0)
         {
             temp = ar[i];
             count = 1;
         }
         else
         {
             if (temp == ar[i])
             {
                 count += 1;
             }
             else
             {
                 count -= 1;
             }
         }
         /*algorithm used to find the majoritty number */
     }
     bmv.majority_number = temp;
     int count2 = 0;
     for (i = 0; i < len - 1; i++)
     {
         if (temp == ar[i])
             count2 += 1;
     }
     if (count2 > len / 2)
         bmv.majority_check = 1;
     else
         bmv.majority_check = 0;
     return bmv;
 }
 
 //driver function
 
 int main()
 {
     int arr[MAX], n, i, result;
     printf(""Enter the number of elements:-"");
     scanf(""%d"", &n);
     printf(""Enter the elements :-"");
     for (i = 0; i < n; i++)
     {
         scanf(""%d"", &arr[i]);
     }
     Struct Result = boyerMooreVote(arr, n);
     if (Result.majority_check == 0)
         printf(""The majority number is %d and it's occurance is less than N/2"", Result.majority_number);
     else
     {
         printf(""The majority number is %d and it's count is more than N/2"", Result.majority_number);
     }
     return 0;
 }
 
 /* 
 Time complexity : O(n) where n is the number of elements
 OUTPUT
 Enter the number of elements:-8
 Enter the elements :-3 4 3 5 3 3 7 9
 The majority number is 3 and it's count is more than N/2
 */
",C
"/*
  Huffman Coding is a famous Greedy Algorithm.
  Huffman coding assigns codes to characters such that the length of the code depends on the relative frequency or weight of the corresponding character.
  It is a lossless data compression algorithm which uses a small number of bits to encode common characters.
  A Huffman tree, similar to a binary tree data structure, needs to be created having n leaf nodes and n-1 internal nodes
  Priority Queue/heaps is used for the implmentation.
 
  Time complexity of the Huffman algorithm is O(nlogn).
  Space complexity = O(n)
  
 */
 
 import java.util.Scanner;
 import java.util.Vector;
 import java.util.Comparator;
 
 
 class huffman_node {
 
     int frequency;
 
     char character;
 
     huffman_node left;
     huffman_node right;
 
     huffman_node() {
         frequency = 0;
         character = ' ';
         left = null;
         right = null;
     }
 }
 
 class MyComparator implements Comparator < huffman_node > {
     public int compare(huffman_node x1, huffman_node y1) {
         return x1.frequency - y1.frequency;
     }
 }
 
 class priority_queue {
     
     Vector < huffman_node > v2;
 
 
     public priority_queue(int number1, MyComparator comp1) {
         v2 = new Vector();
     }
 
     int parent(int h) {
         // if i is  root 
         if (h == 0) {
             return 0;
         }
         return (h - 1) / 2;
     }
 }
 
 public class Huffman {
 
     // recursive function to print
     public static void printCode(huffman_node root, String s) {
 
         if (root.left == null && root.right == null &&
             Character.isLetter(root.character)) {
 
             System.out.println(""   "" + root.character + ""      |      "" + root.frequency +
                 ""        |     "" + s);
             return;
         }
 
         // if left add ""0"" 
         printCode(root.left, s + ""0"");
 
         // if right add""1"" 
         printCode(root.right, s + ""1"");
     }
 
   
     public static void main",Java
"/*
 PROBLEM STATEMENT:
 Given an array, arr of size n with elements ranging from 1 to n. In the given array, one number(from 1 to n) is missing and one is repeating.
 For example: for n = 6, given array is 1 6 3 5 1 2, in this array 4 is missing and 1 is repeating.
 The task is to find these repeatng and missing numbers in the array.
 
 APPROACH:
 The approach is to simply use the mathematical formulas for summation of n numbers:
 sum of n elements, sumn = n*(n+1)/2
 and sum of squares of n elements, sumsqn = n*(n+1)*(2*n+1)/6
 Now, let us assume x is the repeating number and y is the missing number
 total denotes the sum of all the numbers present in the array, and totalsq denotes the sum of squares of numbers present in the array.
 Therefore, we get
 sumn = total - x + y, i.e.,
 => x - y = total - sumn ----- (1)
 Also, 
 sumsqn = totalsq - x^2 + y^2
 => sumsqn = totalsq - ((x + y)*(x - y))	
 => sumsqn = totalsq - ((x + y)*(total - sumn))		{using (1)}
 => x + y = (sumsqn - totalsq)/(sumn - total) ----- (2)
 Now, we have two equations and two variables, therfore these equations can easily be solved. The values of x and y are:
 x = (((sumsqn - totalsq)/(sumn - total)) + total - sumn)/2
 y = x - total + sumn
 */
 
 import java.util.Scanner;
 import java.lang.Math;
 class array
 {
 	//function to find repeating and missing number in an array
 	public static void RepMissNum(int[] arr, int n)
 	{
 		// sum of n numbers
 		int sumn = n*(n+1)/2;
 		// sum of numbers present in the array
 		int total = 0;
 		for(int i = 0; i < n; i++){
 			total += arr[i];
 		}
 		// sum of squares of n numbers
 		int sumsqn = n*(n+1)*(2*n+1)/6;
 		int totalsq = 0;
 		// finding sum of squares of numbers present in the array
 		for(int i = 0; i < n; i++){
 			totalsq += Math.pow(arr[i], 2);
 		}
 		// Using formulas mentioned above to find the repeating and missing numbers
 		int rep = (((sumsqn - totalsq)/(sumn - total)) + total - sumn)/2;
 		int miss = rep - total + sumn;
 		System.out.pr",Java
"/* This code is an implementation of factorial in Go using Dynamic 
 Programming. In DP, we follow bottom-up approach to reach to the 
 desired solution. Doing this prevents multiple calls to same function
 input as in the case of recursion.*/
 
 package main
 
 import (
 	""fmt""
 	""os""
 )
 
 // This function takes a number as input and returns its factorial
 func factorial(number int) int {
 
 	// Make an array to store the factorial in a bottom-up manner
 	array := make([]int, number+1)
 	// Set 0! to be 1
 	array[0] = 1
 
 	// Run a loop from 1 to the number
 	for i := 1; i <= number; i++ {
 		array[i] = i * array[i - 1]
 	}
 	// Return the factorial
 	return array[number]
 }
 
 func main() {
 
 	// Take number as input from the user
 	fmt.Print(""Enter a number to calculate its factorial: "")
 	var number int
 	fmt.Scan(&number)
 
 	// If the number is less than 0, return
 	if(number < 0) {
 		fmt.Print(""\nPlease enter a non-negative number."", ""\n"")
 		os.Exit(0)
 	}
 
 	// Call the factorial function and print the factorial
 	var result int = factorial(number)
 	fmt.Print(""\nFactorial of "", number, "" is: "", result, ""\n"")
 }
 
 /*
 Sample I/O:
 
 1)
 Enter a number to calculate its factorial: 11
 
 Factorial of 11 is: 39916800
 
 2)
 Enter a number to calculate its factorial: -32
 
 Please enter a non-negative number.
 
 */
",Go
"import java.util.*;
 class Main {
     public static void main(String args[]) {
         int c = 0;
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter IPv4 address"");
         String s = sc.next();
         for (int i = 0; i < s.length(); i++)
             if (s.charAt(i) == '.')
                 c++;
         s = s.replace(""."", ""[.]"");
         if (c == 3)
             System.out.println(""Defanged IPv4 address : "" + s);
         else
             System.out.println(""Not a valid IPv4 address"");
 
     }
 }
 
 /*
 Sample Input and Output :
 
 Enter IPv4 address
 1.1.1.1
 Defanged IPv4 address : 1[.]1[.]1[.]1
 Enter IPv4 address
 2500.100.50.0
 Defanged IPv4 address : 2500[.]100[.]50[.]0
 Enter IPv4 address
 1.1.1.1.
 Not a valid IPv4 address
 
 Time Complexity: O(n) where n is the length of address
 Space Complexity: O(1)
 */
",Java
"/* Given an array of integers and a an integer k, we are supposed to return an array 
 which contains the first negative integer in every window of size k */
 
 /* Function to calculate the first negative integer in every window of size k */
 const firstNegativeIntegerInEveryWindowOfSizeK = (array, k) => {
 
     let window = [];
 
     /* Generating the initial window */
     for (let i = 0; i < k; i++) {
 
         /* Storing the index if it is a negative number */
         if (array[i] < 0) {
             window.push(i);
         }
     }
 
     /* Answer array */
     let ans = new Array(array.length - k + 1);
 
     /* Storing the answer if there exists a negative number */
     if (window.length > 0) {
         ans[0] = array[window[0]];
     } else {
         ans[0] = 0;
     }
 
     /* Generating k-1 windows */
     for (let i = k; i < array.length; i++) {
 
         /* Removing the indices which are out of bound */
         while (window.length > 0 && window[0] < i - k + 1) {
             window.shift();
         }
 
         /* Storing the index if it is a negative number */
         if (array[i] < 0) {
             window.push(i);
         }
 
         if (window.length > 0) {
             ans[i - k + 1] = array[window[0]];
         } else {
             ans[i - k + 1] = 0;
         }
 
     }
 
     return ans;
 }
 
 //Using the readline() function of JavaScript to take input from the user
 console.log(""Enter the elements of of the array along with the size of the window"");
 
 //list is input array
 let list = readline()
     .split("" "")
     .map((x) => parseInt(x));
 
 // First n elements represent the elements in the array
 let n = list.length-1;
 
 // Last element of the list represents the size of the window k
 let k = list[n];
 
 /* Using list slicing and passing the first n elements to the
  function as the first parameter and k as the second parameter */
 console.log(""Array of first negative integer in every window of size "", k ,"" is "", 
 firstN",JavaScript
"
 /*
 - A page replacement algorithm looks at the limited information about accesses to the pages provided by hardware and tries to guess which pages should be replaced.
 - The simplest page-replacement algorithm is a FIFO algorithm. The first-in, first-out (FIFO) page replacement algorithm is a low-overhead algorithm that requires little bookkeeping on the part of the operating system.
 - In the Least Recently Used (LRU) page replacement policy, the page that is used least recently will be replaced.
 - Optimal Page Replacement algorithm is the best page replacement algorithm as it gives the least number of page faults.
 
 */
 import java.util.*;
 
 class node {
     int d;
     node next;
     //constructor of node class
     node() 
     {
         d = 0;
         next = null;
     }
 }
 class queue {
     node front;
     node rear;
 	
     //default constructor
     queue() 
     {
         front = null;
         rear = null;
     }
     //returns 1 if queue is empty
     public int isEmpty() 
     {
         if (front == null) {
             return 1;
         } else return 0;
     }
     //adds an element of type node in queue
     public void enq(node temp) 
     {
 	//if queue is empty
         if (front == null) 
         {
             rear = temp;
             front = temp;
         } else {
             rear.next = temp;
             rear = temp;
         }
     }
     //deletes an element of type node from the queue
     public node deq() 
     {
         node x = new node();
         if (isEmpty() == 0) {
             if (front == rear) {
                 x = front;
                 front = null;
                 rear = null;
             } else {
                 x = front;
                 front = front.next;
             }
         } else {
             System.out.println(""Queue is empty."");
         }
         return x;
     }
 }
 
 class page {
     int arr[];
     int pf;
     int ph;
     int pno;
     page() {
         arr = new int[5];
       ",Java
"// C  program to count the number of set bits in a number
 #include <stdio.h>
 
 int countNumSetBits(int num)
 {
     int cnt = 0;
     while (num > 0)
     {
         cnt = cnt + (num & 1);
         num = (num >> 1);
     }
     return cnt;
 }
 
 int main()
 {
     int num;
     printf(""Enter the number: "");
     scanf(""%d"", &num);
     int res = countNumSetBits(num);
     printf(""The number of set bits present in the given number is %d"", res);
 }
 
 /*
 Time Complexity: O(log(n)), where n is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the number: 12354
 The number of set bits present in the given number is 4
 
 SAMPLE II
 
 Enter the number: 2048
 The number of set bits present in the given number is 1 
 */
",C
"// Problem Link- https://www.pepcoding.com/resources/online-java-foundation/dynamic-programming-and-greedy/climb-stairs-with-minimum-moves-official/ojquestion
 /* You are given a number n (the number of stairs in a staircase)
  * You are on the 0th step and are required to climb to the top.
  * You are given n numbers, where ith element's value represents till how far from the step you could jump to in a single move.
  * You are required to print the number of minimum moves in which you can reach the top of staircase.
 */
 
 import java.io.*;
 import java.util.*;
 
 public class Main {
 
     public static void main(String[] args) throws Exception {
         Scanner sc = new Scanner(System.in);
         int n = sc.nextInt();
         int[] arr = new int[n];
         for (int i = 0; i < n; i++) {
             arr[i] = sc.nextInt();
         }
         int res = countStairMin(arr);
         System.out.println(res);
     }
 
     public static int countStairMin(int[] arr) {
         // We will use tabulation Method (Bottom Up Dynamic Programming)
         Integer[] dp = new Integer[arr.length + 1];
         // smallest problem is at end (i.e. 0 move)
         dp[arr.length] = 0;
         for (int i = arr.length - 1; i >= 0; i--) {
             // if having more than 0 steps
             if (arr[i] > 0) {
                 int min = Integer.MAX_VALUE;
                 // loop for number of steps
                 for (int j = 1; j <= arr[i] && i + j < dp.length; j++) {
                     // getting minimum of all moves
                     if (dp[i + j] != null) {
                         min = Math.min(min, dp[i + j]);
                     }
                     if (min != Integer.MAX_VALUE) {
                         dp[i] = min + 1;
                     } else {
                         dp[i] = null;
                     }
                 }
             }
         }
         return dp[0];
     }
 }
 
 /*
  * Sample input- 10 3 3 0 2 1 2 4 2 0 0 
  * Sample Output- 4",Java
"/* Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.
    Find the kth positive integer that is missing from this array. */
    
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function that returns the kth positive integer that is missing  */
 int findkthMissing(int arr[],int size,int k){
 	/* We Apply Binary search as the array is already sorted
 	   It can be found that at any given index how many numbers are 
 	   missing.
 	*/
 	int low=0,high=size-1;
 	while(low <= high){
 		int mid=low+(high-low)/2 ; /* to avoid integer overflow */
 		if(arr[mid]-1-mid <= k) 
 		 low=mid+1;
 		else
 		high=mid+1;
 	}
 	/* here low is the first index that gives atleast k missing numbers .
 	   It may have more missing numbers than we need so we are intrested in low-1 */
 	   return low+k; /* kth smallest positive integer   */
 }
 
 int main(){
 	int size,k; 
 	cout<<""Enter the size of Array : "";
 	cin>>size;
 	cout<<""Enter the value of k : "";
 	cin>>k;
 	int arr[size]; 
 	cout<<""Enter the elements of the array :"";
 	for(int i=0;i<size;i++)
 	cin>>arr[i];
 	int kthmissing=findkthMissing(arr, size , k);
 	cout<<""Kth missing number is :"" <<"" ""<<kthmissing<<endl;
 	return 0;
 }
 
 /*
    Test Case 1-
    Input:
    Enter the size of Array : 5
    Enter the value of k : 5
    Enter the elements of the array : 2 3 4 7 11
    Output :Kth missing number is : 9
     
    Test Case 2-
    Enter the size of Array : 4
    Enter the value of k : 2
    Enter the elements of the array : 1 2 3 4
    Output :Kth missing number is : 6
    
    Time Complexity : O(log(size))
    Auxilary Space Complexity : O(1)
    
 */",C-Plus-Plus
"/*
 A number is said to be Magic Number, when the recursive sum of the digits is 1.
 For example 1729
     1+7+2+9=19
     1+9=10
     1+0=1
 So, it comes out be 1. Hence, 1729 is a Magic Number.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // Function for finding Sum of digits of a number.
 int sum_of_digits(int num)
 {
     int sum = 0;
     while (num > 0) {
         int rem = num % 10;
         sum = sum + rem;
         num = num / 10;
     }
     return sum;
 }
 
 // Function to check whether the Number is Magic Number or Not.
 bool is_magic(int num)
 {
     while (num > 9) {
         num = sum_of_digits(num);
     }
     return num == 1;
 }
 
 int main()
 {
     int num;
     cout << ""Enter the Number to check whether it is Magic Number or Not:"" << endl;
     cin >> num;
     if (is_magic(num))
         cout << num << "" is Magic Number."" << endl;
     else
         cout << num << "" is Not Magic Number."" << endl;
     return 0;
 }
 
 /*
 Sample I/0
 
 Input:
 Enter the Number to check whether it is Magic Number or Not:
 1234
 Output:
 1234 is Magic Number.
 
 */
",C-Plus-Plus
"/*
 C program to find the n-th element from Stern's Diatomic Series
 Stern's diatomic series is the sequence which generates the integer sequence that arises
 in the Calkin-Wilf tree. This sequence can be computed by the fusc function.
 */
 #include <stdio.h>
 
 int sterns_diatomic_num(int n)
 {
     if (n == 0)
         return 0;
 
     int dp[n + 1];
     dp[0] = 0;
     dp[1] = 1;
 
     for (int i = 2; i <= n; i++)
     {
         if (i % 2 == 0)
             dp[i] = dp[i / 2];
         else
             dp[i] = dp[(i - 1) / 2] + dp[(i + 1) / 2];
     }
 
     return dp[n];
 }
 
 int main()
 {
     int n;
     printf(""Enter the value of n(where you need the nth Stern's Diatomic number): "");
     scanf(""%d"", &n);
     if (n < 0)
     {
         printf(""Invalid Value of n !!!"");
         return 0;
     }
     int res = sterns_diatomic_num(n);
     printf(""The %d'th Stern's Diatomic is %d"", n, res);
     return 0;
 }
 
 /*
 Time Complexity: O(n), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the value of n(where you need the nth Stern's Diatomic number): 258
 The 258'th Stern's Diatomic is 8.
 
 SAMPLE 2
 Enter the value of n(where you need the nth Stern's Diatomic number): -98
 Invalid Value of n !!!
 
 */
",C
"# Julia program to reverse a number
 
 # Function to reverse a number.
 function reverse(num)
     rev = 0
     while(num > 0)
         # Extract the last digit of num and add it to rev
         rev = rev * 10 + num %10
         num = num  10
     end
     return rev
 end
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 rev = reverse(num)
 println(""The reverse of the given number is $rev."")
 
 
 """"""
 Time Complexity: O(log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 1234
 The reverse of the given number is 4321.
 
 SAMPLE 2
 Enter the number: 785487
 The reverse of the given number is 784587.
 """"""
",Julia
"/*
 Description : Given a Binary Tree and we have to count leaves in it.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // adding base variables
 struct Node
 {
     int data;
     struct Node *left;
     struct Node *right;
 };
 Node *new_node(int val)
 {
     //initializing NULL to left and right node data
     Node *temp = new Node;
     temp->data = val;
     temp->left = NULL;
     temp->right = NULL;
 
     return temp;
 }
 
 //for making a tree like structure
 Node *tree_struct(string str)
 {
     if (str.length() == 0)
     {
         return NULL;
     }
     //for storing the input
     vector<string> ip;
     // for adding space
     istringstream iss(str);
     for (string str; iss >> str;)
     {
         ip.push_back(str);
     }
     //making the root of tree
     Node *root = new_node(stoi(ip[0]));
 
     queue<Node *> queue;
     queue.push(root);
 
     //starting from second data
     int i = 1;
     while (!queue.empty() && i < ip.size())
     {
         Node *currNode = queue.front();
         queue.pop();
 
         string currVal = ip[i];
 
         //if left child is not null
         if (currVal != ""N"")
         {
             //pushing it to queue
             currNode->left = new_node(stoi(currVal));
             queue.push(currNode->left);
         }
         i++;
         //for right child
         if (i >= ip.size())
         {
             break;
         }
         currVal = ip[i];
 
         //checking if it is null or not
         if (currVal != ""N"")
         {
             currNode->right = new_node(stoi(currVal));
             queue.push(currNode->right);
         }
         i++;
     }
     return root;
 }
 
 //function for counting the leaves
 //root reference given
 int sum_leaves(struct Node *root)
 {
     // base case
     if (root == NULL)
     {
         return 0;
     }
     if (root->left == NULL && root->right == NULL)
     {
         return 1;
     }
     //sum of leaves
     else
     {
         return sum_lea",C-Plus-Plus
"/*
 
 Given two strings s and t, return true if they are equal when both are typed into empty text editors.
 '#' means a backspace character.
 
 Input: s = ""ab##"", t = ""c#d#""
 Output: true
 Explanation: Both s and t become """".
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Create array of characters from the passed string
 const createString = function (string) {
   const builtString = [];
   for (let x = 0; x < string.length; x++) {
     if (string[x] !== ""#"") {
       builtString.push(string[x]);
     } else {
       builtString.pop();
     }
   }
 
   return builtString;
 };
 
 // Compare two provided strings
 const backspaceCompare = function (firstString, secondString) {
   const finalFirstString = createString(firstString);
   const finalSecondString = createString(secondString);
 
   if (finalFirstString.length !== finalSecondString.length) {
     console.log(""Strings don't match"");
     return false;
   } else {
     for (let x = 0; x < finalFirstString.length; x++) {
       if (finalFirstString[x] !== finalSecondString[x]) {
         console.log(""Strings don't match"");
         return false;
       }
     }
   }
 
   console.log(""String match"");
   return true;
 };
 
 // Take strings as input
 let string1 = prompt(
   ""Enter first string with or without # as a backspace character - ""
 );
 let string2 = prompt(
   ""Enter second string with or without # as a backspace character - ""
 );
 
 // Call the algortihm
 backspaceCompare(string1, string2);
 
 /*
 
 > node BackspaceCompare
 
 Enter first string with or without # as a backspace character - a##c
 Enter second string with or without # as a backspace character - #a#c
 String match
 
 Enter first string with or without # as a backspace character - a#c
 Enter second string with or without # as a backspace character - b
 Strings don't match
 
 */
 
",JavaScript
"/*
 Description : 
             Given a number. Find and its reverse that number raised to the power of its own reverse.
             As answers can be very large, print the result modulo 1000000007.
  
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 #define mod 1000000007
 
 class Solution
 {
 public:
     //function to find the power with respect to mod
     long long modular_func(long long n, long long R)
     {
         if (n == 0)
         {
             return 0;
         }
         if (R == 0)
         {
             return 1;
         }
 
         long long y;
         // If we find R is even
         if (R % 2 == 0)
         {
             y = modular_func(n, R / 2);
             y = (y * y) % mod;
         }
 
         // If we find R is odd
         else
         {
             y = n % mod;
             y = (y * modular_func(n, R - 1) % mod) % mod;
         }
         // finally return the answer
         return ((y + mod) % mod);
     }
 
     long long power(int N, int R)
     {
         //using recursion
         return modular_func(N, R) % mod;
     }
 };
 
 //fucntion is used to reverse the number
 long long rev(long long n)
 {
     long long rev_num = 0;
     while (n > 0)
     {
         rev_num = rev_num * 10 + n % 10;
         n = n / 10;
     }
     return rev_num;
 }
 
 int main()
 {
     // user input number
     //using long long variables and function to avoid integer overflow
     long long num;
     cout << ""Enter the number : "" << endl;
     cin >> num;
     // R is used to hold reverse of the original number
     long long R = 0;
     R = rev(num);
 
     Solution obj;
     // calling function
     long long ans = obj.power(num, R);
     cout << ""Number raised to the power of its own reverse is : "" << endl;
     cout << ans << endl;
 }
 
 /*
 Time complexity : O(log N)
 Space complexity : O(log N)
 */
 
 /*
 Test Case :
  Input ;
  Enter the number : 
  12
 
  Output ;
  Number raised to the power of its own reverse is : 
  8643",C-Plus-Plus
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""pn6Z-EQkmVos""
    },
    ""source"": [
     ""# Flight Delay Predictions""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""OG7QXsh5xQ0M""
    },
    ""source"": [
     ""<img src=\""https://www.webintravel.com/wp-content/uploads/2020/05/den-belitsky-GettyImages-854673918-scaled.jpg\"" width=\""700\"">""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""nSxBf4--gC0n""
    },
    ""source"": [
     ""### Link to Dataset: [flights.csv](https://www.kaggle.com/usdot/flight-delays?select=flights.csv)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""5ffM0ge7FcKp""
    },
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {
     ""id"": ""B8VRPIqIp8_V""
    },
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import seaborn as sb\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.preprocessing import StandardScaler\n"",
     ""from sklearn.tree import DecisionTreeClassifier\n"",
     ""from sklearn.metrics import roc_auc_score""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""ZckrxAZjFiC0""
    },
    ""source"": [
     ""### Getting Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {
     ""colab"": {
      ""base_uri"": ""https://localhost:8080/"",
      ""height"": 422
     },
     ""id"": ""bX5VWtiDnlR8"",
     ""outputId"": ""4c728ed8-89ea-4357-b75e-fdf172ee0579""
    },
    ""outputs"": [
     {
      ""name"": ""stderr"",
      ""output_type"": ""stream"",
      ""text"": [
       ""C:\\Users\\DELL\\anaconda3\\lib\\site-packages\\IPython\\core\\interactiveshell.py:3146: DtypeWarning: Columns (7,8) have mixed types.Specify dtype option on import or set low_memory=False.\n"",
       ""  has_raised = await self.run_ast_nodes(code_ast.body, cell_name,\n""
      ]
     },
   ",Python
"/* The n-queens puzzle is the problem of placing n queens 
 on an n x n chessboard such that no two queens attack each other.
 Given an integer n, return the number of distinct solutions to the n-queens puzzle. */
 
 
 /* Function to get the number of way N queens can be placed on a NxN chess board */
 const totalNQueens = (n) => {
     
     /* Helper Function */
     const getTotalWays = (board, row, col, n) => {
 
         /* Base case when we filled each and every row */
         if(row == n){
             return true;
         }
         
         /* Checking every column in a particular row */
         for(let i=col; i<n; i++){
 
             /* Checking if a queen is already placed in that particular spot */
             if(!board[row][i]){
                 /* Placing a queen in that spot */
                 board[row][i] = true;
 
                 /* Checking the validity of our move and continuing to place queens in the next row */
                 if(validMove(board, row, i, n) && getTotalWays(board, row+1, 0, n)){
                     /* Incrementing our answer if n queens are placed on the chessboard */
                     ans++;
                 }
 
                 /* Removing the queen in that spot to get a different combination */
                 board[row][i] = false;
             }
         }
 
         /* Returning false if we cannot place any queens in that row */
         return false;
     }
             
 
     /* Function to check the validity of our move */
     const validMove = (board, row, col, n) => {
         return validCol(board, row, col, n) &&
             validRow(board, row, col, n) && 
             validRightUpperDiagonal(board, row, col, n) && 
             validRightLowerDiagonal(board, row, col, n) && 
             validLeftUpperDiagonal(board, row, col) && 
             validLeftLowerDiagonal(board, row, col, n)
     }
             
 
     /* Function to check if no two queens can kill each other in their respective columns",JavaScript
"""""""Julia program to implement Jump Search algorithm.
 Jump Search is a searching algorithm similar to binary search, where a sorted array is searched. 
 In this algorithm, only fewer comparisons are done, by jumping ahead some elements while traversal
 """"""
 
 
 function jump_search(arr, num, ele)
 
     # Size by which the traversing index should be jumped is calculated.
     jump = floor(Int, sqrt(num))
     step = jump
     temp = 1
     
     """""" The entire sorted array is divided into blocks of sqrt(n) size and the block just after which the
         required element is present is being identified. and the previous block starting index is stored in temp"""""" 
     while (arr[min(step, num)] < ele)
         temp = step
         step = step + jump
         if (temp >= num)
             return false
         end
     end
 
     # The identified block, is searched via linea search for the required element.
     while (arr[temp] < ele)
         temp = temp + 1
         if (arr[temp] == ele)
             return true
         end
         # Check if the end of the array or end of the block is reached 
         if (temp == min(step, num))
             return false
         end
     end
     if (arr[temp] == ele)
         return true
     else
         return false
     end
 end
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""Array is Empty!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())] 
 print(""Which number do you want to search in the array? "")
 ele = readline()
 ele = parse(Int, ele)
 # Sort the array in ascending order
 arr = sort(arr)
 res = jump_search(arr, n, ele)
 if (res == 0)
     print(""The number $ele is not present in the array"")
 else
     print(""The number $ele is present in the array."")
 end
 
 
 
 """"""
 Time Complexity - O(n^(0.5)), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTP",Julia
"/*
 Given a binary array, binary means array's element will be 0 or 1.
 find the maximum number of consecutive 1's in this array.
 */
 
 #include <stdio.h>
 
 // this get_max_consecutive_ones will count max consecutive ones in the array
 int get_max_consecutive_ones(int ar[] , int N)
 {
     int max_consecutive_ones = 0 , count_1 = 0;
     for(int i = 0; i < N; i++)
     {
         if(ar[i] == 1)
         {
             count_1++;
             /* here we will keep the maximum value of consecutive
             1's  */
             if(count_1 > max_consecutive_ones)
             {
                 max_consecutive_ones = count_1;
             }
         }
         else if(ar[i] == 0)
         {
             count_1 = 0;
             /* as array's element is zero (0)
             we will set count_1 as zero */
 
         }
     }
     return max_consecutive_ones;
 }
 
 int main()
 {
     printf(""Enter the size of the array : \n"");
     int N;
     scanf(""%d"", &N);
     int ar[N + 1];
     printf(""Enter array elements :\n"");
     for (int i = 0; i < N; i++)
     {
         scanf(""%d"", &ar[i]);
 
     }
     int max_consecutive_ones = get_max_consecutive_ones(ar , N);
     printf(""Maximum Consecutive Ones in this array is : "");
     printf(""%d \n"",max_consecutive_ones);
 }
 
 /*
 
 Standard Input and Output
 
 Enter the size of the array :
 6
 Enter array elements :
 1 1 0 1 1 1
 
 Maximum Consecutive Ones in this array is : 3
 
 Time Complexity : O( N )
 Space Complexity : O( 1 )
 
 */
",C
"/*
 Given an array of N elements and a value K (K <= N) ,
 calculate maximum summation of K consecutive elements in the array.
 We can solve this problem by using Sliding Window Technique.
 This technique will allow us to solve this problem in O(N)
 */
 
 #include <stdio.h>
 
 // This max_sum_by_sliding_window function will give us maximum sum
 int max_sum_by_sliding_window(int ar[] , int N , int K)
 {
     int sum = 0;
     if(N == K)
     {
         // max_sum will be the sum of all elements of array.
         for(int i = 0; i < N; i++)
         {
             sum += ar[i];
         }
         return sum;
     }
     if(N > K)
     {
         // calculate sum of first window of size K
         int max_sum = 0, win_sum = 0;
         for(int i = 0; i < K; i++)
             max_sum += ar[i];
 
         /*calculate sum of remaining windows
          by removing elements from first window simultaneously
          add elements to current window */
         win_sum = max_sum;
         for(int i = K; i < N; i++)
         {
             win_sum += (ar[i] - ar[i - K]);
             if(win_sum > max_sum)
             {
                 max_sum = win_sum;
             }
         }
         return max_sum;
     }
 }
 int main()
 {
     int N, K;
     printf(""Enter array size and value\n"");
     scanf(""%d %d"", &N, &K);
     int ar[N + 1];
     printf(""Enter array elements \n"");
     for(int i = 0; i < N; i++)
     {
         scanf(""%d"", &ar[i]);
     }
     int solve = max_sum_by_sliding_window(ar, N , K);
     printf(""maximum summation of K consecutive elements in the array is: \n"");
     printf(""%d \n"", solve);
 }
 
 /*
 Standard Input and Output
 
 1. if N == K
 Enter array size and value
 5 5
 1 2 3 4 5
 maximum summation of K consecutive elements in the array is:
 15
 
 2. if N > K
 Enter array size and value
 5 3
 5 2 -1 0 3
 maximum summation of K consecutive elements in the array is:
 6
 
 Time Complexity : O(N)
 Space Complexity : O(1)
 
 */
",C
"/*
 Gray code is an ordering of the binary numeral system such that two successive values differ in only one bit (binary digit).
 In gray code, two consecutive values are differed by one bit of binary digits. To convert gray code into binary number, 1st bit
 in output is taken same as input's 1st bit. Further, xor operation is performed on recently calculated output bit & next input
 bit.
 
 Gray code to binary conversion: 3(Gray) = 0011(Binary)
 0  0  1  1
 | /| /| /|
 0  0  1  0
 Here, 1st bit, i.e 0 is taken as it is. Further, xor operations of recently calculated output bit(i.e 0) & its next input bit
 (i.e 0) is performed. Same process is repeated until last input bit.(xor of (0,0) , (0,1) , (1,1)).
 Therefore, 3 in gray code is equivalent to 2 in decimal format.
 
 In this problem, the gray code is converted into decimal format.
 Example:
 I/O : 3
 O/P : 2
 Explanation: 3 is given in gray code. In binary, 3 is written as 0011. When converted into decimal format, it is 0010. But decimal
 equivalent of 0010 is 2.
 */
 
 #include<iostream>
 using namespace std ;
 
 int gray_code_to_decimal(int fn_in_gray)
 {
     int fn_in_decimal = 0;
 
     /*
     To get decimal format number, xor of output number(number in decimal format) & gray code number has to be performed. In each
     iteration, gray code number is shifted to the right by 1. This process is continued till gray format number becomes 0.
     */
     for (; fn_in_gray; fn_in_gray = fn_in_gray >> 1)
     {
         fn_in_decimal ^= fn_in_gray ;
     }
 
     return fn_in_decimal;
 }
 
 int main(void)
 {
     int n_in_gray = 0, n_in_decimal = 0 ;
 
     //Take user input as gray code number
     cout << ""Enter the number in gray format : "" << endl ;
     cin >> n_in_gray ;
 
     //Call to function gray_code_to_decimal
     n_in_decimal = gray_code_to_decimal(n_in_gray) ;
 
     cout << ""The decimal value of gray code "" << n_in_gray << "" is : "" << n_in_decimal << endl ;
     return 0 ;
 }
 
 /*
  Sample Exam",C-Plus-Plus
"/* Sorting an array of 0's and 1's
 
 Given an array of size n which contains only 0's and 1's
 in any order,we have to modify the array in such a way
 that 0's are on left side and 1's on the right side.
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 //Function to sort an array of 0's and 1's
 void sort()
 {
     int size_of_array;
     cout<<""Enter size of array: "";
     cin >> size_of_array;
     int array[size_of_array];
     cout<<""Enter array elements: "";
     for (int i = 0; i < size_of_array; i++)
     {
         cin >> array[i];
     }
     /*  Two counters to count number of 0's and 1's respectively
 	    which are initialized to 0*/
     int counter_for_0 = 0, counter_for_1 = 0;
     for (int i = 0; i < size_of_array; i++)
     {
         if (array[i] == 0)
         {
 	    counter_for_0++;
             continue;
         }
         counter_for_1++;
     }
     cout<<""Sorted array of 0's and 1's is: "";
     while (counter_for_0--)
     {
 	cout << 0 << "" ""; 
     }
     while (counter_for_1--)
     {
         cout << 1 << "" ""; 
     }
     cout << endl;
 }
 
 int main()
 {
     sort(); 
     return 0;
 }
 /*
 Input:
 Enter size of array: 6
 Enter array elements: 0 1 0 1
 Output:
 Sorted array of 0's and 1's is: 0 0 1 1
 
 Space Complexity-O(N)
 Time Complexity-0(1)
 */
",C-Plus-Plus
"/* C Program to find route between any two nodes in a graph.
     The problem is solved using depth-first-search.We start with root node,
    and during the traversal , check if the node is found.We mark any node found
    in the course of the algorithm as ""already visited"" to avoid cycles and
    repetition of nodes */
 
 #include <malloc.h>
 #include <stdio.h>
 
 // keeping maximum 5 vertices
 #define N 5
 // Edge-Structure of a graph
 struct Edge {
   int from, to;
 };
 
 // Node-Structure
 struct Node {
   int dest;
   struct Node *next;
 };
 
 // graph with array of head pointers
 struct Graph {
   // An array of pointers to Node to represent an adjacency list
   struct Node *head[N];
 };
 
 // stack node structure
 struct Stack {
   int data;
   struct Stack *next;
 };
 
 // insertion at beginning
 int push(struct Stack **q, int data) {
   struct Stack *temp;
 
   temp = (struct Stack *)malloc(sizeof(struct Stack));
   if (temp == NULL) {
     printf(""Allocation not possible"");
     return -1;
   }
   temp->data = data;
   temp->next = *q;
   *q = temp;
 
   return 0;
 }
 
 // check whether stack is empty or not
 int isEmpty(struct Stack *q) {
   if (q == NULL) {
     return 1;
   }
   return 0;
 }
 
 // deletion at beginning
 int pop(struct Stack **s) {
   struct Stack *q;
   int item;
   if (isEmpty(*s)) {
     printf(""\nStack is empty"");
   } else {
     q = *s;
     item = q->data;
     *s = q->next;
     free(q);
     return (item);
   }
   return 0;
 }
 
 struct Graph *Initialize(struct Graph *g) {
   int v, i;
 
   g = (struct Graph *)malloc(sizeof(struct Graph));
 
   // Initialize  adjacency list as empty
   // making head of every adjacency list as empty
   for (i = 0; i < N; i++) {
     g->head[i] = NULL;
   }
   return g;
 }
 
 // Adds an edge to the graph
 int addEdge(struct Graph *graph, int from, int to) {
   struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
   newNode->dest = to;
 
   // point new node to the head
   newNode->n",C
"""""""Julia program to implement Fibonacci Search algorithm.
 Fibonacci Search is a Divide and Conquer strategy based algorithm that works for sorted arrays
 Fibonacci Search avoids CPU costly division operation and uses addition and subtraction opertations
 This algorithm uses Fibonacci series as an underlying principle, where every element of the series is defined by:
 
     fib(n) = fib(n-1) + fib(n-2), where fib(0) = 0, fib(1) = 1
 """"""
 
 function fibonacci_search(arr, n, ele)
 
     # We start the series from 1, 1 as the Julia language is 1-based indexing
     fibn2 = 1
     fibn1 = 1
     fibn = fibn1 + fibn2
     while (fibn < n)
         fibn2 = fibn1
         fibn1 = fibn
         fibn = fibn1 + fibn2
     end
 
     # To denote the eliminted range from left.
     offset = 0
 
     while (fibn > 1)
         i = min(offset + fibn2, n - 1)
         
         """"""Compares the element in i'th index with ele and decide the next fibonacci element. If the element doesn't
             turns out to be greater than or less than the element at i'th index then we find the required element""""""
         if (arr[i] < ele) 
             fibn = fibn1;
             fibn1 = fibn2;
             fibn2 = fibn - fibn1;
             offset = i;
         elseif (arr[i] > ele) 
             fibn = fibn2;
             fibn1 = fibn1 - fibn2;
             fibn2 = fibn - fibn1;
         else
             return true
         end
         if (arr[offset + 1] == ele)
             return true
         end
     end
     return false
 end
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""Array is Empty!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())] 
 print(""Which number do you want to search in the array? "")
 ele = readline()
 ele = parse(Int, ele)
 # Sort the array in ascending order
 arr = sort(arr)
 res = fibonacci_search(arr, n, ele)
 if (res == 0)
    ",Julia
"/*
 AIM :: To implement Priority Queue (PQ) using Linked List (LL).
 
             WHAT IS PRIORITY QUEUE ?
 A priority queue is an abstract data type that behaves similarly to the normal queue except that each element has some priority, 
 i.e., the element with the highest priority would come first in a priority queue. 
 The priority of the elements in a priority queue will determine the order in which elements are removed from the priority queue.
 
 */
 
 #include <stdio.h>
 #include <conio.h>
 #include <stdlib.h>
 
 struct node
 {
     int data;          //for storing data
     int prior;         // for storing priority of the data
     struct node *next; // for storing next node's address
 } * front;
 typedef struct node PQ;
 
 //protorypes
 void enq();     // for insertion
 void deq();     // for deletion
 void display(); // for display
 
 int main()
 {
     int choice;
     printf(""\n\t\tPRIORITY QUEUE IMPLEMENTION USING LINKED LIST\n\n"");
     while (1)
     {
         printf(""\nMAIN MENU\n"");
         printf(""1. ENQ\n2. DEQ\n3. DISPLAY\n4. EXIT\n"");
         printf(""Enter your choice :: "");
         scanf(""%d"", &choice);
 
         switch (choice)
         {
         case 1:
             enq();
             break;
 
         case 2:
             deq();
             break;
 
         case 3:
             display();
             break;
 
         case 4:
             printf(""\nexiting...\n"");
             exit(0);
             break;
 
         default:
             printf(""\nINVALID CHOICE :(\n"");
             break;
         }
     }
     return 0;
 }
 
 void enq()
 {
     // creating new node
     PQ *new_node = (PQ *)malloc(sizeof(PQ));
     new_node->next = NULL;
 
     //take data and priority of that data form the user
     printf(""\nenter data: "");
     scanf(""%d"", &new_node->data);
 
     printf(""\nenter priority of %d: "", new_node->data);
     scanf(""%d"", &new_node->prior);
 
     // if queue is full then insert the new node at the beginning
     if ",C
"/*
 
 We can easily solve this problem in linear time using kadanes algorithm.
 The idea is to maintain maximum (positive sum) sub-array ending at each index of the given array.
 This subarray is either empty (in which case its sum is zero) or consists of one more element than the maximum subarray ending at the previous index.
 And, To Cover Both Positive and Negative Cases, approach requires two traversals of the input array.
 
 */
 
 #include <bits/stdc++.h>
 
 #define ll long long int
 using namespace std;
 
 // Function to find contiguous sub-array with the largest sum
 // in given set of integers (handles negative numbers as well)
 
 int kadane(ll arr[], ll n)
 {
     // stores maximum sum sub-array found so far
     ll max_so_far = arr[0]; 
 
     // stores maximum sum of sub-array ending at current position
     ll max_ending_here = arr[0]; 
 
     for (ll i = 1; i < n; i++)
     {
         // update maximum sum of sub-array ""ending"" at index i (by adding current element to maximum sum ending at previous index i-1)
         max_ending_here = max_ending_here + arr[i];   
         
         // maximum sum is should be more than the current element
         max_ending_here = max(max_ending_here, arr[i]); 
         
         // update result if current sub-array sum is found to be greater
         max_so_far = max(max_so_far, max_ending_here); 
     }
 
     return max_so_far;
 }
 
 int main()
 {
     ll n;
     cin >> n;
     ll arr[n];
     for (ll i = 0; i < n; i++)
     {
         cin >> arr[i];
     }
 
     cout << """" << kadane(arr, n);
 
     return 0;
 }
 
 /*
 
 Time Complexity : O(n)
 Space Complexity: O(1)
 
 Sample Input: 
 
 8
 -2 1 -3 4 -1 2 1 -5 4
 
 Sample Output:
 
 6
 
 */
",C-Plus-Plus
"// This program calculates the count of distinct elements in every window
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void CountDist(int arr[], int n, int k) { //O(n) time and O(n) aux space
 	unordered_map<int, int> freq;   //this map is for storing the frequency of elements
 	for (int i = 0; i < k; i++) {
 		freq[arr[i]]++;
 	}
 	cout << freq.size() << "" "";     //This statement prints the number of first window's distinct elements
 	for (int i = k; i < n; i++) {   //For calculating the ans for other windows, we decrement the freq of the 1st element of prev
 		freq[arr[i - k]]--;         //window and add the freq of new element
 		if (freq[arr[i - k]] == 0) {
 			freq.erase(arr[i - k]);
 		}
 		freq[arr[i]]++;
 		cout << freq.size() << "" "";
 	}
 }
 
 int main() {
 	int n;
 	cout << ""Enter size of array"";
 	cin >> n;
 	int arr[n];
 	cout << ""Enter array elements"";
 	for (int i = 0; i < n; i++) {
 		cin >> arr[i];
 	}
 	int k;
 	cout << ""Enter the size of window"";
 	cin >> k;
 	CountDist(arr, n, k);
 	return 0;
 }
 
 /*
 Examples:
 1. For arr[] = {10, 20, 20, 10, 30, 40, 10}, k = 4
    Output = 2 3 4 3
 2. For arr[] = {10, 10, 10, 10}, k = 3
    Output: 1 1
 3. For arr[] = {10, 20, 30, 40}, k = 3
    Output: 3 3
 */
 
",C-Plus-Plus
"//program for an armstrong number or not
 
 //first we take input for the number
 let number = ""153""
     //window.prompt(""enter a positive no"");
     //then we calculate the no of digits 
 let n = number.length
 console.log(n)
     //we store our number in a temporary variable
 let temp = number
     //variable for summing up the digits raised to the total no of digits
 let sum = 0
 
 
 while (temp > 0) {
 
     //extracting the last digit
     let rem = temp % 10;
 
     //summation
     sum += parseInt(rem ** n);
 
     // removing last digit from the number
     // convert float into integer
     temp = parseInt(temp / 10);
 }
 
 //checking for armstrong no.
 if (sum == number) {
     console.log(`${number} is an Armstrong number`);
 } else {
     console.log(`${number} is not an Armstrong number.`);
 }",JavaScript
"
 /*
 
 COMB SORT :
 
 Comb Sort is mainly an improvement over Bubble Sort. Bubble sort always compares adjacent values.
 So all inversions are removed one by one. Comb Sort improves on Bubble Sort by using gap of size
 more than 1. The gap starts with a large value and shrinks by a factor of 1.3 in every iteration
 until it reaches the value 1. Thus Comb Sort removes more than one inversion counts with one swap
 and performs better than Bubble Sort.
 */
 
 
 
 #include <stdio.h>
 
 void comb_sort(int *ar, int n){
 
     //gap variable gives gap between the values to compare
     int gap = n;
     int q,w;
     
     while(gap>1){
         //updating the gap variable
         gap = gap/1.3;
         if(gap<1){
             gap = 1;
         }
         q=0;w=q+gap;
         while(w<n){
             if(ar[q]>ar[w]){
 		        //swap values
                 int temp = ar[q];
                 ar[q] = ar[w];
                 ar[w] = temp;
             }
             w++;q++;
         }
     }
 }
 
 int main()
 {
     int n;
     int *ar;
     printf(""Enter the limit : "");
 
     //Input the number of elements to be sorted
     scanf(""%d"",&n);
 
     //Dynamically allocate memory for the array
     ar = (int*)malloc(n * sizeof(int));
 
     //Input numbers to be sorted
     for(int i=0;i<n;i++){
         scanf(""%d"",&ar[i]);
     }
     
     printf(""Unsorted array : \n"");
 
     //Print the unsorted array
     for(int i=0;i<n;i++){
         printf(""%d "",ar[i]);
     }
     printf(""\n\n"");
     
     //Execute the comb sort function
     comb_sort(ar, n);
     
     printf(""Sorted array : \n"");
 
     //Print the sorted array
     for(int i=0;i<n;i++){
         printf(""%d "",ar[i]);
     }
     
     return 0;
 }
 
 /*
 CASE 1:
 input = [1, 8, 7, 61, 5, 4, 11];
 EXPECTED: [1,4,5,7,8,11,61]
 
 CASE 2:
 input = [1,8,3,9,10,10,2,4];
 EXPECTED: [1,2,3,4,8,9,10,10]
 
     Time Complexity - O(n log n) for the best case.
                       O(n^2/2^p) (p is a number of increme",C
"/*
     Bipartite Check problem.
     Given a graph. Check whether the graph is bipartite or not.
     
     A bipartite graph (or bigraph) is a graph whose vertices can be divided into two disjoint and independent sets U and V 
     such that every edge connects a vertex in U to one in V. 
     
     Vertex sets U and V are usually called the parts of the graph. 
     
     Equivalently, a bipartite graph is a graph that does not contain any odd-length cycles.[1][2]  (Definition taken from Wikipedia)
     
     Input: No of vertices, edge list of the graph.
     Output: boolean value representing whether the graph is bipartite or not
     
     Code is contributed by Jahnavi Majji
 */
 
 import java.util.*;
 
 public class BipartiteCheck {
     public static void main(String[] args) {
         //driver code;
         Scanner Scanner = new Scanner(System.in);
 
         //take the necessary input: vertices, edges
         System.out.println(""Enter number of vertices and edges: "");
         int vertices = scanner.nextInt();
         int edges = scanner.nextInt();
 
         List<Integer>[] graph = new ArrayList[vertices];
         for(int i = 0; i < vertices; i++) {
             graph[i] = new ArrayList();
         }
 
         //build the graph from the edges.
         System.out.println(""Enter the source and destination of the edges: "");
         while(edges-- > 0) {
             int from = scanner.nextInt();
             int to = scanner.nextInt();
 
             --from; --to;   //this is to make sure the vertices of the edges are by 0-index based
             graph[from].add(to);
             graph[to].add(from);
         }
 
         scanner.close();
 
         System.out.println(""Is the graph Bipartite? "" + isGraphBipartite(graph, vertices));
 
     }
 
     private static boolean isGraphBipartite(List<Integer>[] graph, int vertices) {
         int[] color = new int[vertices];
         for(int i = 0; i < vertices; i++) {
             color[i] = -1;
         }
 ",Java
"#include <stdio.h>
 #include <string.h>
 
 int main()
 {
     char str1[1000] , str2[1000];
     int i = 0 , j = 0;                    // i will point to string 1 and j will point to string 2 
     printf("" Enter first string :\n"");
     scanf(""%s"" , str1);                   // str1 is substring
     printf("" Enter second string :\n"");
     scanf(""%s"" , str2);                   //str2 is full string
     while (i < strlen(str1) && j < strlen(str2)) 
     {
 		if (str1[i] == str2[j]) 
 		{
 			i++;
 		}
 		j++;
 	}
 	
 	if (i == strlen(str1)) 
 	{
 		printf(""Yes, str1 is substring of str2\n"");
 	}
 	else 
 	{
 		printf(""No, str1 is not a substring of str2\n"");
 	}
 		
     return 0;
 }
 
 /*
 Time Complexity: O(n)
 Space Complexity: O(1)
 Input:
 DTH SDFDTHFGB
 QBR EQVBA
 Output:
 Yes, str1 is substring of str2
 No, str1 is not substring of str2
 */
 
",C
"/*
 
 Introduction 
 Given a Binary Tree ,Print all its root to leaf paths
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 Function  prints all its root to leaf paths recursively
 
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Utility Function to print given path
 void PrintThisPath(vector<int>path)
 {
    for( int i: path )   cout<<i<<"" "";
    cout<<endl;
    return ;
 }
 
 //Utility Function to Generate paths
 void GeneratePaths(struct Node* root, vector",C-Plus-Plus
"/*
 Problem statement : 
 A Person is at the bottom of n stairs .
 To reach the top he can climb either 1 or 2 stairs at a time. 
 Find the number of ways he can reach the top
 */
 
 function climbing_stairs(n) {
     let dp = new Array(n);
     dp[0] = 1
     dp[1] = 1
     for (let i = 2; i <= n; i++) {
         dp[i] = dp[i - 1] + dp[i - 2];
     }
     return dp[n];
 }
 //For reading input 
 const readline = require('readline');
 
 const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
 
 const getLine = (function () {
     const getLineGen = (async function* () {
         for await (const line of rl) {
             yield line;
         }
     })();
     return async () => ((await getLineGen.next()).value);
 })();
 
 const main = async () => {
     console.log(""Enter the number stairs"");
     let n = Number(await getLine());
     console.log(""The number of ways to climb the stairs is : "" + climbing_stairs(n));
     process.exit(0);
 };
 
 main();
 
 /*
 Sample I/O:
 
 Enter the number stairs
 5
 The number of ways to climb the stairs is : 8
 
 Time complexity : O(n)
 Space complexity : O(n)
 */
",JavaScript
"/*
    This is a simple program in go language 
    to find out if a number ios happy or not.
    Happy number is a number which eventually 
    reaches 1 when replaced by the sum of the 
    square of each digit. 
 
    Example : 10 => 1^2 +0^2 = 1
    So, 10 is happy number!
 
 */
 
 package main
 
 import (
 
    ""fmt""
 
 )
 
 /* This function counts the number of digits 
    in the the given number*/
 func digits(a int) int {
 
    var counter int
    counter = 0
 
    for a !=0 {
 
      a = a/10
      counter += 1
 
    }
 
    return counter
 }
 
 /* This function returns the sum of squares
    of the individual digits for a given number*/
 func numbersquares(number int) int {
 
   var sum int
   sum = 0
 
   var digit int
   digit = 0
 
   var r int
   r = 0
 
   /* calling the digits function to return number
      of digits for the number we gave it has*/
   digit = digits(number)
 
   for i:=0;i<digit;i++ {
 
      r = number%10
      sum += r*r
      number = number/10
 
   }
 
   return sum
 
 }
 
 /* This function tells us if a given number number 
    is happy or not*/
 func happynumber(n int) int{
 
     var final_sum int
     final_sum = n
 
     // base case as these are happy numbers
     if(n==1 || n==7){
 
        return 1
 
     }
 
     // if the sum is in double digits
     for final_sum > 9 {
 
        final_sum = numbersquares(n)
 
        if(final_sum == 1){
 
             return 1
 
        }
 
        n = numbersquares(n)
 
     }
 
     if(final_sum == 7){
 
        return 1
 
     }else{
 
       return 0
 
     }
 
 }
 
 // driver function
 func main() {
 
    var number int
 
    // Taking the input here
    fmt.Print(""Enter the number you want to check for :"")
    fmt.Scan(&number)
 
    var checker int
    checker = happynumber(number)
 
    // we print out the message here
    if(checker == 1){
 
       fmt.Print(""The number is Happy Number!"")
 
    }else{
 
       fmt.Print(""The number is not a Happy Number!"")
 
    }
 
 }
 
 /*
",Go
"/* 
 The adjacent_difference algo produces a new sequence
 in which each element is difference between adjacent 
 elements in original sequence. 
 */
 
 #include<bits/stdc++.h>
 using namespace std;
  
 void adjacent_difference()
 {
       int num;
       cout << ""Enter the no. of values :"" << endl;
       cin >> num;
 	vector<int> v(num), r(num);
 	
 	for(int i=0; i<num; i++)
 	{
 		v[i] = i*2;
 	}
 
 	cout << ""Original sequence :"" << endl;
 	for(int i=0; i<num; i++)
 	{
 		cout << v[i] << "" "";
 	}
 	cout << endl;
 	
 	adjacent_difference(v.begin(), v.end(), r.begin());
 	
 	cout<<""Resulting sequence :"" << endl;
 	for(int i=0; i<num; i++)
 	{
 		cout<< r[i] <<"" "";
 	}
 }
  
 int main()
 {
 	adjacent_difference();
 	return 0; 
 }
 	
 /*
 Sample Output:
 Enter the no. of values :                                                                                                                       
 5                                                                                                                                               
 Original sequence :                                                                                                                             
 0 2 4 6 8                                                                                                                                       
 Resulting sequence :                                                                                                                            
 0 2 2 2 2 
 */
 
 /*
 Time-Complexity = O(N)
 Space-Complexity = O(N)
 */
",C-Plus-Plus
"""""""Julia program to check if a number is a Magic Number or not
 A number is said to be a magic number if the recursive sum of its digits is 1.
     For Example Let's Consider
       19, 1 + 9 = 10
       10, 1 + 0 = 1
       = 1 , Hence 19 is a Maigc Number
 """"""
 
 
 function sum_of_digits(n)
     sum = 0
     while(n>0)
         rem = n % 10
         sum = sum + rem
         n = n  10
     end
     return sum
 end
 
 function check_magic_num(n)
     while(n > 9)
         n = sum_of_digits(n)
     end
     if(n == 1)
         return true
     else
         return false
     end
 end
 
 
 
 print(""Enter the number: "")
 n = readline()
 n = parse(Int, n)
 res = check_magic_num(abs(n))
 if res
     println(""The given number $n is a Magic Number."")
 else
     println(""The given number $n is not a Magic Number."")
 end
 
 
 """"""
 Time Complexity: O(log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 23
 The given number 23 is not a Magic Number.
 
 SAMPLE 2
 Enter the number: 1729
 The given number 1729 is a Magic Number..
 
 """"""
",Julia
"/*The game used to implement Sprague-Grundy is defined below
 
  -> There are 2 people playing this composite impartial game
  -> The second player writes an arbitrary string . 
  -> Then each player starting with the first player starts 
  	removing a continous substring which exists in a list of 
  	substrings that are possible to remove.
  -> The first player who can't remove a substring loses. */
 
 #include <bits/stdc++.h>
 using namespace std;
 // Macros used 
 typedef pair<int, int> pii;
 
 #define maxs 33
 #define INF 1e9
 
 // Global Variables
 int t, y, st[maxs][maxs], pc[maxs][maxs], kk[maxs][maxs];
 string a, wq[maxs];
 
 void process(int x)
 {
 	// Process the Grundy numbers for each input
 	int g, h;
 	pc[x][0] = -1;
 	for (g = 0, h = -1; g < wq[x].size();)
 	{
 		while (h >= 0 && wq[x][g] != wq[x][h])
 		{
 			h = pc[x][h];
 		}
 		g++, h++;
 		pc[x][g] = h;
 	}
 }
 vector<pii> kmp(int x, string s)
 {
 	int g, h;
 	vector<pii> all;
 	for (g = 0, h = 0; g < s.size();)
 	{
 		while (h >= 0 && s[g] != wq[x][h])
 		{
 			h = pc[x][h];
 		}
 		g++, h++;
 		if (h == wq[x].size())
 		{
 			all.push_back(pii(g - h, g));
 			h = pc[x][h];
 		}
 	}
 	return all;
 }
 
 // Sprague Grundy Theorem implemented
 /*Note that after a player erases a substring S(a, b), 
 in S(i, j), the game is split into two subgames, S(i, a-1) 
 and S(b+1, j). Because a player can choose any game in his/her 
 turn, the Grundy number of the game is simply the XOR of the 
 Grundy numbers of the two subgames. */
 
 int sprague_grundy(int nx, int ny)
 {
 	if (nx > ny)
 		return 0;
 	if (kk[nx][ny] == t)
 		return st[nx][ny];
 	int g, h, px, py, xr1, xr2, now;
 	string s;
 	vector<int> ss;
 	vector<pii> all;
 	for (g = nx; g <= ny; g++)
 	{
 		s += a[g];
 	}
 	for (g = 0; g < y; g++)
 	{
 		all = kmp(g, s);
 		for (h = 0; h < all.size(); h++)
 		{
 			px = all[h].first, py = all[h].second;
 			xr1 = (sprague_grundy(nx, nx + px - 1));
 			xr2 = (sprague_grundy(nx + py, ny));
 			ss.push_bac",C-Plus-Plus
"/*
 	Brian Kernighans Algorithm: To get the number of set bits
 	For eg :- 5 can be represented as 101 number of set bits are 2
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 int main()
 {
 	int n;
 	cout<<""Enter number \n"";
 	cin>>n;
 	int c=0;
 	while (n) {
             n &= (n - 1);
             c++;
         }
         cout<< c;
 }
 
 /*
 Time Complexity: O(logn)
 Space Complexity: O(1)
 */
 
 /*Sample Input:
 	Example 1:- 
 	Enter number
 	5
 	Example 2:-
 	Enter number
 	987
 
 	Sample Output:
 	Example 1:- 2
 	Example 2:- 8
 */
 
",C-Plus-Plus
"
 /*Given two sorted arrays nums1 and nums2 of size m and n 
 respectively, return the median of the two sorted arrays.*/
 
 //function to find median of sorted arrays
 var findMedianSortedArrays = function(arr1, arr2) {
     //concatenate and sort the arrays
   let arr3 = arr1.concat(arr2).sort(function(a, b){return a-b});
     var mid;
     //checking if the length of array is even
     if(arr3.length % 2 !== 0) {
         //return the mid element
         mid = arr3[arr3.length / 2>>0];
         return mid;
     } 
     //if length is odd return the median of two elements
     else {
         var first = arr3[arr3.length / 2>>0];
         var second = arr3[(arr3.length / 2 >> 0 )-1];
         mid =  first + second;
         return( mid ) / 2;
     }
 };
 
 
 var inputArray1 = [];
 var inputArray2 = [];
 var size = prompt(""enter size: "");
 var size1 = prompt(""enter size: "");//Maximum Array size
 
 for(var i=0; i<size; i++) {
 	
 	//Taking Input from user
 	inputArray1[i] = prompt((i+1));
 }
 for(var i=0; i<size1; i++) {
 	
 	//Taking Input from user
 	inputArray2[i] = prompt((i+1));
 }
 
 console.log(findMedianSortedArrays(inputArray1,inputArray2));
 /*
 Time complexity: O(n)
 Space complexity: O(n)
 
 Example 1:
 Input:
 2 1
 1 3
 2
 Output:
 2.00000
 
 Example 2:
 Input:
 5 3
 1 5 7 8 9
 2 4 4
 Output:
 4.50000
 
 */
",JavaScript
"""""""Julia program to implement Ternary Search algorithm.
 Ternary Search is a Divide and Conquer strategy based algorithm similar to binary search.
 Here we divide the entire array into three parts and recursively search for the required element
 """"""
 
 function ternary_search_recursive(arr, low, high, ele)
     while (high >= low)
         # FInd the two required midpoints to divide the array into three.
         midA = low + (high - low)  3
         midB = high - (high - low)  3
         # Search, if the element is present in the midpoint indices
         if (arr[midA] == ele)
             return true
         elseif (arr[midB] == ele)
             return true
         end
     
         # Identify the part in which the required element belongs to and recursively call the function with limited length
         if (ele < arr[midA])
             return ternary_search_recursive(arr, low, midA - 1, ele)
         elseif (ele > arr[midB])
             return ternary_search_recursive(arr, midB + 1, high, ele)
         else
             return ternary_search_recursive(arr, midA + 1, midB - 1, ele)
         end
     end
     return false
 end
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""Array is Empty!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())] 
 print(""Which number do you want to search in the array? "")
 ele = readline()
 ele = parse(Int, ele)
 # Sort the array in ascending order
 arr = sort(arr)
 res = ternary_search_recursive(arr, 1, n, ele)
 if (res == 0)
     print(""The number $ele is not present in the array"")
 else
     print(""The number $ele is present in the array."")
 end
 
 
 """"""
 Time Complexity - O(log(n)), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 How many numbers are present in the array? 5 
 Enter the numbers: 1 2 3 4 5
 Which number do you want to s",Julia
"/*
 
 Unlike a traditional sorting algorithm, which attempts to sort with the fewest comparisons possible,
 the pancake sorting algorithm sorts the sequence in as few reversals as possible. Something similar to selection sort.
 
 Algorithm - Start from current size equal to n and reduce current size by one while it's greater than 1.
                 1. Find max form the reduced array size.
                 2. Compare max with array elements and flip accordingly
 
 Time Complexity - O(n ^ 2)    
             
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Flip elements
 function flip(array, index) {
   let start = 0;
   while (start < index) {
     [array[start], array[index]] = [array[index], array[start]];
     start++;
     index--;
   }
 }
 
 // Perform pancake sorting
 function panCake(array) {
 
   // Create chunks of array one by one
   for (let i = array.length; i > 1; --i) {
     let max = array.indexOf(Math.max(...array.slice(0, i))); // get the max of chunk
 
     if (max !== i - 1) {
       flip(array, max); // flip array by moving max to the beginning
       flip(array, i - 1); // reverse the array
     }
   }
 
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered value is number or not
   if (array.includes(NaN)) return console.log(""Only numbers are allowed"");
 }
 
 console.log(""Your array - "", array);
 
 // Call the algorithm
 panCake(array);
 console.log(""Sorted array - "", array);
 
 /*
 
 > node PancakeSort
 
 Enter array length - 5
 Enter 1 element - 21
 Enter 2 element - 50
 Enter 3 element - 11
 ",JavaScript
"import java.util.*;
 class Wrapping_letter {
     public static void main(String args[]) {
         Scanner sc = new Scanner(System.in);
 
         System.out.println(""Enter the target character"");
         char ch = sc.nextLine().charAt(0); //target character
         List < Character > arr = new ArrayList < > ();
         System.out.println(""Enter the letters"");
         String s = sc.nextLine();
         for (int i = 0; i < s.length(); i++)
             arr.add((s.charAt(i)));
         arr.add((ch));
         Collections.sort(arr);
         int ind = arr.indexOf(ch);
         System.out.print(""The closest letter : "");
         if (ind == (arr.size() - 1))
             System.out.println((arr.get(0)));
         else
             System.out.println((arr.get(ind + 1)));
     }
 
 }
 
 /*
 Sample input and output:
 Enter the target character
 a
 Enter the letters
 cdf
 The closest letter : c
 Enter the target character
 z
 Enter the letters
 abc
 The closest letter : a
 
 Time Complexity: O(n)
 Space Complexity: O(1)
 */
",Java
"#include<stdio.h>
 #include<conio.h>
 #include<stdlib.h>
 
 struct BST{
  int data;
  struct BST *left;
  struct BST *right;
 };
 
 struct BST* create();
 void insert(struct BST*, struct BST*);
 void preorderRecursive(struct BST*);
 void preorderIterative(struct BST*);
 
 int main(){
  char ch;
  struct BST *root=NULL, *temp;
  do{
     temp=create();
     if(root==NULL){
         root=temp;
 	printf(""Element inserted successfully! \n"");
         }
     else{ 
         insert(root,temp);
         printf(""Element inserted successfully! \n"");
     }
     printf(""Do you want to enter more data? (y/n) "");
     getchar();
     scanf(""%c"", &ch);
  }while(ch=='y' || ch== 'Y');
  printf(""\nPreorder traversal using recursion\n"");
  preorderRecursive(root);
  printf(""\nPreorder traversal using iteration\n"");
  preorderIterative(root);
  getch();
  return 0;
 }
 
 struct BST *create(){
  struct BST *temp;
  printf(""Enter data: "");
  temp=(struct BST*)malloc(sizeof(struct BST*));
  scanf(""%d"", &temp->data);
  temp->left=NULL;
  temp->right=NULL;
  return temp;
 }
 
 void insert(struct BST *root, struct BST *temp){
  if(temp->data<root->data){
    if(root->left==NULL){
     root->left=temp;
    }
    else{
     root=root->left;
     insert(root, temp);
    }
  }
  else if(temp->data>root->data){
    if(root->right==NULL){
     root->right=temp;
    }
    else{
     root=root->right;
     insert(root, temp);
    }
  }
 }
 
 void preorderRecursive(struct BST *root){
     if(root!=NULL){
         printf(""%d "", root->data);
         preorderIterative(root->left);
         preorderIterative(root->right);
     }
 }
 
 void preorderIterative(struct BST* root)
 {
     while(root){
         if(root->left!=NULL){
             struct BST* node = root->left;
 			while(node->right && node->right != root){
 			    node=node->right;
 			}
 			if(node->right==root){
 				node->right=NULL;
 				root=root->right;
 			}
 			else{
 		        printf(""%d "", root->data);
 				node->right=root;
 				ro",C
"//Print the topological sort of directed acyclic graph
 #include <bits/stdc++.h>
 using namespace std;
 
 int main()
 {
     int n, m;
     cout << ""Enter the nodes and edges: \n"";
     cin >> n >> m;
     //For storing the graph in adjacency list
     vector<int> arr[n];
     //For storing the visited nodes
     vector<int> vis(n, 0);
     //For storing the indegree of nodes
     vector<int> indegree(n, 0);
     queue<int> q;
     cout << ""Enter the edges\n"";
     while (m--)
     {
         int a, b;
         cin >> a >> b;
         arr[a].push_back(b);
     }
     //Calculating indegree of nodes
     for (int i = 0; i < n; i++)
     {
         for (auto child : arr[i])
         {
             if (vis[child] == 0)
             {
                 indegree[child]++;
             }
         }
     }
     //Push the nodes with indegree 0 in queue
     for (int i = 0; i < n; i++)
     {
         if (indegree[i] == 0)
         {
             q.push(i);
         }
     }
     /*Implement bfs for each node in queue and as you visit
     the child node reduce its indegree and if its indegree is
     0 then push it inside queue */
     cout << ""Topological Sort-> "";
     while (!q.empty())
     {
         int node = q.front();
         cout << node << "" "";
         q.pop();
         for (int child : arr[node])
         {
             indegree[child]--;
             if (indegree[child] == 0)
                 q.push(child);
         }
     }
 }
 /*
 Sample Input Output :-
 Enter the nodes and edges: 
 6 6
 Enter the edges
 5 0
 4 0
 4 1
 3 1
 5 2
 2 3
 Topological Sort-> 4 5 0 2 3 1 
 
 Time Complexity : O( N+E) // Nodes and Edges
 Space Complexity : O( N+E )+O(N)
 */",C-Plus-Plus
"/**
 To find the Longest Common Subsequence of three
 strings using Bottom Up approach.
 */
 
 import java.util.Scanner;
 
 public class LCSThreeStrings {
 
 	private static void longestCommonSubsequeneceBottomUp(String a, String b, String c) {
 
 		int[][][] dp = new int[a.length() + 1][b.length() + 1][c.length() + 1];
 		
 		// for loop will start from last index of each string
 		// in case any of the three strings is empty then
 		// answer will be 0.
 		for (int i = a.length() - 1; i >= 0; i--) {
 			for (int j = b.length() - 1; j >= 0; j--) {
 				for (int k = c.length() - 1; k >= 0; k--) {
 
 					if (a.charAt(i) == b.charAt(j) && a.charAt(i) == c.charAt(k)) {
 						
 						dp[i][j][k] = 1 + dp[i + 1][j + 1][k + 1];
 						
 					} else {
 						int x = dp[i + 1][j][k];
 						int y = dp[i][j + 1][k];
 						int z = dp[i][j][k + 1];
 
 						dp[i][j][k] = Math.max(x, Math.max(y, z));
 					}
 				}
 			}
 		}
 
 		System.out.println(""Length of Longest Common Subsequence - "" + dp[0][0][0]);
 	}
 
 	public static void main(String[] args) {
 
 		Scanner sc = new Scanner(System.in);
 		
 		System.out.print (""Enter String A - "");
 		String a = sc.next();
 		System.out.print (""Enter String B - "");
 		String b = sc.next();
 		System.out.print (""Enter String C - "");
 		String c = sc.next();
 
 		longestCommonSubsequeneceBottomUp(a, b, c);
 	}    
 }
 
 /**
 Time Complexity  : O(A*B*C)
 Space Complexity : O(A*B*C)
 
 Input:
 
 Enter String A - adjkudg
 Enter String B - bsdkdefg
 Enter String C - dkelfudr
 
 Output:
 
 Length of Longest Common Subsequence - 3
 */
",Java
"
 #include <bits/stdc++.h> 
 using namespace std;
 typedef long long ll;
 typedef vector<ll> vl; 
 #define pb push_back 
 
 #define loop(x,n) for(ll x = 1; x <= n; ++x)
 
 //Adjacency List of Graph
 vl graph[100001];  
 
 bool vis[100001],onstack[100001];
 
 ll in[100001],low[100001];
 
 stack<ll> st;
 
 //scc=no. of strongly connected components
 ll timer=1,scc=0;  
 
 void dfs(ll source){
   vis[source]=1;
   //increase in time and low time
   in[source]=low[source]=timer++;  
   
   onstack[source]=true;
    // push into stack
   st.push(source);    
   
   for(auto child:graph[source]){
     if(vis[child]==true && onstack[child]==true)
         //change low time if back edge
           low[source]=min(low[source],in[child]);  
     
     else if(vis[child]==false){
        dfs(child);
     
       if(onstack[child]==true)
       //change low time if visited forward edge
        low[source]=min(low[source],low[child]);   
       }
   }
   
   //case for scc if in=low
   if(in[source]==low[source]){  
    scc++;
     cout<<""Strongly Connected Component #""<<scc<<"":\n"";
 
     ll s;
     while(1){
        s=st.top();
        //delete all elements from stack till it top element equal to scc node
        st.pop();          
        onstack[s]=false;
        
        cout<<s<<"" "";
        if(s==source) break;   
       
      }
     cout<<""\n"";
   }
     
 }
  
 int main() 
 { 
     ios_base::sync_with_stdio(false); 
     cin.tie(NULL); 
     
     ll n,m,a,b;
     //n=no. of vertices, m=no. of edges
     cin>>n>>m;     
     
     loop(i,m){
      cin>>a>>b;
      graph[a].pb(b);
      }
 
      loop(i,n){
         //initialise visited array as false;
      vis[i]=onstack[i]=false;    
      }
     
     loop(i,n){
        //dfs call
       if(vis[i]==false) dfs(i);  
     } 
     return 0; 
 }
 
 /*
 Input:
 First line contains two space separated integers,(n,m) 
 n- no of vertices, m- no of edges.
 Then m lines follow, each line has 2 space separated integers ui ,vi",C-Plus-Plus
"
 /* This is a Java program  to find the longest palindromicsubstring from a word using dynamic programming approach
 
 Pallindromic substring means a part of a word which reads the same backward as forward.
 There may be more than one pallindromic substring in a word but this program gives the longest pallindromic
 substring in terms of length.
 */
 import java.util.*;
  
 class PallindromicSubstr{
 
     public static String expandbothside(String str, int low, int high)
     {
         int len = str.length();
      
         // expand in both directions
         while (low >= 0 && high < len &&
             (str.charAt(low) == str.charAt(high))) {
                 low--;
                 high++;
             }
             return str.substring(low + 1, high);
     }
      
         
         public static String longestPallindromeSubstr(String str, int len)
         {
             // `max_str` stores the maximum length palindromic substring     
             String max_str = """", curr_str;
      
             // `max_length` stores the maximum length of palindromic     
             int max_len = 0, curr_len;
      
             for (int i = 0; i < len; i++)
             {
                 // find the longest odd length palindrome with `str[i]` as a midpoint
      
                 curr_str = expandbothside(str, i, i);
                 curr_len = curr_str.length();    
      
                 // update maximum length palindromic substring if odd length palindrome has a greater length
      
                 if (curr_len > max_len)
                 {
                     max_len = curr_len;
                     max_str = curr_str;
                 }
 
                 curr_str = expandbothside(str, i, i + 1);
                 curr_len = curr_str.length();
      
                 // update maximum length palindromic substring if even length palindrome has a greater length
      
                 if (curr_len > max_len)
                 {
                     max_len ",Java
"/*
 Given a number , check whether the number is power of 2 or not.
 We can check this by doing some bitwise operation. Bitwise operations are best because they perform the operation in least possible time.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 bool number_is_power_of_2(int number)
 {
     if((number & (number - 1)) == 0)
         return true;
     return false;
 }
 int main()
 {
     cout << ""Enter the number \n"";
     int number;
     cin >> number;
     bool solve = number_is_power_of_2(number);
     if(solve)
         cout << ""The Number is power of 2\n"";
     else
         cout << ""No. the number is not power of 2\n"";
 }
 /*
 Standard Input and Output
 
 Enter the number
 64
 The Number is power of 2
 
 Enter the number
 34
 No. the number is not power of 2
 
 Time Complexity : O(1)
 Space Complexity : O(1)
 
 */
",C-Plus-Plus
"# Importing sys module to initalize the maxsize
 import sys
 ''' Longest Common Subsequence '''
 
 '''Problem Statement :Given two sequences, find the length of
                       longest subsequence present in both of them.
                       Both the strings are of uppercase.
 '''
 # Assigning max value a variable can take
 INT_MAX = sys.maxsize - 1
 # Taking input of first string
 print(""Enter the first string:"")
 string_1 = input()
 print(""Enter the second string:"")
 string_2 = input()
 # Calculate the sizes of the strings
 x = len(string_1)
 y = len(string_2)
 # Constructing a table of size (x+1)*(y+1)
 table = [[0 for i in range ( y + 1 )] for j in range ( x + 1 )]
 # Memorization Apporach
 # Longest Common Subsequence function
 def  longestcommonsubsequence(string_1, string_2, x, y, table):
     for i in range(x + 1):
         for j in range(y + 1):
             if(i == 0 and j == 0):
                 table[i][j] = 0
             # Check if the letters at the given positions of the
             # strings are equal add 1 to the previously existing
             # max of lcs
             elif(string_1[i - 1] == string_2[j - 1]):
                 table[i][j] = table[i - 1][j - 1] + 1
             # If non of the given conditions are not fullfilled
             # then we will add the max previous of either table[i-1][j] or
             # table[i][j-1]
             else:
                 table[i][j] = max(table[i - 1][j], table[i][j - 1])
     return(table[x][y])
 
 max_seq = longestcommonsubsequence(string_1, string_2, x, y, table)
 
 # Printing the max sequence
 print(""The longest common subsequence is {}"".format(max_seq))
 ''' 
 Sample input:
     String 1 : djjradc
     String 2 : jwrwadfc
 Sample Output:
     The longest common subsequence is 5
 '''",Python
"/* Vigenere Cipher in C# */
 
 using System; 
       
 class Vigenere_Cipher  
 { 
     static String generateKey(String str, String key) 
     { 
         int x = str.Length; 
         for (int i = 0; ; i++) 
         { 
             if (x == i) 
                 i = 0; 
             if (key.Length == str.Length) 
                 break; 
             key+=(key[i]); 
         } 
         return key; 
     } 
   
     static String cipherText(String str, String key) 
     { 
         String cipher_text="""";     
         for (int i = 0; i < str.Length; i++) 
         { 
             int x = (str[i] + key[i]) %26;    
             x += 'A';     
             cipher_text+=(char)(x); 
         } 
         return cipher_text; 
     } 
   
     static String originalText(String cipher_text, String key) 
     { 
         String orig_text="""";     
         for (int i = 0 ; i < cipher_text.Length && i < key.Length; i++) 
         { 
             int x = (cipher_text[i] - key[i] + 26) %26; 
             x += 'A'; 
             orig_text+=(char)(x); 
         } 
         return orig_text; 
     } 
     
     public static void Main(String[] args)  
     { 
         String str;; 
         String word; 
         Console.WriteLine(""Enter a string:"");
         str = Console.ReadLine(); 
             
         Console.WriteLine(""Enter a pattern word:""); 
         word = Console.ReadLine(); 
             
         String key = generateKey(str, word); 
         String cipher_text = cipherText(str, key); 
     
         Console.WriteLine(""Ciphertext: "" + cipher_text); 
         Console.WriteLine(""Decrypted Text: "" + originalText(cipher_text, key)); 
     } 
 } 
 
 /* OUTPUT
 
 Enter a string:                                                                                                                               
 HACKINCODES                                                                                                                              
 Enter a pattern word:         ",C-Sharp
"# function to convert infix to postfix using array as stack
 def infix_to_postfix(infix_expression):
     # initially empty stack
     stack = []
     # initially empty postfix_expression
     postfix_expression = ''
     for char in infix_expression:
         # if an operand then put it directly in postfix expression
         if char not in operators:
             postfix_expression += char
         # else if operators should be put in stack
         elif char == '(':
             '''append function to push
             elements in the stack '''
             stack.append('(')
         elif char == ')':
             while stack and stack[-1] != '(':
                 postfix_expression += stack.pop()
             ''' pop function to pop
                 elements from stack in LIFO order '''
             stack.pop()
         else:
             '''if priority of char in infix_expression is less than or equal to
                 char at stack[-1] pop out and put in postfix_expression'''
             while stack and stack[-1] !=
             '(' and priorities[char] <= priorities[stack[-1]]:
                 postfix_expression += stack.pop()
             stack.append(char)
     while stack:
         postfix_expression += stack.pop()
     return postfix_expression
 
 # set of operators
 operators = set(['+', '-', '*', '/', '(', ')', '^'])
 # dictionary having priorities
 priorities = {'+': 1, '-': 1, '*': 2, '/': 2, '^': 3}
 print('Input:')
 infix_expression = input('Enter infix expression\n')
 print('Output:')
 # displaying the Output
 print('Postfix expression: ', infix_to_postfix(infix_expression))
 
 '''
 Input:
 Enter infix expression: A+C*(B^D-E)^(G+H*K)-J
 Output:
 Postfix expression:     ACBD^E-GHK*+^*+J-
 
 Time Complexity : O(n)
 Space Complexity: (n)
 '''
",Python
"
 def solve(board, i=0, j=0):
         i,j = nextCell(board, i, j)
         if i == -1:
                 return True
         for e in range(1,10):
                 if isValid(board,i,j,e):
                         board[i][j] = e
                         if solve(board, i, j):
                                 return True
                         board[i][j] = 0
         return False        
 
 def print_board(board):
     for i in range(len(board)):
         if i % 3 ==0 and i != 0:
             print(""------------------------"")
 
         for j in range(len(board[0])):
             if j % 3 ==0 and j !=0:
                 print(""|"",end="""")
 
             if j == 8:
                 print(board[i][j])
             else:
                 print(str(board[i][j]) + "" "" , end="""")  
 
 def nextCell(board, i, j):
         for x in range(i,9):
                 for y in range(j,9):
                         if board[x][y] == 0:
                                 return x,y
         for x in range(0,9):
                 for y in range(0,9):
                         if board[x][y] == 0:
                                 return x,y
         return -1,-1
 
 def isValid(board,x,y,n):
     for i in range(9):
         if board[x][i] == n or board[i][y] == n:
             return False
     new_x = x//3 * 3
     new_y = y//3 * 3
     for i in range(3):
         for j in range(3):
             if board[new_x + i][new_y + j] == n:
                 return False
 
     return True 
 
 if __name__ == ""__main__"":
     print(""Enter the numbers row by row, and put 0 for empty space:"")
     board = [[int(input()) for x in range (9)] for y in range(9)] 
     solve(board)  
     print_board(board)
     """"""
     Let's say we have this board: Empty space is replaced with 0. 
                     [[5, 3, 0, 0, 7, 0, 0, 0, 0],
                    [6, 0, 0, 1, 9, 5, 0, 0, 0], 
                    [0, 9, 8, 0, 0, 0, 0, 6, 0],
                    [8, 0, 0, 0, 6, 0, 0, 0, 3],
                    [4, 0, 0,",Python
"/*
 Description : 
         Given an array and rotate it by one position in clock-wise direction.
 */
 
 #include <iostream>
 using namespace std;
 
 //function is used to rotate the array
 void rotate(int a[], int n)
 {
     int x = a[n - 1];
     //starting the loop from backside of array
     for (int i = n - 1; i > 0; i--)
     {
         a[i] = a[i - 1];
     }
     //storing first element in x
     a[0] = x;
 }
 
 int main()
 {
     int n;
     cout << ""Enter the size of an array : "" << endl;
     cin >> n;
     int a[n];
     cout << ""Enter "" << n << "" number of elements : "" << endl;
     for (int i = 0; i < n; i++)
     {
         cin >> a[i];
     }
     cout << ""Cyclically rotate of an array by one : "" << endl;
     rotate(a, n);
     //printing array
     for (int i = 0; i < n; i++)
     {
         cout << a[i] << "" "";
     }
     return 0;
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Case :
 Test Case 1 :
    Input :
    Enter the size of an array : 
    4
    Enter  4 number of elements : 
    1
    2
    3
    4
 
    Output :
    Cyclically rotate of an array by one : 
    4 1 2 3
 Test Case 2 :
    Input :
    Enter the size of an array : 
    8
    Enter 8 number of elements : 
    9 
    8 
    7
    6
    4 
    2 
    1 
    3
 
    Output :
    Cyclically rotate of an array by one : 
    3 9 8 7 6 4 2 1
 */
 
",C-Plus-Plus
"/*  
 
 QUEUE USING STACKS
 A queue can be implemented using 2 stacks.
 
 Enqueue operation proceeds by:
 Popping second stack and pushing into first stack
 till second stack becomes empty. New value is then
 pushed into the first stack.
 
 Dequeue operation proceeds by:
 Popping first stack and pushing into second stack
 till first stack becomes empty. Thus first element
 appears at the top of second stack. Second stack is
 then popped.
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //structure for stack
 typedef struct Stack
 {
     int data;
     struct Stack *next;
 } Stack;
 
 //to push into stack
 void push(Stack *s, int data)
 {
 
     Stack *ptr, *top=s->next;
     ptr = new Stack;
     ptr->data = data;
     ptr->next = top;
     top = ptr;
     s->next = top;
 }
 
 //to delete from stack
 int pop(Stack *s)
 {
     //if stack is not empty
     if (s->next != NULL)
     {
         Stack *top = s->next;
         Stack *ptr = top;
         int i = top->data;
         top = top->next;
         free(ptr);
         s->next = top;
         return i;
     }
     return -1;
 }
 
 //to display elements of stack
 void display(Stack *s)
 {
     Stack *top = s->next;
     Stack *ptr = top;
     //if stack is empty
     if (top == NULL)
         return;
     else
     {
         while (ptr != NULL)
         {
             printf(""%d "", ptr->data);
             ptr = ptr->next;
         }
     }
     printf(""\n"");
 }
 
 //to insert into queue
 void enqueue(int n,Stack *s1,Stack *s2)
 {
     while (s2->next != NULL)
         push(s1, pop(s2));
     push(s1, n);
 }
 
 //to delete from queue
 void dequeue(Stack *s1,Stack *s2)
 {
     while (s1->next != NULL)
         push(s2, pop(s1));
     //if queue is empty
     if (s2->next == NULL)
         printf(""Deletion not possible\n"");
     else
         pop(s2);
 }
 
 //to display queue contents
 void display_queue(Stack *s1,Stack *s2)
 {
     while (s1->next)
         push(s2, pop(s1));
     if (s2->next == NULL)
   ",C-Plus-Plus
"/*
 Given a Number. Find it's Number of Divisors.
 
 The Number can be big such as 10^6 to 10^9
 So, If we do this in O(N) we will get Time Limit Exceeded [TLE]
 Better Approach is run a loop till sqrt(Number)
 Example square root of 10^9 is 31622 (approx), so iteration optimized a lot.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // this get_number_of_divisors will count the number of divisors of the number
 int get_number_of_divisors(int Number)
 {
     int number_of_divisors = 0;
     int limit = (int) sqrt(Number);
     for(int i = 1; i < limit; i++)
     {
         if(Number % i == 0)
         {
             /* Here i is a divisor of that number
             ( Number / i ) is also a divisor
             */
             number_of_divisors += 2;
         }
     }
 
     if(Number % limit == 0)
     {
         if(limit * limit == Number)
         {
             //means perfect square number
             number_of_divisors++;
         }
         else
         {
             number_of_divisors += 2;
         }
     }
     return number_of_divisors;
 }
 
 int main()
 {
     cout << ""Enter the number : \n"";
     int Number;
     cin >> Number;
     int number_of_divisors = get_number_of_divisors(Number);
     cout << ""Number of Divisors of this Number is : "";
     cout << number_of_divisors << endl;
 }
 
 /*
 Standard Input and Output
 
 Enter the number :
 1000000000
 Number of Divisors of this Number is : 100
 
 Enter the number :
 4567323
 Number of Divisors of this Number is : 16
 
 Time Complexity : O( sqrt(N) )
 Space Complexity : O( 1 )
 
 */
",C-Plus-Plus
"/******************************************************************************
 
 Author - @Suvraneel 
         Suvraneel Bhuin
 
 *Luhn's Algorithm for credit card validation*
 
 A credit card number consists of 16 decimal digits. The first (leftmost) digit corresponds to the type of the
 card (4 for VISA cards, 5 for MASTERCARDs, 3 for Diners Club and American Express cards, and so on).
 The next 6 digits correspond to the number of the bank that issues the card. The next 8 digits constitute the
 account number of the card-holder. The last (rightmost) digit is a check digit that determines whether the
 credit card number is valid or not. In order to determine the check digit, a checksum is computed as follows.
 We first add the digits at the even positions (that is, the second, fourth, sixth, ... , sixteenth digits) of the card
 number. Next, each digit in an odd position is doubled. If the doubled value exceeds 9, then the two digits
 are added. Finally, these doubled digits (after adjustment of 2-digit values) are added to the checksum. The
 check digit is so chosen that the checksum is a multiple of 10. Here is an example.
 Card Number   5        9   8         7   6         5   4   0   2   4   6         8   1   3   5         5
 Step 1        10       9   16        7   12        5   8   0   4   4   12        8   2   3   10        5
 Step 2        1+0 = 1  9   1+6 = 7   7   1+2 = 3   5   8   0   4   4   1+2 = 3   8   2   3   1+0 = 1   5
 
 Checksum = 1 + 9 + 7 + 7 + 3 + 5 + 8 + 0 + 4 + 4 + 3 + 8 + 2 + 3 + 1 + 5 = 70
 
 Since the checksum is divisible by ten, 5987654024681355 is a valid credit card number. Write a program
 that, upon input a 16-digit credit card number, determines whether the card number is valid. A 16-digit
 integer cannot be accommodated in a long int variable, so read the input as a string (a character array).
 *******************************************************************************/
 
 #include <stdio.h>
 //header for string operations",C
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# SOLAR RADIATION PREDICTION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the dataset: https://www.kaggle.com/dronio/SolarEnergy""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import numpy as np\n"",
     ""import matplotlib.pyplot as plt\n"",
     ""import seaborn as sns\n"",
     ""sns.set()\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.linear_model import LinearRegression\n"",
     ""from sklearn.metrics import r2_score\n"",
     ""from sklearn import preprocessing\n"",
     ""import tkinter as tk \n"",
     ""from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting our Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n"",
        ""<table border=\""1\"" class=\""dataframe\"">\n"",
        ""  <thead>\n"",
        ""    <tr style=\""text-align: right;\"">\n"",
        ""      <th></th>\n"",
        ""      <th>UNIXTime</th>\n"",
        ""      <th>Data</th>\n"",
        ""      <th>Time</th>\n"",
        ""      <th>Radiation</th>\n"",
        ""      <th>Temperature</th>\n"",
  ",Python
"/*
 Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering
 of vertices such that for every directed edge uv, vertex u comes before v in
 the ordering. Topological Sorting for a graph is not possible if the graph is
 not a DAG.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 vector<vector<int>> adjList;
 stack<int> s;
 bool *visited;
 
 // Number of Test Cases (Vertices)
 int n;
 
 void createGraph()
 {
     int x, y;
     adjList.resize(n);
 
     for (int j = 0; j < n; j++)
     {
         cin >> x >> y;
         adjList[x].push_back(y);
     }
 }
 
 void topoSortFun(int i)
 {
     visited[i] = true;
     for (int j = 0; j < adjList[i].size(); j++)
     {
         int key = adjList[i][j];
         if (!visited[key])
             topoSortFun(key);
     }
     s.push(i);
 }
 
 void topoSort()
 {
     memset(visited, false, sizeof(visited));
 
     for (int i = 0; i < n; i++)
     {
         if (!visited[i])
             topoSortFun(i);
     }
 }
 void display()
 {
     for (int i = 0; i < n; i++)
     {
         cout << s.top() << "" "";
         s.pop();
     }
 }
 int main()
 {
     cin >> n;
     visited = new bool[n];
     createGraph();
     topoSort();
     display();
 }
 
 /*
     Test Case:
 
     Input 1 :
     6
     5 2 
     5 0 
     4 0 
     4 1 
     2 3 
     3 1 
 
     Output 1 :
     5 4 2 3 1 0 
 
     Input 2 :
     6
     4 2
     5 1
     4 0
     3 1
     1 3
     3 2
 
     Output 2 : 
     5 4 1 3 2 0 
 
     Time Complexity: O(V + E)  where V is the number of vertices and E is the number of edges.
 
     Space Complexity: O(V)
 */
",C-Plus-Plus
"''' Monoalphabetic substitution cipher basically replaces each letter of a plaintext by another
     letter or symbol, depending only on the letter. The same plaintext letter is always replaced
     by the same ciphertext letter and the same letter can be replaced by letter itself.
     Example if a is there we replace it with B to Z .....so on.'''
 
 '''This is the encryption function which takes planetext
    as input and returns us the ciphertext list.''' 
 def monoalphabeticcipher(plaintext,size):
    
    output = ['']*size
    #This is the cipher list we use to encrypt the message 
    cipherer = ['Z','Y','X','W','V','U','T','S','R','Q','P','O','N','M','L','K','J','I','H','G',
    'F','E','D','C','B','A'];
    list = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o','p', 'q',
    'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']
    
    space = ' '   
    
    '''We iterate through the plaintext given to us an find out
       what letter it is and then we use the list called cipherer
       to replace that letter. We keep the space as space in output'''              
    for i in range(size):   
       for j in range(26):
         if plaintext[i] == list[j] :
            output[i] = cipherer[j];
         elif plaintext[i] == space :
            output[i] = space;    
    
    #return the encrypted message
    return output
   
 if __name__ == '__main__':
    
    #we take the plaintext input here
    plaintext = input(""Enter the plaintext here :"")
    size = len(plaintext)
   
    '''calling the monoalphabeticcipher function on the given plaintext
       to return the encrypted message'''
    encrypted_message = monoalphabeticcipher(plaintext,size)
    
    #printing the ciphertext we got using the monoalphabetic function
    print(""Encripted plaintext is :"","""".join(encrypted_message))
 
 '''
    Sample I/O :
 
    a)Case where plaintext has space :
     
    Enter the plaintext here :hello world
    Encripted plaintext is : SVOOL DLIOW 
 ",Python
"/*
 Given a sorted array and a value x, find the floor of x in the array.
 The floor of x is the largest element in array smaller than or equal to x.
 The function shows the implementation of the function, using binary search. 
 */
 
 import 'dart:io';
 
 int findFloor(List arr, int n, int x) {
   // Initializing low and high indices
   int low = 0;
   int high = n - 1;
 
   // Initialinzing floor value
   int floor_val = -1;
 
   // Applying binary search
   while (low <= high) {
     // Finding the mid index
     int mid = ((low + high) / 2).floor();
 
     // If the mid index element is equal to the given element
     if (arr[mid] == x) {
       return arr[mid];
     }
 
     // If given element is less than mid index element, 
     // performing search on the left of mid index
     if (x < arr[mid]) {
       high = mid - 1;
       continue;
     }
 
     // If given element is greater than mid index element, 
     // performing search on the right of mid index
     if (x > arr[mid]) {
       floor_val = arr[mid];
       low = mid + 1;
       continue
     }
   }
 
   return floor_val;
 }
 
 main() {
   // Taking user input
   var array = [];
 
   var n, ele, x;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
   array.sort();
   print('The sorted array entered is: $array');
 
   print('Enter a number X: ');
   x = stdin.readLineSync();
   x = int.parse(x);
 
   // Calling function to obtain the required results
   int floor = findFloor(array, n, x);
   print(""Floor of $x is : $floor"");
 }
 
 /*
 TIME COMPLEXITY: O(log N)
 SPACE COMPLEXITY: O(1)
 
 SAMPLE I/O:
 Enter the number of Elements: 
 7
 Enter Element 1: 
 1
 Enter Element 2: 
 2
 Enter Element 3: 
 8
 Enter Element 4: 
 8
 Enter Element 5: 
 18
 Enter Element 6: 
 27
 Enter Element 7: 
 35
 The sorted array",Dart
"/*
 Given total number of nodes in an undirected graph
 numbered from 1 to n [ number of nodes] and total number of edges in the graph.
 Find  minimum distance of each node using SSSP (Single Source Shortest Path) on trees
 by DFS.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 vector < int > adj[10009];
 int visited[10009];
 int distance_array[10009];
 
 // this function will print the minimum distance
 void print_minimum_distance_of_each_nodes(int nodes)
 {
     for(int i = 1; i <= nodes; i++)
     {
         cout << distance_array[i] << ' ';
     }
     cout << endl;
 }
 
 // this dfs function will visit the nodes
 void dfs(int node, int dist)
 {
     /* for each node we will put  visited[node] = 1
     means that node is visited
     and put distance_array[node] = dist means current distance.
     and then recursively will visit the
     adjacency vector
      */
     visited[node] = 1;
     distance_array[node] = dist;
     for(auto child : adj[node])
     {
         if(visited[child] == 0)
         {
             // will update the distance each step
              dfs(child , distance_array[node] + 1);
         }
     }
 
 }
 
 int main()
 {
     cout << ""Enter the nodes and edges of the graph :\n"";
     int nodes, edges;
     cin >> nodes >> edges;
     cout << ""Enter the start and end points that have edges \n"";
     for(int i = 1; i <= edges; i++)
     {
         int point1, point2;
         cin >> point1 >> point2;
         adj[point1].push_back(point2);
         adj[point2].push_back(point1);
 
     }
     /* here dfs call(1, 0)
     from 1th node distance is 0
     */
     dfs(1, 0);
 
     cout << ""Minimum Distance of Each Nodes: \n"";
     print_minimum_distance_of_each_nodes(nodes);
 }
 
 /*
 Standard Input and Output
 
 Enter the nodes and edges of the graph :
 6 5
 Enter the start and end points that have edges
 1 2
 1 3
 1 4
 2 5
 2 6
 
 Minimum Distance of Each Nodes:
 0 1 1 1 2 2
 
 Time Complexity : O( E + N) // Edges and Nodes
 Space Com",C-Plus-Plus
"/*
    The Playfair cipher( Playfair square ) encrypts pairs of letters (digraphs),
    instead of single letters as in the simple substitution cipher. The Playfair
    is thus significantly harder to break since the frequency analysis used for 
    simple substitution ciphers does not work with it.
 */
 
 package main
 
 import (
 
   ""fmt""
   ""bufio""
   ""os""
 
 )
 
 // Global variables
 var plaintext string
 var key string
 var keyMatrix[5][5] string
 var output string
 var list[4] int
 var alph string = ""abcdefghijklmnopqrstuvwxyz""
 
 //This function will form the 5x5 key Matrix 
 func keyTable() {
 
      i:=0
      j:=0
      c:=0
      var index[26] int;
 
      //initializing the array to 0 as it stores garbage values
      for z:=0;z<26;z++ {
          index[z] = 0;
      }
 
      var hash[100] int;
      //marking the alphabets in key
      for i=0;i<len(key);i++ {
          if(key[i] != 'j'){
             for j=0;j<26;j++ {
                 if(key[i] == alph[j]){
                    index[j] = 2;
                    hash[c] = j;
                    c++;
                 }
             }
          }
      }
 
      //marking alphabetic j
      index[9] = 1;
      i = 0;
      j = 0;
 
      //adding the marked alphabets  
      for k:=0;k<len(key);k++ {
          if(index[hash[k]] == 2) {
             index[hash[k]] -= 1;
             keyMatrix[i][j] = string(key[k]);
             j++;
 
             if(j==5){
               i++;
               j=0;
             }
          }
      }
 
      //adding the remaining alphabets
      for  k:=0;k<26;k++ {
          if(index[k] == 0){
             keyMatrix[i][j] = string(alph[k]);
             j++;
 
             if(j==5){
                i++;
                j=0;
             }
          }
      }
 }
 
 /* This function searches for the characters of the digraph in key matrix
    generated and gives their position*/
 func search(x,y string) {
 
      //replacing j with i   
      if(x == ""j'"") {
          x = ",Go
"// C++ program to reverse the bits of a number
 
 /*
 Given an integer, reverse its bits in its binary equivalent and 
 print the new number obtained in its decimal form
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /*
 The code first stores the lsb of the given number in a variable and then left shifts
 the given number and gives this number to the lsb of the answer variable and then right
 shifts it
 */
 int reverse_bits(int n)
 {
 
     int rev = 0, rem;
 
     // Traverse while there exist bits for the given number
     while (n)
     {
         // Shift the bit of the reversed(answer) number to the right
         rev = rev << 1;
         //Stores the temporary lsb of the given number
         rem = n & 1;
         //Set the lsb of the answer variable with the stored value
         rev = rem | rev;
         //Drops the already processed lsb of the given number
         n = n >> 1;
     }
     return rev;
 }
 
 int main()
 {
     int n, ans;
     cout << ""\nEnter the number? "";
     cin >> n;
 
     //Call the function
     ans = reverse_bits(n);
     cout << ""The bits-reversed number is: "" << ans << endl;
     return 0;
 }
 
 /*
 
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 39
 The bits-reversed number is: 57
 
 */
",C-Plus-Plus
"/*
 Given an array of N elements.
 Find MEX ( Minimum Excluded Element ) of input array.
 
 Mex of an array is the minimum positive integer that doesn't appear in this array.
 For example, MEX of the array containing 1, 3 and 4 is equal to 2.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // this get_MEX_of_array function will give us MEX of input array
 int get_MEX_of_array(int ar[],int N)
 {
     /* will insert array's elements into the set
     as set contain unique values in ascending order
     */
     set < int > mex_find;
     for(int i = 0; i < N; i++)
     {
        mex_find.insert(ar[i]);
 
     }
     // set MEX as 1
     int MEX = 1;
     for(auto i : mex_find)
     {
         /* if current element of Set is equal to MEX
         we will increment MEX by 1
         and if current element of Set is greater to MEX
         means we have got our MEX.
         */
         if(i == MEX)
         {
             MEX++;
         }
         else if(i > MEX)
         {
             //we have got our MEX
             break;
         }
     }
     return MEX;
 }
 
 int main()
 {
     cout << ""Enter the size of the array : \n"";
     int N;
     cin >> N;
     int ar[N + 1];
     cout << ""Enter array elements :\n"";
     for (int i = 0; i < N; i++)
     {
 	    cin >> ar[i];
     }
     int MEX_of_array = get_MEX_of_array(ar , N);
     cout << ""MEX of the Array is : \n"";
     cout << MEX_of_array << endl;
 
 }
 /*
 Standard Input and Output
 
 Enter the size of the array :
 8
 Enter array elements :
 8 2 7 4 6 2 1 4
 
 MEX of the Array is :
 3
 
 Time Complexity : O( logN )
 Space Complexity : O(N)
 
 */
",C-Plus-Plus
"/*
 Description : 
             Given a doubly linked list, rotate the linked list counter-clockwise by N nodes. 
             Here N is a given positive integer and is smaller than the count of nodes in linked list.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // base data
 struct Node
 {
     char data;
     struct Node *prev;
     struct Node *next;
 };
 //function to rotate the dll from n point
 void rotate_from_n(struct Node **head_ref, int N)
 {
     if (N == 0)
         return;
 
     struct Node *current = *head_ref;
 
     int count = 1;
     while (count < N && current != NULL)
     {
         current = current->next;
         count++;
     }
 
     if (current == NULL)
         return;
 
     struct Node *NthNode = current;
 
     while (current->next != NULL)
         current = current->next;
 
     //changing the link
     current->next = *head_ref;
     (*head_ref)->prev = current;
     *head_ref = NthNode->next;
     (*head_ref)->prev = NULL;
 
     NthNode->next = NULL;
 }
 //adding new node to the dll
 void push_data(struct Node **head_ref, int new_data)
 {
     struct Node *new_node = new Node;
     new_node->data = new_data;
     new_node->prev = NULL;
     new_node->next = (*head_ref);
     if ((*head_ref) != NULL)
         (*head_ref)->prev = new_node;
     *head_ref = new_node;
 }
 // printing the node in a pattern
 void print_data(struct Node *node)
 {
     while (node->next != NULL)
     {
         //adding the pattern
         cout << node->data << "" ""
              << ""<=>""
              << "" "";
         node = node->next;
     }
     cout << node->data;
 }
 
 int main(void)
 {
     //size of the list
     int x;
     cout << ""Enter the size : "" << endl;
     cin >> x;
 
     struct Node *head = NULL;
     //N= the point of rotation
     int N;
     cout << ""Enter the rotation point : "" << endl;
     cin >> N;
     cout << ""Enter the data in reverse order : "" << endl;
     for (int i = 0; i < x; i++)
     {
         char z;
    ",C-Plus-Plus
"import java.util.*;
 
 class ManacherAlgorithm {
 
     public static String manacherSearch(String str) {
 
         // array for holding the palindromic sequence around every center
         ArrayList<Integer> positions = new ArrayList<Integer>();
         int start = 0;
         int end = 0;
 
         // i is our current center
         for (int i = 0; i < str.length();) {
 
             // we check on both sides of i till where we can find same letters on 2
             // positions
             while (start > 0 && end < str.length() - 1 && str.charAt(start - 1) == str.charAt(end + 1)) {
                 start--;
                 end++;
             }
 
             // getting the length of palindrome around current center
             positions.add(i, end - start + 1);
 
             // this is case 2. Current palindrome is proper suffix of input. Meaning input
             // is the longest palindrome
             if (end == (str.length() - 1)) {
                 break;
             }
 
             // Mark newCenter to be either end or end + 1 depending on if we dealing with
             // even or old number input.
             int newCenter = end + (i % 2 == 0 ? 1 : 0);
 
             for (int j = i + 1; j <= end; j++) {
 
                 // Its possible left mirror might go beyond current center palindrome. So take
                 // minimum of either left side palindrome or distance of j to end.
                 // T[j] = Math.min(T[i - (j - i)], 2 * (end - j) + 1);
                 positions.add(j, (Math.min(positions.get(i - (j - i)), 2 * (end - j) + i)));
 
                 // This check is to make sure we do not pick j as new center. As soon as we find
                 // a center lets break out of this inner loop.
                 if (j + positions.get(i - (j - i)) / 2 == end) {
                     newCenter = j;
                     break;
                 }
             }
 
             // make i as newCenter. Set right and left to atleast the v",Java
"/**
  * Given an array of type positive integers, having ith element as feet and ith + 1 element as inches.
  * Eg: considering arr = [1,2] where 1 equals to feet and 2 equals to inches.
  * Find the maximum height, where height is calculated sum of feet and inches after converting feet into inches.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int max_height_in_array(std::vector<int>, int);
 
 int max_height_in_array(std::vector<int> arr, int size)
 {
     int max = 0;
     // check for even size.
     if ((size & 1) == 0)
     {
         for (int i = 0; i < size; i = i + 2)
         {
             if (((arr[i] * 12) + arr[i + 1]) > max)
             {
                 max = ((arr[i] * 12) + arr[i + 1]);
             }
         }
         // check for odd size.
     }
     else
     {
         for (int i = 0; i < (size - 1); i = i + 2)
         {
             if (((arr[i] * 12) + arr[i + 1]) > max)
             {
                 max = ((arr[i] * 12) + arr[i + 1]);
             }
         }
 
         // special check for last remaining element at odd th index.
         if ((arr[size - 1] * 12) > max)
         {
             max = (arr[size - 1] * 12);
         }
     }
     return (max);
 }
 
 int main()
 {
     int test_cases, size, ele;
     std::cout << ""Enter test cases : "" << std::endl;
     std::cin >> test_cases;
 
     while (test_cases--)
     {
         std::vector<int> arr;
         std::cout << ""Enter the size of an array : "" << std::endl;
         std::cin >> size;
 
         std::cout << ""Enter the elements in an array : "" << std::endl;
         for (int i = 0; i < size; i++)
         {
             std::cin >> ele;
             arr.push_back(ele);
         }
 
         int result = max_height_in_array(arr, size);
         std::cout << ""Maximum height in the given array is : "" << result
                   << std::endl;
     }
     return (0);
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Case ;
   Input:
   Ente",C-Plus-Plus
"/* Find Subarray of an array with given sum in O(n) time.
 
 Input :
 arr[]={1,4,20,3,10,5} ; sum=33
 Output :
 Sum found between indexes 2 and 4
  * 
  */
 // to find Subarray of an array with given sum in O(n) time
 import java.util.*;
 class Subarray {
     public static void findsubarray(List < Integer > arr, int sum) {
         int startindex = 0, endindex = 0, tempsum = 0;
         boolean flag = true;
         while (tempsum != sum) {
             if (tempsum < sum) {
                 tempsum += arr.get(endindex);
                 endindex += 1;
             } else if (tempsum > sum) {
                 tempsum -= arr.get(startindex);
                 startindex += 1;
             }
             if (endindex == arr.size()) {
                 flag = false;
                 tempsum = sum;
             }
 
         }
         if (flag)
             System.out.println(""Sum found between indexes "" + startindex + "" and "" + (endindex - 1));
         else
             System.out.println("" No such subarray found"");
     }
     public static void main(String args[]) {
         Scanner sc = new Scanner(System.in);
         List < Integer > arr = new ArrayList < > ();
         System.out.print(""Enter sum : "");
         int sum = sc.nextInt();
         System.out.println(""Enter elements of array"");
         while (sc.hasNextInt())
             arr.add(sc.nextInt());
         //System.out.println(arr);
         findsubarray(arr, sum);
 
     }
 }
 
 /* Sample Input and Output : 
  * Enter sum : 33
 Enter elements of array
 1 4 20 3 10 5
 Sum found between indexes 2 and 4
 Enter sum : 33
 Enter elements of array
 1 4 20 3 20 5
 No such subarray found
 
 Time Complexity : O(n)
 Space Complexity : O(1)
  */
",Java
"# Logarithm Algorithm (ln)
 
 """"""
 An algorithm that demonstrates how to approximately calculate the \
 natural algorithm of a value and show how this logarithm is \
 dependent on Inverse hyperbolic functions.
 """"""
 
 def conv_if_neg(x):
     """"""Returns abs of x if it's negative""""""
     if x < 0:
         return abs(x), True
     return x, False
 
 # Inverse Hyperbolic Functions return angles in radian form
 def artanh(val):
     """"""Returns Inverse Hyperbolic Tan of x""""""
     # artanh(-x) = -1 * artanh(x)
     val, neg_flag = conv_if_neg(val)
     if val > 1:  # Domain: [-1,1]
         return ""Domain error"" 
     # Taylor series
     res = 0
     for i in range(1, 92, 2):
         res += val**i/i
     if neg_flag:  # Check negative flag
         res *= -1
     return res  # Radian angle
 
 def ln(x):
     """"""Returns the natural algorithm of x""""""
     # Use fact: ln(x) = 2 * artanh((x-1) / (x+1))
     x = (x-1) / (x+1)
     return 2 * artanh(x)
 
 # Start Checkpoint
 if __name__ == ""__main__"":
     x = float(input(""ln(x), x? > ""))
     # ln(x) domain: ]0,inf[
     if x <= 0:
         print(""Domain error, x must be bigger than 0"")
     else:
         print(ln(x))
 
 """"""
 Steps:
 =======
 It all depends on some expansion facts which are:
     1) ln(x) = 2 * artanh((x-1) / (x+1))
     2) artanh(x) = val + val**3/3 + val**5/5 + ...
     3) artanh(-x) = -1 * artanh(x)
 
 The approach to calculate the natural algorithm is using artanh Taylor's series.
 Here the accuracy of the results decreases as x increases, but deviation can be \
 overcome by increasing the number of terms of artanh Taylor series. Using 46 terms we can \
 assure that correct values can be obtained up to x=300, if x was bigger than this, decimal \
 deviations can be noticed. but by increasing the number of terms of artanh Taylor's series \
 accuracy will increase.
 
 The most efficient way to calculate such function is using the CORDIC algorithms, but these \
 cannot be implemented without the help of th",Python
"# Python code for maximum water Container
 
 
 def maxArea(A):  # Function to find Maximum Area
     start = 0
     end = len(A) - 1
     area = 0
 
     while start < end:
         # Calculating the max area
         area = max(area, min(A[start], A[end]) * (end - start))
 
         if int(A[start]) < int(A[end]):
             start += 1
         else:
             end -= 1
     return area
 
 
 # Driver code
 print(""Input-->"")
 # number of elemetns as input
 size1 = int(input("" Enter the a size :\n""))
 size2 = int(input("" Enter the b size :\n""))
 a = []
 b = []
 # iterating till the range
 print("" Enter the elements of a container :"")
 for i in range(0, size1):
     ele1 = int(input())
 
     a.append(ele1)  # adding the element
 print("" Enter the elements of b container :"")
 for j in range(0, size2):
     ele2 = int(input())
 
     b.append(ele2)  # adding the element
 print(""Output-->"")
 # displaying the Output
 A = int(maxArea(a))
 B = int(maxArea(b))
 if A > B:
     print(""Container a with more area contain more water i.e "" + str(A))
 else:
     print(""Container b with more area contain more water i.e "" + str(B))
 """"""
  Input-->
  Enter the a size : 4
  Enter the b size : 5
  Enter the elements of a container :
  1 5 4 3
  Enter the elements of b container :
  3 2 1 4 5
  Output-->
  Container b contain more water i.e 12
 
  Time Compelxity: O(n) where n is size of array.
  Space Complexity: O(1).
  No extra space is required, so space complexity is constant
 """"""
",Python
"'''
 Python Program to calculate prime factorization of a number n in O(Log n) time complexity using sieve. 
 '''
 import math
   
 Max_Num = 10001
   
 small_prime_factor = [0 for num in range(Max_Num)] # smallest prime factor for every number 
 
 def sieve(): 
 
     ''' Function that calculates Smallest Prime Factor for every number till Max_Num. '''
 
     
     for num in range(1, Max_Num):# smallest prime factor for every number is the number itself
         small_prime_factor[num] = num
   
   
         if(num % 2 == 0):# smallest prime factor of every even number is 2
            
           small_prime_factor[num] = 2 
   
     for num in range(3, math.ceil(math.sqrt(Max_Num))): 
                 
         if (small_prime_factor[num] == num): # checks if num is a prime number
                          
             for num1 in range(num^2, Max_Num, num): # small prime factors for all numbers divisible by num.                  
                
                 if (small_prime_factor[num1] == num1): 
                     small_prime_factor[num1] = num # marking small_prime_factor[num1]
   
 
 def get_factorization(element): # function definition
 
     '''
     Function that calculates prime factors by dividing by smallest  
     prime factor at every step.
     Params: element (input)
     returns: factors
     
     '''
     factors1 = set() # adding factors to set: factors1 to avoid duplicates
 
     while (element != 1): 
 
         factors1.add(small_prime_factor[element]) 
 
         element = element // small_prime_factor[element] # floor divison
 
     factors= list(factors1) # converting set to list to access the elements of the set
     return factors
   
 if __name__ == ""__main__"": 
 
   ''' Main function that runs functions: sieve and get_factorization '''
   
   sieve() # Calculates Smallest Prime Factor 
 
   element = int(input(""Enter the number to find prime factors for:""))
 
   print(""Prime factors of"",element, "":"",end = """") 
 
   y = get_fa",Python
"/*
 
 Comb sort is a sort of improvment over the bubble sort. Rather than comparing adjacent values, it starts with a gap of size more than 1,
 & then it shrinks by a factor of 1.3 for every iteration until it reaches the value 1.
 
 Time Complexity - 1) Average -> O(N^2/2^m) where,
                                 m is the number of increments
                   2) Best -> O(n log n)
                   3) Worst -> O(n^2)
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Calculate the gap factor
 function getGap(gap) {
   gap /= 1.3;
 
   if (gap < 1) return 1;
   return gap;
 }
 
 // Perform the comb sort
 function combSort(array) {
   let gap = array.length;
   let swap = true;
 
   // While the gap condition
   while (gap !== 1 || swap === true) {
     gap = getGap(gap);
 
     swap = false;
 
     // Compare elements & swap them accordingly
     for (let i = 0; i < array.length - gap; i++) {
       if (array[i] > array[i + gap]) {
         [array[i], array[i + gap]] = [array[i + gap], array[i]];
         swap = true;
       }
     }
   }
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered value is number or not
   if (array.includes(NaN)) return console.log(""Only numbers are allowed"");
 }
 
 console.log(""Your array - "", array);
 
 // Call the algorithm
 combSort(array);
 console.log(""Sorted array"", array);
 
 // Sample I/O
 
 /*
 
 > Node CombSort
 
 Enter array length - 6
 Enter 1 element - 30
 Enter 2 element - 89
 Enter 3 element - 76
 Enter 4 element - 21
 Enter 5 element - 55
 Enter 6 element - 62
 Your arra",JavaScript
"/*Problem Statement:
 You are given a string containing numbers, the task is to print all the unique permutations 
 that are possible excluding the string that was entered by the user,that is the entered combination
 of characters entered as string shouldn't be printed. */
 #include<bits/stdc++.h>
 using namespace std;
 
 char temp[1000];
 set<string>s;
 void permute(string in, int i)
 {
     if(in[i]=='\0')
     {
       s.insert(in); 
       return;
     }
 
     for(int j=i;in[j]!='\0';j++)
     {
        swap(in[i],in[j]);
        permute(in,i+1);
     }
 
 
 }
 int main()
 {
    string in;
    cout<<""Enter string: ""<<endl;
    cin>>in;
    string temp;
    temp=in;
    permute(in,0);
    set<string> :: iterator itr;
    cout<<""all distinct permutations are: ""<<endl;
 
    for(itr=s.begin();itr!=s.end();itr++)
    {
      if(*itr>temp)
      {
          cout<<*itr<<endl;
      }
    }
    return 0;
 }
 /*Example:
 Input:-
 Enter string:
 112
 Output:-
 all distinct permutations are:
 121
 211 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
"/*
 What is Quick Sort?
 
 Quick Sort algorithm follows Divide and Conquer approach.
 It divides elements into smaller parts based on some condition and
 performing the sort operations on those divided smaller parts.
 
 Time Complexity : O(N*logN)
 */
 
 var items = [5,3,7,6,2,9];
 function swap(items, leftIndex, rightIndex){
     var temp = items[leftIndex];
     items[leftIndex] = items[rightIndex];
     items[rightIndex] = temp;
 }
 function partition(items, left, right) {
     var pivot = items[Math.floor((right + left) / 2)], //middle element
         i = left,                                      //left pointer
         j = right;                                     //right pointer
     while (i <= j) {
         while (items[i] < pivot) {
             i++;
         }
         while (items[j] > pivot) {
             j--;
         }
         if (i <= j) {
             swap(items, i, j);                        //sawpping two elements
             i++;
             j--;
         }
     }
     return i;
 }
 
 function quickSort(items, left, right) {
     var index;
     if (items.length > 1) {
         index = partition(items, left, right);       //index returned from partition
         if (left < index - 1) {                      //more elements on the left side of the pivot
             quickSort(items, left, index - 1);
         }
         if (index < right) {                         //more elements on the right side of the pivot
             quickSort(items, index, right);
         }
     }
     return items;
 }
 
 // first call to quick sort
 
 var sortedArray = quickSort(items, 0, items.length - 1);
 console.log(sortedArray);
 
 //prints [2,3,5,6,7,9]
",JavaScript
"""""""
 Bellman Ford : In a Directed Graph, the shortest distance between the
         source to destination can be calculated by Dijkstra's Algorithm.
         But in case of negative weight, Dijkstra's Algorithm would fail.
         Bellman Ford is a pathfinding algorithm which even works in negative
         cycle
 
 Purpose: Given a Directed Weighted Graph with N nodes and M edges, where
         each edge possesses an integer weight and a source and destination.
         Find the minimum path sum from source to destination.
 
 Method: Bellman-Ford Algorithm
 Intuition: Below is algorithm find if there is a negative weight cycle
         reachable from the source.
     1) Initialize distances from the source to all vertices as infinite and
         distance to the source itself as 0. Create an array dist[] of size N with
         all values as infinite except dist[src] where src is source vertex.
     2) This step calculates the shortest distances. Do the following N-1 times where
         N is the number of vertices in the given graph.
         (*) Do following for each edge u-v
             If dist[v] > dist[u] + weight of edge uv, then update dist[v]
             dist[v] = dist[u] + weight of edge uv
     3) This step reports if there is a negative weight cycle in the graph. Do following
         for each edge u-v
         If dist[v] > dist[u] + weight of edge uv, then Graph contains negative
         weight cycle
     4) If the graph does not contain any negative cycle, return the distance[source]
 
 Time Complexity:  O((N^2)*M)
 Space Complexity: O(N)
 
 Argument: Dictionary ( Graph with nodes numbered 1 to N )
 Return  : Boolean    ( The graph contain negative cycle or not )
 """"""
 from collections import defaultdict
 
 
 def Bellman_Ford(n, graph, start, end):
 
     # Initilize the distance of each node to infinite
     distance = [float('inf') for i in range(n + 1)]
 
     # Considering source vertex as 1, puting distance[1]=0
     distance[start] = 0
",Python
"/* ROD CUTTING PROBLEM(DP)(C++)
 
 Given a rod of length n units. The rod can be cut into different sizes and each size has a cost
 associated with it. Determine the maximum cost obtained by cutting the rod and selling its pieces.
 */
 
 #include <iostream>
 using namespace std;
 
 //Function that returns maximum value by cutting n length rod
 int rodCutting(int price_arr[], int n)
 {
     int max_val[n],beg,last;
 
     //max price of length 1 is price of 1 itself
     max_val[0]=price_arr[0];
 
     //curr_len is iterator to find max price by cutting rod of length curr_len+1
     for(int curr_len=1; curr_len<n; curr_len++)
     {
         //maximum value of current length without any cuts
         max_val[curr_len]=price_arr[curr_len];
         //iterator going from beginning (rod length=1) to length= current length/2
         beg=0;
         //iterator decreasing from rod length= current-1 to length= current length/2
         last=curr_len-1;
 
         /*Compare sum of optimal values of left and right side of rod (where left rod length goes from 1 till
         mid of current length) with current max value stored*/
         while(beg<=last)
         {
             if(max_val[curr_len]< max_val[beg]+max_val[last])
             {
                 max_val[curr_len]= max_val[beg]+max_val[last];
             }
             beg++;
             last--;
         }
     }
     return max_val[n-1];
 }
 
 int main()
 {
     //size of price array
     int n;
     cout<<""Enter size of price array: "";
     cin>>n;
     //prices for each length of rod
     int prices[n];
     cout<<""Enter prices for each length of rod: ""<<endl;
     for(int i=0; i<n; i++)
         cin>>prices[i];
 
     cout<<""Maximum value is: ""<<rodCutting(prices, n)<<endl;
     return 0;
 }
 /*
 Test Cases:
     Input:
     Enter size of price array: 8
     Enter prices for each length of rod:
     1 5 8 9 10 17 17 20
 
     Output:
     Maximum value is: 22
 
     Input:
     Enter size of price array: 6",C-Plus-Plus
"/*In Vernam cipher, also known as the One-Time Pad, the length
   of the plaintext, ciphertext, and key is the same. Below is
   an implementation of Vernam cipher in Java. Here the ith letter
   of the cipher text is fomred by shifting the numerical value of
   ith letter of the plaintext by the numerical value ofith letter
   of key. The conversion here is a-0, b-1, c-2, ...., z-25.*/
 
 import java.util.*;
 import java.lang.*;
 
 public class vernamCipher {
 
 	/* This method takes a string as input and converts
 	   each character in the string to its respective
 	   numerical value and returns it.*/
 	static int[] asciiToDec(String str) {
 
 		int[] decimal = new int[str.length()];
 
 		for(int i = 0; i < str.length(); i++) {
 
 			/* We first convert the character to its
 			 decimal and then shift it by 97 as, a-97,
 			 b-98, and so on. So to change the indexing
 			 and start from 0, we subtract the value by 97.*/
 			decimal[i] = str.charAt(i);
 			decimal[i] = decimal[i] - 97;
 		}
 
 		return decimal;
 	}
 
 	/* This method is the encryption method. It takes 
 	   plaintext and key as the input.*/
 	static String encrypt(String plaintext, String key) {
 
 		String ciphertext = new String("""");
 
 		/* Converting both plaintext and key to their
 		   respective numerical values.*/
 		int[] plaintextArray = asciiToDec(plaintext);
 		int[] keyArray = asciiToDec(key);
 
 		int[] ciphertextArray = new int[keyArray.length];
 
 		/* Forming the ciphertext by shifting each value of
 		plaintext by the value present at same index of the key*/
 		for(int i = 0; i < keyArray.length; i++) {
 			ciphertextArray[i] = (plaintextArray[i] + keyArray[i]) % 26;
 
 			//Shifting the values by 97, to get proper ascii values.
 			ciphertextArray[i] += 97;
 		}
 
 		/* Converting the decimal values to respective ascii
 		values and forming the ciphertext string.*/
 		for(int i = 0; i < ciphertextArray.length; i++) {
 			ciphertext += (char)ciphertextArray[i];
 		}
 
 		return c",Java
"/* MATRIX MULTIPLICATION
     2 matrices are input and multiplied using following algorithm:
     START
     Input no. of rows m1 and columns n1 of first matrix
     For i = 0 to m1-1
         For j=0 to n1-1
             Input elements of first matrix and store in a[i][j]
     Input no. of rows m2 and columns n2 of second matrix
     For i = 0 to m2-1
         For j=0 to n2-1
             Input elements of second matrix and store in b[i][j]
     If (n1 != m2)
         Print ""Multiplication is not possible""
     Else
         Initialize product matrix c[m1][n2] as 0 matrix
         For i = 0 to m1-1
             For j=0 to n2-1
                 For k=0 to n1-1
                     c[i][j] =c[i][j]+( a[i][k] * b[k][j])
         For i = 0 to m1-1
             For j=0 to n2-1
                 Print c[i][j] 
     STOP 
 
 */
 
 //import package to accept input
 import java.util.Scanner;
 
 //class for matrix multiplication
 public class Matrix {
 
     ////to multiply 2 matrices.2 matrices and corresponding rows and columns are arguments
     static void multiply(int a[][],int b[][],int m1,int n1,int m2,int n2){
         //check if no of columns of first matrix is 
         //equal to number of rows of second matrix 
         if (n1 != m2)
             System.out.println(""Multiplication is not possible"");
 
         else 
         {
             int i,j;
             //initialize new matrix to store product
             int c[][] = new int[m1][n2];
 
             //matrix multiplication
             for (i = 0; i < m1; i++) 
             {
                 for (j = 0; j < n2; j++) 
                 {
                     for (int k = 0; k < n1; k++)
                         c[i][j] += a[i][k] * b[k][j];
                 }
             }
             //to print product matrix 
             System.out.println(""Product:"");
             for (i = 0; i < m1; i++) 
             {
                 for (j = 0; j < n2; j++) 
                 {
                     System.out.prin",Java
"/**
 Function to search for a given element in a list using binary search algorithm.
 For this algorithm we need a sorted list. After getting the list, we compare
 the value of the element to be searched with the middle value and then search
 for it either in the half before the middle element or after it. This way our
 search area gets reduced by half.
  */
 import 'dart:io';
 
 //function which runs the binary search algorithm
 int binarySearch(List arr, int num) {
   // initial bounds of array
   int low = 0;
   int high = arr.length - 1;
 
   while (low <= high) {
     // find middle position of the bounds
     int mid = (low + high) ~/ 2;
     // if num is found, return index
     if (arr[mid] == num) {
       return mid;
     }
     // if num > mid, that means it might be in the 2nd half of the list
     // so we increase the lower bound by 1 to get into that half
     else if (arr[mid] < num) {
       low++;
     }
     // else if num < mid, we try for first half by decreasing upper bound
     else {
       high--;
     }
   }
   // return invalid index to show that element is not in the list
   return -1;
 }
 
 // main function, entry point of program
 void main() {
   print(""Enter the size of list:"");
   int size = int.parse(stdin.readLineSync()!);
   List arr = [];
   print(""Enter the sorted list:"");
   for (int i = 0; i < size; i++) {
     arr.add(int.parse(stdin.readLineSync()!));
   }
   print(""Enter the number to be searched:"");
   int num = int.parse(stdin.readLineSync()!);
   // sorting
   int result = binarySearch(arr, num);
   if (result != -1) {
     print(""$num found at position: ${result + 1}"");
   } else {
     print(""$num not found in the list."");
   }
 }
 
 /**
 Enter the size of list:
 6
 Enter the sorted list:
 12
 25
 32
 47
 56
 68
 Enter the number to be searched:
 47
 47 found at position: 4
 
 Time complexity: O(log n)
 Space complexity: O(1)
  */
",Dart
"''' 
 Euler-circuit-and-Path
 
 Problem Statement : Eulerian Path is a path in graph that
                    visits every edge exactly once.
                    Eulerian Circuit is an Eulerian
                    Path which starts and ends on the
                    same vertex.
                    The task is to find that there
                    exists the Euler Path or circuit
                    or none in given undirected graph.
 
 Input : First line consists of test cases T. First
        line of every test case consists of 2
        integers V and E, denoting the number of
        vertex and edges. Second line of every test
        case consists of 2*E spaced integers denoting
        the edge connected.
 
 
 Output : Return the int value to print 1 if Euler path
         exists print 2 if Euler cycle exists else 0.
 
 Time Complexity : O(V+E)
 Time Complexity : O(N)
 
 '''
 
 # Importing sys module to initalize the maxsize
 import sys
 # Importing collections model to access deque and defaultdict
 from collections import deque, defaultdict
 
 # Assigning max value a variable can take
 INT_MAX = sys.maxsize - 1
 # Initialize Infinity
 INF = 9999999
 
 # Create The graph
 class Graph():
 
     # Add the vertices of the graph
 
     
     def __init__(self,vertices):
         self.graph = defaultdict(list)
         self.V = vertices
 
     # Add directed edge from u to v.
 
 
     def addEdge(self,u,v): 
         self.graph[u].append(v)
 
 # Check for Euler Path
 def Eulerpath(G, no_of_vertices, no_of_edges):
     # G is G.graph
     Nodes_odd_degree = 0
     for node, connectednodes in G.items():
         if (len(connectednodes) %2 == 1):
             Nodes_odd_degree = Nodes_odd_degree + 1
         if Nodes_odd_degree > 2 :
             return 0
     if (Nodes_odd_degree == 0):
         return 2
     else:
         return 1
 
 # -----------------------Driver Code-----------------------
 
 no_of_vertices = int(input(""Enter the number of vertices: ""))
 no_of_",Python
"/* ADJACENCY LIST FOR REPRESENTING DIRECTED GRAPH
     It is a method of representing a digraph using 2 linked lists
         1. Node list
         2. Edge list corresponding to each node
     Edges arising from a node are stored in edge list of each node
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /* Declare a structure for representing digraph with data and 2 links
  * link represents the edge between the parent node and next node (edge list)
  * pnext point to the next node from which new edges arise(node list)
  * g points to the graph
 */
 typedef struct AdjacencyList
 {
     int data;
     struct AdjacencyList *link, *pnext;
 } AdjacencyList;
 AdjacencyList *g;
 
 //to insert into the graph
 void insert_to_graph(AdjacencyList *g, int parent, int value)
 {
     //ptr points to the first node in the graph
     AdjacencyList *ptr = g->link, *p;
     //Check if the graph is empty
     if (g->link == NULL)
     {
         // ptr stores the value of parent node
         ptr = new AdjacencyList;
         ptr->data = parent;
         ptr->pnext = NULL;
         ptr->link = NULL;
         g->link = ptr;
     }
     else
     {
         //Search for parent in the node list
         while (ptr != NULL && ptr->data != parent)
         {
             p = ptr;
             ptr = ptr->pnext;
         }
         //If parent is not found in the node list insert as last node
         if (ptr == NULL)
         {
             ptr = new AdjacencyList;
             ptr->data = parent;
             ptr->pnext = NULL;
             ptr->link = NULL;
             p->pnext = ptr;
         }
     }
     //insert value in the edge list of parent node
     AdjacencyList *node;
     node = new AdjacencyList;
     node->data = value;
     node->link = NULL;
     node->pnext = NULL;
     //Traverse till the end of the edge list
     while (ptr->link != NULL)
         ptr = ptr->link;
     //Insert value as the last node in the edge list
     ptr->link = node;
 }
 
 //To delete a ",C-Plus-Plus
"/*
 A number has exactly 4 factors if below given any condition is satisfied
  1.If the number is a cube of a prime number.
  2.If the number is a product of two distinct prime numbers.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // maxi gives the range of numbers
 int maxi = 1000;
 //arr contain the 1 value for the numbers which has exactly 4 factors
 int arr[1000]={0};
 
 void check() 
 {
 	//Implementing Sieve of Eratosthenes for checking prime numbers upto maxi
 	int primeNumbers[maxi + 1];
 	for(int i=0;i<maxi+1;i++)
 		primeNumbers[i]=1;
 		
 	for (int i = 2; i <= sqrt(maxi); i++)
 	{
 	    if (primeNumbers[i])
 		{
 	    	for (int j = i * 2; j <= maxi; j += i)
 	        primeNumbers[j] = 0;
 	    }
 	}
 	
   // Creating a array of dynamic size containing all prime numbers upto maxi	
 	vector<int> temp;
 	for (int i = 2; i <= maxi; i++)
 	    if (primeNumbers[i])
 	        temp.push_back(i);
 	
 	for (int i = 0; i < temp.size(); ++i)
 	{
 		int x = temp[i];
 		//If the number is a cube of a prime number, then it has exactly 4 factors
 	  	if (1 *(pow(x, 3)) <= maxi)
 	    	arr[x*x*x] = 1;
 	    	
 	      //If the number is a product of two distinct prime numbers,then it has exactly 4 factors
 	  	for (int j = i + 1; j < temp.size(); ++j)
 		{
 	    	int y = temp[j];
 	     	if (1 * x*y > maxi)
 	        break;
 	     	arr[x*y] = 1;
 	   }
 	}
 }
 
 int main()
 {
     int num;
     cout<<""Enter the number you want to check: "";
     cin>>num;
     check();
     if(arr[num])
        cout<<num<<"" has exactly four factors\n"";
     else
        cout<<num<<"" does not have exactly four factors\n"";
     return 0;
 }
 
 
 /* 
   Sample Input/Output:
   
   Enter the number you want to check: 
   Input: num=27
   Output: 27 has exactly four factors
   
   Enter the number you want to check: 
   Input: num=109
   Output:109 does not have exactly four factors
 
   Time complexity-O(Nlog(log(N)))
   Space complexity-O(N)
 */
",C-Plus-Plus
"/*
 
 Given an unsorted array, sort the array into a wave form.
 Wave form - array[0] >= array[1] <= array[2] >= array[3] <= array[4] >= array[5] and so on
 Algorithm - 1. Sort the given array
             2. Swap all adjacent elements 
 Time Complexity - O(nLog n), if sorting algorithm like Merge sort is used
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 function mergeSort(array) {
   // Case of only one array element
   if (array.length === 1) {
     return array;
   }
 
   // get the mid point and divide the array in each half
   const middle = Math.floor(array.length / 2);
   const left = array.slice(0, middle);
   const right = array.slice(middle);
 
   // Call the algorithm to compare elements of each sub half
   return merge(mergeSort(left), mergeSort(right));
 }
 
 function merge(left, right) {
   let arr = [];
 
   // Compare elements and add accordingly in arr
   while (left.length && right.length) {
     if (left[0] < right[0]) {
       arr.push(left.shift());
     } else {
       arr.push(right.shift());
     }
   }
 
   // return the arr & the left elements from leftArray + rightArray
   return [...arr, ...left, ...right];
 }
 
 // Perform waveSort
 function waveSort(array) {
   // Call the merge sort algorithm
   let sortedArray = mergeSort(array);
 
   // Swap adjacent elements
   for (let i = 0; i < sortedArray.length - 1; i += 2) {
     [sortedArray[i], sortedArray[i + 1]] = [sortedArray[i + 1], sortedArray[i]];
   }
 
   return sortedArray;
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered valu",JavaScript
"import java.util.*;
 import java.util.Stack;
  class Node {
      Node left;
      Node right;
      int data;
 
      Node(int data) {
          this.data = data;
          left = null;
          right = null;
      }
  }
  class preOrderTraversal{
                 //recursive
      public static void preOrderRec(Node root){
          if(root == null)
          return;
          else{
              System.out.print(root.data+"" "");
              preOrderRec(root.left);
              preOrderRec(root.right);
          }
      }
                 //iterative
    public static void preOrderIte(Node root) {
          if (root == null) { 
              return; 
          } 
          Stack<Node> stack = new Stack<>();
          stack.push(root);
          while (!stack.empty()) {
              Node node = stack.pop();
              if (node != null) {
                  System.out.print(node.data + "" "");
                  stack.push(node.right);
                  stack.push(node.left);
              }
          }
     }
  	public static Node insert(Node root, int data) {
          if(root == null) {
              return new Node(data);
          } else {
              Node curr;
              if(data <= root.data) {
                  curr = insert(root.left, data);
                  root.left = curr;
              } else {
                  curr = insert(root.right, data);
                  root.right = curr;
             }
              return root;
          }
      }
      public static void main(String[] args) {
          Scanner sc = new Scanner(System.in);
          System.out.println(""Enter number of nodes:"");
          int t = sc.nextInt();
          System.out.println(""Enter nodes:"");
          Node root = null;
          while(t-- > 0) {
              int data = sc.nextInt();
              root = insert(root, data);
          }
          System.out.print(""Recursive approach: "");
          preOrderRec(root);
          System.out.println();
          System.out.pri",Java
"/*
 AIM :: Take a string form the user.
 	   Consider each individual character and print the corresponding ASCII code of that character.
 */
 import java.util.Scanner;
 
 public class AsciiOfString {
 
     public static void main(String[] args) {
 
         //taking user input of string
         System.out.print(""Enter the string :: "");
         Scanner sc = new Scanner(System.in);
         String str = sc.nextLine();
 
         // printing all the characters with their ASCII code
         for (int i = 0; i < str.length(); i++)
             System.out.println(str.charAt(i) + "" = "" + (int) str.charAt(i));
     }
 }
 
 /*
 TEST CASE
 
 Enter the string :: ANAND
 A = 65
 N = 78
 A = 65
 N = 78
 D = 68
 
 TIME COMPLEXITY  :: O(n)
 SPACE COMPLEXITY :: O(1)
 
  */
 
",Java
"
 import java.util.*;
 class node{
     int value;
     node left;
     node right;
 
     node(int key)
     {
         value = key;
         left = null;
         right = null;
     }
     node(int key, node left, node right )
     {
         this.value = key;
         this.left = left;
         this.right = right;
 
     }
 
 }
 class stack
 {
     node[] array = new node[10000];
     private int top;
     stack()
     {
         top = 0;
     }
     void push(node item)
     {
         array[++top] = item;
     }
     node pop()
     {
         
         int temp  = top;
         --top;
         return array[temp];
     }
     boolean isEmpty()
     {
         if(top == 0)
          return true;
          else
          return false;
     }
 }
 public class postorder_Traversal {
     node root;
     void postorder_traversal_Iterative()
     {
         stack stack1 = new stack();
         stack stack2 = new stack();
         if(root == null)
         return;
         stack1.push(root);
         while(!stack1.isEmpty())
         {
             node item = stack1.pop();
             stack2.push(item);
             if(item.left!=null)
             {
                 stack1.push(item.left);
             }
             if(item.right!=null)
             {
                 stack1.push(item.right);
             }
         }
         while(!stack2.isEmpty())
         {
             node item = stack2.pop();
             System.out.print(item.value+"" "");
         }
         System.out.print(""\n"");
     }
     public void postorderRecursive(node root)
     {
         if(root == null)
         return;
         postorderRecursive(root.left);
         postorderRecursive(root.right);
         System.out.print(root.value + "" "");
         
     }
     void postorder_traversal_recursive()
     {
         postorderRecursive(root);
     }
     public postorder_Traversal(){
         root=takeInput(null,false);
     }
       node takeInput(node parent,Boolean isleftorright){
         ",Java
"""""""Julia program to implement Minimum XOR value.
 Given an array of integers, we have to find the minimum XOR value, a pair in the array makes.""""""
 
 
 function minimumXOR(arr, n)
     # Sort the array, so that elements with minimum bit difference are present consecutive.
     sort(arr)
     minXOR = typemax(Int64)
     val = 0
 
     # Compute the XOR values of the consecutive elements of the array.
     for i in 1:(n-1)
         val = arr[i]  arr[i+1]
         minXOR = min(minXOR, val)
     end
 
     return minXOR
 end
 
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""No numbers are present in the array!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 res = minimumXOR(arr, n)
 print(""The minimum XOR value present in the given array is $res"")
 
 
 """"""
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 How many numbers are present in the array? 8
 Enter the numbers: 25 45 36 458 651 89 52 95 
 The minimum XOR value present in the given array is 9
 
 SAMPLE II
 
 How many numbers are present in the array? 5
 Enter the numbers: 5 4 3 2 1
 The minimum XOR value present in the given array is 1
 
 """"""
",Julia
"class Node:
     def __init__(self, val):
         self.val = val
         self.next = None
 
 
 class LinkedList:
     def __init__(self):
         self.head = None
 
     def create_linked_list(self, arr):
         last = dummy = self.head = Node(arr.pop(0))
 
         while arr:
             dummy.next = Node(arr.pop(0))
             last = dummy
             dummy = dummy.next
         return last
 
     def intersection_point(self, head2):
         """""" Return the point of intersection of Y-shaped linked lists""""""
         iterator1 = self.head
         iterator2 = head2
         while iterator1 or iterator2:
             if iterator1 == iterator2:
                 return iterator1.val
             iterator1 = iterator1.next if iterator1 else head2
             iterator2 = iterator2.next if iterator2 else self.head
         return 'No intersecting point found!'
 
 inp1 = list(map(int, input('Elements of list1: ').split(',')))
 inp2 = list(map(int, input('Elements of list2: ').split(',')))
 try:
     intersection = list(map(int, input('Intersection list').split(',')))
     intersectionList = LinkedList()
 except:
     intersection = []
 
 linked_list1 = LinkedList()
 linked_list2 = LinkedList()
 
 last_list1 = linked_list1.create_linked_list(inp1)
 last_list2 = linked_list2.create_linked_list(inp2)
 if intersection != []:
     intersectionList.create_linked_list(intersection)
     last_list1.next = intersectionList.head
     last_list2.next = intersectionList.head
 
 
 print(linked_list1.intersection_point(linked_list2.head))
 
 
 '''
 Input format: 4 lines-> For Intersection
 3,5,6,2         :: linkedlist1 elements which won't intersect with list 1
 3,12,4,10,3,32  :: linkedlist2 elements  which won't intersect with list 2
 9,1,5,3         :: elements to be common in both list
 
                    3 - 5 - 6 - 2
                                 \
                                  9 - 1 - 5 - 3
                                 /
         3 - 12 - 4 - 10 - 3 - 32
 ",Python
"from collections import defaultdict
 import sys
 
 
 def subArraylen(arr, n, K):
     mp = defaultdict(lambda: 0)
     mp[arr[0]] = 0
     for i in range(1, n):
         arr[i] = arr[i] + arr[i - 1]
         mp[arr[i]] = i
     ln = sys.maxsize
     for i in range(n):
         if(arr[i] < K):
             continue
         else:
             x = K - arr[i]
             if(x == 0):
                 ln = min(ln, i)
             if(x in mp.keys()):
                 continue
             else:
                 ln = min(ln,  i - mp[x])
     return ln
 arr = []
 n = int(input(""enter the number of elements""))
 for i in range(0, n):
     ele = int(input(""enter the elements""))
     arr.append(ele)
 K = int(input(""enter the sum ""))
 ln = subArraylen(arr, n, K)
 if(ln == sys.maxsize):
     print(""-1"")
 else:
     print(ln)
 
 # Time complexity: O(NlogN)
 # Space Complexity: O(N)
 '''
 Output:
 enter the number of elements6
 enter the elements2
 enter the elements4
 enter the elements6
 enter the elements10
 enter the elements2
 enter the elements1
 enter the sum 12
 2
 '''
",Python
"# Vigenere Cipher python code.
 
 def encrypt(msg, key):
     cipher = """"
     n = len(key)
     i = 0
     for l in msg:
         # finding the index of the character
         p = int(ord(l) + ord(key[i % n])) % 26
         # to perform the shift with the key
         cipher += chr(p + ord('A'))
         i += 1
     return cipher
 
 
 def decrypt(cipher, key):
     msg = """"
     n = len(key)
     j = 0
     for l in cipher:
         p = int(ord(l) - ord(key[j % n]) + 26) % 26
         msg += chr(p + ord('A'))
         j += 1
     return msg
 
 if __name__=='__main__':
     
     # Use uppercase only
     choice = int(input(""Choose 1 if you want to ENCRYPT or 2 if you want to DECRYPT: ""))
 
     if(choice == 1):
         msg = input(""Enter a plaintext message: "")
         key = input(""Enter a keyword: "")
 
         # encrypting the message
         cipher = encrypt(msg, key)
         print(""\nEncrypted message: "", cipher)
 
     elif(choice == 2):
         cipher = input(""Enter a ciphertext: "")
         key = input(""Enter a keyword: "")
 
         # decrypting the ciphar text
         original = decrypt(cipher, key)
         print(""\nDecrypted message: "", original)
 
     else:
         print(""\nInvalid choice."")
 
 '''
 Sample I/O:
 
 1)
 Choose 1 if you want to ENCRYPT or 2 if you want to DECRYPT: 1
 Enter a plaintext message: NEOALGO
 Enter a keyword: MARS
 
 Encrypted message:  ZEFSXGF
 
 2)
 Choose 1 if you want to ENCRYPT or 2 if you want to DECRYPT: 2
 Enter a ciphertext: ZEFSXGF
 Enter a keyword: MARS
 
 Decrypted message: NEOALGO
 
 '''
",Python
"""""""
 Program to calculate sum of linked list.
 In the sum_ll function we traversed through all the functions of the linked list and calculate
 the sum of every data element of every node in the linked list.
 """"""
 
 # A node class
 class Node:
     # To create a new node
     def __init__(self, data):
         self.data = data
         self.next = None
 
 # Class Linked list
 class LinkedList:
     # create a empty linked list
     def __init__(self):
         self.head = None
 
     # Function to insert elements in linked list
     def push(self, data):
         newNode = Node(data)
         temp = self.head
 
         newNode.next = self.head
 
         # If linked list is not None then insert at last
         if self.head is not None:
             while (temp.next != self.head):
                 temp = temp.next
             temp.next = newNode
         else:
             newNode.next = newNode  # For the first node
 
         self.head = newNode
 
     # Function to print given linked list
     def print_List(self):
         temp = self.head
         if self.head is not None:
             while (True):
                 print(temp.data)
                 temp = temp.next
                 if (temp == self.head):
                     break
 
     # Function to calculate sum of a Linked list
     def sum_ll(self, head):
         sum_ = 0
         temp = self.head
         if self.head is not None:
             while True:
                 sum_ += temp.data
                 temp = temp.next
 
         return sum_
 
 # Initialize lists as empty by creating Linkedlist objects
 head = LinkedList()
 
 # Pushing elements into LinkedList
 n = int(input(""Enter the no. of elements you want to insert: ""))
 for i in range(n):
     number = int(input(f""Enter Element {i + 1}: ""))
     head.push(number)
 
 print(""Entered Linked List: "")
 head.print_List()
 
 sum_ = head.sum_ll(head)
 print(f""\nSum of Linked List: {sum_}"")
 
 """"""
 Time Complexity: O(n)
 Space Complexity: O(n)
 
 SAM",Python
"/*
 Find total number of Squares in a N*N cheesboard.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Solution
 {
 public:
     long long squaresInChessBoard(long long n)
     {
         return (n * (n + 1) * (2 * n + 1)) / 6;
     }
 };
 
 int main()
 {
     long long num;
     cout << ""Enter the number : "" << endl;
     cin >> num;
 
     Solution obj;
     cout << ""The square is : "" << endl;
     cout << obj.squaresInChessBoard(num) << endl;
 }
 
 /*
 Time complexity : O(N)
 Space complexity : O(1)
 */
 
 /*
 Input :
 Enter the number :  1
 Output :
 The square is : 1
 */
 
",C-Plus-Plus
"/*
  reverse linked list is an implimention of a singly linked list with an algorithm to reverce the order of the list
 */
 package main
 
 import (
 	""fmt""
 )
 
 type Node struct {
 	value int
 	next  *Node
 }
 
 type List struct {
 	head *Node
 	tail *Node
 	size int
 }
 
 // makeLinkedList: creates an empty linked list
 func makeLinkedList() List {
 	var node *Node = nil
 	l := List{node, node, 1}
 	return l
 }
 
 // createAtFront: create a node at the front of the list with the value the passed in int
 func (list *List) createAtFront(data int) {
 	var node Node
 	node.value = data
 	node.next = list.head
 	if list.tail == nil {
 		list.tail = &node
 	}
 	list.head = &node
 	list.size++
 	fmt.Printf(""created a node with the value %d at the frount of the list\n"", data)
 }
 
 // printList: prints out the linked list from head to tail.
 // func (list *List) printList() {
 // 	currentNode := list.head
 // 	for currentNode != nil {
 // 		fmt.Printf(""%d "", currentNode.value)
 // 	}
 // }
 
 // printList: prints out the linked list from head to tail
 func (list *List) printList() {
 	currentNode := list.head
 	for currentNode != nil {
 		fmt.Printf(""%d->"", currentNode.value)
 		currentNode = currentNode.next
 	}
 	fmt.Printf(""\n"")
 }
 
 // reverseLinkedList: reverses the linked list
 func (list *List) reverseLinkedList() {
 	// grabs first node in the list
 	currentNode := list.head
 	// setting up the previous node
 	var prev *Node = nil
 	// grabs the next node in the list
 	next := currentNode.next
 	// while not at the end of the list
 	for currentNode != nil {
 		// takes the next node after the current node
 		next = currentNode.next
 		// swap the current nodes next node to previous
 		currentNode.next = prev
 		// the new previous becomse the old previous
 		prev = currentNode
 		// the current node becomes the next node
 		currentNode = next
 	}
 	// the lists tail is now the head
 	list.tail = list.head
 	// the lists head is now the last not nil node
 	list.h",Go
"/* Extended Euclidean Algorithm
 
   GCD of two numbers is the largest number that divides both of them.
   A simple way to find GCD is to factorize both numbers and multiply
   common factors.
  
      GCD(a,b) = ax + by
      
   If we can find the value of  x and y then we can easily find the
   value of GCD(a,b) by replacing (x,y) with their respective values.
 */
 
 #include <stdio.h>
 
 int extendedGCD(int a, int b, int *x, int *y)
 {
     //base case
     if (a == 0)
     {
         *x = 0;
         *y = 0;
         return b;
     }
    
     int x1, y1;
    
     //recursive call
     int ans = extendedGCD(b % a, a, &x1, &y1);
    
     //Update x and y using results of recursive call
     *x = y1 - (b/a) * x1;
     *y = x1;
    
     return ans;
 }
 
 //Driver Code
 int main()
 {
     int x, y, a, b;
     printf(""Enter the values of a and b : "");
     scanf(""%d %d"", &a, &b);
     int gextnd = extendedGCD(a, b, &x, &y);
     printf(""\nGCD using Extended Euclidean algorithm is: %d "", gextnd);
     return 0;
 }
 
 /*
 Time Complexity : O(log(max(A, B)))
 
 Sample I/O :
 
 Input :
 Enter the values of a and b : 55 10                                                                                          
  
 Output :
 GCD using Extended Euclidean algorithm is: 5
 */
",C
"#A thief wants to loot houses. He knows the amount of money in each house. He cannot loot two consecutive houses. Find the maximum amount of money he can loot.
 
 
 def maxMoneyLooted(amountInHouses, totalHouses) :
     #If there are 0 houses , return 0 
     if totalHouses == 0 :
         return 0
 
     #If there is only one house , return its money    
     if totalHouses == 1 :
         return amountInHouses[0]
 
     #If there are atleast 2 houses ,create arr and calculate the maximum amount of money that can be looted
     maxMoneyCanBeLooted = [0]*totalHouses
 
     maxMoneyCanBeLooted[0] = amountInHouses[0]
     maxMoneyCanBeLooted[1] = max(amountInHouses[0], amountInHouses[1])
 
     for currHouse in range(2,totalHouses) :
         #At each i th house either (houses upto i-2) + (i th house) or (houses upto i-1) can be robbed
         maxMoneyCanBeLooted[currHouse] = max(maxMoneyCanBeLooted[currHouse - 1], (amountInHouses[currHouse] + maxMoneyCanBeLooted[currHouse - 2]))
 
     #Return the required answer which is the maximum amount of money that can be robbed till last house    
     return maxMoneyCanBeLooted[totalHouses-1]
 
 
 def takeInput() :
     n = int(input().rstrip())
     if n == 0 :
         return list(), 0
 
     arr = list(map(int, input().rstrip().split("" "")))
     return arr, n
 
 def main():
     print('Enter total number of houses and amount that each house contains: ')
     amountInHouses,totalHouses = takeInput()
     print('Maximum amount that can be taken be the thief is: ')
     print(maxMoneyLooted(amountInHouses,totalHouses))
 
 if __name__ == '__main__':
     main()
 
 
 '''
 Time Complexity: O(n)
 Space Complexity: O(n)
 where n is the total number of houses
 
 Sample Input:
 Enter total number of houses and amount that each house contains:
 6
 10 2 30 20 3 50
 
 Sample Output:
 Maximum amount that can be taken be the thief is:
 90
 Explanation :
 Looting first, third, and the last houses([10 + 30 + 50]) will result in the maximu",Python
"/*
 A number is said to be a neon number when the sum of digits of the square of the number
 is equal to the number itself
 */
 import 'dart:io';
 
 // Function to check if number is a neon number
 bool isNeon(int num) {
   int sum = 0;
   int square = num*num;
 
   while (square > 0) {
     int digit = square % 10;
     sum += digit;
     square ~/= 10;
   }
   if (sum == num) {
     return true;
   }
   return false;
 }
 
 // Main Function with driver code
 void main() {
   print(""Enter a number :"");
   int num = int.parse(stdin.readLineSync()!);
 
   // Call function to check if number is a neon number
   if (isNeon(num)) {
     print(""$num is a Neon Number"");
   } else {
     print(""$num is not a Neon Number"");
   }
 }
 
 /**
 Space Complexity O(1)
 Time Complexity  O(log(n))
 
 Sample input/output:
 Enter a number :
 9
 9 is a Neon Number
 
 Enter a number :
 12
 12 is not a Neon Number
 */
",Dart
"# Julia program to Left Rotate a number by a specific bits.
 
 
 # Left Rotate 'cnt' number of bits of the given number 'n'
 function left_rotate_bits(n, cnt)
     cnt = cnt % 31
     while(cnt > 0)
         # Store the current MSB in a temporary variable
         msb = (n >> 31) & 1;
         # Left rotate the given number by one bit
         n = (n<<1);
         # Set the dropped MSB as the new LSB
         n = n | msb;
         # Decrement cnt
         cnt = cnt - 1
     end
     return n
 end
 
 print(""Enter the number? "")
 num = readline()
 num = parse(Int, num)
 print(""How many bits do you want to rotate? "")
 cnt = readline()
 cnt = parse(Int, cnt)
 left = left_rotate_bits(num, cnt)
 print(""The Left-rotated number is: $left"")
 
 
 """"""
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 39
 How many bits do you want to rotate? 17
 The Left-rotated number is: 5111808 
 """"""
",Julia
"/*
 COCKTAIL SORT IN DART
 Cocktail Sort is a variation of Bubble sort. 
 Cocktail Sort traverses through a given array in both directions alternatively,
 in a similar fashion of Bubble sort where comparision is performed between 
 consecutive elements. 
 */
 
 import 'dart:io';
 
 CocktailSort(var arr, int n) {
   bool flag = true;
   int first = 0;
   int last = n - 1;
 
   while (flag) {
     // resetting the flag
     flag = false;
 
     // loop from left to right and performing comparisons 
     // through the iterations to check for greater values
     for (int i = first; i < last; ++i) {
       if (arr[i] > arr[i + 1]) {
         int temp = arr[i];
         arr[i] = arr[i + 1];
         arr[i + 1] = temp;
         flag = true;
       }
     }
 
     // if no swapping occured, the array is sorted
     if (!flag) break;
 
     // Resetting the flag
     flag = false;
     --last;
 
     // loop from right to left and performing comparisons 
     // through the iterations to check for greater values
     for (int i = last - 1; i >= first; --i) {
       if (arr[i] > arr[i + 1]) {
         int temp = arr[i];
         arr[i] = arr[i + 1];
         arr[i + 1] = temp;
         flag = true;
       }
     }
 
     ++first;
   }
 }
 
 main() {
   // Driver code to generate the required input/output
   var array = [];
 
   var n, ele;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
 
   CocktailSort(array, n);
   print(array);
 }
 
 /*
 TIME COMPLEXITY: O(n*n)
 SPACE COMPLEXITY: O(1)
 
 SAMPLE I/O:
 Enter the number of Elements: 
 7
 Enter Element 1: 
 34
 Enter Element 2: 
 23
 Enter Element 3: 
 78
 Enter Element 4: 
 90
 Enter Element 5: 
 9
 Enter Element 6: 
 66
 Enter Element 7: 
 45
 [9, 23, 34, 45, 66, 78, 90]",Dart
"/*
 The function find the MEX of an n integer array.
 MEX is the minimum excluded element in an array, i.e, the minimum number which
 is not present in the given array.
 */
 
 import 'dart:io';
 import 'dart:core';
 
 int get_MEX_of_array(List arr, int n) {
   // Creating a set to store the unique elements of the array
   var mex_find = <int>{};
   for (int i = 0; i < n; i++) {
     mex_find.add(arr[i]);
   }
 
   // Iterating through the array and checking if integers from 0 to n are not in
   // the given array
   int mex = 1;
   for (int i in mex_find) {
     // Checking if the mex chosen is in the set mex_find
     if (mex_find.contains(mex)) {
       mex++;
     }
     // Indicating that we have already found the mex of the array
     else if (i > mex) {
       break;
     }
   }
   return mex;
 }
 
 main() {
   // Driver code to take user input
   var array = [];
 
   var n, ele, x;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
 
   int arr_mex = get_MEX_of_array(array, n);
   print(""Minimum excluded element of the Array is : $arr_mex"");
 }
 
 /*
 
 TIME COMPLEXITY: O(log N)
 
 SPACE COMPLEXITY: O(N)
 
 Standard I/O:
 Enter the number of Elements: 
 6
 Enter Element 1: 
 5
 Enter Element 2: 
 2
 Enter Element 3: 
 9
 Enter Element 4: 
 1
 Enter Element 5: 
 1
 Enter Element 6: 
 3
 Minimum excluded element of the Array is : 4
 */
",Dart
"/*
 This problem is solved using backtracking.
 In this problem we will be given string of parenthesis which will open and closing parenthesis.
 We will have to remove minimum no. of parenthesis to make the string valid and will print all possible valid strings made by min. removal.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 // this function is to find no. of parenthesis to be removed from the string
 int minRemoval(string str){
     stack<int> s;
     for(int i=0;i<str.length();i++){
         // if it is a open parentheses then we will always push
         if(str[i] == '('){
             s.push(str[i]);
         }
         // if closed parentheses
         else if(str[i] == ')'){
             // if stack is empty then we will push
             if(s.size() == 0){
                 s.push(str[i]);
             }
             // if stack top is closed parentheses then we will push
             else if(s.top() == ')'){
                 s.push(str[i]);
             }
             // if stack top is open parentheses then we will pop
             else {
                 s.pop();
             }
         }
     }
     // size left will me the minimum parentheses to be removed to make the string valid
     return s.size();
 }
 
 void validParentheses(string str, int rm, unordered_set<string> &result){
     if(rm == 0){
         int remove = minRemoval(str);
         if(remove == 0){
             result.insert(str);
         }
         return;
     }
     for(int i=0;i<str.length();i++){
         string left = str.substr(0,i);
         string right = str.substr(i+1);
         validParentheses(left + right,rm-1,result);
     }
 }
 
 // driver code
 int main() {
     // Input the parentheses string
     string str;
     cin>>str;
     unordered_set<string> result;
     // no. of parentheses to be removed
     int remove = minRemoval(str);
     //recursive call
     validParentheses(str,remove,result);
     for(auto i:result){
         cout<<i<<endl;
     }
     retur",C-Plus-Plus
"//Given a string,print reverse of the string using stack
 //Approach:-
 //In stack,we know LIFO principle works.
 //First,i create an empty stack,then i push each character of string in stack
 //then,using for loop i popped out every single character.
 
 #include<bits/stdc++.h>
 using namespace std;
 
 //function to reverse the string
 void reverse(string &s)
 {
 	int i;
 	stack<int> str;
 
 	for(char ch:s){
         str.push(ch);
     }
     for(i=0;i<s.size();i++){
         s[i]=str.top();
         str.pop();
     } 
 }
 
 int main()
 {
 	cout<<""***********Program to reverse a string using stack***********""<<endl;
 	string s;
 	cout<<""Enter a string you want to reverse: "";
 	cin>>s;
 	reverse(s);
       cout<<""String After Reverse: "";
 	cout<<s;
 	return 0;
 }
 
 /*
 Test Case 1:
 Input :
 ***********Program to reverse a string using stack***********
 Enter a string you want to reverse: Harshit
 Output :
 String After Reverse: tihsrah
 
 Time Complexity : O(n), where n is the length of the input string.
 Space Complexity : O(n) for stack.
 */
",C-Plus-Plus
"/*
 The script below determines if a number is Trimorphic or not.
 A trimorphic number is whose cube's last digits are equal to the actual number.
 */
 
 import 'dart:io';
 
 // Function to check if a number is Trimorphic or not
 bool checkTrimorphic(int no) {
   // Cubing the number
   int cube = no * no * no;
 
   // checking if the last digits of the cube is exactly equal to the given number
   while (no > 0) {
     // If a digit is not equal, we can say it is not trimorphic
     if (no % 10 != cube % 10) return false;
 
     // Obtaining each digit of the number and cube respectively
     no = (no / 10).floor();
     cube = (cube / 10).floor();
   }
 
   return true;
 }
 
 main() {
   // Taking user input
   var number;
   print('Enter a number: ');
   number = stdin.readLineSync();
   number = int.parse(number);
 
   bool result = checkTrimorphic(number);
 
   // Displaying results
   if (result)
     print('$number is a Trimorphic Number');
   else
     print('$number is not a Trimorphic Number');
 }
 
 /*
 TIME COMPLEXITY: O(log N)
 SPACE COMPLECITY: O(1)
 
 SAMPLE I/O 1:
 Enter a number: 
 12
 12 is not a Trimorphic Number
 Explanaton: 12*12*12 = 1728
 
 SAMPLE I/O 2:
 Enter a number: 
 9
 9 is a Trimorphic Number
 Explanation: 9*9*9 = 729
 */
",Dart
"// C++ program to implement In Place Merge Sort
 #include <bits/stdc++.h>
 using namespace std;
 
 // Time Complexity: O(n^2)
 // Space Complexity: O(n)
 
 // Merges two subarrays in an inPlace mode
 void inplace_merge(int arr[], int beg, int mid, int end)
 {
     int sec_beg = mid + 1;
 
     // If the last element of the first subarray is greater than the first element
     // of the second subarray, then the both arrays are already in sorted order
     if (arr[mid] <= arr[sec_beg])
     {
         return;
     }
 
     // beg points to the beginning of the first subarray and sec_beg to that of second
     while (beg <= mid && sec_beg <= end)
     {
 
         // Compare the first element of both the subarrays, to find the smaller one
         //If the first one is smaller, increment beg
         if (arr[beg] <= arr[sec_beg])
         {
             beg++;
         }
         else
         {
             int pos = sec_beg;
             int val = arr[sec_beg];
 
             // Else Shift all the elements to the right till the second element and
             // place the second element at the first element's position
             for (; pos != beg; pos--)
             {
                 arr[pos] = arr[pos - 1];
             }
             arr[beg] = val;
 
             // Increment the pointers
             beg++;
             mid++;
             sec_beg++;
         }
     }
 }
 
 void merge_sort(int arr[], int beg, int end)
 {
     if (beg < end)
     {
 
         //Finds the mid index of the concerned array
         int mid = beg + (end - beg) / 2;
 
         // Recursively call the function for the first and the second part of the array
         merge_sort(arr, beg, mid);
         merge_sort(arr, mid + 1, end);
 
         // Merge the two arrays
         inplace_merge(arr, beg, mid, end);
     }
 }
 
 int main()
 {
     int n;
     cout << ""\nHow many numbers do you want to sort? "";
     cin >> n;
     int arr[n];
 
     if (n <= 0)
     {
         cout << ""Ther",C-Plus-Plus
"/*
 To find whether the given string is a palindrome or not.
 A palindrome is a word, number, phrase, or other sequence of characters which reads the same backward as forward, such as madam or racecar.
 */
 
 #include<stdio.h>
 #include<conio.h>
 struct Node
 {
     char data;
     struct Node *next;
     struct Node *prev;
 };
 struct Node *head,*ptr;
 void insert(char data)
 {
     //allocate dynamic memory
     struct Node *newnode=(struct Node*)malloc(sizeof(struct Node));
     if(newnode==NULL)
     {
        printf(""Overflow"");
        return;
     }
     newnode->next=NULL;
     newnode->prev=NULL;
     newnode->data=data;
     if(head==NULL)
         head=newnode;
     else
     {
         ptr=head;
         while(ptr->next!=NULL)  
            ptr=ptr->next;
         ptr->next=newnode;
         newnode->prev=ptr;
     }
 }
 int isPalindrome()
 {
     if(head==NULL)
         return 1;
     struct Node *right,*left;
     right=left=head;
     while(right->next!=NULL)
         right=right->next;
     while(left!=right)
     {
         if(left->data!=right->data)
             return 0;
         left=left->next;
         right=right->prev;
     }
     return 1;
 }
 void main()
 {
     char s[20];
     int l=0,i=0,res;
     head=NULL;
     scanf(""%s"",&s);
     while(s[i]!='\0')
     {
         l++;
         i++;
     }
     for(i=0;i<l;i++)
         insert(s[i]);
     res=isPalindrome();
     if(res==1)
         printf(""Palindrome"");
     else
         printf(""Not palindrome"");
 }
 
 /*
 Test case 1:
 Input : malayalam
 Output : Palindrome
 
 Time complexity : O(n)
 Space complexity : O(n)
 */
",C
"class AVLTree {
    constructor() {
       // Initialising the root element to null.
       this.root = null;
    }
 
    getBalanceFactor(root) {
       return this.getHeight(root.left) - this.getHeight(root.right);
    }
 
    getHeight(root) {
       let height = 0;
       if (root === null || typeof root == ""undefined"") {
          height = -1;
       } else {
          height = Math.max(this.getHeight(root.left), this.getHeight(root.right)) + 1;
       }
       return height;
    }
 
    insert(data) {
       let node = new this.Node(data); 
       // Checking if the tree is empty
       if (this.root === null) {
          // Insert the first element as this.root = node;  
       } else {
          insertHelper(this, this.root, node);
       }
    }
    inOrder() {
       inOrderHelper(this.root);
    }
 }
 
 AVLTree.prototype.Node = class {
    constructor(data, left = null, right = null) {
       this.data = data;
       this.left = left;
       this.right = right;
    }
 };
 
 function insertHelper(self, root, node) {
    (root === null) {
       root = node;
    } else if (node.data < root.data) {
       // Go left
       root.left = insertHelper(self, root.left, node)
       // Check for balance factor and perform the appropriate rotation
       if (root.left !== null && self.getBalanceFactor(root) > 1) {
       if (node.data > root.left.data) {
          root = rotationLL(root);
       } else {
          root = rotationLR(root);
       }
    }
 } else if (node.data > root.data) {
    // Go Right
    right = insertHelper(self, root.right, node);
    // Check for balance factor and perform appropriate rotation
    if (root.right !== null && self.getBalanceFactor(root) < -1) {
       if (node.data > root.right.data) {
          root = rotationRR(root);
       } else {
          root = rotationRL(root);
       }
    }
 }
 return root;
 }
 
 function inOrderHelper(root) {
    if (root !== null) {
       inOrderHelper(root.left);
       console.log(root.data);
",JavaScript
"/*
 * Matrix is the Two-Dimensional Model
 * Matrix is the combination of rows and columns,here the rows are n & columns are m
 * size = n x m
 * Transpose of the matrix is swapping of the rows and columns in the given matrix
 * Following code gives the output of the transpose of the matrix
 */
 
 import java.util.Scanner;
 
 public class Matrix_Transpose 
 {
 	//Function for the transpose
 	public static void transpose(int[][] a,int[][] b, int n , int m) 
 	{
 		int i=0, j=0;
 		
 	    	for(i=0;i<m;i++)
     		{
 	    		for(j=0;j<n;j++)
 	    		{
 				//Each element of the transpose is assigned
 				b[i][j]=a[j][i]; 
 	    		}
     		}
 	}
 	
 	public static void main(String[] args) 
 	{
 		//To read inputs from the users Scanner is used
 		Scanner sc = new Scanner(System.in);
 		//To read number of rows required in the matrix as per user 
 		System.out.println(""Enter number of rows:"");
 		int n = sc.nextInt(); 
 		//To read number of columns required in the matrix as per user 
 		System.out.println(""Enter number of columns:"");
 		int m = sc.nextInt(); 
 		int i=0,j=0;
 		//Assigning the memory to the 2-D array according to given matrix size
 		int[][] a = new int[n][m];
 		int[][] b = new int[m][n]; 
 		System.out.println(""Enter matrix elements:"");
 	    	for(i=0;i<n;i++)
 		{
 			for(j=0;j<m;j++)
 			{
 			        //Taking user inputs(elements) of the matrix
 				a[i][j]=sc.nextInt();
 			}
 
 			System.out.println();
 		}
 	    
 	     	System.out.println(""Given Matrix elements are:"");
 	    	for(i=0;i<n;i++)
 		{
 			for(j=0;j<m;j++)
 			{
 				System.out.print(a[i][j]+"" "");
 			}
 
 			System.out.println();
 		}
 	   	transpose(a, b , n , m);
 	        System.out.println(""Transpose of Matrix:"");
 	        for(i=0;i<m;i++)
 	   	{
 		   	for(j=0;j<n;j++)
 		   	{
 		   		//Printing the elements of the matrix after transpose calculation
 		   		System.out.print(b[i][j]+"" "");
 		   	}
 		   	System.out.println();
 	   	}
 	}
 }
 	
 /*
 Sample Input:
 
 Enter numb",Java
"/* Program to convert the given BST into a Min Heap.
  Conditions are that all the values in the left subtree of a node should be less than all the values in the right subtree of the node.*/
 #include <bits/stdc++.h>
 using namespace std;
 /* Data structure to store a binary tree node*/
 struct Node
 {
     int key;
     Node *left, *right;
 };
 /* Function to create a new binary tree node having a given key*/
 Node* newNode(int key)
 {
     Node* node = new Node;
     node->key = key;
     node->left = node->right = nullptr;
     return node;
 }
 /* Recursive function to insert a key into a BST*/
 Node* insert(Node* root, int key)
 {
     /* if the root is null, create a new node and return it*/
     if (root == nullptr) {
         return newNode(key);
     }
     /* if the given key is less than the root node, recur for the left subtree*/
     if (key < root->key) {
         root->left = insert(root->left, key);
     }
     /* if the given key is more than the root node, recur for the right subtree*/
     else {
         root->right = insert(root->right, key);
     }
     return root;
 }
 /* Helper function to perform level order traversal on a binary tree*/
 void printLevelOrderTraversal(Node* root)
 {
     /* base case: empty tree*/
     if (root == nullptr) {
         return;
     }
     queue<Node*> q;
     q.push(root);
     while (!q.empty())
     {
         int n = q.size();
         while (n--)
         {
             Node* front = q.front();
             q.pop();
             cout << front->key << ' ';
             if (front->left) {
                 q.push(front->left);
             }
             if (front->right) {
                 q.push(front->right);
             }
         }
         cout << endl;
     }
 } 
 /* Function to perform inorder traversal on a given binary tree and
    enqueue all nodes (in encountered order)*/
 void inorder(Node* root, queue<int> &keys)
 {
     if (root == NULL) {
         return;
     }
     inorder(root->left, keys);
",C-Plus-Plus
"public class Solution
 {
 	/*
 
 	Given a string, return the length of the longest substring WITHOUT repeating characters.
 
 	Samples...
 	Example 1:
 		Input: ""abcabcbb""
 		Output: 3
 		Explanation: The answer is ""abc"", with the length of 3.
 
 	Example 2:
 	    Input: ""bbbbb""
 	    Output: 1
 	    Explanation: The answer is ""b"", with the length of 1.
 
 	Example 3:
 	    Input: ""pwwkew""
 	    Output: 3
 	    Explanation: The answer is ""wke"", with the length of 3. Note that the answer must be a substring, ""pwke"" is a subsequence and not a substring.
 
 	Algorithm complexity analysis:
 	This is the sliding window solution for the 'Longest Substring without Repeating Characters' problem, which is far more efficient than the naive brute force approach.
 
 	Time complexity: O(n), where n is the length of the input string.
 	Space complexity: O(k), where k is the number of unique characters in the input string.
 
 	*/
 
 	public int LengthOfLongestSubstring(string s)
 	{
 		// pointers to the substring without duplicating characters
 		int left = 0, right = -1;
 		// length of the longest substring
 		int longest_length = 0;
 		// dictionary (HashMap) for storing indices of characters in the string
 		Dictionary<char, int> d = new Dictionary<char, int>();
 
 
 		for (int i = 0; i < s.Length; i++)
 		{
 			// get current char from string
 			char c = s[i];
 
 			// check if the char is already present in dictionary's keys. If not, then, add the character into our longest substring (by updating the right pointer to our sliding window)
 
 			// If yes, then, check if the char is part of our CURRENT longest substring. If not, then, add the character into our longest substring
 			if ((!d.ContainsKey(c)) || (d[c] < left))
 			{
 				d[c] = i;
 				right += 1;
 			}
 			else
 			{
 				// If a repeating char is encountered, then update the left pointer to our current sliding window that tracks the current longest substring
 				left = d[c] + 1;
 				right += 1;
 				d[c] = i",C-Sharp
"/* Find the length of the longest sub-sequence. */
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function to Find the length of the longest sub-sequence. */
 int solve()
 {
     /* Input n = size of array */
     int n;
     cin >> n;
 
     int arr[n];
 
     /* Input values in array */
     for (int i = 0; i < n; ++i)
     {
         cin >> arr[i];
     }
 
     /* Input array element in set*/
     set<int> s;
 
     for (int i = 0; i < n; ++i)
     {
         s.insert(arr[i]);
     }
 
     int ans = 0;
     for (int i=0; i<n; i++) 
     { 
         /* Check the element is starting point of subsequences
            simply check arr[i]-1 in set */
         if (s.find(arr[i]-1) == s.end()) 
         { 
             /*check next elements in the sequence */
             int j = arr[i]; 
             while (s.find(j) != s.end()) 
                 j++; 
   
             /* Store length in ans*/
             ans = max(ans, j - arr[i]); 
         } 
     } 
     /* Return final Length */
     return ans;
 
 
 }
 
 int main()
 {
     int length = solve();
 
     cout << ""Length of the Longest subsequence is : "" << length << endl;
     return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
         
         7
         1 9 3 10 4 20 2
 
     Output 1 :
 
         Length of the Longest subsequence is : 4
 
     Input 2 :
 
         11
         36 41 56 35 44 33 34 92 43 32 42
     
     Output 2 :
     
         Length of the Longest subsequence is : 5
     
     Time complexity: O(n)
     Space Complexity: O(1)
 */
",C-Plus-Plus
"
 /* Java program to solve N Queen Problem
 using backtracking in an Optimization Method*/
 import java.util.*;
 
 class nQueens
 {
     static int N;
     //ldia : Left Diagonal to store negative indices
     static int []ldia = new int[30];
     //rdia : Right Diagonal queen placed in right diagonal or not(row+column)
     static int []rdia = new int[30];
     //col :  column array
     static int []col = new int[30];
 
     //An Effective Funtion to print Solution
     static void printSolution(int onBoard[][])
     {
         for (int i = 0; i < N; i++)
         {
             for (int j = 0; j < N; j++)
                 System.out.printf("" %d "", onBoard[i][j]);
             System.out.printf(""\n"");
         }
     }
 
     /* By this Utility Function, Consider using column 
     and try placing this queen in all rows one by one and
     check if queen can be placed or not. If Queen can be
     placed on Board then we can check left diagonal and 
     Right diagonal. If Queen placed dosen't match the 
     rules, then remove Queen on that position.*/
     static boolean solveUtil(int onBoard[][], int colo)
     {
         //BaseCase : If all Queens Placed
         if (colo >= N)
             return true;
 
         for (int i = 0; i < N; i++) {
             if ((ldia[i - colo + N - 1] != 1 &&
                     rdia[i + colo] != 1) && col[i] != 1) {
 
                 onBoard[i][colo] = 1;
                 ldia[i - colo + N - 1] =
                         rdia[i + colo] = col[i] = 1;
 
                 if (solveUtil(onBoard, colo + 1))
                     return true;
 
                 onBoard[i][colo] = 0; // BACKTRACK
                 ldia[i - colo + N - 1] =
                         rdia[i + colo] = col[i] = 0;
             }
         }
         return false;
     }
     /* This function returns false if queens
     cannot be placed, otherwise, return true and
     prints placement of queens in the form of 1s.
     */
     static boolean solBoard()
     {",Java
"# Python program to Left Rotate a number by a specific bits.
 
 
 # Left Rotate 'cnt' number of bits of the given number 'n'
 def left_rotate_bits(n, cnt):
     cnt = cnt % 31
     while(cnt > 0):
         # Store the current MSB in a temporary variable
         msb = (n >> 31) & 1
         # Left rotate the given number by one bit
         n = (n << 1)
         # Set the dropped MSB as the new LSB
         n = n | msb
         # Decrement cnt
         cnt = cnt - 1
     return n
 
 
 if __name__ == '__main__':
     print(""Enter the number? "", end="""")
     num = int(input())
     print(""How many bits do you want to rotate? "", end="""")
     cnt = int(input())
     left = left_rotate_bits(num, cnt)
     print(""The Left-rotated number is: {}"".format(left))
 
 
 """"""
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 23
 How many bits do you want to rotate? 12 
 The Left-rotated number is: 94208 
 """"""
",Python
"/*
 FIRST FIT MEMORY ALLOCATION
 Available memory blocks are accepted as input from the user
 The list of available storage is searched and as soon as a
 free block of size >= N is found, the pointer of that block
 is returned, after retaining residual space
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //structure to represent memoryblock with id and size
 typedef struct MemoryBlock
 {
     int id;
     int size;
 } MemoryBlock;
 
 //to print the id of allocated memory block
 void print_block(MemoryBlock block)
 {
     if (block.id != -1 && block.size != -1 && block.size != 0)
         printf(""Block #%d \n"", block.id);
     else
         printf(""Invalid Memory Block\n"");
 }
 
 //linked list to store memory blocks
 typedef struct MemoryManager
 {
     MemoryBlock b;
     struct MemoryManager *llink, *rlink;
 } MemoryManager;
 
 //first fit memory allocation
 MemoryBlock first_fit(MemoryManager *m, int memory)
 {
     MemoryBlock bl;
     //if the list is empty
     if (m == NULL)
     {
         bl.id = -1;
         bl.size = -1;
     }
     else
     {
         MemoryManager *ptr = m, *ptr1, *ptr2, *p;
         while (ptr->rlink != NULL && ptr->b.size < memory)
             ptr = ptr->rlink;
         //if block of size greater than memory is found
         if (ptr->b.size >= memory)
         {
             bl = ptr->b;
             bl.size = ptr->b.size;
             ptr->b.size -= memory;
         }
         else
         {
             bl.id = -1;
             bl.size = -1;
         }
     }
     return bl;
 }
 
 //to add available memory blocks to linked list
 void deallocate(MemoryManager *m, MemoryBlock memory)
 {
     MemoryManager *ptr = m;
     while (ptr->rlink != NULL)
     {
         ptr = ptr->rlink;
     }
     MemoryManager *n = new MemoryManager;
     n->b = memory;
     ptr->rlink = n;
     n->llink = ptr;
     n->rlink = NULL;
 }
 
 //driver code
 int main()
 {
     //accept the number of memory blocks and sizes as user input
     Memory",C-Plus-Plus
"// C++ program to check collinearity of three given points
 #include <bits/stdc++.h>
 using namespace std;
 
 struct Point {
     int x;
     int y;
 };
 
 /*
 We can calculate the area formed by the three points, and if the area is
 zero then they lie on a same line. 
 */
 bool check_collinear(Point a, Point b, Point c) {
     int area = 0;
 
     /*
     The Area of a Triangle formed by three points (x1, y1), (x2, y2), (x3, y3)
     is determined by the following formula
     
     Area = (1/2) * {x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)}     
     */
     area = a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y);
 
     if (area == 0)
         return true;
     else
         return false;
 }
 
 int main() {
     int x, y;
     Point a, b, c;
     cout << ""\nEnter the first co-ordinates:  "";
     cin >> a.x >> a.y;
     cout << ""Enter the second co-ordinates: "";
     cin >> b.x >> b.y;
     cout << ""Enter the third co-ordinates:  "";
     cin >> c.x >> c.y;
 
     if (check_collinear(a, b, c)) {
         cout << ""\nThe given points are collinear"" << endl;
     } else {
         cout << ""\nThe given points are not collinear"" << endl;
     }
     return 0;
 }
 
 /*
 
 Time Complexity: O(1)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the first co-ordinates:  1 1
 Enter the second co-ordinates: 2 2
 Enter the third co-ordinates:  3 3
 
 The given points are collinear
 
 */
",C-Plus-Plus
"/*
 Given an array of N elements and a value K (K <= N) , calculate maximum summation of K consecutive elements in the array.
 We can solve this problem by using Sliding Window Technique. This technique will allow us to solve this problem in O(N)
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 int ar[100009];
 
 int max_sum_by_sliding_window(int ar[] , int N , int K)
 {
     int sum = 0;
     if(N == K)
     {
         // max_sum will be the sum of all elements of array.
         for(int i = 0; i < N; i++)
             sum += ar[i];
         return sum;
     }
     if(N > K)
     {
         // calculate sum of first window of size K
         int max_sum = 0, win_sum = 0;
         for(int i = 0; i < K; i++)
             max_sum += ar[i];
 
         /*calculate sum of remaining windows
          by removing elements from first window simultaneously add elements to current window */
         win_sum = max_sum;
         for(int i = K; i < N; i++)
         {
             win_sum += (ar[i] - ar[i - K]);
             if(win_sum > max_sum)
             {
                 max_sum = win_sum;
             }
         }
         return max_sum;
       }
 }
 
 int main()
 {
 	int N, K;
 	cout << ""Input array size and value\n"";
 	cin >> N >> K;
 	for(int i = 0; i < N; i++)
     {
         cin >> ar[i];
     }
     int solve = max_sum_by_sliding_window(ar, N , K);
     cout << ""maximum summation of K consecutive elements in the array is "" << solve << endl;
 
 }
 /*
 
 Standard Input and Output
 1. if N == K
 Input array size and value
 5 5
 1 2 3 4 5
 maximum summation of K consecutive elements in the array is 15
 2. if N > K
 Input array size and value
 5 3
 5 2 -1 0 3
 maximum summation of K consecutive elements in the array is 6
 Time Complexity : O(N)
 Space Complexity : O(1)
 
 */
",C-Plus-Plus
"/*Below code is an implementation of factorial in Go. Factorial
 of a number n is defined as:
 	fact(n) = n * (n - 1) * (n - 2) ........ * 1 
 The code contains a factorial function which calculates the
 factorial of the number iteratively.*/
 
 package main
 
 import (
 	""fmt""
 )
 
 // This function calculates the factorial
 func factorial(number int) uint64 {
 
 	// Decalring variable to store the factorial
 	var factorial_number uint64 = 1
 
 	if(number >= 0) {
 		// Multiply 1 * 2 * .... * (n) using for loop
 		for i:=1; i <= number; i++ {
 			// Type conerting i to uint64 for multiplication
 			factorial_number = factorial_number * uint64(i)
 		}
 	} else {
 		// If number is negative return 0
 		return 0
 	}
 	// Return the factorial
 	return factorial_number
 }
 
 func main() {
 
 	// Taking a number as input from the user
 	var number int
 	fmt.Print(""Enter a number to find its factorial: "")
 	fmt.Scan(&number)
 
 	// Calling the factorial function
 	var factorial_value uint64 = factorial(number)
 
 	/* If the returned value is zero, the number is negative
 	   Else, the factorial of the number is printed.*/
 	if(factorial_value == 0) {
 		fmt.Print(""Please enter a positive number.\n"")
 	} else {
 		fmt.Print(""Factorial of "", number, "" is "", factorial_value, ""\n"")
 	}
 }
 
 /* Sample I/O:
 
 a) 
 Enter a number to find its factorial: -3
 Please enter a positive number.
 
 b)
 Enter a number to find its factorial: 11
 Factorial of 11 is 39916800
 
 Time Complexity - O(n)
 Space Complexity - O(1)
 
 */
 
",Go
"# Julia program to toggle the k-th bit of a number.
 function toggle(num, k)
     return (num  (1 << (k-1)))
 end
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 print(""Enter the value of k(where you need to toggle the k'th bit): "")
 k = readline()
 k = parse(Int, k)
 new_num = toggle(num, k)
 println(""The given number, after toggling the k-th bit is $new_num."")
 
 """"""
 Time Complexity: O(1)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 24
 Enter the value of k(where you need to toggle the k'th bit): 3
 The given number, after toggling the k-th bit is 28.
 
 SAMPLE 2
 Enter the number: 33
 Enter the value of k(where you need to toggle the k'th bit): 12
 The given number, after toggling the k-th bit is 2081.
 """"""
",Julia
"'''
   Sleep sort is a sorting algorithm used to sort non-negative integers. Sleep sort works by creating a separate thread for each item in the input which is to be
   sorted and then each thread sleeps for an amount of time which is proportional to the value of corresponding array element. Therefore, the thread which is having
   the least amount of sleep time wakes up first and the element gets printed and then the second least element and so on. The largest element wakes up after a long
   time and then the element gets printed at the last and thus the output obtained is a sorted array.     
 '''
   
 import threading
 import time
 
 lock = threading.Lock()
 
 class SleepSortThread(threading.Thread):
     def __init__(self, val):
         self.val = val
         threading.Thread.__init__(self)
 
     def run(self):
         global lock
         # Thread is made to sleep in proportion to value
         time.sleep(self.val * 0.01)
         # Acquire lock
         lock.acquire()
         print(self.val, end = "" "")
         # Release lock
         lock.release()
 
 def SleepSort(list):
     thread_array = []
 
     # Intialize a thread corresponding to each element in list
     for i in list:
         thread = SleepSortThread(i)
         thread_array.append(thread)
 
     # Start all Threads
     for i in thread_array:
         i.start()
 
     # Wait for all threads to terminate
     for i in thread_array:
         i.join()
 
 
 if __name__ == ""__main__"" :
     unsorted_array =[]
     number_of_elements = int(input(""Enter the number of elements : ""))
     print(""Enter the elements: "")
     for i in range(number_of_elements):
         element = int(input())
         unsorted_array.append(element)
 
     print(""The elements in sorted manner are: "")
     sorted_array = SleepSort(unsorted_array)
 
 '''
 Enter the number of elements : 7
 
 Enter the elements: 
 10
 20
 40
 5
 9
 88
 104
 
 The elements in sorted manner are:
 5 9 10 20 40 88 104
 
 
 Time Complexity -
  ",Python
"# Julian program to Find the n'th Catalan number
 # To know more about Catalan Numbers Visit Here : https://en.wikipedia.org/wiki/Catalan_number
 
 
 function find_catalan(n)
     if (n == 0 || n == 1)
         return 1
     end
 
     # DP Table 
     cat = [0 for i in 1:(n + 1)]
 
     # Initialize the first to values
     cat[1] = 1
     cat[2] = 1
     for i in 3:(n + 1)
         for j in 1:(i - 1)
             cat[i] = cat[i] +  (cat[j] * cat[i - j])
         end
     end
     return cat[n + 1]
 end
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 catalan_number = find_catalan(abs(num))
 println(""The $num'th catalan number is $catalan_number."")
 
 """"""
 Time Complexity: O(num^2), where 'num' is the given number
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 12
 The 12'th catalan number is 208012.
 
 SAMPLE 2
 Enter the number: 2
 The 2'th catalan number is 2.
 
 """"""
",Julia
"/*
 Problem link : https://www.hackerrank.com/challenges/crush/problem
 
 Problem description:
 Starting with a 1-indexed array of zeros and a list of operations, for each query add a value to each the array element between two given indices, inclusive.
 Once all operations have been performed, return the maximum value in the array.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 #define ll long long int
 
 void Max_Value(int n, int m)
 {
   int a, b, k;
   vector<ll> prefix_sum(n + 1, 0);
   for (ll queries = 1; queries <= m; queries++)
   {
     cin >> a >> b >> k;
     // Adding k at the starting point of the query
     prefix_sum[a] += k;
     // Subtracting K at the position after end point of query if and only if, it is valid.
     if ((b + 1) <= n)
     {
       prefix_sum[b + 1] -= k;
     }
   }
   ll answer = INT_MIN;
   for (ll index = 1; index <= n; index++)
   {
     prefix_sum[index] += prefix_sum[index - 1];
     answer = max(answer, prefix_sum[index]);
   }
   cout << answer << endl;
 }
 
 int main()
 {
   ll n, m;
   cin >> n >> m;
   // Max_value function prints the required answer after performing all queries.
   Max_Value(n, m);
 }
 
 /*
 Time Complexity  : O(n)
 Space Complexity : O(n)
 Input:
 5 3
 1 2 100
 2 5 100
 3 4 100
 Output:
 200
 */
 
",C-Plus-Plus
"/* This program prints the topological sorted ordering of vertices
 of a directed acyclic graph(DAG). Topological sort is the linear
 ordering of vertices in a directed acyclic graph(DAG). It is useful
 in solving many other applications on DAG.*/
 
 package main
 
 import (
 	""fmt""
 )
 
 var cnt int
 
 // This function calls the DFS recursively for adjacency list of a vertex
 func DFS_VISIT(Graph [][]int, source int, sorted, visited []int) {
 
 	// Mark the current vertex as visited
 	visited[source] = 1
 	// Visit its adjacency list recursively
 	for i := 0; i < len(Graph[source]); i++ {
 		if(visited[Graph[source][i]] == 0) {
 			DFS_VISIT(Graph, Graph[source][i], sorted, visited)
 		}
 	}
 	// After the adjacency list has been visited, add vertex to the list
 	sorted[cnt] = source
 	cnt -= 1
 }
 
 // This is trhe depth first search function
 func DFS(Graph [][]int, vertices int, sorted []int) {
 
 	// List of all visited vertices
 	visited := make([]int, vertices)
 	// Visit all the vertices
 	for i := 0; i < vertices; i++ {
 		if(visited[i] == 0) {
 			DFS_VISIT(Graph, i, sorted, visited)
 		}
 	}
 }
 
 // This function uses DFS and prints the topological sorted ordering
 func topologicalSort(Graph [][]int, vertices int) {
 
 	// Array to store the topological sorted ordering
 	sorted := make([]int, vertices)
 
 	// Call DFS
 	DFS(Graph, vertices, sorted)
 
 	// Print the sorted ordering of vertices
 	for i := 0; i < vertices; i++ {
 		fmt.Print(sorted[i], "" "")
 	}
 	fmt.Print(""\n"")
 }
 
 func main() {
 
 	var vertices int
 	var edges int
 
 	// Take number of vertices in graph as input
 	fmt.Print(""Enter the number of vertices: "")
 	fmt.Scan(&vertices)
 
 	// Take number of edges in graph as input
 	fmt.Print(""Enter the number of edges: "")
 	fmt.Scan(&edges)
 
 	cnt = vertices - 1
 
 	// Take vertex pair forming edges as input
 	fmt.Print(""Enter all the vertex pairs forming an edge: \n"")
 	var Graph = make([][]int, vertices)
 
 	var u int
 	var v int
 
 	for i",Go
"#include <bits/stdc++.h>
 using namespace std;
 //Main Begin
 int main()
 {
     string str, res;
     //Count variable take care
     //of number of count prsent
     int count = 0;
     //Input the String
     cout << ""Enter String :"" << endl;
     cin >> str;
     //For Each loop
     //traverse the entire str
     for (auto ch : str) {
         /*Check if '(' is present,
     	    then increment count variable
     	    by +1
     	    else decrement the count variable 
     	    by -1
     	    */
         if (ch == '(') {
             ++count;
             //if count >0 then
             //add ch to res String
             if (count != 1) {
                 res += ch;
             }
         }
         else {
             --count;
             //if count >1 then
             //add ch to res String
             if (count != 0) {
                 res += ch;
             }
         }
     }
     //Print the final output
     cout << ""Output:"" << res;
     return 0;
 }
 
 /* Sample Input Output 1.
 Enter String : ""(()())(())""
 Output:  ()()()
 Sample Input Output 1.
 Enter String : ""()()""
 Output: """"
 Complexities :
 Time Complexity : O(n)
 Space Complexity : O(n)
 */
",C-Plus-Plus
"""""""
 Negative Cycle: In a Directed Graph, if the sum of the weight along the
         cycle turns out to be negative, then the graph is said to have
         a negative cycle. Detection of the negative cycle in a graph is very
         important for better implementation of pathfinding algorithms.
 
 Purpose: Given a Directed Weighted Graph with N nodes and M edges, where
         each edge possesses an integer weight. Detect whether the given Graph
         has a negative cycle or not.
 
 Method: Bellman-Ford Algorithm
 Intuition: Below is algorithm find if there is a negative weight cycle
         reachable from the source (Consider 1).
     1) Initialize distances from the source to all vertices as infinite and
         distance to the source itself as 0. Create an array dist[] of size N with
         all values as infinite except dist[src] where src is source vertex.
     2) This step calculates the shortest distances. Do the following N-1 times where
         N is the number of vertices in the given graph.
         (*) Do following for each edge u-v
             If dist[v] > dist[u] + weight of edge uv, then update dist[v]
             dist[v] = dist[u] + weight of edge uv
     3) This step reports if there is a negative weight cycle in the graph. Do following
         for each edge u-v
         If dist[v] > dist[u] + weight of edge uv, then Graph contains negative
         weight cycle
 
 Time Complexity:  O((N^2)*M)
 Space Complexity: O(N)
 
 Argument: Dictionary ( Graph with nodes numbered 1 to N )
 Return  : Boolean    ( The graph contain negative cycle or not )
 """"""
 from collections import defaultdict
 
 
 def Negative_Cycle(n, graph):
 
     # Initilize the distance of each node to infinite
     distance = [float('inf') for i in range(n + 1)]
 
     # Considering source vertex as 1, puting distance[1]=0
     distance[1] = 0
 
     # To keep a count of iteration
     x = 0
     while True:
 
         # To keep a track of any updation
         boo = F",Python
"#include<bits/stdc++.h>
 using namespace std;
 void bfs(int source,vector <int> adj[],bool visited[],int parent[]){
     //Initializing a queue and pushing the source into it and marking visited for source as true
     queue<int> q; 
     q.push(source);
     visited[source] = true;
     while(!q.empty()){
         int curr = q.front();
         q.pop();
         //Traversing all the adjacents of the node
         for(auto s: adj[curr]){
             //Checking if this adjacent is visited or not
             if(!visited[s]){
                 //Pushing into the queue
                 q.push(s);
                 //Marking visited as true
                 visited[s] = true;
                 //If not visited, this parent is the one closet to the source, i.e from 0->curr->s is the shortest path till s
                 parent[s] = curr;
             }
         }
     }
 }
 int main(){
     int n,m; cin>>n>>m;
     vector <int> adj[n];
     int a,b;
     for(int i=0;i<m;i++){
         cin>>a>>b;
         adj[a].push_back(b);
         adj[b].push_back(a);
     }
     bool visited[n];
     memset(visited,false,sizeof(visited));
     //Parents array for storing the parent a nodes parent closest to the source
     int parent[n];
     //Considering 0 as the source
     parent[0] = -1;
     bfs(0,adj,visited,parent);
     //Printing shortest paths for each node from node 0
     for(int i=1;i<n;i++){
         int curr = i;
         vector<int> ans;
         while(curr!=-1){
             ans.push_back(curr);
             curr = parent[curr];
         }
         reverse(ans.begin(),ans.end());
         for(auto s: ans){
             cout<<s<<"" "";
         }cout<<endl;
     }
     return 0;
 }
 /*
 Input:
 6 7
 0 1
 1 2
 2 0
 0 3
 3 4
 4 5
 1 5
 
 Output:
 0 1 
 0 2 
 0 3 
 0 3 4 
 0 1 5
 
 Time complexity : O(n+m)
 Space complexity : O(n)
 */
",C-Plus-Plus
"#= Given a number n, print its prime factorization. We could do it 
 normal way which will be having time complexity of O (sqrt(N)) 
 but we will be using Sieve to lessen the time complexity
 We will make a sieve to get all the prime numbers and then get the 
 prime factorization of the number using that.=#
 
 ## Function
 
 function PrimeFactor(n)
     a = zeros(Int64, n)
     for i = 2:n
         a[i] = i
     end
     for i = 2:n
         if (a[i] == i)
             for j = (i*i):i:n
                 if (a[j] == j)
                     a[j] = i
                 end
             end
         end
     end
     while (n != 1)
         println(a[n])
         n = div(n, a[n])
     end
 end
 
 ## Input
 
 n = readline()
 n = parse(Int64, n)
 
 #Calling the function
 
 PrimeFactor(n)
 
 #=
 Sample Test case
 Input:
     n = 495
 Output:
     3 3 5 11
 
 Time Complexity: O( log N )
 =#",Julia
"/*
  *   Algorithm: Linear Search
  *   Author: Davide Pollicino (@omonimus1)
  *   Date: 25/06/2020
  *   Last Modified by: Davide Pollicino (@omonimus1) 26/06/2020
  *
  *	Linear search: compare every element for the beginning to the en
  *   with our target (element to find). It returns true if the target * is found, false otherwise
  */
 
 /*
  *   Search in a list a target using linear search algorithm
  */
 function linear_search(arr, target) {
   for (var i = 0; i < arr.length; i++) {
     if (arr[i] == target) return ""Found"";
   }
   return ""Not Found"";
 }
 
 /*
  *	@Test : Search an element that exists in the list
  *   Output expected: Found
  */
 function linear_search_pass_test() {
   var test1 = [1, 2, 3, 4, 5, 6, 7];
   console.log(linear_search(test1, 6));
 }
 
 /*
  *	@Test : Search an element that do not exists in the list
  *   Output expected: 'Not Found'
  */
 function linear_search_failure_test() {
   var test1 = [1, 2, 4, 5];
   console.log(linear_search(test1, 9));
 }
 
 // Entry file of the js application
 linear_search_pass_test();
 linear_search_failure_test();
",JavaScript
"/*
   Following is the code to find the minimum insertion steps required to make string a palindrome
   Approach:
       1.  Find the longest palindromic subsequence of the given string.Let it be
           stored in a variable len.
       2.  The minimum number of insertions required to make the given string a palindrome
           will be the difference of the given string and len (lps of the string).
 */
 #include<bits/stdc++.h>
 using namespace std;
 int LongestPalindromicSubsequence(string a)
 {
     int n=a.length();
     string b=a;
 
     //reversing the string
     reverse(a.begin(),a.end());
 
     //forming a 2d matrix to find lps
     vector<vector<int>>dp(n+1,vector<int>(n+1,0));
     for(int i=1;i<=n;i++)
     {
         for(int j=1;j<=n;j++)
         {
             if(a[i-1]==b[j-1])dp[i][j]=1+dp[i-1][j-1];
             else
             {
                 dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
             }
         }
     }
     return dp[n][n];
 }
 int main()
 {
     string a;
     cout<<""Enter string: "";
     cin>>a;
     int len=LongestPalindromicSubsequence(a);
     int ans=a.length()-len;
     cout<<""Minimum Insertions Required: ""<<ans<<endl;
     return 0;
 }
 /*
 Sample Input:
 Enter string: mbadabgr
 
 Sample Output:
 Minimum Insertions Required: 3
 
 Time Complexity: O(n^2)
 Space Complexity: O(n^2)
 */
",C-Plus-Plus
"/*
 Rabin Karp Algorithm (using rolling hash)
 =========================================
 Given a text and a pattern, find all the occurences of the pattern in the text
 
 Time Complexity: O(n) n=size of string
 Space Complexity: O(1)
 */
 #include <bits/stdc++.h>
 #define int long long
 using namespace std;
 
 const int mod = 1e9 + 7;
 const int p = 31;
 
 // returns (a^b)%mod
 int powr(int a, int b) {
 	int ans = 1;
 	while (b) {
 		if (b & 1LL) {
 			ans *= a;
 			ans %= mod;
 		}
 		a *= a;
 		b = b >> 1;
 		a %= mod;
 	}
 	return ans % mod;
 }
 
 // returns (a^-1)%mod
 int inv(int a) {
 	return powr(a, mod - 2) % mod;
 }
 
 // Assigns hash to a string
 int polyHashString(string s) {
 	int hash = 0;
 	int coef = 1;
 	for (int i = 0; i < s.size(); i++) {
 		hash += (s[i] - 'a' + 1) * coef;
 		coef *= p;
 		coef %= mod;
 		hash %= mod;
 	}
 	return hash % mod;
 }
 
 // Rabin Karp Algorithm for pattern matching
 // returns indices of pattern in string s
 void rabinKarp(string s, string pat) {
 
 	int n = s.size();
 	int m = pat.size();
 
 	int patHash = polyHashString(pat);
 	// Maintains hash of current window of size m
 	int currHash = polyHashString(s.substr(0, m));
 
 	bool patFound = 0;
 
 	// If first window matches pattern
 	if (currHash == patHash) {
 		cout << 0 << endl;
 		patFound = 1;
 	}
 
 	// coefficient for next character
 	int coef = powr(p, m - 1);
 
 	for (int i = 1; i <= (n - m); i++) {
 		int newHash = currHash;
 
 		// Subtract previous character
 		newHash -= s[i - 1] - 'a' + 1;
 		newHash += mod; newHash %= mod;
 
 		// divide by prime
 		newHash *= inv(p);
 		newHash %= mod;
 
 		// Add next char
 		newHash += (s[i + m - 1] - 'a' + 1) * coef;
 		newHash %= mod;
 
 		// Check
 		if (newHash == patHash) {
 			cout << i << endl;
 			patFound = 1;
 		}
 
 		currHash = newHash;
 	}
 
 	if (!patFound) {
 		cout << ""Not found"";
 	}
 }
 
 // Driver Code
 signed main() {
 
 	// Take input
 	string s, pat;
 	cin >> s >> pat;
 
 	rabinKarp(s, pat);
 }",C-Plus-Plus
"//Qs class for implementing queue using two stack with costly dequeue() 
 import java.util.Scanner;
 class QueueUsingStack {
 	int s1[];			//First stack
 	int s2[];			//Second stack
 	int size;			//size of queue
 	int topS1;			//To maintain top of stack 1
 	int topS2;			//To maintain top of stack 2
 	int count;  		//To count number of items in queue
 	public QueueUsingStack(int s)
 	{
 		topS1 = 0;
 		topS2 = 0;
 		count = 0;
 		size = s;
 		s1 = new int[size];
 		s2 = new int[size];
 	}
 	public void pushS1(int d)	  //Function to push an item of stack 1
 	{
 		s1[topS1] = d;
 		topS1++;
 	}
 	public int popS1()	         //Function to pop an item of stack 1
 	{
 		topS1--;
 		int temp = s1[topS1];
 		return temp;
 	}
 	public void pushS2(int d)	 //Function to push an item of stack 2
 	{
 		s2[topS2] = d;
 		topS2++;
 	}
 	public int popS2()			//Function to pop an item of stack 1
 	{
 		topS2--;
 		int temp = s2[topS2];
 		return temp;
 	}
 	public boolean isFull(int c) 	//Function to check whether queue is full or not
 	{
 		return (c == size);
 	}
 	public boolean isEmpty(int c)	//Function to check whether queue is empty or not
 	{
 		return (c == 0);
 	}
 	
 	public void enqueue(int d)		// Function to enqueue an item to the queue
 	{
 		if(isFull(count))
 		{
 			System.out.println(""Queue is full"");
 			System.exit(0);
 		}
 		else {
 			pushS1(d);
 			count++;
 		}
 	}
 	public int dequeue()		//Function to deQueue an item from queue
 	{
 		int temp,i,dq;
 		if(isEmpty(count))
 		{
 			System.out.println(""Queue is empty"");
 			System.exit(0);
 		}
 
 		//push all the items in stack 2
 		for(i=0;i<count;i++)
 		{
 			temp = popS1();
 			pushS2(temp);
 		}
 		dq = popS2();
 		count--;
 
 		//After poping push all the items of stack 2 back into stack 1
 		for(i=0;i<count;i++)
 		{
 			temp = popS2();
 			pushS1(temp);
 		}
 		return dq;
 	}
 	public void display()
 	{
 		int i;
 		for(i=0;i<count;i++)
 		{
 			System.out.print(s1[i]+"" "");
 		}
 	}
 }
 
 //Sq class to",Java
"/*
 Given a binary array, binary means array's element will be 0 or 1.
 find the maximum number of consecutive 1's in this array.
 */
 
 import java.util.Scanner;
 import java.lang.*;
 
 
 public class MaxConsecutiveOnes
 {
    
    static int get_max_consecutive_ones(int ar[] , int N)
    {
        int max_consecutive_ones = 0 , count_1 = 0;
        for(int i = 0; i < N; i++)
        {
             if(ar[i] == 1)
             {
                count_1++;
                //here we will keep the maximum value of consecutive 1's
                if(count_1 > max_consecutive_ones)
                {
                    max_consecutive_ones = count_1;
                }
             }
             else if(ar[i] == 0)
             {
                count_1 = 0;
             //as array's element is zero (0) we will set count_1 as zero 
             }
        }
        return max_consecutive_ones;
    }
 	
    public static void main(String args[])  
    {
 	Scanner scan = new Scanner(System.in);
 	System.out.print(""Enter the size of array \n"");
 	int number = scan.nextInt();
 		
 	int[] ar = new int[number];
 	System.out.println(""Enter array elements \n""); 
 	for(int i = 0; i < number; i++)
 	{
            ar[i] = scan.nextInt();
 	}
 	scan.close();
 	int max_consecutive_ones = get_max_consecutive_ones(ar , number);
         System.out.print(""Maximum Consecutive Ones in this array is : "");
         System.out.println(max_consecutive_ones);
 		
 	}
 }
 
 /*
 Standard Input and Output
 
 Enter the size of the array :
 6
 Enter array elements :
 1 1 0 1 1 1
 
 Maximum Consecutive Ones in this array is : 3
 
 Time Complexity : O( N )
 Space Complexity : O( 1 )
 
 */
",Java
"class Container_with_most_Water {
 public:
     int calculate(int i, int j, int x1, int x2){
         int part1 = min(x1,x2);
         return part1 * abs(j - i);
     }
     
     int maxArea(vector<int>& height) {
         int max = 0;
         int i = 0;    // left pointer
         int j = height.size() - 1;    // right pointer
         
         while (i < j){
             int curr = calculate(i,j, height[i], height[j]);
             if (curr > max) max = curr;
             if (height[i] < height[j]) i++;     
             else j--;
         }
         return max;  // Returning maxarea
     }
 };
 
 /*
 TIME COMPLEXITY
 2 POINTER APPROACH USED
 O(N) where n is the size of the array
 
 TEST CASE
 
 INPUT
 [1,8,6,2,5,4,8,3,7]
 OUTPUT
 49
 */
 
 
",C-Plus-Plus
"/*
 Code Description :
 A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations.
 It consists of nodes.A Node has 2 parts.
 One is the data part and the other is the address part. Address part contains the address of the next or the 
 successor node and data part contains value of the node.
 Through this C program,Nodes of a linked list are arranged such that the odd and the even nodes are segregated.
 Here,all even nodes appear before all the odd nodes in the modified linked list. 
 */
 
 #include <stdio.h>
 #include <malloc.h>
 
 /* Defining the structure of a Node */
 struct node
 {
   int data;
   struct node *next;
 };
 
 /* Header to point to the first node and Last to point to the Last one */
 struct node *header, *last;
 
 /* Function Declarations */
 void SegregateOddEven();
 void create();
 void show();
 
 /* Driver Function */
 void main()
 {
     int i, num;
   
     printf(""Enter the number of nodes : "");
     scanf(""%d"", &num);
   
     for (i = 1; i <= num; i++)
     {
     	create();
 	}
   	
     printf(""\nLinked List is : \n"");
     show();
   
     SegregateOddEven();
   
     printf(""\nLinked List after calling SegregateOddEven() : \n"");
     show();
 }
 
 /* Function for Creation of a Linked List */
 void create()
 {
     struct node *temp = (struct node*) malloc(sizeof(struct node));
     
     printf(""Enter value of Node: "");
     scanf(""%d"", &temp->data);
     temp->next= NULL;
     
 	if (header == NULL)
 	{
     	header = temp;
     	last = temp;
     	return;
 	}
     else
     {
     	last->next = temp;
     	last = temp;
     	return;
     }
 }
 
 /* Function to Display Nodes of a Linked List */
 void show()
 {
     struct node *temp = header;
     
     while (temp != NULL)
   	{
     	printf(""-->%d"", temp->data);
     	temp = temp->next;
     }
     
 }
 
 /* Function to Segregate Even and Odd Nodes of a Linked List */
 void SegregateOddEven()
 {
     struct node *temp = header, *p1",C
"""""""This program finds the total number of possible combinations that can be used to
  climb statirs . EG : for 3 stairs ,combination and output will be 1,1,1 , 1,2 , 2,1 i.e 3 . """"""
 
 def counting_stairs(stair_number):
     result = stair_number
     # This function uses Recursion.
     if(stair_number <=1):
         result = 1
     else:
         result = (counting_stairs(stair_number-1) + counting_stairs(stair_number-2))
     return result
 
 if __name__ == '__main__':
     count_stair = int(input(""Enter total number of stairs: ""))
     print(f""Total Number of possible Combinations = {counting_stairs(count_stair)}"")
 
 
 """"""Output 
 Total Number of possible Combinations = 8
 Enter total number of stairs: 5
 
 Time Complexity : O(2^n)
 Space Complexity :O(1)
 Created by Shubham Patel on 16-12-2020 on WoC
 """"""
",Python
"""""""
 Transpose of a matrix is a matrix obtained by changing rows to columns and columns
 to rows.In other words, transpose of Arr[][] is obtained by changing Arr[i][j] to Arr[j][i].
 The below program finds transpose of matrix[][] and stores the result in result[][]
 """"""
 
 Row = int(input(""Enter the number of rows : ""))
 Col = int(input(""Enter the number of columns : ""))
 
 matrix = []
 print(""Enter the entries rowwise:"")
 for i in range(Row):
     matrix.append([int(x) for x in input().split("" "")])
 
 result = [[0 for i in range(Col)] for j in range(Row)]
 # Storing transpose of matrix in result
 for i in range(Row):
     for j in range(Col):
         result[i][j] = matrix[j][i]
 
 print(""The Transpose of the matrix is"")
 for i in range(Row):
     for j in range(Col):
         print(result[i][j], end="" "")
     print()
 
 """"""
 Sample I/O :
 
 Enter the number of rows : 3
 Enter the number of columns : 3
 Enter the entries rowwise:
 1 2 3
 4 5 6
 7 8 9
 The Transpose of the matrix is
 1 4 7
 2 5 8
 3 6 9
 
 Time complexity : O(n^2)
 Space complexity : O(n^2)
 """"""
",Python
"/*
 Problem - 
 	To reverse the content of a queue using only a stack.
 
 Algorithm - 
 	First we pop each element from the queue and push it element by element into the stack. We keep doing this until the queue is empty.
 	Then we pop each element from the stack and push it element by element into the queue. We keep doing this until the stack is empty.
 	We get the content of queue reversed.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // Displays all content of queue
 void Q_Display(queue <int> q)
 {
 	while (!q.empty())
 	{
 		cout << q.front() << "" "";
 		q.pop();
 	}
 }
 
 // Reverses content of queue using stack
 void reverse_queue(queue <int> *q)
 {
 	stack <int> s;
 	
 	// Poping from queue and pushing into stack
 	while (!q->empty())
 	{
 		s.push(q->front());
 		q->pop();
 	}
 	// Poping from stack and pushing into queue
 	while (!s.empty())
 	{
 		q->push(s.top());
 		s.pop();
 	}
 }
 
 int main()
 {
 	queue <int> q;
 	int temp, n;
 	
 	cout << ""Enter queue size : "";
 	cin >> n;
 	
 	while (n--)
 	{
 		cout << ""\nEnter a number : "";
 		cin >> temp;
 		q.push(temp);
 	}
 	
 	cout << ""\nOriginal queue : "";
 	Q_Display(q);
 	
 	reverse_queue(&q);
 	
 	cout << ""\nReversed queue : "";
 	Q_Display(q);
 }
 /*
 Test run example - 
 	Enter queue size : 5
 	Enter a number : 1
 	Enter a number : 2
 	Enter a number : 3
 	Enter a number : 4
 	Enter a number : 5
 	
 	Original queue : 1 2 3 4 5
 	Reversed queue : 5 4 3 2 1
 
 Time and Space Complexity - 
 	Time - O(n)
 	Space - O(n)
 */
",C-Plus-Plus
"/* Program to calculate b^n%m . This program also known as 
     Recursive Modular Exponentiation */
 	 
 #include<iostream>
 #include <cmath>
 using namespace std;
 
 int power(int b,int n,int m)  
 {
 	if(n==0)
 	  return 1;
 	else if(n%2==0)
 	  return power(b,n/2,m)*power(b,n/2,m)%m;
 	else
 	  return power(b,n/2,m)*power(b,n/2,m)%m*b%m;
 }
 int main()
 {
 	int b,n,m;
 	cout<<""Enter base \n"";
 	cin>>b;
 	cout<<""Enter Exponent \n"";
 	cin>>n;
 	cout<<""Enter Value to take modulus\n"";
 	cin>>m;
 	cout<<""\nAnswer of b ^ n % m : ""<<power(b,n,m);
 }
 /*
 Input:-
 2 6 6 
 Ouput:-
 4
 */
 
 /*
 Time Complexity - O(n)
 Space Complexity - O(n)
 */
 
 
",C-Plus-Plus
"'''
 is_prime_iterative() function uses an iterative approach to check the
 primality of the passed argument. It checks for each number i from 5 to
 sqrt(num)+1 that whether it divides the passed number or not. If it does, the
 passed number is not prime, otherwise the number is prime.
 
 Time Complexity: O(sqrt(n))
 Space Complexity: O(1)
 Return Type: Boolean
 '''
 
 
 def is_prime_iterative(num):
 
     # Base Cases
     if(num <= 1):
         return False
     elif (num <= 3):
         return True
     elif(num %2 == 0 or num %3 == 0):
         return False
     for i in range(5, int(num**(1/2))+1,6):
         if (num % i == 0 or num % (i+2) == 0):
             return False
 
     # If the passes this test, then the num is prime, hence return True
     return True
 
 
 '''
 is_prime_recursive() function checks the primality of number passed through
 recursive approach. It is similar to the iterative function but here we use
 recursion to check for the next divisor.
 
 Time Complexity: O(sqrt(n))
 Space Complexity: O(1)
 Return Type: Boolean
 '''
 
 
 def is_prime_recursive(num, i=2):
 
     # Base Cases
     if num == 2 or i * i > n:
         return True
 
     if num <= 1 or n % i == 0:
         return False
 
     # check the next divisor
     return is_prime_recursive(num, i + 1)
 
 # -------------------------------Driver Code-------------------------------
 
 if __name__ == ""__main__"":
     n = int(input(""Enter the number to be checked : ""))
     print(""Iterative Approach:- "", is_prime_iterative(n))
     print(""Recursive Approach:- "", is_prime_recursive(n))
 
 """"""
 Enter the number to be checked : 13
 Iterative Approach:-  True
 Recursive Approach:-  True
 
 Enter the number to be checked : 35
 Iterative Approach:-  False
 Recursive Approach:-  False
 
 Enter the number to be checked : 1
 Iterative Approach:-  False
 Recursive Approach:-  False
 """"""
",Python
"#!/usr/bin/env python3
 """""" Solution: Sort an array of random integers with merge sort using sequential way.""""""
 
 import random
 
 """""" sequential implementation of merge sort """"""
 def sequential_mergesort(array, *args):
     # first call
     if not args: 
         sequential_mergesort(array, 0, len(array)-1)
         # return the sorted array
         return array 
         # recursive call
     else: 
         left, right = args
         if (left < right):
             # find the middle point
             mid = left + ((right - left) // 2) 
             # sort the left half
             sequential_mergesort(array, left, mid) 
             # sort the right half
             sequential_mergesort(array, mid+1, right) 
             # merge the two sorted halves
             merge(array, left, mid, right) 
 
 """""" helper method to merge two sorted subarrays
     array[l..m] and array[m+1..r] into array """"""
 def merge(array, left, mid, right):
     # copy data to temp subarrays to be merged
     left_temp_arr = array[left:mid+1].copy()
     right_temp_arr = array[mid+1:right+1].copy()
     # initial indexes for left, right and merged subarrays
     left_temp_index = 0
     right_temp_index = 0
     merge_index = left
     # merge temp arrays into original
     while (left_temp_index < (mid - left + 1) or right_temp_index < (right - mid)):
         if (left_temp_index < (mid - left + 1) and right_temp_index < (right - mid)):
             if (left_temp_arr[left_temp_index] <= right_temp_arr[right_temp_index]):
                 array[merge_index] = left_temp_arr[left_temp_index]
                 left_temp_index += 1
             else:
                 array[merge_index] = right_temp_arr[right_temp_index]
                 right_temp_index += 1
                 # copy any remaining on left side
         elif (left_temp_index < (mid - left + 1)): 
             array[merge_index] = left_temp_arr[left_temp_index]
             left_temp_index += 1
             # copy any remaini",Python
"/*
 AVL tree is basically a self-balancing binary search tree in which the balancing factor
 i.e difference between the height of left-subtree and right-subtrees is either 0 or 1 or -1
 (not more than one). If the balance factor is disturbed then we need to rotate the nodes 
 to maintain the balance factor.
 */
 #include<stdio.h>
 #include<stdlib.h>
 /*Structure of the AVL Tree*/
 struct node
 {
     int info;
     struct node *left,*right;
     int height;
 };
 /*Function to perform in-order traversal of the tree*/
 void inorder(struct node* root)
 {
     if(root==NULL)
         return;
     inorder(root->left);
     printf(""%d  "",root->info);
     inorder(root->right);
 }
 /*Function to perform pre-order traversal of the tree*/
 void preorder(struct node* root)
 {
    if(root==NULL)
     return;
    printf(""%d  "",root->info);
    preorder(root->left);
    preorder(root->right);
 }
 /*Function to perform post-order traversal of the tree*/
 void postorder(struct node* root)
 {
    if(root==NULL)
     return;
    preorder(root->left);
    preorder(root->right);
    printf(""%d  "",root->info);
 }
 /*Function to height of the tree*/
 int height(struct node *root)
 {
     if(root==NULL)
         return 0;
     else
         return root->height;
 }
 /*Function to calculate maximum of two given numbers*/
 int max(int a,int b)
 {
     return(a>b)?a:b;
 }
 /*Function that returns tree-node after left-left rotation*/
 struct node* LLrotation(struct node *root)
 {
     struct node *p1;                         //for adjustments
     struct node *p2;
     p1=root;                               //A
     p2=root->left;                         //B
     p1->left=p2->right;                    //A->left = B->right;
     p2->right=p1;                          //B->right = A;
     return p2;                               //new pointer i.e. B
 }
 /*Function that returns tree-node after right-right rotation*/
 struct node* RRrotation(struct node *root)
 {
     struct node *p1;            ",C
"# Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
 # Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
 # In simpler words sort an array containing 0,1,2.
 # Solve the problem with a one-pass algorithm using only O(1) constant space?
 # The bruteforce approach - Sort the vector in nlogn time
 
 # PROBLEM STATEMENT- https://leetcode.com/problems/sort-colors/
 
 #                                 ************************DUTCH_NATIONAL_FLAG ALGORITHM***********************************
 
 # Python program to sort an array with 0, 1 and 2 in a single pass using DUTCH NATIONAL FLAG ALGORITHM
 
 # Function to sort array 
 def dnf_algo( array, len): 
     low = 0 
     high = len - 1
     mid = 0
     while mid <= high:        
         if array[mid] == 0: 
             array[low], array[mid] = array[mid], array[low] 
             low = low + 1
             mid = mid + 1
         elif array[mid] == 1: 
             mid = mid + 1
         else: 
             array[mid], array[high] = array[high], array[mid]  
             high = high - 1
     return array 
 
 if __name__ == ""__main__"":
     
     # Now by taking all the values in one line and mapping into list    
     array = list(map(int,input().split()))  
 
     # finding length of list
     arr_size = len(array) 
     array = dnf_algo(array, arr_size) 
     print(""Array after applying Dutch National Flag Algo :"")
 
     # printing the final resultant array
     print(*array)   
 
 # ------------------------------------------ TEST CASES -------------------------------------
 # Sample I/P 1:
 # 2 0 1
 
 # Sample O/P 1:
 # Array after applying Dutch National Flag Algo : 0 1 2
 
 #--------------------------------------------------------------------------------------------
 
 # Sample I/P 2:
 # 2 0 2 1 1 0
 
 # Sample O/P 2:
 # Array after appl",Python
"/**
 It is a backtracking problem in which there are N knights 
 that need to be placed on an N*N board in such a manner so 
 that no two knights can kill each other.
 The code will display all the possible positions of Knights
 where - will represent a blank box and 
 X will represent a Knight in a box.
 */
 
 import java.util.Scanner;
 
 public class NKnightKill {
 
     private static void display(char[][] board) {
 		
 		for (int i=0; i<board.length; i++) {
 			for (int j=0; j<board.length; j++) {
 				System.out.print (board[i][j]+""\t"");
 			}
 			System.out.println();
 		}
 	}
 	
 	private static boolean isSafe(char[][] board, int i, int j) {
 		// function will check if is it safe to
 		// place the Knight at i,j
 
 		if (i-2>=0 && j-1>=0 && board[i-2][j-1]=='X') {
 			return false;
 		}
 		if (i-2>=0 && j+1<board.length && board[i-2][j+1]=='X') {
 			return false;
 		}
 		if (i-1>=0 && j-2>=0 && board[i-1][j-2]=='X') {
 			return false;
 		}
 		if (i-1>=0 && j+2<board.length && board[i-1][j+2]=='X') {
 			return false;
 		}
 		return true;
 	}
 	
 	private static void nKnight(char[][] board, int i, int j, int n) {
 
 		if (n==0) {
 			System.out.println(""Possibility ""+count+"" - "");
 			display (board);
 			count++;
 			System.out.println();
 			return;
 			
 		} else if (i==board.length) {
 			return;
 			
 		} else if (j==board.length) {
 			nKnight(board, i+1, 0, n);
 			
 		} else {
 			if (isSafe(board,i,j)) {
 				board[i][j]='X';
 				nKnight(board, i, j+1, n-1);
 				board[i][j]='-';
 			}
 			
 			nKnight(board, i, j+1, n);
 		}
 	}
 	
 	static int count = 1;
 	
 	public static void main(String[] args) {
 
 		Scanner sc=new Scanner(System.in);
 		
 		System.out.print (""Enter no. of Knights / board size - "");
 		int n=sc.nextInt();
 		
 		char[][] board=new char[n][n];
 		for (int i=0; i<n; i++) {
 			for (int j=0; j<n; j++) {
 				board[i][j]='-';
 			}
 		}
 		
 		nKnight(board,0,0,n);
 	}
 }
 
 /**
 Time Complexity  : O(2^(N*N))
 Space Complexity :",Java
"/*
 Rabin Karp Algorithm (using prefix sum)
 =========================================
 Given a text and a pattern, find all the occurences of the pattern in the text
 
 Time Complexity: O(n) n=size of string
 Space Complexity: O(1)
 */
 #include <bits/stdc++.h>
 #define int long long
 using namespace std;
 
 const int mod = 1e9 + 7;
 const int p = 31;
 
 // returns (a^b)%mod
 int powr(int a, int b) {
 	int ans = 1;
 	while (b) {
 		if (b & 1LL) {
 			ans *= a;
 			ans %= mod;
 		}
 		a *= a;
 		b = b >> 1;
 		a %= mod;
 	}
 	return ans % mod;
 }
 
 // returns (a^-1)%mod
 int inv(int a) {
 	return powr(a, mod - 2) % mod;
 }
 
 // Assigns hash to a string
 int polyHashString(string s) {
 	int hash = 0;
 	int coef = 1;
 	for (int i = 0; i < s.size(); i++) {
 		hash += (s[i] - 'a' + 1) * coef;
 		coef *= p;
 		coef %= mod;
 		hash %= mod;
 	}
 	return hash % mod;
 }
 
 // Rabin Karp Algorithm for pattern matching
 // returns indices of pattern in string s
 void rabinKarp(string s, string pat) {
 
 	int pat_hash = polyHashString(pat);
 	int n = s.size(), m = pat.size();
 
 	int pref[n] = {0};
 
 	for (int i = 0; i < n; i++) {
 		pref[i] = (s[i] - 'a' + 1) * powr(p, i);
 		pref[i] %= mod;
 	}
 
 	for (int i = 1; i < n; i++) {
 		pref[i] += pref[i - 1];
 		pref[i] %= mod;
 	}
 
 	bool patFound = 0;
 	for (int i = 0; i <= (n - m); i++) {
 		// substring from s[l.......r]
 		// r = i+m - 1
 		int l = i;
 		int r = i + m - 1;
 
 		int new_hash = pref[r];
 
 		if (i - 1 >= 0) {
 			new_hash -= pref[l - 1];
 		}
 
 		new_hash += mod; new_hash %= mod;
 
 		if (new_hash == (pat_hash * powr(p, l)) % mod) {
 			cout << i << endl;
 			patFound = 1;
 		}
 	}
 
 	if (!patFound) {
 		cout << ""Not found"";
 	}
 }
 
 // Driver Code
 signed main() {
 
 	// Take input
 	string s, pat;
 	cin >> s >> pat;
 
 	rabinKarp(s, pat);
 }
 
 /*
 Input:
 ilovecoding
 love
 
 Output:
 1
 
 Input:
 aaaaaaaa
 aaa
 
 Output:
 0
 1
 2
 3
 4
 5
 */
",C-Plus-Plus
"/* Cpp code for Sqrt Monotonic Binary Search,
    In this algorithm we will find the square root of a number `num`
    upto `p` digits after decimal using the binary search algorithm. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /* Function to find the square root of a number `num` */
 float sqrt(int num, int p)
 {
 	int start = 0;	
 	int end = num;		
 	float ans = -1; 
 	int mid;	
 	while (start <= end)
 	{
 		/* find the middle element */
 		mid = (start + end) / 2;
 
 		/* return `mid` 
 		   if `num` is a perfect square */
 		if (mid * mid == num)
 			return mid;
 
 		/* if `mid*mid` is less than `num` */
 		else if (mid * mid < num)
 		{
 			/* change the starting point to mid+1 
 			   and update the answer */
 			start = mid + 1;
 			ans = mid;
 		}
 
 		/* if `mid*mid` is more than `num`,
 		   change the end point to mid-1 */
 		else
 			end = mid - 1;
 	}
 
 	float temp = 0.1;
 
 	/* This for loop will give `p` digits 
 	   after the decimal to the `ans` */
 	for (int i = 1; i <= p; i++)
 	{
 		while (ans * ans <= num)
 			ans = ans + temp;
 
 		ans = ans - temp;
 		temp = temp / 10;
 	}
 
 	/* return answer */
 	return ans;
 }
 
 /* Driver Function */
 int main()
 {
 	int num;
 	cout << ""Enter the number : "";
 	cin >> num;
 	cout << ""The square root of "" << num << "" is : "" << sqrt(num, 3);
 }
 
 /*
 SAMPLE I/O =>
 
 1.
 Enter the number : 20
 The square root of 20 is : 4.472
 
 2.
 Enter the number : 16
 The square root of 16 is : 4
 
 Time complexity : O(log(n))
 Space complexity : O(n)
 
 */
",C-Plus-Plus
"''' This code checks if a number is a happy number. A number is
     called happy if it becomes 1 after iterating thorugh a several
     number of steps wherein each step the number is replaced by the
     sum of its digits.'''
 
 
 ''' This function takes a number as input and returns
     sum of its digits.'''
 def sum_square_digits(number):
 
     sum_squares = 0
     
     while(number):
         ''' Taking mod of number with 10 each time
             gives its units place digit. We add its
             square to the sum.'''
         sum_squares += (number % 10) ** 2;
         # Replace the number with number / 10.
         number = number // 10;
     
     return sum_squares
 
 ''' This function takes a number as input and checks
     if the number is a happy number. The idea behind
     the code is - we maintain two variables. The second
     variable is one step ahead of the first one. If
     the first variable becomes 1 so the second will be
     1 anyhow, because 1*1 = 1. So, we terminate the loop.'''
 def is_happy_number(number):
 
     first = number
     second = number
 
     while(True):
 
         # The first variable calling sum of digits function once 
         first = sum_square_digits(first)
 
         # The second variable calling sum of digits function twice
         second = sum_square_digits(second)
         second = sum_square_digits(second)
 
         ''' If the first one equals the second, we break out of the
             loop. Otherwise, it will run into an infinite loop.'''
         if(first == second):
             break
         else:
             continue
     ''' The number is happy if at the end of iterations the number
         becomes 1. If it is one, then we return True.'''
     if(first == 1):
         return True
     else:
         return False
 
 ''' This function prints the sequence of steps, if the number
     indeed was a happy number.'''
 def print_steps(number):
 
     display = 0
     # Iterate till we get 1
     while(",Python
"/*
 The problem states that Given an array of integer and a target value. 
 Return all the unique combination of array where chosen number sum to 
 target. You may return combination in any order. (Note that each element
 in returned array should occur one time only)
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void find(vector<int> arr, vector<vector<int>> &ans, vector<int> &r, int sum, int start)
 {
   if (sum < 0)
     return;
   else if (sum == 0)
   {
     ans.push_back(r);
     return;
   }
   for (int i = start; i < arr.size(); i++)
   {
     if (i > start && arr[i] == arr[i - 1])
       continue;
     if (sum - arr[i] < 0)
       break;
     r.push_back(arr[i]);
     find(arr, ans, r, sum - arr[i], i + 1);
     r.pop_back();
   }
 }
 vector<vector<int>> combinationSum2(vector<int> &arr, int target)
 {
   vector<vector<int>> ans;
   vector<int> r;
   sort(arr.begin(), arr.end());
   find(arr, ans, r, target, 0);
   return ans;
 }
 
 int main()
 {
   int n;
   cout<<""Enter Number of elements in the array:"";
   cin >> n;
   cout<<""Enter elements of array:"";
   vector<int> arr;
   for (int i = 0; i < n; i++)
   {
     int x;
     cin >> x;
     arr.push_back(x);
   }
   int target;
   cout<<""Enter target:"";
   cin >> target;
   vector<vector<int>> answer = combinationSum2(arr, target);
   cout<<""\nCombination Sum without Repeated Values are:\n"";
   for (int i = 0; i < answer.size(); i++)
   {
     cout << ""["";
     for (int j = 0; j < answer[i].size(); j++)
     {
       cout << answer[i][j] << "","";
     }
     cout << ""]\n"";
   }
 }
 
 /*
 Test case 1:
 Input:
 Enter Number of elements in the array:7
 Enter elements of array:10 1 2 7 6 1 5
 Enter target:8
 
 Output:
 
 Combination Sum without Repeated Values are:
 [1,1,6,]
 [1,2,5,]
 [1,7,]
 [2,6,]
 
 Time-Complexity : O(2^n)
 Space-Complexity: O(n)
 
 */
",C-Plus-Plus
"/*
 Top view of binary tree
 
 Given a binary tree, print the nodes in left to right manner as visible from above the tree.
 Input is given in order of root left child then right child.
 For e.g. 1 2 3 4 5 6 -1 -1 -1 -1 -1 -1 -1
 Tree looks like 
               1
           /      \
       2           3
     /     \       /
   4       5     6
    
 nodes '5' and '6' will be overlapped by '1' as seen from above, 
 so when viewed from the top , we would see the nodes 4, 2, 1 and 3.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // class for defining the the node, left and right child pointer along 
 // with a constructor for assigning the ""key"" to the node.
 class node
 {
 public:
     int val;
     node *left;
     node *right;
 
     node(int d)
     {
         val = d;
         left = NULL, right = NULL;
     }
 };
 
 // function for taking the input from user and assigning the node values accordingly.
 // Queue has been used to assign the ""keys"" to left and right child alternatively
 node *maketree()
 {
     int d;
     queue<node *> q;
     cout << ""Enter the root value: "";
     cin >> d;
     node *root = new node(d);
     q.push(root);
     while (!q.empty())
     {
         node *temp = q.front();
         q.pop();
         int l, r;
         cout << ""\nEnter the left and right childs : "";
         cin >> l >> r;
         if (l != -1)
         {
             // assigning value to the left child pointer and inserting  is as the parent node to repeat the process
             temp->left = new node(l);
             q.push(temp->left);
         }
         if (r != -1)
         {
             // assigning value to the right child pointer and inserting it as the parent node to repeat the process
             temp->right = new node(r);
             q.push(temp->right);
         }
     }
     cout << ""\n"";
     return root;
 }
 
 // The Concept is combining the left side view and right side view of that tree, will be the in total, the top view as all overlapp",C-Plus-Plus
"/* Program Statement: Given an array, and a percent K, we need to find out the mean of the remaining elements in the array after removing
                      K-th percent smallest and greatest numbers from it.
 Approach used: After sorting the given array, find the K-th percent of the size of the array, then add the elements with the index numbers K% to(n-1)-K%.
                Ultimately we find the mean of those elements added.
 Time Complexity: O(n log n)
 Space Complexity: O(n) */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /* Function to find out the K-th percent and then eventually the mean */
 void solve(int a[], int n, int k)
 {
 	/* Sorting the array */
 	sort(a, a + n);
 
 	/* Finding the K-th percent */
 	int kth_percent = (n * k) / 100;
 	float s = 0;
 
 	/* Storing the remaining elements in the array
 	after removing the largest and smallest K-th percent number in the array */
 	for (int i = 0; i < n; i++)
 		if (i >= kth_percent && i < (n - kth_percent))
 			s = s + a[i];
 
 	/* Calculating the mean */
 	float m = s / (n - 2 * kth_percent);
 
 	/* The mean would be printed upto 3 decimal places  */
 	cout << fixed << setprecision(3) << m << endl;
 }
 
 /* Main Function */
 int main()
 {
     ios_base::sync_with_stdio(false);
     cin.tie(NULL);
 
     /*Taking the number of test cases as input*/
     int tc;
     cin >> tc;
     while(tc--)
     {
     /* The size of the array and the K-th percent is being taken as input */
     int n,k;
     cout << ""Enter the size of the array "" << endl;
 	cin >> n;
 	cout << ""Enter the K-th percent "" << endl;
 	cin >> k;
 
     /* Taking the array values as input */
     int a[n];
     cout << ""Enter the array values "" << endl;
 	for(int i = 0; i < n; i++)
         cin >> a[i];
 
     /*Calling the function solve() to calculate the mean */
 	solve(a, n, k);
 
     }
 
 	return 0;
 }
 
 /* A Sample test case for the above problem
 
 Input:
 1
 Enter the size of the array
 5
 Enter the K-th percent
 20
 Ent",C-Plus-Plus
"#include<bits/stdc++.h>
 using namespace std;
 
 //Mapping one plain-text alphabet to more than one cipher-text alphabet.
 void mapping(vector<vector<char> > &code) {    
 	code[0].push_back('Q');code[0].push_back('4');
 	code[1].push_back('W');
 	code[2].push_back('E');
 	code[3].push_back('R');
 	code[4].push_back('T');code[4].push_back('5');code[4].push_back('9');code[4].push_back('0');
 	code[5].push_back('Y');
 	code[6].push_back('U');
 	code[7].push_back('I');
 	code[8].push_back('O');code[8].push_back('8');
 	code[9].push_back('P');
 	code[10].push_back('A');
 	code[11].push_back('S');
 	code[12].push_back('D');
 	code[13].push_back('F');code[13].push_back('7');
 	code[14].push_back('G');code[14].push_back('2');
 	code[15].push_back('H');
 	code[16].push_back('J');
 	code[17].push_back('K');
 	code[18].push_back('L');code[18].push_back('1');
 	code[19].push_back('Z');code[19].push_back('6');
 	code[20].push_back('X');
 	code[21].push_back('C');
 	code[22].push_back('V');
 	code[23].push_back('B');
 	code[24].push_back('N');
 	code[25].push_back('M');	
 }
 
 /* Encodes characters of plain text by one of the 
 several different cipher text letters using a map. */
 string encode(string plain) {
 	
 	vector<vector<char> >code(26);
 	mapping(code);
 	string encrypted = """";
 	int n = plain.length();
 	for(int i = 0;i < n; ++i) {
 		//if lowercase character
 		if(plain[i] >= 97) {
 			int num = (rand() % (code[plain[i] - 97].size()));
 			
 			if(code[plain[i]-97][num] >= 65)
 				encrypted = encrypted+char(code[plain[i]-97][num]- 65 + 97);
 			else
 				encrypted = encrypted+code[plain[i]-97][num];
 		}
 		//uppercase letter
 		else {
 			int num = (rand() % (code[plain[i]-65].size()));
 			encrypted = encrypted+code[plain[i]-65][num];
 		}
 	}
 	
 	return encrypted;
 }
 
 int main(){
 	
 	vector<vector<char> >code(26);
 	mapping(code);
 	
 	string plain,encrypt;
 	cout<<""Enter the plain text: "";
 	cin>>plain;
 	
 	encrypt = encode(plain);
 	cout<<""Cipher Text: ""<<",C-Plus-Plus
"//Count Inversion problem with mergesort algorithm where i < j and arr[j] < arr[i] is an inversion
 using System;
 
 namespace CountInversionsProblem
 {
     class Count_Inversions
     {
         //The merge step to sort the elements and count inversions
         private static int Merge(int[] arr, int[] temp, int leftStart, int mid, int rightEnd)
         {
             int left = leftStart, right = mid + 1, index = left, count = 0;
             //Compare Elments from arr portion and sort them in temproray array temp
             while (left < mid + 1 && right <= rightEnd)
             {
                 if (arr[right] < arr[left])
                 {
                     temp[index] = arr[right++];
                     count += mid + 1 - left;
                 }
                 else
                 {
                     temp[index] = arr[left++];
                 }
                 index++;
             }
             // if the arr porion sorted but i didn't reach the last element place the rest in temp 
             for (; left <= mid; left++)
                 temp[index++] = arr[left];
             // if the arr porion sorted but j didn't reach the last element place the rest in temp 
             for (; right <= rightEnd; right++)
                 temp[index++] = arr[right];
             //Place the sorted elements from temp into arr
             for (left = leftStart; left <= rightEnd; left++)
                 arr[left] = temp[left];
 
             return count;
         }
         // recursive part in merge sort to break the array into smaller portions and count inversions
         private static int CountInversions(int[] arr, int[] temp, int leftStart, int rightEnd)
         {
             if (leftStart < rightEnd)
             {
                 int count = 0;
                 int mid = leftStart + (rightEnd - leftStart) / 2;
                 count += CountInversions(arr, temp, leftStart, mid);
                 count += CountInversions(arr, temp, mid ",C-Sharp
"""""""
 Julia program to implement Eulerian Number
 Eulerian number is a number found in combinatorial mathematics. It is the number of permutations of the 
 numbers 1 to n in which exactly m elements are greater than previous element.
 """"""
 
 
 function eulerian(n, m)
     # Build a Dynamic Programming table
     dp = zeros(Int, n + 1, m + 1)
 
     # Fill the table in Bottom-Up manner
     for i in 2:(n+1)
         for j in 1:(m+1)
             #Update the table only if i greater than j
             if(i > j)
                 if(j == 1)
                     dp[i, j] = 1
                 else
                     dp[i, j] = (((i - j) * dp[i-1, j-1]) + ((j) * dp[i-1, j]))
                 end
             end
         end
     end
     return dp[n + 1,m + 1]
 end
 
 
 print(""Enter the value of n? "")
 n = readline()
 n = parse(Int64, n)
 print(""Enter the value of m? "")
 m = readline()
 m = parse(Int64, m)
 ans = eulerian(n, m)
 print(""The required eulerian number is "")
 print(ans)
 
 
 """"""
 Time Complexity - O(n * m)
 Space Complexity - O(n * m)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 Enter the value of n? 3
 Enter the value of m? 1
 The required eulerian number is 4
 
 SAMPLE II
 Enter the value of n? 15
 Enter the value of m? 6
 The required eulerian number is 311387598411
 """"""
",Julia
"#include<iostream>        //Header file 
 #include<ctime>           //To use time function as a seed for pseudo random generator
 #include<cstdlib>         //For pseudo random number generator
 using namespace std;      //For cin and cout
 
 /*
     In Randomized Quick Sort, we use random number to pick the next pivot (or we randomly shuffle the array)
     and then apply quick sort on the array. Randomization is used here to eliminate the worst case time complexity
     of quick sort (that is, when the input array is already sorted).
 
     @author Aditya Saxena
     @since 27-7-2020
 */
 
 //Implemention randomShuffle function
 void randomShuffle( int a[], int start, int end ){
 
     //Seed time to the pseudo random number generator
     srand( time( NULL ) );
 
     int i, j;
 
     //Generate random number and bring them to range 0 to i+1 and store in j
     //Swap element at ith and jth index
     for( i= end; i >= 0; i-- ){
 
         j= rand() % ( i + 1 );
         swap(a[j],a[i]);
 
     }
 }
 
 //Implement partitionPivot function
 int partitionPivot( int a[], int start, int end ){
 
     int i= start-1;
     int j= start;
     int pivot= a[end];
 
     //Traverse the array - whenever an element smaller than pivot occurs, swap it with (i+1)th element 
     for(j= start; j<= end-1; j++){
         
         if(a[j] <= pivot){
             i++;
             swap(a[i],a[j]);
         }
     }
 
     //Place the pivot element at i+1 (between smaller and larger elements)
     swap(a[i+1],a[end]);
 
     //Return position of pivot
     return i+1;
 }
 
 //Implement Quick Sort function
 void quickSort( int a[], int start, int end ){
 
     //base case
     //If start (index) crosses end (index), there are no elements to sort further, thus return
     if( start >= end ){
         return;
     }
 
     //Taking end element as pivot, place the pivot element in its right position such that
     //elements left to the pivot are smaller than pivot and elements right to t",C-Plus-Plus
"/*
 Floyd-Warshall Algorithm is an algorithm
 for finding the shortest path between all the
 pairs of vertices in a weighted graph.
 This algorithm works for both the directed
 and undirected weighted graphs.
 But, it does not work for the graphs with negative cycles
 */
 
 #include<stdio.h>
 int i, j, k, n, arr[10][10];
 //Floyd function
 void floyd_Warshall () {
 //Add all vertex one by one
 	for (k = 0; k < n; k++) {
 		//pick all as a source
 		for (i = 0; i < n; i++) {
 			//pick all as a destination
 			for (j = 0; j < n; j++) {
 				if ((arr[i][k] * arr[k][j] != 0) && (i != j)) {
 					//If vertex k is on the shortest path from
 					// i to j, then update the value of arr[i][j]
 					if ((arr[i][k] + arr[k][j] < arr[i][j]) || (arr[i][j] == 0)) {
 						arr[i][j] = arr[i][k] + arr[k][j];
 					}
 				}
 			}
 		}
 	}
 }
 //Main function Began
 int main() {
 	int i, j;
 	//Enter the number of vertex
 	printf(""enter no of vertices :"");
 	scanf(""%d"", &n);
 	printf(""\n"");
 //Enter values for array
 	for (i = 0; i < n; i++)
 		for (j = 0; j < n; j++) {
 			printf(""arr[%d][%d]:"", i, j);
 			scanf(""%d"", &arr[i][j]);
 		}
 //call Floyd function
 	floyd_Warshell();
 //OUTPUT
 	printf(""OUTPUT"");
 //print the output
 	printf ("" \n\n Shortest distances are :\n"");
 	for (int i = 0; i < n; i++) {
 		for (int j = 0; j < n; j++)
 			printf (""%d\t"", arr[i][j]);
 		printf(""\n"");
 	}
 	return 0;
 }
 //main function ends
 
 /*
 Sample Input Output:
 enter no of vertices:4
 
 dist[0][0]:0
 dist[0][1]:8
 dist[0][2]:999
 dist[0][3]:1
 
 dist[1][0]:999
 dist[1][1]:0
 dist[1][2]:1
 dist[1][3]:999
 
 dist[2][0]:4
 dist[2][1]:999
 dist[2][2]:0
 dist[2][3]:999
 
 dist[3][0]:999
 dist[3][1]:2
 dist[3][2]:9
 dist[3][3]:0
 
 OUTPUT:
 Shortest distances are:
 0	3	4	1
 5	0	1	6
 4	7	0	5
 7	2	3	0
 
 Time Complexity:O(N^3)
 */
",C
"/*Sort an array using a single loop.*/
 
 #include <bits/stdc++.h>
 using namespace std;
 void swapping(int *arr, int index)
 {
     int temp = arr[index];
     arr[index] = arr[index + 1];
     arr[index + 1] = temp;
 }
 int main ()
 {
     int length;
     cout << ""Enter the size of array: "";
     cin >> length;
     int *arr = new int[length];
 
     for(int i = 0; i < length; i++)
     {
         cout << ""Array["" << i << ""] : "";
         cin >> arr[i];
     }
 
     for(int i = 0; i < length - 1; i++)
     {
         if(arr[i] > arr[i+1])
         {
             swapping(arr, i);
             i = -1;
         }
     }
     cout << ""Sorted Array: "";
     for(int i = 0; i < length; i++)
         cout << arr[i] << ""\t"";
     delete[] arr;
     return 0;
 }
 
 /*
 INPUT 1
 Enter the size of array: 5
 Array[0] : 89
 Array[1] : 54
 Array[2] : 654
 Array[3] : 3
 Array[4] : 15
 
 OUTPUT
 Sorted Array: 3 15      54      89      654
 
 INPUT 2
 Enter the size of array: 9
 Array[0] : 0
 Array[1] : 0
 Array[2] : 0
 Array[3] : 1
 Array[4] : 1
 Array[5] : 1
 Array[6] : 0
 Array[7] : 1
 Array[8] : 6
 
 OUTPUT
 Sorted Array: 0 0       0       0       1       1       1       1       6
 
 TIME COMPLEXITY
 The time complexity does not change for sorting using single loop in comparison to more than one loop sorting techniques.
 
 SPACE COMPLEXITY
 O(n)
 
 */
",C-Plus-Plus
"/*Matrix Sort Method
 Matrix is sorted in a way such that all elements in a row are sorted in increasing order and for row i, 
 where 1 <= i <= n-1, first element of row 'i' is greater than or equal to the last element of row 'i-1'.
 */
 #include <stdio.h>
 #include <stdlib.h>
 
 void matrix_sort(int[][10], int, int);
 int main()
 {
 	int ROW, COLUMN;
 	printf(""Enter Row: "");
 	scanf(""%d"", &ROW);
 	printf(""Enter Column: "");
 	scanf(""%d"", &COLUMN);
 	printf(""Enter the elements of Matrix:\n"");
 	int arr[10][10], i, j;
 	for (i = 0; i < ROW; i++)
 	{
 		for (j = 0; j < COLUMN; j++)
 		{
 			scanf(""%d"", &arr[i][j]);
 		}
 	}
 
 	matrix_sort(arr, ROW, COLUMN);
 	printf(""\nSorted Matrix: \n"");
 	for (i = 0; i < ROW; i++)
 	{
 		for (j = 0; j < COLUMN; j++)
 		{
 			printf(""%d "", arr[i][j]);
 		}
 
 		printf(""\n"");
 	}
 
 	return 0;
 }
 
 // Sorting the matrix using matrix sort method
 void matrix_sort(int arr[][10], int ROW, int COLUMN)
 {
 	int i, j, minumum, temp, q, w, minimum, k, z;
 	for (i = 0; i < ROW; i++)
 	{
 		for (j = 0; j < COLUMN; j++)
 		{
 			temp = i;
 			q = j;
 			minimum = arr[i][j];
 			w = j;
 			for (k = i; k < ROW; k++)
 			{
 				for (; w < COLUMN; w++)
 				{
 					if (arr[k][w] < minimum)
 					{
 						minimum = arr[k][w];
 						z = k;
 						q = w;
 					}
 				}
 
 				w = 0;
 			}
 
 			if (arr[z][q] < arr[i][j])
 			{
 				temp = arr[i][j];
 				arr[i][j] = minimum;
 				arr[z][q] = temp;
 			}
 		}
 	}
 }
 
 /*
 Sample Output
 Enter Row: 3
 Enter Column: 3
 Enter the elements of matrix :
 7 8 9
 5 6 4
 3 1 2
 Sorted Matrix :
 1 2 3
 4 5 6
 7 8 9
 
 Complexities
 Time Complexity: O(n2log2n)
 Space Complexity : Auxiliary Space: O(n2)
  */
 
  ",C
"""""""
     Rabin-Karp or Karp-Robin is an pattern matching algorithm with  average case and best case complexity O(m + n) and the worst case complexity  O(mn), it is most efficient when  used with multiple patterns
     as it is able to check if any of a set of patterns match a section of text in O(1)
     given the precomputed hashes.
 """"""
 # Numbers of alphabet which we call base
 alphabet_size = 256
 
 def rabin_karp(pattern, text, modulus=1000003):
 
     M = len(pattern)
     N = len(text)
     i = 0
     j = 0
     pattern_hash = 0
     text_hash = 0
     h = 1
     no_of_matches = 0
 
     for i in range(M-1):
         h = (h*alphabet_size) % modulus
 
     # Calculate the hash values of pattern and text
 
     for i in range(M):
         pattern_hash = (alphabet_size*pattern_hash + ord(pattern[i])) % modulus
         text_hash = (alphabet_size*text_hash + ord(text[i])) % modulus
 
     # Slide the pattern over text one by one
     for i in range(N-M+1):
 
         if pattern_hash == text_hash:
 
             for j in range(M):
                 if text[i+j] != pattern[j]:
                     break
 
             j += 1
 
             if j == M:
                 print(f""Pattern found at index {i}"")
                 no_of_matches += 1
 
         if i < N-M:
             text_hash = (alphabet_size*(text_hash -
                                         ord(text[i])*h) + ord(text[i+M])) % modulus
 
             if text_hash < 0:
                 text_hash = text_hash+modulus
 
     if no_of_matches == 0:
         print(""No matches found for the given pattern"")
     elif no_of_matches == 1:
         print(""Only one match found for the given pattern"")
     else:
         print(
             f""There are {no_of_matches} matches for the pattern in the text "")
 
 def main():
 
     text = input(""Enter the text: "")
     pattern = input(""Enter the pattern: "")
     rabin_karp(pattern, text)
 
 main()
",Python
"/*
   Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering
   of vertices such that for every directed edge uv, vertex u comes before v in
   the ordering. Topological Sorting for a graph is not possible if the graph is
   not a DAG.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 vector<vector<int>> adjList;
 stack<int> s;
 bool *visited;
 
 // Number of Test Cases (Vertices)
 int n;
 
 // function to Create and represent a graph by storing data.
 void createGraph()
 {
     int x, y;
     adjList.resize(n);
 
     for (int j = 0; j < n; j++)
     {
         cin >> x >> y;
         adjList[x].push_back(y);
     }
 }
 
 // A recursive function used by topoSortFun.
 void topoSortFun(int i)
 {
     visited[i] = true;
     for (int j = 0; j < adjList[i].size(); j++)
     {
         int key = adjList[i][j];
         if (!visited[key])
             topoSortFun(key);
     }
     s.push(i);
 }
 
 // The function to do Topological Sort. It uses recursive topoSortFun(). 
 void topoSort()
 {
     memset(visited, false, sizeof(visited));
 
     for (int i = 0; i < n; i++)
     {
         if (!visited[i])
             topoSortFun(i);
     }
 }
 
 void display()
 {
     for (int i = 0; i < n; i++)
     {
         cout << s.top() << "" "";
         s.pop();
     }
 }
 
 int main()
 {
     cout<<""Enter number of node you want to add: "";
     cin >> n;
     visited = new bool[n];
     cout<<""Enter nodes of graph: "";
     createGraph();
     topoSort();
     cout<<""Graph after topological sort: \n"";
     display();
 }
 
 /*
 Test Case:
 Input:
 Enter number of node you want to add: 6
 Enter nodes of graph: 
 5 2 
 5 0 
 4 0 
 4 1 
 2 3 
 3 1 
 
 Output:
 Graph after topological sort: 
 5 4 2 3 1 0 
 
 Time Complexity: O(V + E)  where V is the number of vertices and E is the number of edges.
 Space Complexity: O(V)
 */ 
 
",C-Plus-Plus
"// C++ program to implement Matrix Multiplication
 #include <bits/stdc++.h>
 using namespace std;
 
 int main()
 {
     int r1, c1, r2, c2;
     cout << ""Enter the number of rows and columns of the first matrix:  "";
     cin >> r1 >> c1;
     cout << ""Enter the number of rows and columns of the second matrix: "";
     cin >> r2 >> c2;
 
     //If the number of columns of the second matrix and the number of rows of first matrix differ, they cannot be added
     if (c1 != r2)
     {
         cout << ""Given Matrices cannot be multiplyable!!!"";
         return 0;
     }
     int A[r1][c1], B[r2][c2], C[r1][c2] = {0};
 
     // Input the values of the matrices
     cout << ""Enter the values of the first matrix\n"";
     for (int i = 0; i < r1; i++)
     {
         for (int j = 0; j < c1; j++)
             cin >> A[i][j];
     }
     cout << ""Enter the values of the second matrix\n"";
     for (int i = 0; i < r2; i++)
     {
         for (int j = 0; j < c2; j++)
             cin >> B[i][j];
     }
 
     // Multiply both the matrices
     for (int i = 0; i < r1; i++)
     {
         for (int j = 0; j < c2; j++)
         {
             C[i][j] = 0;
             for (int k = 0; k < c1; k++)
                 C[i][j] += A[i][k] * B[k][j];
         }
     }
 
     cout << ""The resultant matrix is:\n"";
     for (int i = 0; i < r2; i++)
     {
         for (int j = 0; j < c2; j++)
             cout << C[i][j] << "" "";
         cout << endl;
     }
     return 0;
 }
 
 /*
 Time Complexity: O(r1 * c2 * c1), where 'r1' is the number of rows of first matrix and 'c2' is the number of columns 
                  of second matrix and 'c1' is the number of columns of first matrix   
 Space Complexity: O(r1 * c2)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number of rows and columns of the first matrix:  2 2
 Enter the number of rows and columns of the second matrix: 2 2
 Enter the values of the first matrix
 1 1
 1 1
 Enter the values of the second matrix
 1 1
 1 1
 The resultant matrix is:
 2 2",C-Plus-Plus
"/*
 Given a sorted array of N elements and a value, find the first and last index position of the value number.
 We can do this with the help of Binary Search.
 */
 
 #include <stdio.h>
 
 //this f_indx will give us first position of the number
 int f_indx(int ar[], int N , int value)
 {
     int low = 0;
     int high = N;
     while (low < high)
     {
         int mid =  low + (high - low) / 2;
         /* here if the mid contains value greater than or equal to our targeted value
         we set that position as high */
         if (value <= ar[mid])
         {
             high = mid;
         }
         else
         {
             low = mid + 1;
         }
     }
     return low;
 }
 
 //this l_indx will give us last position of the number
 int l_indx(int ar[], int N , int value)
 {
     int low = 0;
     int high = N;
     while (low < high)
     {
         int mid =  low + (high - low) / 2;
          /* here if the mid contains value greater than or equal to our targeted value
         we set that position as low */
         if (value >= ar[mid])
         {
             low = mid + 1;
         }
         else
         {
             high = mid;
         }
     }
     return low - 1;
 }
 
 int main()
 {
     printf(""Enter the size of the array : \n"");
     int N;
     scanf(""%d"", &N);
     printf(""Enter the target value\n"");
     int value;
     scanf(""%d"", &value);
     int ar[N + 1];
     printf(""Enter array elements :\n"");
     for(int i = 0; i < N; i++)
     {
         scanf(""%d"", &ar[i]);
     }
     int first_index = f_indx(ar, N , value);
     int last_index = l_indx(ar, N , value);
     printf(""First index position is :\n"");
     printf(""%d\n"" ,first_index);
     printf(""Last index position is : \n"");
     printf(""%d\n"" ,last_index);
 }
 
 /*
 Standard Input and Output
 
 Enter the size of the array :
 10
 Enter the target value
 12
 Enter array elements :
 1 2 4 6 8 10 12 12 12 12
 
 First index position is :
 6
 Last index position is :
 9
 
 Time C",C
"// C++ program to Rotate a number by a specific bits
 #include <bits/stdc++.h> 
 using namespace std; 
 
 // Left Rotate 'cnt' number of bits of the given number 'n'
 int left_rotate_bits(int n, int cnt)
 {
     int msb;
     
     // 32 is the total number of bits used to store an INT variable in C++
     for(cnt = cnt % 31;cnt>0;cnt--)
     {
         //Store the current MSB in a temporary variable
         msb = (n >> 31) & 1;
         //Left rotate the given number by one bit
         n = (n<<1);
         //Set the dropped MSB as the new LSB
         n = n | msb;
     }
     return n;
 }
 
 // Right Rotate 'cnt' number of bits of the given number 'n'
 int right_rotate_bits(int n, int cnt)
 {
     int lsb;
     
     // 32 is the total number of bits used to store an INT variable in C++
     for(cnt = cnt % 31;cnt>0;cnt--)
     {
         //Store the current LSB in a temporary variable
         lsb = n & 1;
         //Right rotate the given number by one bit and drop its LSB
         n = (n >> 1) & (~(1 << 31));
         //Set the dropped LSB as the new MSB
         n = n | (lsb << 31);
     }
     return n;
 }
 
 
 int main()
 {
     int n,cnt,left,right;
     cout<<""\nEnter the number? "";
     cin>>n;
 
     cout<<""How many bits do you want to rotate? "";
     cin>>cnt;
   
     //Call the sort function 
     left = left_rotate_bits(n, cnt);  
     right = right_rotate_bits(n,cnt);
 
     cout<<""The Left-rotated number is: ""<<left<<endl;
     cout<<""The Right-rotated number is: ""<<right<<endl;
 
     return 0;
 }
 
 /*
 
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 39
 How many bits do you want to rotate? 17
 The Left-rotated number is: 5111808 
 The Right-rotated number is: 1277952
 
 */
",C-Plus-Plus
"// Checking Armstrong number with Recursion
 
 import java.util.Scanner;
 class ArmStrongRecursion
 {
     static int p;
     public static int armstrong(int i)
     { if(i<10) //base class
         return (int)(Math.pow(i,p));
         else
         return((int)Math.pow(i%10,p)+armstrong(i/10));
     }
     public static void main(String args[])
     {
         Scanner sc=new Scanner(System.in);
         System.out.print(""N = "");
         int n=sc.nextInt();
         p=Integer.toString(n).length(); //calculating the number of digits in the number by converting it into String
 
         if(n==armstrong(n))
         System.out.println(n+"" is an Armstrong number"");
         else
         System.out.println(n+"" is not an Armstrong number"");
     }
 }
 
 /*
 Sample Input and Output :
 N = 153
 153 is an Armstrong number
 Space Complexity: O(1)
 Time Complexity : O(p)
 */
",Java
"""""""Julia program to implement Quick sort
 Quick Sort is a Divide and Conquer strategy based sorting algoithm, that partitions the array
 around a selected pivot element. In the below implemented version of Quick Sort we always took the 
 last element as the pivot element.
 
 """"""
 function  partition(arr, low, high)
     # Select the last element as pivot
     pivot = arr[high]
     i = low - 1
     for j in low:high
         # Check if there is any element less than the pivot element
         if(arr[j] < pivot)
             i = i + 1
             # Swap such an element with the to the start position
             arr[i], arr[j] = arr[j], arr[i]
         end
     end
     # Now place the pivot to its original position
     arr[i+1], arr[high] = arr[high], arr[i+1]
     return (i+1)
 end
 
 function quick_sort(arr, low, high)
     if (low < high)
         pi = partition(arr, low, high)
         # Recursively call quick_sort function
         quick_sort(arr, low, pi - 1)
         quick_sort(arr, pi + 1, high)
     end
 end
        
 
 
 print(""How many numbers do you want to sort? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""No numbers to sort!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 quick_sort(arr, 1, n)
 print(""The numbers in sorted order is "")
 print(arr)
 
 
 
 """"""
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 How many numbers do you want to sort? 5
 Enter the numbers: 4 2 5 1 3
 The numbers in sorted order is [1, 2, 3, 4, 5]
 
 """"""
",Julia
"
 '''
 Random search (RS) is a family of numerical optimization methods that do not require the gradient 
 of the problem to be optimized, and RS can hence be used on functions that are not continuous or 
 differentiable. Such optimization methods are also known as direct-search, derivative-free, or 
 black-box methods.
 
 The name ""random search"" is attributed to Rastrigin[1] who made an early presentation of RS 
 along with basic mathematical analysis. RS works by iteratively moving to better positions in
 the search-space, which are sampled from a hypersphere surrounding the current position.
 
 The algorithm described herein is a type of local random search, where every iteration is
 dependent on the prior iteration's candidate solution. There are alternative random search 
 methods which sample from the entirety of the search space (for example pure random search or 
 uniform global random search).
 
 This is the Las vegas version of the random search. a Las Vegas algorithm is a randomized algorithm 
 that always gives correct results; that is, it always produces the correct result or it informs about
 the failure. However, the runtime of a Las Vegas algorithm differs depending on the input. 
 
 It take a element from the list randomly and compare it with element give input by user untill correct one found.
 
 Improvement:
 *The stopping condition if not found element in search space.
 
 '''
 
 
 import random
 
 # manual input function from user
 
 
 def get_list(size):
     l = []
     for i in range(size):
         l.append(int(input()))
     return l
 
 # random algorithm to search the algorithm.
 
 
 def random_search(ele, _list):
     collector = random.choice(_list)
 
     while True:
         prev = collector
         if collector == ele:
             print('element found')
             break
 
         collector = random.choice(new_list)
 
 
 if __name__ == ""__main__"":
     new_list = get_list(int(input(""enter the size of the list:"")))
     ele = int(i",Python
"# This program checks whether a number is an armstrong number or not
 
 import math
 
 def no_of_digits(n : int) -> int:
     count = 0
     while n > 0:
         count += 1
         n = n // 10
     return count
 
 def add(n : int) -> int:
     temp = n
     tot = 0
     nod = no_of_digits(temp)
     while n > 0:
         r = n % 10
         tot += r ** nod
         n = n // 10
     return tot
 
 def checkArmstrong(num : int) -> bool:
     return add(num) == num
     
 num = int(input(""Enter the number""))
 print(add(num))
 if checkArmstrong(num):
     print(""It is an armstrong number"")
 else:
     print(""It is not an armstrong number"")
     
 # Example: 
 # 1. Input : 153
 #   Output : It is an armstrong number
 # 2. Input : 12
 #   Output : It is not an armstrong number
",Python
"""""""
 A Queue is a linear structure which follows a particular order in which the operations are performed.
 The order is First In First Out. The below program reverses a queue using stack data structure.
 """"""
 stack = []
 queue = []
 
 def reverse(queue):
     while(len(queue)):
         stack.append(queue.pop(0))
     while(len(stack)):
         queue.append(stack.pop())
 
 
 n = int(input(""Enter the elements to insert into queue : ""))
 print(""Enter the elements"")
 temp = list(map(int,input().split("" "")))
 for i in range(n):
     queue.append(temp[i])
 print(""The elements in the queue are "")
 for i in range(n):
     print(queue[i],end = "" "")
 print()
 print(""Elements in queue after reversing using stack"")
 reverse(queue)
 for i in range(n):
     print(queue[i],end = "" "")
 
 """"""
 Sample I/O:
 
 Enter the elements to insert into queue : 5
 Enter the elements
 2 4 3 1 5
 The elements in the queue are
 2 4 3 1 5
 Elements in queue after reversing using stack
 5 1 3 4 2
 
 Time complexity : O(n)
 Space complexity : O(n)
 """"""
 
",Python
"/*
 Given:
 1. 'n' jobs.
 2.  an array containing respective deadlines.
 3.  an array containing respective profits. 
 4. all jobs takes unit time to complete.
 5. Initially all the jobs are at t=0;
 
 Assumption:
  profit array is in descending order.
 
 Problem statement:
 select the subset of given n-jobs, such that the jobs which are selected must be completed
 within their deadlines and get maximum profit. 
 
 Objective:
 to get max profit and sheduled jobs.
 */
 #include<iostream>
 #include<algorithm>
 using namespace std;
 void JSD_algo(int[],int[],int[],int);
 int main()
 {
   int n,k;
   cout<<""enter the no. of jobs:""<<endl;
   cin>>n;
   int jobs[n],profit[n],deadlines[n];
   cout<<""enter the profit in decreasing order:""<<endl;
   for(k=0;k<n;k++)
       cin>>profit[k];
   cout<<""enter the respective deadline:""<<endl;
   for(k=0;k<n;k++)
       cin>>deadlines[k];
   cout<<""enter the respective job serial no.:""<<endl;
   for(k=0;k<n;k++)
       cin>>jobs[k];
   JSD_algo(jobs,profit,deadlines,n);
 }
 
 void JSD_algo(int jobs[],int p[],int d[],int n)
 {
   int profit=0,i,max_dl,j;
   max_dl=*max_element(d,d+n); /* finding max deadline*/
   int sub_job[max_dl]={0}; /* no. of maximum jobs can be sheduled will be equal to max deadline */
   for(i=0;i<n;i++)   
      {
          for(j=d[i]-1;j>=0;j--)
          {
            if(sub_job[j]==0)
            {
               profit=profit+p[i];
               sub_job[j]=jobs[i];
               break;
            }
          }  
      }
      cout<<""sheduled jobs:\n"";
      for(int k=0;k<max_dl;k++)
          cout<<sub_job[k]<<"" "";
      cout<<""\nmax profit:""<<profit;
 }
 
 /* 
 Time complexity:O(n^2) becase we are using loop inside a loop .(nxn)
 space complexity:O(1)
 --------------------------------------------------------------------------------------------------------
 input:
 enter the no. of jobs:
 6
 enter the profit in decreasing order:
 100 85 74 65 60 43
 enter the respective deadline:
 4 1 3 1 2 2
 enter t",C-Plus-Plus
"/**
  * Minimum Window Substring 
  *          OR
  * Smallest Window in a String Containing All Characters of Another String
  * Given two strings string1 and string2, find the smallest substring in 
  * string1 containing all characters of string2. 
  */
 
 import java.io.*;
 public class MinimumWindowSubstring {
     
     static final int CHAR_COUNT = 26; 
 
     //Checking if all characters in pattern are contained in substring
     //or not
     public static boolean isValid(int[] str, int[] pattern) {
         for(int i=0; i<CHAR_COUNT; i++) {
             if(str[i] < pattern[i])
                 return false; 
         }
         return true; 
     }
 
     public static String findSmallestSubstring(String str, String pattern) {
 
         //To store count of characters in str and pattern, respectively
         int strCount[] = new int[CHAR_COUNT];
         int ptrCount[] = new int[CHAR_COUNT]; 
 
         //Counting number of occurrences of each character in pattern
         for(int i=0; i<pattern.length(); i++) 
             ptrCount[pattern.charAt(i) - 'a']++; 
 
         int end, start;
         end = start = 0;
         String result = ""-1""; //If no valid substring is found, ""-1"" is returned
 
         //start and end are pointers for start and end of substring
         while(end < str.length()) {
 
             //When substring does not contain all characters of pattern, we 
             //expand substring by adding characters from the end
             if(!isValid(strCount, ptrCount)) {
                 strCount[str.charAt(end) - 'a']++; 
                 end++; 
                 continue; 
             } 
 
             //Updating substring contained in result
             if(result.equals(""-1"") || result.length() > (end - start))
                 result = str.substring(start, end); 
 
             //To get length of smallest valid substring, we shorten the substring 
             //from front (i.e., eliminate characters from start)
             strCo",Java
"# Program to merge two arrays in a single array
 
 # function to perform arrays merge operation
 
 def mergearray(array1, array2, size1, size2):
 
     i = size1 - 1
     j = 0
 
     # iterating through first array from the end and the second array from
     # start
     while i >= 0 and j < size2:
 
         # swap if number in 1st array is greater than 2nd array
         if array1[i] > array2[j]:
             temporary = array1[i]
             array1[i] = array2[j]
             array2[j] = temporary
         i = i - 1
         j = j + 1
 
     # sorting both the arrays to get the final result
     array1.sort()
     array2.sort()
     print(""Array after merge:"")
     for i in range(size1):
         print(array1[i], end=' ')
         i = i + 1
     for i in range(size2):
         print(array2[i], end=' ')
         i = i + 1
 
 size1 = int(input('Enter size of 1st array:'))
 print('Enter elements of array 1: ')
 array1 = list(map(int, input().split()))
 
 size2 = int(input('Enter size of 2nd array: '))
 print('Enter elements of array 2: ')
 array2 = list(map(int, input().split()))
 mergearray(array1, array2, size1, size2)
 
 '''
 Sample I/O:
 
     Input:
 
     Enter size of 1st array:3
     Enter elements of array 1:
     1 2 3
     Enter size of 2nd array: 2
     Enter elements of array 2:
     1 2
 
     Output:
 
     Array after merge:
     1 1 2 2 3
 
 Time Complexity: O(NlogN)(where N will be max of size1 and size2)
 Space Complexity: O(1)
 '''
",Python
"// Author: @belikesayantan
 
 package main
 
 import (
 	""bufio""
 	""errors""
 	""fmt""
 	""log""
 	""os""
 	""strconv""
 	""strings""
 	""time""
 )
 
 func main() {
 	var strArray []string
 	var intArray []int
 
 	fmt.Println(""Enter an array with spaces"")
 	reader := bufio.NewReader(os.Stdin)
 	arr, err := reader.ReadString('\n')
 	if err != nil {
 		inputErr := errors.New(""something is wrong with your array input"")
 		log.Fatal(inputErr)
 	}
 	arr = strings.TrimSpace(arr)
 	strArray = strings.Split(arr, "" "")
 
 	for _, val := range strArray {
 		ele, err := strconv.Atoi(val)
 		if err != nil {
 			panic(err)
 		}
 		intArray = append(intArray, ele)
 	}
 
 	start := time.Now() // timer starts and records running time of SelectionSort Algorithm
 	fmt.Println(""Sorted Array is: "", SelectionSort(intArray))
 	end := time.Now() // timer stops and recording running time of SelectionSort Algorithm is completed
 
 	fmt.Println(""\nRunning Time of SelectionSort Algorithm is: "", end.Sub(start))
 }
 
 // SelectionSort Algorithm Time Complexity : O(n^2)
 func SelectionSort(arr []int) []int {
 	for i := 0; i < len(arr); i++ {
 		min := i
 		for j := i + 1; j < len(arr); j++ {
 			if arr[j] < arr[min] {
 				min = j
 			}
 		}
 		if min != i {
 			swap(arr, i, min)
 		}
 
 	}
 
 	return arr
 }
 
 func swap(arr []int, i, j int) {
 	temp := arr[i]
 	arr[i] = arr[j]
 	arr[j] = temp
 }
 
 /*
 	I/O Sample:
 
 	Sample 1:
 	 go run selectionSort.go
 	Enter an array with spaces
 	5 3 2 4 5 84 6 1 54
 	Sorted Array is:  [1 2 3 4 5 5 6 54 84]
 
 	Running Time of SelectionSort Algorithm is:  73.83s
 
 
 	Sample 2:
 	 go run selectionSort.go
 	Enter an array with spaces
 	5 8 6 9 1 3 2 7 4
 	Sorted Array is:  [1 2 3 4 5 6 7 8 9]
 
 	Running Time of SelectionSort Algorithm is:  39.509s
 
 
 
 	Time Complexity:
 		1. (n^2) in best case
 		2. O(n^2) in average case
 		3. O(n^2) in worst case
 
 	Space Complexity: O(1) in worst case
 
 */
",Go
"/*
 Factorial is the product of all positive integers less than or equal to a given positive integer 
 and denoted by that integer and an exclamation point. 
 Thus, factorial five is written 5!, meaning 1  2  3  4  5.
 Factorial zero is defined as equal to 1.
 */
 
 import java.util.Scanner;
 
 public class Factorial {
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter Number: "");
         int n = sc.nextInt();
         System.out.println(""Factorial of "" +n+ "" is: "" + fact(n));
     }
     public static int fact(int n){
         if(n==0)
             return 1;
 
         return n*fact(n-1);
     }
 }
 
 /*
     Test Cases:
     Enter Number: 7
     Factorial of 7 is: 5040
 
     Enter Number: 0
     Factorial of 0 is: 1
 
     Time Complexity: O(n)
     Space Complexity: O(n)
 */",Java
"/*
 Given a database with user names.
 Each time a new user wants to register, he sends to the system a request with his name.
 If such a name does not exist in the system database, it is inserted into the database.
 and the user gets confirming the successful registration.
 If the name already exists in the system database, the system makes up a new user name,
 sends it to the user as a prompt Numbers, starting with 1, are appended one after another to
 name (name1, name2..) and so on. Print all user names with their corresponding database names.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // this insert_usernames_in_database function will print all user names with their corresponding database names
 void insert_usernames_in_database(vector < string >user_names)
 {
     map < string , int > user_entry;
     int size_of_username = user_names.size();
     for(int i = 0; i < size_of_username; i++)
     {
         if(user_entry.find(user_names[i]) == user_entry.end())
         {
             cout << ""The User name is unique: "";
             cout << user_names[i] << endl;
             user_entry[user_names[i]]++;
         }
         else if(user_entry.find(user_names[i]) != user_entry.end())
         {
             cout << ""The User name is not unique: "";
             cout << user_names[i] << user_entry[user_names[i]] << endl;
             user_entry[user_names[i]]++;
 
         }
     }
 }
 
 int main()
 {
     cout << ""Enter the number of User Names : \n"";
     int Number;
     cin >> Number;
     vector < string > user_names;
     cout << ""Enter user names:\n"";
     for (int i = 0; i < Number; i++)
     {
 	    string name;
 	    cin >> name;
 	    user_names.push_back(name);
     }
     insert_usernames_in_database(user_names);
 }
 
 /*
 Standard Input and Output
 
 Enter the number of User Names :
 8
 Enter user names:
 karim
 rahim
 khan
 bhab
 gssoc
 gssoc
 karim
 rahim
 The User name is unique: karim
 The User name is unique: rahim
 The User name is",C-Plus-Plus
"//This is the post-order traversal 
 /*
 Author - Chaitanya Khinvasara
 */
 
 /*
 Working of the algorithm 
    
    1. Traverse the left subtree until you find null
    2. Traverse the right subtree until you find null
    3. Visit the root.
 */
 
 
 
 #include <iostream>
 using namespace std;
 
 
 struct node
 {
     int data;
     struct node *left, *right;
 };
 
 //Creation of new node
 struct node *newNode(int item)
 {
     struct node *temp = new node;
     temp->data = item;
     temp->left = temp->right = NULL;
     return temp;
 };
 
 //insertion of the node
 struct node * insert(struct node *root, int element)
 {
     if(root == NULL)
         return newNode(element);
     if(root->data > element)
         root->left = insert(root->left, element);
     else if (root->data < element)
         root->right = insert(root->right, element);
     return root;
 }
 
 //Post-order traversal
 void postorder(struct node *root)
 {
     if(root == NULL)
         return;
     
     postorder(root->left);
     postorder(root->right);
     cout << root->data << "" "";
 }
 
 int main()
 {
     struct node *root = NULL;
     root = insert(root, 60);
     insert(root, 40);
     insert(root, 50);
     insert(root, 70);
     insert(root, 80);
     insert(root, 10);
 
 
     cout<<""Post-order is "" <<endl;
     postorder(root);
     return 0;
 }
",C-Plus-Plus
"'''
 Counting sort is a sorting algorithm that sorts the elements of an
 array by counting the number of occurrences of each unique element in the array.
 Worst Case Complexity: O(n+k)
 Best Case Complexity: O(n+k)
 Average Case Complexity: O(n+k)
 where n is size of an array , and k is element range of the array.
 In this program default 'k' is 1000.
 '''
 
 def counting_sort(l, k=None):
     #  creating an array for counting elements
     if k == None:
         arr = [0]*1000
     else:
         arr = [0]*(k+1)
     # counting the occurrence of elements
     for i in l:
         arr[i]+=1
     # generating sorted array
     l=[]
     for i in range(len(arr)):
         l+=[i]*arr[i]
     return l
 
 
 if __name__ == ""__main__"":
     l = list(map(int,input(""Enter the elements of the list to be sorted:"").split()))
     l = counting_sort(l)
     print(""List after sorting:"",*l)
 
 '''
 Sample Input:
 Enter the elements of the list to be sorted:12 0 1 3 5 3 3 2 1 1
 
 Sample Output:
 List after sorting:0 1 1 1 2 3 3 3 5 12
 '''
",Python
"'''
 8 PUZZLE PROBLEM SOLVING USING BREADTH FIRST SEARCH
 
 An instance of the n-puzzle game consists of a board holding n^{2}-1 
 distinct movable tiles, plus an empty space. The tiles are numbers from 
 the set 1,..,n^{2}-1. For any such board, the empty space may be legally 
 swapped with any tile horizontally or vertically adjacent to it. In this 
 assignment, the blank space is going to be represented with the number 0. 
 Given an initial state of the board, the combinatorial search problem is 
 to find a sequence of moves that transitions this state to the goal state; 
 that is, the configuration with all tiles arranged in ascending order 
 0,1,..,n^{2}-1.
 
 So, this is the goal state that we want to reach:
 [1, 2, 3]
 [8, 0, 4]
 [7, 6, 5] 
 
 The search space is the set of all possible states reachable from the 
 initial state. The blank space may be swapped with a component in one of 
 the four directions {Up, Down, Left, Right}, one move at a time.
 
 Algorithm Review:
 The search begins by visiting the root node of the search tree, given by 
 the initial state. Among other book-keeping details, three major things 
 happen in sequence in order to visit a node:
 -First, we remove a node from the frontier set.
 -Second, we check the state against the goal state to determine if a 
  solution has been found.
 -Finally, if the result of the check is negative, we then expand the node. 
  To expand a given node, we generate successor nodes adjacent to the current 
  node, and add them to the frontier set. Note that if these successor nodes 
  are already in the frontier, or have already been visited, then they should 
  not be added to the frontier again.
 
 '''
 
 # importing the necessary libraries
 from time import time
 from queue import Queue
 
 # creating a class Puzzle
 class Puzzle:
     # setting the goal state of 8-puzzle 
     goal_state=[1,2,3,8,0,4,7,6,5]
     num_of_instances=0
     # constructor to initialize the class membe",Python
"/* Given a list of non-negative integers nums (The numbers not need necessarily to be single digit), arrange them such that they form the largest number. 
    Intuition
    To construct the largest number, we want to ensure that the most significant digits are occupied by the largest digits. */ 
    
 /* Code / Solution */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Comparator function for custom sorting  */
 static bool comparator(int first ,int second){
 	//to_string is inbuilt function which converts int to string
 	string a=to_string(first);
 	string b=to_string(second);
 	
 	return (a + b > b + a); // Returns true/false based on the condition
 	
 }
 
 /* Largest number function return maximum number as a string as the number can be very large   */
 string largestNumber(int n,int arr[]){
 	
 /* A simple solution is to sort the numbers in descending order but simply sorting doesn't works.
    This would definately work if only single digit numbers are present .
    For this we first convert each integer into string and then create a custom sort function.
    We assume that for some pair of integer a and b our comparator a + b > b + a. Here a ,b represents
    strings so + gives concatenation of strings. In other words our custom comparator preserves transitivity,
    so this sort is correct.        */
    sort(arr,arr+n,comparator); //using custom sort 
    string res="""";//Initialising result string 
    
 /* Iterating over the numns array after sorting and storing in a string   */
    for(int i=0;i<n;i++)
    res+=to_string(arr[i]);
    
 /* Edge case if the array consist of only zeroes
    So if the most significant number is 0, we can simply
    return 0  */
    if(res[0]=='0')
    return ""0"";
    
    return res;	  
 }
 
 //Driver Code
 int main(){
 	int n;
 	cout<<""Enter the size of the Array : "";
 	cin>>n;
 	int arr[n];//Initialising array of size n
 	cout<<""Enter the elements of the Array arr :"";
 	for(int i=0;i<n;i++)
 	cin>>arr[i];
 	string re",C-Plus-Plus
"/*
  Author: Sarthak Saxena (@Sarthak-9)
 
  A Linked List is a linear data structure which includes a series of connected nodes. Each node stores the data and the address of the next node.
  Middle Element can be extracted using following two methods :
  Method 1 - MiddleNode1 finds the length of the linked list and the prints the data at position length/2.
  Time complexity of MiddleNode1 : O(n)
  Space Complexity of MiddleNode1 : O(1)
  Method 2 - MiddleNode2 is an optimized approach which uses two pointers namely slow and fast pointers. The fast pointer moves two steps in each iteration while the slow pointer jumps only one step.
  When the fast pointer reaches the end, the slow pointer reaches the middle element and its data is printed.
  Time complexity of MiddleNode2 : O(n/2)
  Space Complexity of MiddleNode2 : O(1)
 */
 
 #include <iostream>
 #include <cmath>
 
 using namespace std;
 
 class Node{
 public:
         int data;
         Node* next;
 };
 
 Node* head = new Node;
 
 void create(int arr[], int n){
         Node* temp;
         Node* tail;
 
         head->data = arr[0];
         head->next = nullptr;
         tail = head;
 
         // creates the linked list from array
         for (int i = 1; i < n; i++){
                 temp = new Node;
                 temp->data = arr[i];
                 temp->next = nullptr;
                 tail->next = temp;
                 tail = temp;
         }
 }
 
 // counts the length of list and prints the value at length/2
 void MiddleNode1(Node* p){
 
         int length = 0;
 
         // counts the length
         while (p){
                 length++;
                 p = p->next;
         }
 
         int index = (int) ceil(length / 2.0);
 
         Node* q = head;
 
         // traverses to the middle element
         for (int i = 0; i < index - 1; i++){
                 q = q->next;
         }
         cout << ""Middle Element (Method-I): "" << q->data << endl;
 }
 
 // uses two pointers where 1st jumps two ",C-Plus-Plus
"/*
 Problem Statement:
 Given an array of integers. Find the Inversion Count in the array.
 Two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j.
 */
 
 #include <stdio.h>
 
 // answer stores the inversion count.
 int answer = 0;
 
 // Merge function helps us to calculate the inversion count.
 void Merge(int input[], int start, int end, int mid)
 {
     // temp is an array, which finally stores the elements of input array in sorted manner.
     int temp[end - start + 1];
     int left = start, right = mid + 1, new_ind = 0;
     while (left <= mid && right <= end)
     {
         if (input[left] <= input[right])
         {
             temp[new_ind++] = input[left++];
         }
         else
         {
             // In this case, inversions are possible.
             answer += (mid - left + 1);
             temp[new_ind++] = input[right++];
         }
     }
     while (left <= mid)
     {
         temp[new_ind++] = input[left++];
     }
     while (right <= end)
     {
         temp[new_ind++] = input[right++];
     }
     for (int index = start; index <= end; index++)
     {
         input[index] = temp[index - start];
     }
     return;
 }
 
 void MergeSort(int input[], int start, int end)
 {
     if (start >= end)
     {
         return;
     }
     int mid = start + (end - start) / 2;
     MergeSort(input, start, mid);
     MergeSort(input, mid + 1, end);
     Merge(input, start, end, mid);
 }
 
 int main()
 {
     printf(""Enter the size of the input array\n"");
     int SIZE;
     scanf(""%d"", &SIZE);
     int input[SIZE];
     printf(""Enter the elements of the input array\n"");
     for (int i = 0; i < SIZE; i++)
     {
         scanf(""%d"", &input[i]);
     }
     MergeSort(input, 0, SIZE - 1);
     printf(""Number of inversions in the input array are %d."", answer);
 }
 
 /*
 Time Complexity  : O(SIZE*log(SIZE)).
 Space Complexity : O(SIZE).
 
 Input:
 Enter the size of the input array
 5
 Enter the elements of the input array
 2 4 1 3 5
 Outp",C
"/*
 
 This program is about merging two Linked list. Here the user is going to enter
 values of first and second linked list.
 It will merge the two linked lists into one linked list by comparing the each
 and every node values and convert into one linked list.
 
 */
 #include <stdio.h>
 #include <stdlib.h>
 
 struct Node {
     int data;
     struct Node *next;
 } *first = NULL, *second = NULL, *third = NULL;
 
 void Create(int Array1[], int size) {
     int i;
     struct Node *temp, *last;
     first = (struct Node *)malloc(sizeof(struct Node));
     first->data = Array1[0];
     first->next = NULL;
     last = first;
     for (i = 1; i < size; i++) {
         temp = (struct Node *)malloc(sizeof(struct Node));
         temp->data = Array1[i];
         temp->next = NULL;
         last->next = temp;
         last = temp;
     }
 }
 
 void Create2(int Array2[], int size) {
     int i;
     struct Node *temp, *last;
     second = (struct Node *)malloc(sizeof(struct Node));
     second->data = Array2[0];
     second->next = NULL;
     last = second;
     for (i = 1; i < size; i++) {
         temp = (struct Node *)malloc(sizeof(struct Node));
         temp->data = Array2[i];
         temp->next = NULL;
         last->next = temp;
         last = temp;
     }
 }
 
 void Display(struct Node *p) {
     while (p != NULL) {
         printf(""%d "", p->data);
         p = p->next;
     }
     printf(""\n"");
 }
 
 void Merge(struct Node *p, struct Node *q) {
     struct Node *last;
     /*Merging the two linkedlists and making it as third linkedlist
     if the condition satisfies*/
     if (p->data < q->data) {
         third = last = p;
         p = p->next;
         third->next = NULL;
     } else {
           third = last = q;
           q = q->next;
           third->next = NULL;
     }
     while (p && q) {
         if (p->data < q->data) {
             last->next = p;
             last = p;
             p = p->next;
             last->next = NULL;
       } else {
        ",C
"#Problem Statement: To find out the maximum sum of k consecutive elements in an array
 # For example: Input : arr = {40, 30, 50, 10}, k = 2
 #              Output: 80
 def maxSumofKelements(arr, n, k):
     if(k > n):
         return -1;                      #k must be smaller than n
     ans = 0;
     for i in range(0, k):              #first we find sum of first k elements
         ans += int(arr[i])
     curr_sum = ans                     #curr_sum is the current sum
     for i in range(k, n):
         curr_sum += int(arr[i]) - int(arr[i - k])   
         ans = max(ans, curr_sum)
     return ans
     
 
 n = int(input(""Enter number of elements in array: ""));                     #inputting num of elements in array
 
 input_string = input(""Enter array elements in a single line seperated with spaces : "")                #inputting array elements
 arr = input_string.split()
 
 k = int(input(""Enter k: ""))                      #inputting k
 
 print(""Maximum sum of k consecutive elements in array is: "" + str(maxSumofKelements(arr, n, k)))
 
 #Sample test case: 
 # arr = {50, 70, 30, 10}, k = 2, n = 4
 # 1. ans = 0, now once the for loop is executed, ans becomes 120 (50 + 70)
 # 2. Now we have to check whether any other sum of k consecutive elements is greater than our initial sum.
 # 3. Now we run a loop from k to n, and everytime we calculate curr_sum and check whether it is greater than our ans or not, if it is greater, we update our ans.
 # 4. Iterations: curr_sum = 120 + 30 - 50 = 100(i.e 70 + 30) (So here we calculated arr[1] + arr[2]) (i = 2)(ans > curr_sum, therefore, ans = 120)
 #                curr_sum = 100 + 10 - 70 = 40(i.e. 30 + 40) (arr[2] + arr[3]) (i = 3)(ans > curr_sum, therefore, ans = 120)
 # 5. So the final ans is 120
",Python
"/**
 Given a Maze of dimensions M*N in which X represents blocked 
 path and - represents open path. It is required to generate
 all the possible pathways to reach from top-left corner to
 bottom-right corner. Movement is allowed in all the four 
 directions. The code will generate all the possible pathways 
 where * will represent the path of the movement.
 */
 
 import java.util.Scanner;
 
 public class BlockedMaze {
 
 	private static void display(char[][] maze, int m, int n) {
 
 		for (int i = 0; i < m; i++) {
 			for (int j = 0; j < n; j++) {
 				System.out.print(maze[i][j] + "" "");
 			}
 			System.out.println();
 		}
 	}
 
 	private static boolean isSafe(char[][] maze, int i, int j, int m, int n, boolean[][] visited) {
 
 		if (i < 0 || j < 0 || i >= m || j >= n) {
 			return false;
 		}
 		if (visited[i][j] == true || maze[i][j] == 'X') {
 			return false;
 		}
 		return true;
 	}
 
 	private static void blockedMaze(char[][] maze, int i, int j, int m, int n, boolean[][] visited) {
 
 		if (i == m - 1 && j == n - 1) {
 			display(maze, m, n);
 			System.out.println();
 			return;
 
 		} else {
 			
 			// Move in up direction
 			if (isSafe(maze, i - 1, j, m, n, visited)) {
 				visited[i - 1][j] = true;
 				maze[i - 1][j] = '*';
 				blockedMaze(maze, i - 1, j, m, n, visited);
 				visited[i - 1][j] = false;
 				maze[i - 1][j] = '-';
 			}
 			
 			// Move in left direction
 			if (isSafe(maze, i, j - 1, m, n, visited)) {
 				visited[i][j - 1] = true;
 				maze[i][j - 1] = '*';
 				blockedMaze(maze, i, j - 1, m, n, visited);
 				visited[i][j - 1] = false;
 				maze[i][j - 1] = '-';
 			}
 			
 			// Move in down direction
 			if (isSafe(maze, i + 1, j, m, n, visited)) {
 				visited[i + 1][j] = true;
 				maze[i + 1][j] = '*';
 				blockedMaze(maze, i + 1, j, m, n, visited);
 				visited[i + 1][j] = false;
 				maze[i + 1][j] = '-';
 			}
 			
 			// Move in right direction
 			if (isSafe(maze, i, j + 1, m, n, visited)) {
 				visited[i][j + 1] = true;",Java
"/* Jump search is a searching algorithm for sorted arrays. In this algorithm,
 we jump ahead by a fixed number of steps each time, instead of traversing the
 whole array. Suppose array is of size 10, and jump is 3, then, we check array[0],
 array[3], array[6], array[9]. We get an interval in which we are searching for
 is present. We then traverse the interval lineally to get the exact index of the
 element. The optimal jump size of sqrt(size of the array). This can be easily proved.
 
 REMEMBER : If the array is not sorted, jump search won't work.*/
 
 package main
 
 import (
 	""fmt""
 	""math""
 )
 
 /* This is the function which implements the jump search algorithm.
 The input to the function is the sorted array, the element which we
 are looking for and the size of the sorted array.*/
 func search(array []int, element, n int) int {
 
 	//Size to jump
 	var jump int = int(math.Sqrt(float64(n)))
 
 	initial := 0
 
 	/*Ensures that value of jump does not cross the 
 	size of the array. And also checks if the value
 	at that jump is less than element or not.*/
 	for jump < n && array[jump] <= element {
 
 		/*This keeps track of the lower bound of the
 		interval in which element could be present*/
 		initial = jump
 
 		//Everytime we increase jump by sqrt(size of array)
 		jump = jump + int(math.Sqrt(float64(n)))
 
 		/*If jump exceeds the size of the array, then we
 		set jump as the last index  of array + 1*/
 		if(jump >= n) {
 			jump = n
 		}
 	}
 
 	/*As the while loop ends, we are sure that the element, if
 	present in the array is present between index initial and jump.
 	We linearlly travere that interval to look for the element*/
 	for i := initial; i <= jump - 1; i++ {
 
 		//If we find the element, we return the index in the array
 		if(array[i] == element) {
 			return i
 		} else {
 			continue
 		}
 	}
 	//We reuturn -1 if element is not found in the array
 	return -1
 }
 
 func main() {
 
 	// Take length of array as input from the user
 	fmt.Print(""",Go
"//SIMPLE COLUMNAR TRANSPOSITION TECHNIQUE
 /* It is a type of transposition cipher technique which encrypts the plain text 
 message into a cipher text by rearranging the characters of the 
 plain text. The plain text is written row-wise and read column-wise. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 string encrypt(string s) {
 	float n = s.length();
 	int row = ceil(n/5),col = 5;
 	char arr[row][col];
 	for(int i = 0;i < row; ++i) {
 		for(int j = 0;j < col; ++j) {
 			if((i*col + j) >= s.length()) {
 				//1 is the bogus character  
 				arr[i][j] = '1' ;
 			}
 			else
 				arr[i][j] = s[i*col + j];
 		}
 	}
 	vector<int>order;  
 	//For example order of columns could be 1 0 2 3 4
 	cout<<""Enter the order of repositioning columns: "";
 	int x;
 	for(int i = 0;i < col; ++i) {
 		cin>>x;
 		order.push_back(x);
 	}
 	string encString = """";
 	for(int i = 0;i < col; ++i) {
 		for(int j = 0;j < row; ++j) {
 			encString += arr[j][order[i]];
 		}	
 	}
 	return encString;
 }
 
 int main() {
 	
 	string s;
 	cout<<""Enter the plain text: "";
 	cin>>s;
 	cout<<encrypt(s);
 
 }
 
 /*
 Example:
 Plain Text: TESSERACTCODING
 Order of Columns: 2 3 1 0 4
 Cipher Text: SCISTNEADTROECG
 
 Plain Text: NEOALGO
 Order of Columns: 3 0 1 4 2
 Cipher Text: A1NGEOL1O1
 
 Time Complexity: O(n)
 Space Complexity: O(1)
 */
",C-Plus-Plus
"""""""
 CombSort Algorithm Implementation in Python 3
 
 Purpose:
 Comb sort is a relatively simple sorting algorithm.
 Comb sort improves on bubble sort algorithm.
 In bubble sort, distance (or gap) between two compared elements is always one.
 Comb sort improvement is that gap can be much more than 1, in order to prevent
 slowing down by small values at the end of a list.
 
 Time Complexity :
 Worst case complexity is O(n^2)
 Best Case complexity is O(n log n)
 
 Space Complexity: O(1)
 
 Argument/ Return Type:
 arr : Unorded list
 output : Return list in ascending order
 
 """"""
 
 
 def combsort(arr, n):
 
     """"""
     Pure implementation of comb sort algorithm in Python
     :param data: mutable collection with comparable items
     :return: the same collection in ascending order
     Examples:
     >>> comb_sort([0, 5, 3, 2, 2])
     [0, 2, 2, 3, 5]
     >>> comb_sort([])
     []
     >>> comb_sort([99, 45, -7, 8, 2, 0, -15, 3])
     [-15, -7, 0, 2, 3, 8, 45, 99]
 
     """"""
 
     gap = n
     while gap > 1:
         gap = int(gap / 1.3)
         for i in range(0, n - gap):
             if arr[i] > arr[i + gap]:
                 arr[i], arr[i + gap] = arr[i + gap], arr[i]
     return arr
 
 
 a = int(input(""Enter the number of elements in the array: ""))
 li = []
 for i in range(0, a):
     li.append(int(input('Enter the element one at a time: ')))
 print('The unsorted array you have given is:', li)
 print('The sorted array using combsort method is: ', end="""")
 print(combsort(li, len(li)))
",Python
"import java.util.*;
 class sorting
 {
     public static void main()
     {
         Scanner sc=new Scanner(System.in);
         int indexI,indexJ,arrayLength,temp,indexK;
         System.out.println(""Enter the length of array"");
         arrayLength=sc.nextInt();
         int array[]=new int[arrayLength];
         System.out.println(""Enter array elements"");
         for(indexI=0;indexI<arrayLength;indexI++)
         array[indexI]=sc.nextInt();
         indexI=0;indexJ=1;
         while(indexI<arrayLength-2)
         {    indexJ=indexI+1;
              while(array[indexI]<=array[indexJ])
             {   if(indexI==arrayLength-2)
                 break;
                 indexI++;
                 indexJ=indexI+1;
             }
             if(array[indexI]>array[indexJ])
             {
                 temp=array[indexJ];
                 array[indexJ]=array[indexI];
                 array[indexI]=temp;
                 indexI=0;
                 continue;
             }
         }
         for(indexI=0;indexI<arrayLength;indexI++)
         System.out.println(array[indexI]+"" "");
     }
     
 } 
 
 /*
 Input :
 Enter the length of array
 5
 Enter array elements
 1
 2
 3
 1
 1
 
 Output :
 1 
 1 
 1 
 2 
 3 */
",Java
"const searchPattern = (text, pattern) => {
   let concatNewStr = pattern + ""$"" + text;
   let zArr = [];
 
   //get the z array
   getZarr(concatNewStr, zArr);
 
   // looping to find the array locations
   for (let i = 0; i < zArr.length; i++) {
       if (zArr[i] == pattern.length) {
           console.log(""Found pattern at index "" + (i - pattern.length - 1));
       }
   }
 };
 const getZarr = (str, zArr) => {
   let n = str.length;
 
   // [left,right] make a window which matches with prefix of s
   let left = 0,
       right = 0;
 
   for (let i = 1; i < n; ++i) {
       // if i>right nothing matches
       if (i > right) {
           left = right = i;
 
           // right-left = 0 in starting, so it will start checking from 0'th index.
           while (right < n && str.charAt(right - left) == str.charAt(right)) {
               right++;
           }
 
           zArr[i] = right - left;
           right--;
       } else {
           // k = i-left so k corresponds to number which matches in [left,right] interval.
           let k = i - left;
 
           // if zArr[k] is less than remaining interval then zArr[i] will be equal to zArr[k].
           if (zArr[k] < right - i + 1) {
               zArr[i] = zArr[k];
           } else {
               // else start from right and check manually
               left = i;
               while (right < n && str.charAt(right - left) == str.charAt(right)) {
                   right++;
               }
               zArr[i] = right - left;
               right--;
           }
       }
   }
 };
 
 searchPattern(""AABAACAADAABAABA"", ""AABA"");
 
 /*
 Output:
 Found pattern at index 0
 Found pattern at index 9
 Found pattern at index 12
 Time complexity and Space complexity: O(m + n), length of text be n and of the pattern be m
 */",JavaScript
"import java.util.*;
 
 class Graph {
   class Edge implements Comparable<Edge> {
     int src, dest, weight;
 
     public int compareTo(Edge compareEdge) {
       return this.weight - compareEdge.weight;
     }
   };
 
   // Union
   class subset {
     int parent, rank;
   };
 
   int vertices, edges;
   Edge edge[];
 
   // Graph creation
   public Graph(int v, int e) {
     vertices = v;
     edges = e;
     edge = new Edge[edges];
     for (int i = 0; i < e; ++i)
       edge[i] = new Edge();
   }
 
   int find(subset subsets[], int i) {
     if (subsets[i].parent != i)
       subsets[i].parent = find(subsets, subsets[i].parent);
     return subsets[i].parent;
   }
 
   void Union(subset subsets[], int x, int y) {
     int xroot = find(subsets, x);
     int yroot = find(subsets, y);
 
     if (subsets[xroot].rank < subsets[yroot].rank)
       subsets[xroot].parent = yroot;
     else if (subsets[xroot].rank > subsets[yroot].rank)
       subsets[yroot].parent = xroot;
     else {
       subsets[yroot].parent = xroot;
       subsets[xroot].rank++;
     }
   }
 
   // Applying Krushkal Algorithm
   void KruskalAlgo() {
     Edge result[] = new Edge[vertices];
     int e = 0;
     int i = 0;
     for (i = 0; i < vertices; ++i)
       result[i] = new Edge();
 
     // Sorting the edges
     Arrays.sort(edge);
     subset subsets[] = new subset[vertices];
     for (i = 0; i < vertices; ++i)
       subsets[i] = new subset();
 
     for (int v = 0; v < vertices; ++v) {
       subsets[v].parent = v;
       subsets[v].rank = 0;
     }
     i = 0;
     while (e < vertices - 1) {
       Edge next_edge = new Edge();
       next_edge = edge[i++];
       int x = find(subsets, next_edge.src);
       int y = find(subsets, next_edge.dest);
       if (x != y) {
         result[e++] = next_edge;
         Union(subsets, x, y);
       }
     }
     System.out.println(""Edge  : Weight"");
     for (i = 0; i < e; ++i)
       System.out.println(result[i].src + "" - "" + result[i].dest + "" : ",Java
"/*
 
 Remove an element from the array
 
 For a given array of integers arr[], and
 a value key, your task is to remove all the instances of value present 
 in the array, and return the new size of the array.
 It is given that the arrangement should be done in-place i.e.
 with no extra space used.
 
 */
 
 import java.util.*;
 
 class remove_element_from_array
 {
     //function to find the new size of the array
     public int removeKey(int arr[], int key)
     {
         int pass=0;
         int size=arr.length;
         while(pass<size)
         {
             if(arr[pass]==key)
             {
                 //on encountering the key value we replace the current element 
                 //with the last element and then decreament the size of array
                 // that is we basically remove key element from array  
                 arr[pass]=arr[size-1];
                 size--;//decrementing the size of array
             }
             else
             {
                 pass++;
             }
         }
         return size;
     }
 
     //driver method
     public satic void main(String []args)
     {
         Scanner sc = new Scanner(System.in);
 
         System.out.print(""Enter the length of the array: "");
         int n = sc.nextInt();
 
         System.out.print(""Enter the value to be removed: "");
         int key = sc.nextInt();
         
         int arr[] = new int[n];
         System.out.println(""Enter the values for array: "");
         for(int i=0; i<n; i++)
         {
             arr[i] = sc.nextInt();
         }
 
         System.out.println(""New size of the array after removing the key element ""+key+"" is: "");
         System.out.print(removeKey(arr, key));
     }
 
 }
 
 /*
 
 EXAMPLES:
 
 Example 1-
 Input--
 Enter the length of the array: 5
 Enter the value to be removed: 1
 Enter the values for array: 1 3 4 5 1
 Output--
 New size of the array after removing the key element 1 is: 3
 
 Example 2-
 Input--
 Enter the length of the arra",Java
"''' Below code is an implementation of binary search in a iterative manner in python3.
     A List is taken as input from the user, followed by the element the user wants to
     search in the array. The search function is called. If the element is present 
     in the array, then print the index of the element in the array.
    
     NOTE : For binary search to work, the input array must be SORTED '''
 
 # This function searchs for the element and prints the output
 def binarysearch(n,List):
 
    # We start search on the entire List 
    start = 0
    end = len(List)-1
    mid = 0
 
    #we check if the search is valid or not
    if(start<=end):
      
        while(True):
      
           #updating the mid element according to the part we search for
           mid = (start+end)//2
 
           if List[mid] > n:
 
               # if n is smaller we ignore the right part
               end = mid-1
 
           elif List[mid] < n:
 
               # if n is greater we ignore the left part
               start = mid+1
 
           else:
 
               print(""The element is present at the index : ""+str(mid))
               return  
 
    else:
       print(""Element not found in the List!"")
       return 
 
 if __name__ == '__main__':
 
    # This is the element we need to search for
    n = int(input(""Enter the number you need to search :""))
    
    print(""Please enter the List in sorted manner !\n"")
 
    ''' Here we take the list of elements spaced and split them and
        store them in a List''' 
    list_elements = input(""Enter the elements of the list with space :"")
    List = list_elements.split()
    
    # Converting the string list into int list
    for i in range(0, len(List)):
       List[i] = int(List[i])
 
    #calling the binary search function
    binarysearch(n,List) 
 
 '''
    Sample I/O :
   
    Enter the number you need to search :3
    Please enter the List in sorted manner !
 
    Enter the elements of the list with space :1 2 3 4
    The",Python
"# Julia program to Find the Number of Digits in a Number 
 
 # Extracting the number of digits
 function number_of_digits(num)
     count = 0
     while(num != 0)
         count = count + 1
         num = num  10
     end
     return count
 end
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 count = number_of_digits(abs(num))
 println(""The number of digits in the given number is $count."")
 
 """"""
 Time Complexity: O(log(num)), where 'num' is the length of the given number
 Space Complexity: O(1)
 SAMPLE INPUT AND OUTPUT
 SAMPLE 1
 Enter the number: -12
 The number of digits in the given number is 3.
 SAMPLE 2
 Enter the number: 43258
 The number of digits in the given number is 22.
 """"""
",Julia
"/*
 Heap is a binary tree which satisfies two properties:
     1.Structure Property: All levels have maximum number of nodes except possibly the last level. In the last level, all nodes are to the left.
     2.Heap Order Property: (max heap)Key in any node N is greater than or equal to the keys in both children of N.
                            (min heap)Key in any node N is less than or equal to the keys in both children of N.
 Representation of heap tree: 
     Sequential representation is good as heap is a complete binary tree. (No wasted array locations)
     We maintain the heap size in a variable. 
     Left child of a node at i is 2i+1 (When using array from index 0)
     Right child of a node at i is 2i+2
     Parent is (i-1)/2
 
 In the following code both max heap and min heap are implemented.
 */
 #include<bits/stdc++.h>
 
 using namespace std;
 class Maxheap {
   //Pointer to the start of array
   int * heap;
   //For the current size of heap
   int size;
   //The maximum number of nodes it can have
   int capacity;
   public:
     Maxheap(int cap): capacity {
       cap
     }, size {
       0
     } {
       heap = new int[capacity];
     }
 
   //Returns the index of left child 
   int left_child(int parent) {
     int index_of_left_child = 2 * parent + 1;
     if (index_of_left_child <= size) {
       return index_of_left_child;
     } else {
       return -1;
     }
   }
 
   //Returns the index of right child 
   int right_child(int parent) {
     int index_of_right_child = 2 * parent + 2;
     if (index_of_right_child <= size) {
       return index_of_right_child;
     } else {
       return -1;
     }
   }
 
   //Returns the index of parent 
   int parent(int child) {
     return (child - 1) / 2;
   }
 
   //Method to insert an item into the heap
   void insert_value(int data) {
     if (size == capacity) {
       cout << ""Overflow, heap at max capacity"" << endl;
       return;
     }
     size++;
     int index = size - 1;
     heap[index] = dat",C-Plus-Plus
"#include<bits/stdc++.h>
 
 using namespace std;
 
 typedef long long int ll;
 
 string decimalToBinary(ll n) 
 {      
     string s = bitset<64> (n).to_string();  // stl to convert integer tobinary and convert into string 
       
     //Finding the first occurance of ""1"" 
     //to strip off the leading zeroes. 
     const auto loc1 = s.find('1'); 
       
     if(loc1 != string::npos) 
         return s.substr(loc1); 
       
     return ""0""; 
 } 
 
 
 int main() {
     
     int n;
     cout<<""Enter a number: "";
     cin>>n;
     cout<<""binary string of given number is :""<< decimalToBinary(n);
 
     return 0;
 }
",C-Plus-Plus
"// This program prints all the possible subsequences for a given string.
 #include <bits/stdc++.h>
 using namespace std;
 
 void printSubsequences(string str, string curr="""", int idx = 0){
     //Base case
     if(idx == str.size()){ 
         cout << curr << endl;
         return; 
     }
     //Recursive call when character does not get added to curr
     printSubsequences(str, curr, idx + 1); 
     //Recursive call when character gets added to curr
     printSubsequences(str, curr + str[idx], idx + 1); 
 }
 
 int main() {
     string s;
     cout << ""Enter the string"";
     cin >> s;
     printSubsequences(s, """", 0);
     return 0;
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(1)
 */
 
 /*Example:
 Input : s = ""abcd""
 Output :
 
 d
 c
 cd
 b
 bd
 bc
 bcd
 a
 ad
 ac
 acd
 ab
 abd
 abc
 abcd */
",C-Plus-Plus
"/* 
 Add two numbers in a Linked list
 
 You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order,
 and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.
 You may assume the two numbers do not contain any leading zero, except the number 0 itself.
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //Definition for singly-linked list.
 class node {
     public:
         int value;
         node* next;
         node(int input) {
             value = input;
             next = NULL;
         }
 };
 //function to add the element in linked list
 void Insertion(node *&head, int input)
 {
     node *new_link = new node(input);
     if (head == NULL)
     {
         head = new_link;
         return;
     }
     node *temp = head;
     while (temp->next != NULL)
     {
         temp = temp->next;
     }
     temp->next = new_link;
 }
 // function to add calculate the sum of two non-empty linked lists which will return the answer as reversed.
 node* AddTwoNumbers(node* list1,node* list2){
     // initialize a list to store the result.
     node* answer_list = NULL;
     // Two temporary pointers of 'type' node pointing to list 1 and 2 respectively.
     node *pointer1 = list1;        
     node *pointer2 = list2;
     // to store the carry obtain if the sum exceeds 9.
     int carry = 0; 
     while (pointer1 != NULL || pointer2 != NULL)
     {
         // a temporary variable 'x' to store the value at the current node of list1
         int x = (pointer1 != NULL) ? pointer1->value : 0; 
         // a temporary variable 'y' to store the value at the current node of list2
         int y = (pointer2 != NULL) ? pointer2->value : 0; 
         // calculating sum of the respective nodes
         int sum = carry + x + y;
         // calculating the carry
         carry = sum / 10;
         // storing the sum obtained in the answerList;
         Insertion(answer_li",C-Plus-Plus
"//Java implementation to sort the given matrix 
 
 import java.io.* ;
 import java.util.* ;
 
 public class MatrixSorting {
 
   // function to sort the given matrix 
   static void sortMatrix(int mat[][], int size) {
     // temporary matrix of size^2 
     int tempmat[] = new int[size * size];
     int index = 0;
     // copy the elements of matrix one by one into tempmat[] 
     for (int row = 0; row < size; row++) {
       for (int col = 0; col < size; col++) {
         tempmat[index++] = mat[row][col];
       }
     }
     // sort temporary matrix tempmat[] 
     Arrays.sort(tempmat);
     // copy the elements of tempmat[] one by one in mat[][] 
     index = 0;
     for (int row = 0; row < size; row++) {
       for (int col = 0; col < size; col++) {
         mat[row][col] = tempmat[index++];
       }
     }
   }
 
   // Driver program to test above 
   public static void main(String args[]) {
     Scanner sc = new Scanner(System. in );
     System.out.println(""Input : "");
     System.out.println(""Enter the size of matrix : "");
     int size = sc.nextInt();
     int matrix[][] = new int[size][size];
     System.out.println(""Enter the elements of square matrix:"");
     for (int row = 0; row < size; row++) {
       for (int col = 0; col < size; col++) {
         matrix[row][col] = sc.nextInt();
       }
     }
     sortMatrix(matrix, size);
     System.out.println(""Output : "");
     System.out.println(""The Sorted Matrix is :"");
     for (int row = 0; row < size; row++) {
       for (int col = 0; col < size; col++) {
         //print the given matrix 
         System.out.print(matrix[row][col] + "" "");
       }
       System.out.println();
     }
   }
 }
 
 /* 
   Input :
   Enter the size of matrix :
   3
   Enter the elements of square matrix :
   7 8 9
   5 6 4
   3 1 2
   Output :
   Sorted Matrix :
   1 2 3
   4 5 6
   7 8 9
 
   Time Complexity: O(n2log2n)
   Space Complexity : Auxiliary Space: O(n2)
  */
",Java
"'''
     COUNT OF LEAF NODES IN A BINARY SEARCH TREE
     Binary Search Tree is a special type of binary tree where
     1. The value of all the nodes in the left sub-tree is less than or equal to the value of the root.
     2. The value of all the nodes in the right sub-tree is greater than value of the root.
     3. This rule will be recursively applied to all the left and right sub-trees of the root.
 
     Leaf node is a node which does not have left or right child
     No. of leaf nodes varies with the order in which the nodes are inserted
 '''
 
 # Declare treeNode with data , rc (right child) and lc (left child )
 class treeNode:
     def __init__(self, item):
         self.data = item
         self.lc = None
         self.rc = None
 
 # to insert a node into BST
 def insertIntoTree(root, data):
     # If tree is empty insert as root node
     if root is None:
         root = treeNode(data)
     else:
         # insert recursively in accordance with BST properties
         if root.data >= data:
             root.lc = insertIntoTree(root.lc, data)
         elif root.data < data:
             root.rc = insertIntoTree(root.rc, data)
     return root
 
 # to count the leaf nodes
 def leaf_nodes(root):
     # If tree is not empty
     if root is not None:
         # If the node doesn't have any child increment count
         if root.lc is None and root.rc is None:
             leaf_nodes.count += 1
         else:
             # recursively check left and right sub-trees
             if root.lc is not None:
                 leaf_nodes(root.lc)
             if root.rc is not None:
                 leaf_nodes(root.rc)
     return leaf_nodes.count
 
 # driver code
 def main():
     # Initialize tree as empty
     root = None
     # Accept the no. of elements and elements as user input
     n = int(input(""Enter the number of elements: ""))
     print(""Enter the numbers: "")
     for _ in range(0, n):
         data = int(input())
         root = insertIntoTree(root, data)",Python
"/*
 -Shortest Job First (SJF) is an algorithm in which the process having the smallest execution time is chosen for the next execution. 
 -This scheduling method can be preemptive or non-preemptive. It significantly reduces the average waiting time for other processes 
 awaiting execution. 
 -It can improve process throughput by making sure that shorter jobs are executed first, hence possibly have a short turnaround time.
 */
 
 import java.util.Scanner;
 
 class sjf
 {
     int arrival_time;
     int finish_time=0;
     int turnaround_time;
     int waiting_time;
     int burst_time;
     int id;
     public sjf(int B_T,int id)			//Parameterized constructor
     {
         arrival_time=0;
         burst_time=B_T;
     }
 }
 
 class process_sjf
 {
     sjf process[]=new sjf[30];				//Array of objects
     Scanner sc=new Scanner(System.in);
    
     int burst_time;
     int id;
     int num;
 
     public void create()			
     {
     System.out.println(""Enter number of processes: "");
     num=sc.nextInt();
     for(int i=0;i<num;i++)
     {
 
         System.out.println(""Enter the process id: "");
         id=sc.nextInt();
         System.out.println(""Enter the burst time: "");
         burst_time=sc.nextInt();
         process[i]=new sjf(burst_time,id);
     }
     }
    
     public void sorting()					//Bubble sort
     {
         int i,j;
         sjf temp;
         for(i=0;i<num-1;i++)
         {
             for(j=0;j<num-i-1;j++)
             {
                 if(process[j].burst_time > process[j+1].burst_time)
                 {
                     temp=process[j];
                     process[j]=process[j+1];
                     process[j+1]=temp;
                 }
    
             }
         }
        
     }
    
     public void calc()			
     {
         int i;   
         sorting();
         process[0].finish_time=process[0].burst_time;
         System.out.println(process[0].finish_time);
         for(i=1;i<num;i++)          //Completion time
        ",Java
"{
  ""cells"": [
   {
    ""cell_type"": ""code"",
    ""execution_count"": 135,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import numpy as np\n"",
     ""\n"",
     ""import warnings\n"",
     ""warnings.filterwarnings('ignore')""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 136,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/plain"": [
        ""Loan_ID               0\n"",
        ""Gender               13\n"",
        ""Married               3\n"",
        ""Dependents           15\n"",
        ""Education             0\n"",
        ""Self_Employed        32\n"",
        ""ApplicantIncome       0\n"",
        ""CoapplicantIncome     0\n"",
        ""LoanAmount           22\n"",
        ""Loan_Amount_Term     14\n"",
        ""Credit_History       50\n"",
        ""Property_Area         0\n"",
        ""Loan_Status           0\n"",
        ""dtype: int64""
       ]
      },
      ""execution_count"": 136,
      ""metadata"": {},
      ""output_type"": ""execute_result""
     }
    ],
    ""source"": [
     ""train=pd.read_csv(r'C:\\Users\\prath\\LoanEligibilityPrediction\\Dataset\\train.csv')\n"",
     ""train.Loan_Status=train.Loan_Status.map({'Y':1,'N':0})\n"",
     ""train.isnull().sum()""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 137,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n"",
        ""<table border=\""1\"" class=\""dataframe\"">\n"",
        ""  <thead>\n"",
        ""    <tr style=\""text-align: right;\"">\n"",
        ""      <th></th>\n"",
        ""      <th>Loan_I",Python
"'''
 A program for warshall algorithm.It is a shortest path algorithm which is used to find the 
 distance from source node,which is the first node,to all the other nodes.
 If there is no direct distance between two vertices then it is considered as -1
 '''
 def warshall(g,ver):
     dist = list(map(lambda i: list(map(lambda j: j, i)), g))
     for i in range(0,ver):
         for j in range(0,ver):
             dist[i][j] = g[i][j]
 	#Finding the shortest distance if found
     for k in range(0,ver):
         for i in range(0,ver):
             for j in range(0,ver):
                 if dist[i][k] + dist[k][j] < dist[i][j] and  dist[i][k]!=-1 and dist[k][j]!=-1:
                     dist[i][j] = dist[i][k] + dist[k][j]
 	#Prnting the complete short distance matrix
     print(""the distance matrix is"")
     for i in range(0,ver):
         for j in range(0,ver):
             if dist[i][j]>=0:
                 print(dist[i][j],end="" "")
             else:
                 print(-1,end="" "")
         print(""\n"")
 #Driver's code
 def main():
     print(""Enter number of vertices\n"")
     ver=int(input())
     graph=[]
 	#Creating the distance matrix graph
     print(""Enter the distance matrix"")
     for i in range(ver):
         a =[]
         for j in range(ver):     
             a.append(int(input()))
         graph.append(a)
     warshall(graph,ver)
 if __name__==""__main__"":
 	main()
 
 '''
 Time Complexity:O(ver^3)
 Space Complexity:O(ver^2)
 
 Input/Output:
 Enter number of vertices 
 4
 Enter the graph
 0
 8
 -1
 1
 -1
 0
 1
 -1
 4
 -1
 0
 -1
 -1
 2
 9
 0
 The distance matrix is
 0 3 -1 1 
 -1 0 1 -1 
 4 -1 0 -1 
 -1 2 3 0 
 '''
",Python
"#include <bits/stdc++.h>
 using namespace std;
 
 void getZ(string s, int z[])
 {
 	int n = s.size();
 	int left = 0, right = 0;
 	for (int i = 1; i < n; ++i)
 	{
 		if (i > right)
 		{
 			left = right = i;
 			while (right < n && s[right - left] == s[right])
 				right++;
 			z[i] = right - left;
 			right--;
 		}
 		else
 		{
 			int k = i - left;
 			if (z[k] < right - i + 1)
 			{
 				z[i] = z[k];
 			}
 			else
 			{
 				left = i;
 				while (right < n && s[right - left] == s[right])
 					right++;
 				z[i] = right - left;
 				right--;
 			}
 		}
 	}
 }
 
 int main()
 {
 	string text, pattern;
 	cout << ""Enter the text: "";
 	cin >> text;
 	cout << ""Enter the pattern: "";
 	cin >> pattern;
 	string concat = pattern + ""$"" + text;
 	int n = concat.size();
 	int m = pattern.size();
 	int z[n];
 	getZ(concat, z);
 	for (int i = 0; i < n; ++i)
 	{
 		if (z[i] == m)
 		{
 			cout << ""Pattern found at index "" << i - m - 1 << ""\n"";
 		}
 	}
 	return 0;
 }
 
 /*
 Time Complexity: O(length of text + length of pattern)
 
 Input
 Enter the text: AABACAAFGAABAABA
 Enter the pattern: AABA
 
 Output
 Pattern found at index 0
 Pattern found at index 9
 Pattern found at index 12
 */
",C-Plus-Plus
"/*
 This problem is solved using backtracking.
 It will print all possible Palindromes in the string
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 /*To check whether a given string is Palindrome or not*/
 int isPalindrome(string& word)
 {
     int n = word.length() - 1;
     for (int i = 0; i < n; i++) {
         if (word[i] != word[n]) {
             return false;
         }
         n--;
     }
     return true;
 }
 
 // Prototype of PalindromeUtil
 void printPalindrome(string str, int n, string result);
 
 // Prints all possible Palindromes of given string
 void Palindrome(string str)
 {
     // Last argument is word
     printPalindrome(str, str.size(), """");
 }
 
 /* Result store the current word with spaces
  between words */
 void printPalindrome(string str, int n, string result)
 {
     //Process all words one by one
     for (int i = 1; i <= n; i++) {
         // Extract substring from 0 to i in word
         string word = str.substr(0, i);
 
         /* If dictionary conatins this word, then
          we check for remaining string. Otherwise
          we ignore this word (there is no else for
          this if) and try next */
         if (isPalindrome(word)) {
             // If no more elements are there, print it
             if (i == n) {
                 // Add this element to previous word
                 result += word;
                 cout << result << endl;
                 return;
             }
             printPalindrome(str.substr(i, n - i), n - i, result + word + "" , "");
         }
     }
 }
 
 int main()
 {
     // Function call
     string str;
     cin >> str;
     Palindrome(str);
 
     return 0;
 }
 /*
 Input - abaaba
 Output -
 a , b , a , a , b , a
 a , b , a , aba
 a , b , aa , b , a
 a , baab , a
 aba , a , b , a
 aba , aba
 abaaba
 
 Time Complexity - O(n^n)
 Space Complexity - O(n*n)
 */
",C-Plus-Plus
"/*
 Insert Position
 
 For a given sorted array of distinct integers arr[]
 and a key value, your task is to return the index where 
 it would best fit or be inserted in the order.
 */
 
 import java.util.*;
 
 public class InsertPosition
 {
     public static int searchPosition(int[] arr, int key)
     {
         int leftptr = 0;
         int rightptr = arr.length - 1;
 
         while(leftptr < rightptr)
         {
             int mid = (leftptr + rightptr) / 2;
             if(arr[mid] == key)
             {
                 return mid;
             }
             else if(arr[mid] < key)
             {
                 leftptr = mid + 1;
             }
             else
             {
                 rightptr = mid - 1;
             }
         }
 
         return leftptr;
     }
 
     //DRIVER CODE
     public static void main(String[] args)
     {
         Scanner sc = new Scanner(System.in);
 
         //size of array
         System.out.println(""Enter the number of elements of array: "");
         int size = sc.nextInt();
 
         //key value
         System.out.println(""Enter the key value to be inserted: "");
         int key = sc.nextInt();
 
         int []arr = new int[size];
         //array elements
         System.out.println(""Enter the elements for array in sorted order: "");
         for (int i = 0; i < size; i++) {
             arr[i] = sc.nextInt();
         }
 
         System.out.println(""Position at which the key value should be inserted is: "");
         System.out.print(searchPosition(arr, key));
         sc.close();
     }
 }
 
 /*
 
 Example:
 Input--
 Enter the number of elements of array: 5
 Enter the key value to be inserted: 2
 Enter the elements for array in sorted order: [1, 4, 5, 8, 9]
 Output--
 Position at which the key value should be inserted is: 1
 
 TIME COMPLEXITY--> O(N)
 SPACE COMPLEXITY--> O(1)
 
 */
",Java
"from binascii import unhexlify as unhex
 
 
 def encryption(message: str, key: int) -> str:
     """"""Return the ciphertext by xor the message with a repeating key""""""
 
     return b"""".join(
         [bytes([message[i] ^ key[i % len(key)]]) for i in range(len(message))]
     )
 
 
 def decryption(cipher: str, key=None) -> str:
     """"""
     Decode repeating xor with optional key parameter
     """"""
 
     # find keysize
     keysize = find_keysize(cipher)
 
     if key is None:
         pt = []
         for ks in keysize:
             # find key
             key = find_key(cipher, ks[""keysize""])
             # return plaintext
             plaintext = encryption(cipher, key)
             pt.append({
                 ""plaintext"": plaintext, 
                 ""key"": key, 
                 ""score"": scoring_system(plaintext)
                 })
 
         return sorted(pt, key=lambda pt: pt[""score""], reverse=True)
     else:
         return encryption(cipher, key)
 
 
 def single_xor(input_string: str, key_value: int) -> str:
     """"""Return the input_string xored with a key value""""""
 
     return b"""".join([bytes([byte ^ key_value]) for byte in input_string])
 
 
 def scoring_system(input_string: str) -> int:
     """"""Return the score of input_string""""""
 
     # create a dictionary to store value of frequency
     char_freq = {
         ""a"": 0.08497,
         ""b"": 0.01492,
         ""c"": 0.02202,
         ""d"": 0.04253,
         ""e"": 0.11162,
         ""f"": 0.02228,
         ""g"": 0.02015,
         ""h"": 0.06094,
         ""i"": 0.07456,
         ""j"": 0.00153,
         ""k"": 0.01292,
         ""l"": 0.04025,
         ""m"": 0.02406,
         ""n"": 0.06749,
         ""o"": 0.07507,
         ""p"": 0.01929,
         ""q"": 0.00095,
         ""r"": 0.07587,
         ""s"": 0.06327,
         ""t"": 0.09356,
         ""u"": 0.02758,
         ""v"": 0.00978,
         ""w"": 0.02560,
         ""x"": 0.00150,
         ""y"": 0.01994,
         ""z"": 0.00077,
         "" "": 0.12000,
     }
 
     return sum([char_freq.ge",Python
"class graph:
     #Dictionary with keys to map the corresponding vertex object
     def __init__(self):
         self.vertices = {}
  
     #Adding vertex to the graph with the key provided
     def Addvertex(self, key):
         vertex = Vertex(key)
         self.vertices[key] = vertex
  
     #Getting vertex object with the corresponding key!
     def Getvertex(self, key):
         return self.vertices[key]
  
     def __contains__(self, key):
         return key in self.vertices
  
     #Adding edge from source key to the destination key with given weight
     def Addedge(self, source_key, destination_key, weight=1):
         self.vertices[source_key].Addnbr(self.vertices[destination_key], weight)
  
     #To check weather the edge exits or not.
     def Edge_exists(self, source_key, destination_key):
         return self.vertices[source_key].pointing_to(self.vertices[destination_key])
  
     def Display(self):
         print('Vertices: ', end='')
         for v in self:
             print(v.get_key(), end=' ')
         print(""***"")
  
         print('Edges: ')
         for v in self:
             for destination in v.getnbr():
                 w = v.getweight(destination)
                 print('(source={}, destination={}, weight={}) '.format(v.get_key(),
                                                              destination.get_key(), w))
  
     def __len__(self):
         return len(self.vertices)
  
     def __iter__(self):
         return iter(self.vertices.values())
  
  
 class Vertex:
     def __init__(self, key):
         self.key = key
         self.points_to = {}
  
     #getting key corresponding to vertex object
     def get_key(self):
        return self.key
  
     #adding this vertex point to destination with provided edge weight
     def Addnbr(self, destination, weight):
         self.points_to[destination] = weight
  
     #Returns all vertices pointed by this vertex
     def getnbr(self):
         return self.points_to.keys()
  
     #Get",Python
"'''
 PROBLEM STATEMENT:
 Given a linked list, the task is to find whether the linked list consists of
 a loop or not.
 The user will enter the elements in a linked list and will specify whether
 the tail of the linked list is pointed to some other node or to NULL.
 If the tail is pointing to NULL, the user will input -1 in 'pos' variable,
 otherwise, the user will input the index of the node to which the tail pointer
 will point.
 'pos' variable is only used to create a linked list as per the data entered
 by the user, and is not passed to the function for detecting a loop,
 it is being detected by using Floyd's cycle detection algorithm.
 '''
 
 
 class Node:
     # Constructor to initialize node
     def __init__(self, val):
         self.val = val
         self.next = None
 
 
 class LinkedList:
     # Constructor to initialize head and variable pointer
     def __init__(self):
         self.head = None
         self.var = None
 
     # Function to create a linked list
     def push(self, newval):
         newnode = Node(newval)
         if self.var:
             self.var.next = newnode
             self.var = newnode
         else:
             self.head = newnode
             self.var = newnode
         return newnode
 
     # Function to create a loop
     def CreateLoop(self, idx, last):
         temp = self.head
         if idx >= 0:
             while idx > 0:
                 temp = temp.next
                 idx -= 1
             last.next = temp
 
     # Function for detecting loop using Floyd's cycle detection algorithm
     def LoopDetect(self):
         slow = self.head
         fast = self.head
         while slow and fast and fast.next:
             slow = slow.next
             fast = fast.next.next
             if slow == fast:
                 print(""Loop Detected!"")
                 return
         print(""Loop not found!"")
 
 
 # Driver Code
 n = int(input(""Enter the size of linked list: ""))
 ll = LinkedList()
 print(""Enter elements:"")
 for i in",Python
"/*
 Lucas Number is a sequence of numbers similar to the Fibonacci Series and is defined as the sum of previous two digits
 starting with ""2"" and ""1"".
 */
 
 
 #include <bits/stdc++.h>
 
 using namespace std;
 void lucas(int n) {
   int x = 2;
   int y = 1;
   int z, count;
   if (n == 0)
     cout << "" "";
   else if (n == 1)
     cout << x;
   else {
     cout << x << "" "" << y << "" "";
 
     for (count = 2; count < n; count++) {
       z = x + y;
       x = y;
       y = z;
       cout << y << "" "";
     }
   }
 
 }
 int main() {
   int n;
   cout << ""Enter the number of terms of Lucas Numbers you want to print: "";
   cin >> n;
   cout << ""The Lucas Series of "" << n << "" terms is: "";
   lucas(n);
 }
  
 /*
 Time Complexity: O(n)
 Space Complexity: O(1)
 where n is the input number (number of terms)
 
 Sample Input:
 Enter the number of terms of Lucas Numbers you want to print: 9
 
 Sample Output:
 The Lucas Series of 9 terms is: 2 1 3 4 7 11 18 29 47 
 
 */
",C-Plus-Plus
"import java.util.HashMap;
 import java.util.Scanner;
 
 public class FindNumbers {
 
     public static void main(String[] args) {
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter number of elements:"");
         int size = scanner.nextInt();
         int[] arr = new int[size];
         System.out.println(""Enter array elements:"");
         for (int i = 0; i < size; i++) {
             arr[i] = scanner.nextInt();
         }
         scanner.close();
 
         findNonRepeating(arr, size);
     }
 
     private static void findNonRepeating(int[] arr, int length) {
         HashMap<Integer, Integer> freq = new HashMap<Integer, Integer>();
         for (int i = 0; i < length; i++) {
             if (freq.containsKey(arr[i])) {
                 freq.put(arr[i], freq.get(arr[i]) + 1);
             } else {
                 freq.put(arr[i], 1);
             }
         }
 
         System.out.println(""Unique terms are:"");
         for (Integer i : freq.keySet()) {
             if (freq.get(i) == 1) {
                 System.out.println(i);
             }
         }
     }
 }
 
 /*
 * Sample input/output
 * Enter number of elements:
 * 6
 * Enter array elements:
 * 1 2 3 2 1 4
 * Unique terms are:
 * 3
 * 4
 *
 * Time and space complexity: O(n)
 */
",Java
"#include <iostream>
 using namespace std;
 
 int Hash(int x, int s) {
 	return x % s;
 }
 //Function to insert element in HashTable.
 void LinearProbe(int L[], int s, int x) {
 	int index = Hash(x, s);
 	int i = 0;
 	while (L[index] != 0 && L[index] != -1) {
 		i++;
 		index = (Hash(x, s) + i) % s;
 
 	}
 	L[index] = x;
 }
 //Function to search for an element.
 void LPSearch(int L[], int s, int x) {
 	int index = Hash(x, s);
 	int i = 0;
 	while (L[index] != 0) {
 		if (L[index] == x) {
 			cout << ""Element found at index "" << index << endl;
 			return;
 		}
 		i++;
 		index = (Hash(x, s) + i) % s;
 
 	}
 	cout << ""Element not found "" << endl;
 }
 //Function to Delete an element from Hashtable.
 void LPDelete(int L[], int s, int x) {
 	int index = Hash(x, s);
 	int i = 0;
 	while (L[index] != 0) {
 		if (L[index] == x) {
 			cout << ""Element deleted "" << endl;
 			L[index] = -1;
 			return;
 		}
 		i++;
 		index = (Hash(x, s) + i) % s;
 
 	}
 	cout << ""Element not found hence cant be deleted "" << endl;
 
 }
 //Main function
 //Space Complexity: O(n) - space for hashtable.
 //Time Complexity: O(m) - The algorithm will scan an auxiliary array of size m to allocate the elements their correct position
 int main() {
 	int n, x;
 	cout << ""Hello world!"" << endl;
 	cout << ""Enter number of elements "" << endl;
 	cin >> n;
 	int s = 2 * n;
 	int p = s;
 	while (p > 0) {
 		if ( ( ((p - 1) % 6 == 0) && ((p + 1) % 6 != 0) )  || ( ((p + 1) % 6 == 0) && ((p - 1) % 6 != 0) ))
 			break;
 		p--;
 	}
 	int L[s] = {0}, Q[s] = {0}, D[s] = {0};
 	cout << ""Enter elements for Linear probing "" << endl;
 	for (int i = 0; i < n; i++) {
 		cin >> x;
 		LinearProbe(L, s, x);
 	}
 	for (int i = 0; i < s; i++) {
 		cout << L[i] << endl;
 	}
 	cout << ""Enter element to be searched in LP : "";
 	cin >> x;
 	LPSearch(L, s, x);
 	cout << ""Enter element to be deleted in LP : "";
 	cin >> x;
 	LPDelete(L, s, x);
 	cout << ""The hash table is"" << endl;
 	for (int i = 0; i < s; i++) {
 		cout << L[i] << ",C-Plus-Plus
"""""""
 Given an array of positive integers. Find the length of the longest sub-sequence such that 
 elements in the subsequence are consecutive integers,
 the consecutive numbers can be in any order.
 
 Example:
 Input: {2,6,1,9,4,5,3}
 Output: 6
 
 Explanation:
 The consecutive numbers here
 are 1, 2, 3, 4, 5, 6. These 6 
 numbers form the longest consecutive
 subsquence.
 
 """"""
 
 def LongestConsecutiveSubsequence(arr):
     #let take dict save the the element 
     dict={}
     
     for l in arr:
         if l not in dict.keys():
             dict[l]=1
 
     sub=[0]*len(arr)
     #check  present or not then increase the count with 1 
     for i in range(0,len(arr)):
 
         key=arr[i]
 
         while key in dict.keys():
             key=key+1
 
         sub[i]=key-arr[i]
     #result
     return sorted(sub,reverse=True)[0]
 
 if __name__ == '__main__':
     arr = list(map(int,input(""Enter the number: "").split()))
     print(""The longest consective subsequence is "",LongestConsecutiveSubsequence(arr))
 
 '''
 Time complexity : O(n^n) 
 Space complexity : O(n^n) 
 
 INPUT:-
 Enter the number: 36 41 56 35 44 33 34 92 43 32 42 
 
 OUTPUT:-
 The Longest Consecutive Subsequence is  5
 
 '''
",Python
"{
   ""nbformat"": 4,
   ""nbformat_minor"": 0,
   ""metadata"": {
     ""colab"": {
       ""name"": ""Numerical_outlier_method.ipynb"",
       ""provenance"": []
     },
     ""kernelspec"": {
       ""name"": ""python3"",
       ""display_name"": ""Python 3""
     }
   },
   ""cells"": [
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""qsCL6wPSvJwY"",
         ""colab_type"": ""text""
       },
       ""source"": [
         ""## IMPORTS""
       ]
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""zAy3SIjkvAXF"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""import numpy as np\n"",
         ""import random\n"",
         ""import matplotlib.pyplot as plt""
       ],
       ""execution_count"": 1,
       ""outputs"": []
     },
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""KPueZtWmvPFE"",
         ""colab_type"": ""text""
       },
       ""source"": [
         ""###Creating a Pseudo-Dataset""
       ]
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""vm5Vyj80vOsu"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""def dataset_developer(n, probability=[0.05, 0.05, 0.15, 0.5, 0.15]):\n"",
         ""\tX = []\n"",
         ""\twhile len(X)<n:\n"",
         ""\t\tt = random.random()\n"",
         ""\t\tif t<probability[0]:\n"",
         ""\t\t\tX.append(random.random()*0.2)\n"",
         ""\t\telif t>=probability[0] and t<probability[1]+probability[0]:\n"",
         ""\t\t\tX.append(random.random()*0.2+0.2)\n"",
         ""\t\telif t>= probability[1]+probability[0] and t<probability[0]+probability[1]+probability[2]:\n"",
         ""\t\t\tX.append(random.random()*0.2+0.2*2)\n"",
         ""\t\telif t>=probability[0]+probability[1]+probability[2] and t<probability[0]+probability[1]+probability[2]+probability[3]:\n"",
         ""\t\t\tX.append(random.random()*0.2+0.2*3)\n"",
         ""\t\telse:\n"",
         ""\t\t\tX.append(random.random()*0.2+0.2*4",Python
"/**
 You are given n activities (from 0 to n-1) with their start and finish times.
 Select the maximum number of activities that can be performed by a single person, 
 assuming that a person can only work on a single activity at a time.
 
 Input Format
 The first line consists of an integer T, the number of test cases.
  For each test case, the first line consists of an integer N, the number of activities. 
  Then the next N lines contain two integers m and n, the start and end time of each activity.
 
 Output Format
 For each test case find the maximum number of activities that you can do.
 
 Sample Input
 1 
 3
 10 20
 12 15
 20 30
 
 Sample Output
 2
 
 Explanation
 Person can only do 0th and 2nd activities.
 **/
 #include<bits/stdc++.h>
 #include<iostream>
 #include<algorithm>
 #include<utility>
 
 using namespace std;
 
 bool compare(pair<int,int> a,pair <int ,int> b)         //made compare function for sorting
 {
 	return a.second<b.second;
 }
 
 int main() 
 {
 	int testcases;
 	
 	cout<<""Enter no. of Testcases:"";                      //no.of test cases to be tested
 	cin>>testcases;
 
 	while(testcases--)
 	{
 		int num,count;                                     //counter for answer
 		count=1;                                           // Initialize count with 1
 		
 		cout<<""Enter no. of Activities:"";
 		cin>>num;
 		
 		pair<int,int>* arr = new pair<int,int>[num];      //An dynamic Array of Pairs
         
 		cout<<""Enter activities:""<<endl;
 		for(int i=0;i<num;i++)
 		{
 			cin>>arr[i].first>>arr[i].second;
 		}
 
 		sort(arr,arr+num,compare);                        // Inbuilt Sorting Function taking compare function as a parameter 
 
 		int prev=0;
 
 		for(int curr=1;curr<num;curr++)
 		{
 			if(arr[prev].second<=arr[curr].first)
 			{
 				count++;
 				prev=curr;
 			}
 		}
 		
         cout<<""Person can do only ""<<count<<"" activities at a time""<<endl;    //Result
 		delete[] arr;  
 	}
 	return 0;
 }
",C-Plus-Plus
"/*
 Introduction 
 Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
 - Each row must contain the digits 1-9 without repetition.
 - Each column must contain the digits 1-9 without repetition.
 - Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.
 
 Note:
 - A Sudoku board (partially filled) could be valid but is not necessarily solvable.
 - Only the filled cells need to be validated according to the mentioned rules.
 
 Argument/Return Type
 Input of 9x9 matrix is taken
 A function which returns bool is implemented
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 // Function to determine if the sudoku is valid
 bool isValidSudoku(vector<vector<char>>& sudoku) 
 {
     /*Define 2D maps to store presence of already visited values 
       row wise , column wise and box wise */
     map<int,map<int,int>>row;
     map<int,map<int,int>>col;
     map<int,map<int,int>>box;
 
     // Now Traverse to every cell
     for(int rowInd=0;rowInd<=8;rowInd++)
     {
        //In each row visit all cells column wise
        for(int colInd=0;colInd<=8;colInd++)
        {
            // If the cell is not empty
            if( sudoku[rowInd][colInd] != '.')
             {
                 // Get the relative ASCII value of character 
                 int value = sudoku[rowInd][colInd]-'0';
 
                 /* Check if the this value is already present in 
                    the column or row or box to which this value belongs to */
                 bool isPresentInRow = row[value][rowInd];
                 bool isPresentInCol = col[value][colInd];
                 bool isPresentInBox = box[value][3*(rowInd/3)+(colInd/3)];
                 if(isPresentInRow || isPresentInCol || isPresentInBox)   
                 {
                    /*If it is present in any of them already
                     It means that the sudoku is not valid */
                    return f",C-Plus-Plus
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# MOBILE PRICE RANGE CLASSIFICATION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [Mobile Price Classification](https://www.kaggle.com/iabhishekofficial/mobile-price-classification?select=train.csv)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import numpy as np\n"",
     ""from statsmodels.stats.outliers_influence import variance_inflation_factor\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.ensemble import RandomForestClassifier\n"",
     ""import matplotlib.pyplot as plt\n"",
     ""from scipy import stats\n"",
     ""import seaborn as sns\n"",
     ""from sklearn.metrics import confusion_matrix""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting our Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n"",
        ""<table border=\""1\"" class=\""dataframe\"">\n"",
        ""  <thead>\n"",
        ""    <tr style=\""text-align: right;\"">\n"",
        ""      <th></th>\n"",
        ""      <th>battery_power</th>\n"",
        ""      <th>blue</th>\n"",
        ""      <th>clock_speed</th>\n"",
        ""      <th>dual_sim",Python
"/*
 Given an undirected graph G(V, E) and two vertices v1 and v2 (as integers), check if there exists any path between them or not. 
 Print true if the path exists and false otherwise.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 // create a boolean fucntion to check path which return true or false
 bool path(int V, int ** mat, bool * visited, int v1, int v2) {
 
   //base case (check if the vertices are adjacent)
   if (mat[v1][v2] == 1) {
     return true;
   }
   visited[v1] = true;
 
   for (int i = 0; i < V; i++) {
     if (visited[i]) {
       continue;
     }
     // visited[i]=true;
     //If this adjacent node is the destination node, then return true
     if (mat[v1][i] == 1) {
       bool small = path(V, mat, visited, i, v2);
       if (small == true) {
         return true;
       }
     }
   }
   return false;
 }
 
 int main() {
   int V, E;
   //take input of the vertices and edges of the graph
   cout<<""Enter the number of vertices and edges of the graph""<<endl;
   cin >> V >> E;
   int ** mat = new int * [V];
   for (int i = 0; i < V; i++) {
     mat[i] = new int[V];
     for (int j = 0; j < V; j++) {
       mat[i][j] = 0;
     }
   }
   cout<<""Enter the two vertices that have a edge between them""<<endl;
   for (int i = 0; i < E; i++) {
     int f, g;
     cin >> f >> g;
     mat[f][g] = 1;
     mat[g][f] = 1;
   }
 
   bool * visited = new bool[V];
   for (int i = 0; i < V; i++) {
     // Mark all the vertices as not visited
     visited[i] = false;
   }
   int v1, v2;
   //take input of the vertices v1 and v2, to check if a path exists between them
   cout<<""Enter the two vertices v1 and v2, to check if a path exists between them""<<endl;
   cin >> v1 >> v2;
 
   //call the fucntion
   bool small = path(V, mat, visited, v1, v2);
 
   if (small) {
     cout << ""true"";
   } else {
     cout << ""false"";
   }
   return 0;
 }
 
 
 /*
 Time Complexity: O(V+E)
 Space Complexity: O(V^2)
 where V is the number of vertices and E is the number of edg",C-Plus-Plus
"
 // C++ Program for implementation of Cocktail shaker sort.
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //  function to sort the array using Cocktail sort
 void Cocktail_shaker_sort(int a[], int n)
 {
 	int initial = 0;
 	int end = n - 1;
 	bool flag = true;
 	while (flag) 
 	{
 		flag = false;
 		
 		// loop from left to right
 		for (int i = initial; i < end; ++i) 
 		{
 			if (a[i] > a[i + 1]) {
 				swap(a[i], a[i + 1]);
 				flag = true;
 			}
 		}
 		
 		// if nothing moved, then array is sorted
 		if (!flag)
 			break;
 
 		flag = false;
 
 		--end;
 
         // comparing from right to left
 		for (int i = end - 1; i >= initial; --i) 
 		{
 			if (a[i] > a[i + 1]) {
 				swap(a[i], a[i + 1]);
 				flag = true;
 			}
 		}
 
 		++initial;
 	}
 }
 
 // Function to print the sorted array 
 void Print(int a[], int n)
 {
 	for (int i = 0; i < n; i++)
 		printf(""%d "", a[i]);
 	printf(""\n"");
 }
 
 // Main function
 int main()
 {
 	int no_element;
 	cout << ""Enter the no of element to be sorted: ""; 
   	cin >> no_element;
 	int a[no_element];
 
 	// taking input 
 	for(int x=0; x < no_element; x++){
 		cin>>a[x];
 	}
 
 	int n = sizeof(a) / sizeof(a[0]);
 	Cocktail_shaker_sort(a, n);
 	printf(""The Sorted array :\n"");
 	Print(a, n);
 	return 0;
 }
 
",C-Plus-Plus
"/*
 
 Introduction 
 Given a Binary Tree , check if it is a valid Binary Search Tree
 
 A valid Binary Search Tree is defined as follows:
 - The left subtree of a node contains only nodes with keys less than the node's key.
 - The right subtree of a node contains only nodes with keys greater than the node's key.
 - Both the left and right subtrees must also be binary search trees.
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 Bool is returned as a result and corresponding statement is printed
 
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j+",C-Plus-Plus
"""""""
 Sorting the array into a wave-like array.
 For eg: arr[] = {1,2,3,4,5}
 Output: 2 1 4 3 5
 """"""
 
 
 def convertToWave(length,array):
     for i in range(0, length - length%2, 2):               #swapping alternatively
         temp=array[i]
         array[i]=array[i+1]
         array[i+1]=temp
     return array
 
 arr = list(map(int,input(""Enter the elements of the array : "").split()))
 N = len(arr)    # length of the array
 
 arr = convertToWave(N,arr)
 
 print(""Wave Array: "")
 for el in arr:
   print(el, end="" "")
    
     
 """"""
 Time complexity : O(1) 
 Space complexity : O(1) 
 
 INPUT:-
 Enter the elements of the array : 1 2 3 4 5 6 7
 OUTPUT:-
 Wave Array: 2 1 4 3 6 5 7 
 
 """"""
",Python
"""""""
 Post Order Binary tree traversal follows the pattern:
 
 Left Child -> Right Child -> Root
 """"""
 
 
 class Node:
     def __init__(self, value):
         self.value = value
         self.left = None
         self.right = None
 
 
 class Tree:
     def __init__(self):
         self.root = None
 
     # Function to insert nodes into tree
     def insert(self, array_of_nodes):
 
         # Queue to create the tree
         queue = []
         self.root = Node(int(array_of_nodes.pop(0)))
         queue.append(self.root)
         size_of_queue = len(queue)
 
         # Logic for nodes insertion
         while array_of_nodes:
             while size_of_queue:
                 root = queue.pop(0)
                 if root:
                     value = array_of_nodes.pop(0)
                     if value == 'null':
                         root.left = None
                     else:
                         root.left = Node(int(value))
                         queue.append(root.left)
                     value = array_of_nodes.pop(0)
                     if value == 'null':
                         root.right = None
                     else:
                         root.right = Node(int(value))
                         queue.append(root.right)
                 size_of_queue -= 1
             size_of_queue = len(queue)
 
     # Function to perform Post order traversal on our tree
     def postorder_traversal(self, root):
 
         if not root:
             return []
 
         # This will be our main list that contains the traversed tree
         self.traversed = []
 
         # This list will help in the creation of traversed list
         helper_stack = [root]
 
         # Keeping track of visited nodes
         left_visited_nodes = set()
         right_visited_nodes = set()
 
         # Main logic for post order traversal
         while helper_stack:
 
             # Temporary list of nodes to check visited nodes
             temp = helper_stack[-1]
 
             #",Python
"/* Find array is Subset of another array */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function for Finding array is subset of another array */
 int solve()
 {
     /* Input n1 = size of array 1
        Input n2 = size of array 2 */
     int n1,n2;
     cin >> n1 >> n2;
 
     int a1[n1],a2[n2];
 
     /* Input values in array 1 */
     for (int i = 0; i < n1; ++i)
     {
         cin >> a1[i];
     }
 
     /* Input values in array 2 */
     for (int i = 0; i < n2; ++i)
     {
         cin >> a2[i];
     }
 
     int i = 0, j = 0;
 
     /* Check if n1 is less then n2 */
     if(n1 < n2)
       return 0; 
 
     /*Sort the array 1*/
     sort(a1, a1 + n1);
 
     /*Sort the array 2*/
     sort(a2, a2 + n2);
 
     while(j < n1 && i < n2 )
     {
         /* If array 1 is less than array 2
            then increament j*/
         if( a1[j] < a2[i] )
         {
             j++;
         }
 
         /* If array 1 is equal to array 2
            then increament i and j*/
         else if( a1[j] == a2[i] )
         {
             j++;
             i++;
         }
 
         /* Return if element is not equal and
            smaller than array 2*/
         else if( a1[j] > a2[i] )
             return 0;
     }
 
         /* Return 0 if array 1 is subset of 
        array 2*/
         if(i < n2)
             return 0;
         else
             return 1;
 }
 
 int main()
 {
     int k = solve();
     if(k)
         cout << ""Array2 is a subset of Array1"" ;
     else
         cout << ""Array2 is not a subset of Array1"" ;
     return 0;
 }
 
 /*
 /*
 Test cases :
     
     Input 1 :
         
         6 4
         11 1 13 21 3 7
         11 3 7 1
 
     Output 1 :
 
         Array2 is a subset of Array1
 
     Input 2 :
 
         5 3
         10 5 2 23 19
         19 5 3
     
     Output 2 :
     
         Array2 is not a subset of Array1  
     
     Time complexity: O(n)
     Space Complexity: O(1)
 */
",C-Plus-Plus
"""""""
 Purpose: Given a binary matrix of N*M order where 0 is the wall and 1 is the way.
         Find the shortest distance from a source cell to a destination cell,
         traversing through limited cells only. Also, you can move only
         up, down, left and right. If found then print the distance and
         path in separate lines, else return -1.
 
 """"""
 # Main DFS function using recursion
 
 
 def DFS(maze, Dim, cur_pos, des, visited, path, moves):
     x, y = cur_pos
     n, m = Dim
 
     # Base case: if the current position is the destination, return the path
     if cur_pos == des:
         return path
 
     # Check for each possible move from a possition
     for i in moves.keys():
         r = x + i[0]
         c = y + i[1]
 
         # If the next node inside the maze , has a way and not yet visited
         # then mark it visited, add the path and recursively call DFS()
         # Function from that position
         if 0 <= r < n and 0 <= c < m and maze[r][c] == 1 and not visited[r][c]:
             visited[r][c] = True
             path += moves[i]
             temp = DFS(maze, Dim, (r, c), des, visited, path, moves)
 
             # If the path is found, simply return path
             if temp:
                 return temp
 
             # If the path is not found, pop the path
             path.pop()
 
     # If no path from the current node is possible, return False
     return False
 
 
 def Find_Path(maze, src, des):
 
     # Base Case: If there is no way from the source, returnn False
     if(maze[src[0]][src[1]] != 1):
         return False
 
     # Dimention of the maze
     n = len(maze)
     m = len(maze[0])
 
     # To keep a track of visited nodes, also mark source as visited
     visited = [[False] * m for i in range(n)]
     visited[src[0]][src[1]] = True
 
     # All possible moves from a cell
     moves = {(1, 0): 'D', (-1, 0): 'U', (0, 1): 'R', (0, -1): 'L'}
 
     path = DFS(maze, (n, m), src, des, visited, [], moves)
 
     # ",Python
"//Given a number n find the smallest number evenly divisible by each number 1 to n.
 
 #include<bits/stdc++.h> 
 using namespace std; 
 
 // Function returns the gcd of first n numbers 
 long long gcd(long long a,long long b )
 {
     if (a == 0)
         return b;
     return gcd(b % a, a);
 }
 
 // Function returns the lcm of first n numbers 
 long long lcm(long long n) 
 { 
 	long long ans = 1;	 
 	for (long long i = 1; i <= n; i++) 
 		ans = (ans  *  i) /  (gcd(ans, i)); 
 	return ans; 
 } 
 // Driver program to test the above function 
 int main() 
 { 
 	long long n;
 	cout<< ""Enter the number: "";
 	cin>>n;             
 	cout << lcm(n); 
 	return 0; 
 } 
 
 /*
 ##Example :
 
 1.Input : Enter the number: 4
   Output: 12
 
 Explanation : 12 is the smallest numbers divisible by all numbers from 1 to 4
 
 2.Input : Enter the number: 6
   Output: 60
 
 ##Time Complexity:O(nlogn)
 ##Space Complexity:O(1)								 
 
 */
",C-Plus-Plus
"/*
 Pascal's triangle is a triangular array of the binomial coefficients. It has many applications in mathematics and computer science
 The below code prints the Pascal's Triangle upto the given number of lines
 */
 #include <stdio.h>
 
 //fact function returns factorial of the number
 int fact(int n)
 {
     if (n <= 1)
     {
         return 1;
     }
     return n * fact(n - 1);
 }
 
 // function to find the binomial coefficient
 int binomial_coef(int n, int r)
 {
     return fact(n) / (fact(n - r) * fact(r));
 }
 
 //function to print the pascals triangle
 void pascalsTriangle(int n)
 {
     for (int i = 0; i < n; i++)
     {
         for (int j = i; j < n; j++)
         {
             printf("" "");
         }
         for (int j = 0; j <= i; j++)
         {
             printf(""%d "", binomial_coef(i, j));
         }
         printf(""\n"");
     }
 }
 
 int main()
 {
     printf(""Enter the number of lines for the pascal's triangle\n"");
     int n;
     scanf(""%d"", &n);
     printf(""The pascal's triangle with %d number of lines is :\n"", n);
     pascalsTriangle(n);
     return 0;
 }
 
 /*
 Sample I/O :
 
 Enter the number of lines for the pascal's triangle
 5
 The pascal's triangle with 5 number of lines is :
      1
     1 1
    1 2 1
   1 3 3 1
  1 4 6 4 1
 
 Time Complexity : O(n^3)
 Space complexity : O(1)
 */
",C
"""""""
 Strongly Connected Components : A directed graph is strongly connected
         if there is a path between all pairs of vertices. A strongly
         connected component (SCC) of a directed graph is a maximal
         strongly connected subgraph.
 
 Purpose: To find all the Strongly Connected Components (SCC) in the
         given directed graph.
 
 Method: Kosaraju's Algorithms / Double DFS
 Intution: We can find all strongly connected components in O(N+M) time
         using Kosarajus algorithm. Following is detailed Kosarajus algorithm.
 
         1) Create an empty stack S and do DFS traversal of a graph.
             In DFS traversal, after calling recursive DFS for adjacent
             vertices of a vertex, push the vertex to stack.
         2) Reverse directions of all arcs to obtain the transpose graph.
         3) One by one pop a vertex from S while S is not empty. Let the
         popped vertex be v. Take v as source and do DFS (call DFSU(node)).
         The DFS starting from v prints strongly connected component of v.
 
 Time Complexity:  O(N+M)
 Space Complexity: O(N)
 
 Argument: Dictionary ( Graph with each node numbered from 1 to N)
 Return  : List       ( List of diffrent Strongly Connected Components)
 
 """"""
 from collections import defaultdict
 
 
 def DFS(graph, node, visited, stack, display):
 
     # Mark the node Visited
     visited[node] = True
 
     for i in graph[node]:
 
         # Recursively call all DFS() function to all its unvisited adjacent
         # nodes
         if not visited[i]:
             DFS(graph, i, visited, stack, display)
 
     # If the display is True, then Display the SCC
     if display:
         print(node, end="" "")
     else:
         stack.append(node)
 
 # Reverse_Graph() function reverse all the directed edges of the graph
 
 
 def Reverse_Graph(graph):
 
     rev_graph = defaultdict(list)
     for i in graph.keys():
         for j in graph[i]:
             rev_graph[j].append(i)
 
  ",Python
"
 // In this program we will check whether a number is an Armstrong number 
 // An Armstrong number is a three-digit number in which 
 // the sum of the cube of the digits is equal to the number itself. 
 // Hence 153 is an Armstrong number -> 1^3 + 5^3 + 3^3 = 153
 
 
 process.stdin.setEncoding(""utf-8"");
 var str = """";
 process.stdin.on(""data"", (data) => {
   str += data;
 });
 process.stdin.on(""end"", () => {
   str = str.split(""\n"");
   var number = str[0];
   var temp = number;
   var answer = 0;
   var rem = 0;
   var n = 0;
   while (temp != 0) {
     temp = Math.floor(temp / 10);
     n++;
   }
 
   temp = number;
 
   while (temp != 0) {
     rem = Math.floor(temp % 10);
     answer = answer + Math.pow(rem, n);
     temp = Math.floor(temp / 10);
   }
 
   if (answer == number)
     console.log(number + "" is an Armstrong number."");
   else
     console.log(number + "" is not an Armstrong number."");
 
 });
 // Example
 // Input: 371
 // Output: 371 is an Armstrong number.
 // Explanation 3*3*3+7*7*7+1*1*1 = 371
 
 // Example
 // Input: 321
 // Output: 321 is not an Armstrong number.
 // Explanation 3*3*3+2*2*2+1*1*1 = 44
 
 // Example
 // Input: 4321
 // Output: 4321 is not an Armstrong number.
 // Explanation 4*4*4*4+3*3*3*3+2*2*2*2+1*1*1*1 = 354
 
 // Example
 // Input: 1634
 // Output: 1634 is an Armstrong number.
 // Explanation 1*1*1*1+6*6*6*6+3*3*3*3+4*4*4*4 = 1634
 
 // Example
 // Input: 0
 // Output: 0 is an Armstrong number.
 // Explanation 0 = 0
 
",JavaScript
"import java.util.*;
 class Longest_Common_Prefix{
     public static String LongestCommonPrefixFn(String[] strs) {
         if(strs.length==0){
             return """";
         }
         String st = strs[0];
         for(int i=1; i<strs.length; i++){
             while(strs[i].indexOf(st)!=0){
                 st = st.substring(0, st.length()-1);
             }
         }
         return st;
     }
     public static void main(String args[]){
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter strings"");
         String st = sc.nextLine();
         String[] arrOfStr = st.split("" "");
         System.out.println(""Longest Common Prefix : ""+LongestCommonPrefixFn(arrOfStr));
     }
 }
 
 /*sample input and output:
 
 Enter strings
 encourage encoder enchant
 
 Longest Common Prefix : enc
 
 Complexities
 Time: O(n^2)
 Space: O(n)*/
",Java
"/*                  
 PROBLEM STATEMENT- https://leetcode.com/problems/sort-colors/
 
 Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
 Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
 In simpler words sort an array containing 0,1,2.
 
 Solve the problem with a one-pass algorithm using only O(1) constant space?
 
 The bruteforce approach - Sort the vector in nlogn time
 
                                 ************************DUTCH_NATIONAL_FLAG ALGORITHM***********************************
  */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void sortColors(vector<int> nums) {
         int n=nums.size();
         int low=0,med=0,high=n-1;
         int temp;
         while(med<=high){ 
             if(nums[med]==0){
                 temp=nums[med];
                 nums[med]=nums[low];
                 nums[low]=temp;
                 low++;
                 med++;
             }
             else if(nums[med]==1){
                 med++;
             }
             else{
                 temp=nums[med];
                 nums[med]=nums[high];
                 nums[high]=temp;
                 high--;
             }
         }
         for(int i=0;i<n;i++){
           cout<<nums[i]<<"" "";
         }
     }
 
     int main(){
       vector<int >nums;
       int n,input;
       cin>>n;
       for(int i=0;i<n;i++){
           cin>>input;
           nums.push_back(input);
       }
       sortColors(nums);
     }
 
 /*TEST CASE-
 Input:
 n=6
 nums = [2,0,2,1,1,0]
 Output: [0,0,1,1,2,2]
 
 Input:
 n=3
 nums = [2,0,1]
 Output: [0,1,2]
 
 COMPLEXITY ANALYSIS-
       Time= O(N)
       space=O(1)
 */
",C-Plus-Plus
"/*
 
 A happy number is a number which will yield 1 when it is replaced by the sume of the square of its digits repeatedly.
 If the process results in and endless cycles of numbers containing 4, then the number is an unhappy number
 
 Below is the implementation of program with 3 different approaches - 1. Using builtIn methods
                                                                      2. Using single loop + recursion
                                                                      3. Using loops i.e without recursion 
 Time Complexity - O(log n)
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Using Built-in methods
 function happyNumber(number) {
   // Check if it is 4 ( as it will produce an endless loop )
   if (number === 4)
     return console.log(""Using built-in methods - Not a happy number"");
 
   // Ge the digits
   let digits = number.toString().split("""");
   let sum = digits.reduce((acc, rem) => acc + rem ** 2, 0); // Get the sum
 
   // Check if it is happy
   if (sum === 1) return console.log(""Using built-in methods - Happy Number"");
   else happyNumber(sum); // else pass the sum to algorithm
 }
 
 // Using recursion + loop
 function happyNumberLoop(number) {
   // Check the endless condition, if so, return
   if (number === 4) return console.log(""Using Loop - Not a Happy Number"");
   let isHappy = 0;
 
   // Get the digits & add them to isHappy
   while (number !== 0) {
     let rem = number % 10;
     isHappy += rem ** 2; // Stores the sum of digit
     number = Math.floor(number / 10);
   }
 
   // Check if it is happy, if so, return happy
   if (isHappy === 1) return console.log(""Using Loop - Happy Number"");
   else happyNumberLoop(isHappy); // Else pass the obtained sum to same function
 }
 
 // Without recursion
 function happyNumberWithoutRecursion(number) {
   // An endless condition
   while (true) {
     let isHappy = 0;
 
     // Get the digits & store sum in ",JavaScript
"/*
 Matrix is a 2-D Array.
 The Subtraction of a matrix is possible by subtracting the element of another matrix having same order.
 This code gives the output as as difference between two input matrices.
 */
 #include <stdio.h>
 
 //Function that computes Matrix Subtraction
 void subtract(int row_1, int column_1, int matrix_1[row_1][column_1], int matrix_2[row_1][column_1])
 {
     int matrix_3[row_1][column_1];
     for(int i = 0; i < row_1; i++)
         for(int j = 0; j < column_1; j++)
         //Subtracting both the matrix
             matrix_3[i][j] = matrix_1[i][j] - matrix_2[i][j];
             printf(""Matrix after subtraction is -->\n"");
     for(int i = 0; i < row_1; i++)
     {   for(int j = 0; j < column_1; j++)
         {
             printf(""%d\t"", matrix_3[i][j]);
         }
         printf(""\n"");
     }
 }
 
 //Function that takes input of both matrices
 void input(int row_1, int column_1, int matrix_1[row_1][column_1], int matrix_2[row_1][column_1])
 {
     printf(""Enter the values in matrix 1 -->\n"");
     for(int i = 0; i < row_1; i++)
         for(int j = 0; j < column_1; j++)
             scanf(""%d"", &matrix_1[i][j]);
             printf(""\n\nEnter the values in matrix 2 -->\n"");
     for(int i = 0; i < row_1; i++)
         for(int j = 0; j < column_1; j++)
             scanf(""%d"", &matrix_2[i][j]);
             printf(""\n\n"");
 }
 
 int main()
 {
   int row_1, row_2, column_1, column_2;
   printf(""\nEnter the number of rows in matrix 1 = "");
   scanf(""%d"", &row_1);
   printf(""\nEnter the number of columns in matrix 1 = "");
   scanf(""%d"", &column_1);
   printf(""\nEnter the number of rows in matrix 2 = "");
   scanf(""%d"", &row_2);
   printf(""\nEnter the number of columns in matrix 2 = "");
   scanf(""%d"", &column_2);
   int matrix_1[row_1][column_1], matrix_2[row_2][column_2];
   if (row_1 == row_2 && column_1 == column_2)
    {
      input(row_1, column_1, matrix_1, matrix_2);
      subtract(row_1, column_1, matrix_1, matrix_2);
    }
   else
   p",C
"/*Given the number of nodes and edges of graph print an array containg subtree size of each node*/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //Adjacency List storing the graph
 vector<int> arr[50];
 //Visited array, it stores wheather the node is visited or not
 vector<int> vis(50, 0);
 //Subsize array, it stores the subtree size of each node
 vector<int> subsize(50, 0);
 
 int dfs(int node)
 {
     /*We mark the node as visited and then 
     recursively visit every unvisited child on 
     each call we increament the size of subtree 
     till we reach the last child of that node */
     vis[node] = 1;
     int curr_size = 1;
     for (auto child : arr[node])
     {
         if (vis[child] == 0)
             curr_size += dfs(child);
     }
     subsize[node] = curr_size;
     return curr_size;
 }
 
 int main()
 {
     int nodes, edges, u, v;
     cout << ""Enter nodes and number of edges: "";
     cin >> nodes >> edges;
     cout << ""Enter the edges:- \n"";
     for (int i = 1; i <= edges; i++)
     {
         cin >> u >> v;
         arr[u].push_back(v);
         arr[v].push_back(u);
     }
     dfs(1);
     cout << ""Subtree size array : \n"";
     for (int i = 1; i <= nodes; i++)
     {
         cout << subsize[i] << "" "";
     }
 }
 
 /*
 Sample Input Output :-
 
 Enter nodes and number of edges: 6 5
 Enter the edges:- 
 1 2
 1 3
 2 4
 2 5
 3 6
 Subtree size array :
 6 3 2 1 1 1 
 
 Time Complexity : O( N+E) // Nodes and Edges
 Space Complexity : O( N )
 
 */",C-Plus-Plus
"""""""
 Python program to find the Delannoy number for a given rectangular grid.
 A Delannoy number describes the number of paths from the southwest corner 
 (0, 0) of a rectangular grid to the northeast corner (m, n) using only single steps north, northeast, or east.
 Delannoy number is named after the French mathematican Henri Delannoy.
 """"""
 
 def delannoy_number(r, c):
 
     # Initialize the dp array with '0' as value.
     dp = [[0 for k in range(r+1)] for k in range(c+1)]
 
     for i in range(c):
         dp[0][i] = 1
 
     for i in range(1, c+1):
         dp[i][0] = 1
 
     # From Each point calculate the number of paths, to the north-east point, that can be reached by
     # traversing through the immediate right or immediate top or immediate top-right point.
     for i in range(1, c+1):
         for j in range(1, r+1):
             dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i][j-1]
 
     return dp[c][r]
 
 
 if __name__ == '__main__':
     print(""Enter the co-ordinates of the north-east corner.\nEnter the row co-ordinate: "", end="""")
     x = int(input())
     print(""Enter the column co-ordinate: "", end="""")
     y = int(input())
     res = delannoy_number(x, y)
     print(""The Delannoy number of the given grid is {}."".format(res))
 
 
 """"""
 Time Complexity - O(x * y), where `x`, `y` is the given co-ordinates.
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the co-ordinates of the north-east corner.
 Enter the row co-ordinate: 5
 Enter the column co-ordinate: 6
 The Delannoy number of the given grid is 3653.
 """"""
",Python
"// C program to reverse a number.
 #include <stdio.h>
 
 // Function to reverse a number.
 int reverse(int num)
 {
     int rev = 0;
     while (num > 0)
     {
         rev = rev * 10;
         //Extract the last digit of the number.
         int rem = num % 10;
         rev = rev + rem;
         num = num / 10;
     }
     return rev;
 }
 
 int main()
 {
     int num;
     printf(""Enter the number: "");
     scanf(""%d"", &num);
     int rev = reverse(num);
     printf(""The reverse of the given number is %d."", rev);
     return 0;
 }
 
 /*
 Time Complexity: O(log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 1234
 The reverse of the given number is 4321.
 
 SAMPLE 2
 Enter the number: 785487
 The reverse of the given number is 784587.
 */
",C
"// SudokuSolver
 //Given a partially filled 99 2D array grid[9][9], the goal is to assign digits (from 1 to 9) to the empty cells so that every row, column, and subgrid of size 33 contains exactly one instance of the digits from 1 to 9.
 #include <bits/stdc++.h>
 using namespace std;
 
 bool isSafeToPut(int **mat, int i, int j, int n, int number)
 {
     // Check the rows and cols
     for (int k = 0; k < n; k++)
     {
         if (mat[k][j] == number)
         {
             return false;
         }
     }
 
     for (int k = 0; k < n; k++)
     {
         if (mat[i][k] == number)
         {
             return false;
         }
     }
 
     n = sqrt(n);
     int starti = (i / n) * n;
     int startj = (j / n) * n;
 
     for (int k = starti; k < starti + n; k++)
     {
         for (int l = startj; l < startj + n; l++)
         {
             if (mat[k][l] == number)
             {
                 return false;
             }
         }
     }
     return true;
 }
 
 bool SudokuSolver(int **mat, int i, int j, int n)
 {
     if (i == n)
     {
         // Print the sudoku
         cout << endl;
         cout << ""Solved Sudoku:"" << endl;
         for (int k = 0; k < n; k++)
         {
             for (int l = 0; l < n; l++)
             {
                 cout << mat[k][l] << "" "";
             }
             cout << endl;
         }
         cout << endl;
         return true;
     }
     if (j == n)
     {
         return SudokuSolver(mat, i + 1, 0, n);
     }
     if (mat[i][j] != 0)
     {
         return SudokuSolver(mat, i, j + 1, n);
     }
     for (int number = 1; number <= n; number++)
     {
         if (isSafeToPut(mat, i, j, n, number))
         {
             mat[i][j] = number;
             bool t = SudokuSolver(mat, i, j + 1, n);
             if (t)
             {
                 return true;
             }
             mat[i][j] = 0;
         }
     }
     return false;
 }
 
 int main()
 {
     int n;
     cout << ""Enter ",C-Plus-Plus
"# Python Program to compute Large factorial numbers
 
 
 def factorial_range(start, end):
     if start+1 < end:
         middle = start + ((end - start)//2)  # computing the mid element
         # recursive function to half the digits
         return factorial_range(start, middle) * factorial_range(middle+1, end)
     if start == end:
         return start
     return start*end
 
 
 def factorialtree(n):  # function to divide the factorial in trees
     if n < 2:
         return 1
     return factorial_range(1, n)
 
 
 # Driver Code
 n = int(input())
 print(factorialtree(n))
 
 '''
 Sample I/O:
 input:
 12
 Output:
 479001600
 Time Complexity: O(logN)
 Space Complexity: O(1)
 '''
",Python
"# Importing Libraries
 import matplotlib.pyplot as plt
 import networkx as nx
 
 # Creating an empty Graph
 g = nx.Graph()
 
 # Adding Nodes to empty graph
 for i in range(1, 7):
     g.add_node(i)
 
 # Printing Nodes
 # print(""Nodes are "")
 print(g.nodes())
 # Adding Edges
 g.add_edge(1, 2)
 g.add_edge(1, 3)
 g.add_edge(4, 6)
 g.add_edge(5, 4)
 g.add_edge(2, 3)
 g.add_edge(2, 6)
 
 # Edge Testing
 print(""Edges are "")
 print(g.edges())
 
 nx.draw(g)
 plt.show()
 
 # dijkstra's Algorithm
 h = nx.Graph()
 e = [('a', 'b', 1), ('b', 'c', 2),
      ('a', 'c', 3), ('c', 'd', 4), ('d', 'e', 2), ('b', 'e',  1)]
 
 h.add_weighted_edges_from(e)
 nx.draw(h, with_labels=True)
 plt.show()
 
 print(nx.dijkstra_path(h, 'a', 'e'))
",Python
"'''
 Problem Statement-
 Given a linked list, i & j, swap the nodes that are
 present at i & j position in the Linked List.
 You need to swap the entire nodes, not just the data.
 
 Logical Intuition-
 We change the links of the prev
 and the next pointers of the nodes
 we are swapping.
 '''
 
 
 class Node:
     def __init__(self, data):
         self.data = data
         self.next = None
 
 
 def inputLL():
     '''
     Summary Line-:
     This method helps to take input for the Linked List.
     We use '-1' at the end of our input to indicate the
     end of our list.
 
     Returns:
     Returns the head of our newly
     formed Linked List
     '''
     print(""Enter elements of the Linked List and use -1 to end the list-"")
     llist = list(int(i) for i in input().split())
     head = None
     tail = None
     for data in llist:
         if data != -1:
             newNode = Node(data)
             if head is None:
                 head = newNode
                 tail = newNode
             else:
                 tail.next = newNode
                 tail = newNode
         else:
             return head
 
 
 def lengthLL(head):
     '''
     Summary Line:
     Helps us to get the length
     of the Linked List.
 
     Args:
     head- Head of our Linked List.
 
     Returns:
     Length of our Linked list.
     '''
     count = 0
     while head is not None:
         count += 1
         head = head.next
     return count
 
 
 def swapNodes(head, m, n):
     '''
     Summary Line:
     This function helps us to swap the
     particular nodes of the Linked List.
 
     Args:
     head- Head of our Linked List
     m- index of the first node being swapped.
     n- index of the second node being swapped.
 
     Returns:
     Head of the new Linked list with
     swapped nodes.
     '''
     if head is None:
         return head
     x = m
     y = n
     m = min(x, y)
     n = max(x, y)
     i = 0
     temp = head
     prev1 = None
     while(i < m):
         if ",Python
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# E-MAIL CLASSIFICATION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [E-Mails](https://www.kaggle.com/datatattle/email-classification-nlp)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [
     {
      ""name"": ""stderr"",
      ""output_type"": ""stream"",
      ""text"": [
       ""[nltk_data] Downloading package stopwords to\n"",
       ""[nltk_data]     C:\\Users\\DELL\\AppData\\Roaming\\nltk_data...\n"",
       ""[nltk_data]   Package stopwords is already up-to-date!\n""
      ]
     }
    ],
    ""source"": [
     ""import pandas as pd\n"",
     ""from sklearn import preprocessing\n"",
     ""import nltk \n"",
     ""nltk.download('stopwords')                 # download the stopwords from NLTK\n"",
     ""\n"",
     ""import re                                  # library for regular expression operations\n"",
     ""import string                              # for string operations\n"",
     ""\n"",
     ""from nltk.corpus import stopwords          # module for stop words that come with NLTK\n"",
     ""from nltk.stem import PorterStemmer        # module for stemming\n"",
     ""from nltk.tokenize import TweetTokenizer   # module for tokenizing strings\n"",
     ""\n"",
     ""from sklearn.linear_model import LogisticRegression  \n"",
     ""from sklearn.feature_extraction.text import CountVectorizer  \n"",
     ""from sklearn.model_selection import train_test_split  \n"",
     ""from sklearn.metrics import roc_auc_score\n"",
     ""from sklearn.metrics import confusion_matrix\n"",
     ""import matplotlib.pyplot as plt            # library for visualization\n"",
     ""import seaborn as sns""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting ",Python
"''''
 This is the simple python code for finding the roots of quadratic equation.
 Approach :  Enter the values of a,b,c  of the quadratic equation of the form (ax^2  bx + c )
 the function quadraticRoots will calculate the Discriminant , if D is greater than 0 then it will find the roots and print them otherwise it will print Imaginary!!
 '''
 
 
 import math
 class Solution:
     def quadraticRoots(self, a, b, c):
         d = ((b*b) - (4*a*c))
         if d<0:
             lst=[]
             lst.append(-1)
             return lst
         D = int(math.sqrt(d))
         x1 = math.floor((-1*b + D)/(2*a))
         x2 =  math.floor((-1*b - D)/(2*a))
         lst = []
         lst.append(int(x1))
         lst.append(int(x2))
         lst.sort()
         lst.reverse()
         return lst
 
 
 #  Driver Code Starts
 if __name__ == '__main__':
     # For the values of a,b,c taking in a list in one line  eg : 1 2 3
     print(""Enter the values for a,b,c of the equation of the form ax^2 + bx +c"")
     abc=[int(x) for x in input().strip().split()]
     a=abc[0]
     b=abc[1]
     c=abc[2]
     # Making a object to class Solution
     ob = Solution()
     ans = ob.quadraticRoots(a,b,c)
     if len(ans)==1 and ans[0]==-1:
         print(""Imaginary Roots"")
     else:
         print(""Roots are :"",end="" "")
         for i in range(len(ans)):
             print(ans[i], end="" "")
         print()
 
 
 '''
 Sample Input/Output:
 
 Enter the values for a,b,c of the equation of the form ax^2 + bx +c
 1 2 1
 
 Output:
 Roots are : -1 -1 
 
 Time Complexity : O(1)
 Space Complexity : O(1)
 
 '''
",Python
"// C++ program for Sparse Matrix Representation
 // using Array
 //A matrix is a two-dimensional data object made of m rows and n columns,
 //therefore having total m x n values. If most of the elements
 //of the matrix have 0 value, then it is called a sparse matrix.
 #include <iostream>
 using namespace std;
 class Element
 {
 public:
     int row;
     int colmn;
     int entry;
 };
 class Sparse
 {
 private:
     int m;
     int n;
     int num;
     Element *ele;
 public:
     Sparse(int m,int n,int num)
     {
     this->m=m;
     this->n=n;
     this->num=num;
     ele=new Element[this->num];
         }
     ~Sparse()
     {
     delete [] ele;
     }
     Sparse operator+(Sparse &s);
     friend istream & operator>>(istream &is,Sparse &s);
     friend ostream & operator<<(ostream &os,Sparse &s);
 };
 Sparse Sparse::operator+(Sparse &s)
 {
     int row,colmn,new_index;
     if(m!=s.m || n!=s.n)
         return Sparse(0,0,0);
     Sparse *sum=new Sparse(m,n,num+s.num);
     row=colmn=new_index=0;
     while(row<num && colmn<s.num)
     {
         if(ele[row].row<s.ele[colmn].row)
             sum->ele[new_index++]=ele[row++];
         else if(ele[row].row > s.ele[colmn].row)
             sum->ele[new_index++]=s.ele[colmn++];
         else
         {
         if(ele[row].colmn<s.ele[row].colmn)
             sum->ele[new_index++]=ele[row++];
         else if(ele[row].colmn > s.ele[colmn].colmn)
             sum->ele[new_index++]=s.ele[colmn++];
         else
         {
             sum->ele[new_index]=ele[row];
             sum->ele[new_index++].entry=ele[row++].entry+s.ele[colmn++].entry;
         }
         }
     }
     for(;row<num;row++)sum->ele[new_index++]=ele[row];
     for(;colmn<s.num;colmn++)sum->ele[new_index++]=s.ele[colmn];
     sum->num=new_index;
     return *sum;
 }
     istream & operator>>(istream &is,Sparse &s)
     {
         cout<<""Enter non-zero elements"";
         for(int row=0;row<s.num;row++)
             cin>>s.ele[row].row>>s.ele[row]",C-Plus-Plus
"/*
 Author: @Suvraneel
 	Suvraneel Bhuin
 
 Problem Statement:
 * There are n concert tickets available, each with a certain price. Then, m customers arrive, one after another.
 * Each customer announces the maximum price he or she is willing to pay for a ticket (like an auction)
 * They will get a ticket with the nearest possible price such that it does not exceed the maximum price.
 
 Input:
 * The first line contains integers n and m: the number of tickets and the number of customers.
 * The next line contains n integers h1,h2,,hn: the price of each ticket.
 * The last line contains m integers t1,t2,,tm: the maximum price for each customer.
 
 Output:
 For each customer, the price that they'll pay for their ticket. Same ticket can't be purchased again.
 If a customer cannot get any ticket, print 1.
 
 Constraints:
 *   1      n,m    2105
 *   1     hi,ti   109
 */
 
 
 #include <iostream>
 //For cin and cout
 using namespace std;
 
 //Swap function --> simply exchanges the values of inputs
 void swap(int *xp, int *yp) 
 { 
     int temp = *xp; 
     *xp = *yp; 
     *yp = temp; 
 } 
 
 int partition(int array[], int lo, int hi)
 {
     int i = (lo - 1);
     // Select the pivot element
     int pivot = array[hi];
     //Traverses the array - whenever an element < pivot occurs, swap it with (i+1)th element 
     //This leads to elements < pivot on the left & elements > pivot on the right wrt the pivot
     for (int j = lo; j < hi; j++) {
         if (array[j] <= pivot) {
             i++;
             swap(&array[i], &array[j]);
         }
     }
     //Place the pivot element at i+1 (between smaller and larger elements)
     swap(&array[i + 1], &array[hi]);
     //Returns the pivot position
     return (i + 1);
 }
 
 void quickSort(int array[], int lo, int hi) {
     //If starting index crosses end index, then there're no elements to sort further, thus return
     if( lo >= hi ){
         return;
     }
     // Select pivot position and pu",C-Plus-Plus
"/**
  A linear search or sequential search is a method for finding an element within a list.
  It sequentially checks each element of the list until a match is found or the whole list has been searched
  */
 import 'dart:io';
 
 linearSearch(List array, int toFind) {
   for (int index = 0; index < array.length; index++) {
     if (array[index] == toFind) {
       // If element is found return index at which it is found
       return index;
     }
   }
   // If element is not found return -1
   return -1;
 }
 
 void main() {
   //Driver code
   print(""Enter List size: "");
   int listSize = int.parse(stdin.readLineSync()!);
   var listUser = [];
 
   // Take list input
   print(""Enter $listSize elements: "");
   for (int i = 0; i < listSize; i++) {
     int userInput = int.parse(stdin.readLineSync()!);
     listUser.add(userInput);
   }
   print(""Enter Element to search: "");
   int toFind = int.parse(stdin.readLineSync()!);
   // Search and display result
   int result = linearSearch(listUser, toFind);
   if (result == -1) {
     print(""$toFind not found in list"");
   } else {
     print(""$toFind found at index $result"");
   }
 }
 
 /**
 Time complexity: O(n)
 Space complexity: O(1)
 
 Enter List size:
 5
 Enter 5 elements:
 1
 2
 3
 4
 5
 Enter Element to search:
 4
 4 found at index 3
  */
",Dart
"/*
 WORST FIT MEMORY ALLOCATION
 Available memory blocks are accepted as input from the user
 Allocates largest block available in storage list
 This aims to reduce the production of small blocks, 
 which is common in best fit strategy
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //structure to represent memoryblock with id and size
 typedef struct MemoryBlock
 {
     int id;
     int size;
 } MemoryBlock;
 
 //to print the id of allocated memory block
 void print_block(MemoryBlock block)
 {
     if (block.id != -1 && block.size != -1 && block.size != 0)
         printf(""Block #%d \n"", block.id);
     else
         printf(""Invalid Memory Block\n"");
 }
 
 //linked list to store memory blocks
 typedef struct MemoryManager
 {
     MemoryBlock b;
     struct MemoryManager *llink, *rlink;
 } MemoryManager;
 
 //worst fit memory allocation
 MemoryBlock worst_fit(MemoryManager *m, int memory)
 {
     MemoryBlock bl;
     //if the list is empty
     if (m == NULL)
     {
         bl.id = -1;
         bl.size = -1;
     }
     else
     {
         MemoryManager *ptr = m, *ptr1, *ptr2, *p;
         MemoryBlock worst;
         worst.id = -1;
         worst.size = -1;
         //to find the largest memory block
         while (ptr != NULL)
         {
             if (ptr->b.size >= memory && ptr->b.size > worst.size)
             {
                 worst.id = ptr->b.id;
                 worst.size = ptr->b.size;
             }
             ptr = ptr->rlink;
         }
         worst.size = memory;
         bl = worst;
         ptr = m;
         //to remove the memory allocated from the block
         while (ptr->rlink != NULL)
         {
             if (ptr->b.id == worst.id)
             {
                 ptr->b.size -= memory;
                 break;
             }
             ptr = ptr->rlink;
         }
     }
     return bl;
 }
 
 //to add available memory blocks to linked list
 void deallocate(MemoryManager *m, MemoryBlock memory)
 {
     MemoryManager *ptr",C-Plus-Plus
"/*
 Description : 
         Given a string str and another string pattern. Find the character in pattern that 
         is present at the minimum index in str. If no character of patt is present in 
         str then print No character found from the given pattern.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Pattern
 {
 public:
     //Function to find the minimum indexed character.
     int min_index(string str, string patt)
     {
         int minIndex = INT_MAX;
         unordered_map<char, int> umap;
         int n = patt.size();
         int m = str.size();
 
         //storing index character
         for (int i = 0; i < m; i++)
             if (umap.find(str[i]) == umap.end())
                 umap[str[i]] = i;
 
         //iterating over the second string ""patt"".
         for (int i = 0; i < n; i++)
         {
             if (umap.find(patt[i]) != umap.end() && umap[patt[i]] < minIndex)
             {
                 //updating minimum index.
                 minIndex = umap[patt[i]];
             }
         }
 
         if (minIndex != INT_MAX)
             return minIndex;
         else
             return -1;
     }
 };
 
 int main()
 {
     //input string
     string str;
     cout << ""Enter the string "" << endl;
     cin >> str;
     //pattern string
     string pattern;
     cout << ""Enter the pattern to be found "" << endl;
     cin >> pattern;
 
     Pattern ob;
     int res = ob.min_index(str, pattern);
     //if no pattern returned from the function
     if (res == -1)
     {
         cout << ""No character found from the given pattern "" << endl;
     }
     else
     {
         cout << ""First character present from pattern "" << endl;
         cout << str[res];
     }
     return 0;
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Case :
  Input :
  Enter the string
  xyxyxz
  Enter the pattern to be found
  tree
 
  Output :
  No character found from the given pattern
 */",C-Plus-Plus
"/* This programm is used to swap any data type 
    that is a number or a character and etc.
    It is make our code efficient and workful. */
 
 #include <iostream>
 using namespace std;
 
 // This is a function template
 // Calling the function by reference
 template <class X> void swap(X *a,X *b)
 {
 	X temp;
 	 temp = *a;
 	 *a = *b;
 	 *b = temp;
 }
 
 int main(){
 	
 	int n,m;
 	   cout<<""\n Enter two Integer :"";
 	   cin >> n >> m;
 	
 	char a,b;
 	  cout<<""\n Enter two Charcter :"";
 	  cin >> a >> b;
 	
 	swap(&n,&m);  //calling function to swap integer
 	swap(&a,&b); // calling function to  swap char
 	
 	cout<<""\n Swapped n,m :""<< n <<"" ""<< m << endl;
         cout<<""\n Swapped a,b :""<< a <<"" ""<< b << endl;	
     
     return 0;
 }
 /*
 Time-Complexity = O(N)
 Space-Complexity = O(N)
 */
 
 /*
 Input:
 1 2 or a b
 Output:
 2 1 or b a
 */
 
 
 
",C-Plus-Plus
"/* C++ Program to find lexicographically largest palindrome subsequence 
 In this Program only input line contains a non-empty string S consisting of lowercase English letters only. Its length does not exceed 10.
 Here, Characters in the strings are compared according to their ASCII codes and the one with largest ASCII code is lexicographically largest. 
 And output contain frequency and all the reoccurrence of that character in string S in a single line.
 */     
 #include<iostream>
 #include<string>
 using namespace std;
 
 void Lexicographically_largest_palindrome_subsequence(string String) {
     string  assign, maxAscii;
     int i, j, counter, maxFrequency;
     //initialising maxAscii with character ""a""                                
     maxAscii = ""a"";                         
     maxFrequency = 0;                     
     for(j = 0; j < String.size(); j++) {
         //initialising c with 0         
         counter = 0;                             
         for(i = 0; i < String.size(); i++) {
             //assigning value of element with index 'i' to a           
             assign = String[i];
             //this is for getting the lexicographically largest element (the one with largest ascii value)                  
             if(assign >= maxAscii)                       
             	maxAscii = assign;                     
         }
     }   
     for(i = 0; i < String.size(); i++) {
         assign = String[i];                           
         if(assign == maxAscii) {
             //increament c when we find our lexicographically largest character in string more than one time                  
             counter++;
             //for finding maximum frequency of character                              
             if(counter > maxFrequency) 
                 maxFrequency = counter;                    
         } 
     }
     cout << maxFrequency << "" "";
     for(i = 0; i < maxFrequency; i++) {  
         //printing subsequence of lexico",C-Plus-Plus
"/*
 All Basics Functionality of Queue
 @author: cherryWood55
 @created: 20/08/2020
       Here Indexing starts from 0
       All Insertion and Deletion are based on Index 0.
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 struct queue
 {
 	int front;
 	int rear;
 	int curr_size;
 	int max_size;
 	int *arr;
 };
 
 //This function creates a queue and allocates space for the queue
 struct queue *create_queue(int max_size)
 {
 	struct queue *new_queue = (struct queue *)malloc(sizeof(struct queue));
 	new_queue->max_size = max_size;
 	new_queue->curr_size = 0;
 	new_queue->front = 0;
 	new_queue->rear = max_size - 1;
 	new_queue->arr = (int *)malloc(sizeof(max_size * sizeof(int)));
 	return new_queue;
 }
 
 //This function checks whether the queue is empty
 int is_queue_empty(struct queue *q)
 {
 	if (q->curr_size == 0)
 		return 1;
 	else
 		return 0;
 }
 
 //This function checks whether the queue is full
 int is_queue_full(struct queue *q)
 {
 	if (q->curr_size == q->max_size)
 		return 1;
 	else
 		return 0;
 }
 
 //This function adds an element to the queue
 void enqueue(struct queue *q, int data)
 {
 	if (is_queue_full(q))
 	{
 		printf(""\nQueue is full."");
 		return;
 	}
 	q->rear = (q->rear + 1) % q->max_size;
 	q->arr[q->rear] = data;
 	q->curr_size = q->curr_size + 1;
 	printf(""\n%d is inserted into the queue at position %d."", data, q->rear);
 }
 
 //This function removes the front element of the queue every time it is called
 int dequeue(struct queue *q)
 {
 	if (is_queue_empty(q))
 	{
 		printf(""\nQueue is empty. There are no elements to remove from it."");
 		return;
 	}
 	int data = q->arr[q->front];
 	q->front = (q->front + 1) % q->max_size;
 	q->curr_size = q->curr_size - 1;
 	printf(""\n%d is dequeued from the queue."", data);
 }
 
 //This function returns the first element of the queue, if there are no elements in the queue, it prints a message
 void get_front(struct queue *q)
 {
 	if (is_queue_empty(q))
 	{
 		printf(""\nQueue is empty"");
 		return;
 	}
 ",C
"
 /* Given n non-negative integers representing an elevation map where the 
 width of each bar is 1, compute how much water it can trap after raining. */
 
 import java.io.*;
 import java.util.*;
 
 class Trapping_rain_water {
     static int trap(int arr[]) {
 
         // Your code here
         int n = arr.length;
         if (n == 0)
             return 0;
         int left[] = new int[n];
 
         int right[] = new int[n];
 
         // Initialize result
         int water = 0;
 
         // Fill left array
         left[0] = arr[0];
         for (int i = 1; i < n; i++)
             left[i] = Math.max(left[i - 1], arr[i]);
 
         // Fill right array
         right[n - 1] = arr[n - 1];
 
         // Find max
         for (int i = n - 2; i >= 0; i--)
             right[i] = Math.max(right[i + 1], arr[i]);
 
         // Find min
         for (int i = 0; i < n; i++)
             water += Math.min(left[i], right[i]) - arr[i];
 
         // return the answer
         return water;
 
     }
 
     public static void main(String args[]) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter number of elements: "");
         int n = sc.nextInt();
         int arr[] = new int[n];
         System.out.println(""Enter the elements: "");
         for (int i = 0; i < n; i++)
             arr[i] = sc.nextInt();
         System.out.println(""Water it can trap is: "" + trap(arr));
     }
 }
 
 /* 
 Time Complexity: O(n)
 Space Complexity: O(n)
 
 Example 1:
 
 Input:
 Enter number of elements: 
 12
 Enter the elements: 
 0 1 0 2 1 0 1 3 2 1 2 1
 
 Output:
 Water it can trap is: 6
 
 Example 2:
 
 Input:
 Enter number of elements: 
 5
 Enter the elements: 
 1 4 2 0 1
 
 Output:
 Water it can trap is: 1
 
 */
",Java
"/* 
 The function is expected to place last element after 1st element, 2nd last element after 2nd element and so on.
 
 Example 1
 1->2->3->4->5
 will fold as
 1->5->2->4->3 
 
 Implement on singly Linked List , using Recurrsion.
  */
 
 
 import java.io.*;
 import java.util.*;
 
 public class Main {
   
   // Creating Node for Singly Linked List
   public static class Node {  
     int data;
     Node next;
   }
   // singly Linked List
   public static class LinkedList {    
     Node head;
     Node tail;
     int size;
 
     void addLast(int val) {
       Node temp = new Node();
       temp.data = val;
       temp.next = null;
 
       if (size == 0) {
         head = tail = temp;
       } else {
         tail.next = temp;
         tail = temp;
       }
 
       size++;
     }
     // size function
     public int size() {       
       return size;
     }
     // display function
     public void display() {                
       for (Node temp = head; temp != null; temp = temp.next) {
         System.out.print(temp.data + "" "");
       }
       System.out.println();
     }
 
 
     // static variable for ending purpose
     static int c;     
     // static left pointer 
     static Node left;                   
 
     // helper function
     private void foldHelper(Node node) {   
 
         // If reached null node simply return
         if(node==null)                    
         {
             return;
         }
         // else call helper function for next node for placing right pointer at the tail
         foldHelper(node.next);
         
         // c works as flag to check if left pointer and right pointer has crosssed each other
         if(c==1)                          
         {
             return;
         }
       
         // if left.next = right node or left == right node
         else if(left.next==node || left==node)   
         {   
             // this node will be our tail node
             node.next=null;                     
         ",Java
"/*
 a linear search or sequential search is a method for finding an element within a list. 
 It sequentially checks each element of the list until a match is found or the whole list 
 has been searched.
 
 It has time complexity of O(n).
 ____________________
 |1|5|8|9|0|10|11|12|  -----> search(9)
                                 |
                                 |
 ___________________        
 |1|5|8|9|0|10|11|12|
 
  |_______________________is i==9 false next element i=1
    |_____________________is i==9 false next element i=5
      |___________________is i==9 false next element i=8
         |________________is i==9 true return found and break the loop i=9
 
 So it is searching the whole array linearly.
 
 */
 
 #include<stdio.h>
 #include<stdlib.h>
 
 //base utility function to create the array
 int* create(int n){
     int *a = (int*)malloc(n*sizeof(int));
 
     for (int i = 0; i < n; i++)
     {
         /* code */
         scanf(""%d"",(a+i));
     }
     
     return a;
 }
 
 
 //linear searching a element
 void linear_search(int element,int *a,int n){
 
      //loop intitialisation
      for (int i = 0; i < n; i++)
      {
          /* check if the element is in the array */
          if(*(a+i)==element){
              printf(""\nelement found at:%d position"",i);
              break;
          }
      }
      
 }
 
 //printting the array function
 void display(int *a,int n){
     for (int i = 0; i < n; i++)
     {
         /* code */
 
         printf(""%d "",*(a+i));
     }
     
 }
 
 //main function
 int main(int argc, char const *argv[])
 {
     int n;
 
     printf(""\nenter the size of the array:"");
     scanf(""%d"",&n);
 
     int *arr = create(n);
     
     printf(""\n the array is:"");
     display(arr,n);
 
     int element;//element to search
 
     printf(""\n enter the element to search:"");
     scanf(""%d"",&element);
 
     linear_search(element,arr,n);
     return 0;
 }
 
",C
"/* To print the occurrence of the given number in the list/array using Binary Search Technique 
 
 inputs:
 Size of array/list
 Elements in the array/list
 A number whose occurrence is to be printed
 
 The program should do :
 Find the occurrence of the given number using the above technique
 
 Sample Test Case:
 Input :
 5
 1 4 2 3 4
 4
 Output:
 Occurrence of '4': 2
 
 Space Complexity - O(1)
 Time complexity - logn
 */
 
 
 #include <iostream>
 using namespace std;
 
 
 //Binary_search() for performing binary search on elements
 
 
 int Binary_search (int array[], int sizeOf_array, int number, bool found)
 {
     int start = 0, end = sizeOf_array - 1;
     int value = -1;
     while (start <= end)
     {
         int middle = start + ((end - start) / 2);
 
         if (number == array[middle]) 
         {
             value = middle;
 
             if (found)
 
                 end = middle - 1;
             else 
 
                 start = middle + 1;
             
         }
 
         else if (number < array[middle])
         {
             end = middle - 1;
         }
 
         else
         {
             start = middle + 1;
         }
     }
 
     return value;
 }
 
 //Partition() for quick_sort Algorithm
 
 
 int Partition (int *Array, int start, int end)
 {
     int pivot = Array[end];
     int partition_index = start;
     for(int i = start; i < end ;i++)
     {
         if(Array[i] <= pivot)
         {
             swap(Array[i], Array[partition_index]);
             partition_index++;
 
 
         }
     }
 
     swap(Array[partition_index], Array[end]);
 
     return partition_index; 
 
 }
 
 //Quick_sort() for performing quick_sort Algorithm
 
 int Quick_sort (int array[] , int lower_bound , int  upper_bound)
 {
     int temporary ;
 
     if (lower_bound < upper_bound)
     {
         temporary = Partition (array , lower_bound , upper_bound );
         Quick_sort (array , lower_bound , temporary - 1);
         Quick_sort (array , temporary + 1, up",C-Plus-Plus
"#include <iostream>
 #include <tuple>
 
 using namespace std;
 
 int gcd (int a, int b, int &x, int &y) 
 {
 	//base case
 	if (a == 0) 
   {
 		x = 0; y = 1;
 		return b;
 	}
 	int x1, y1;
 	int d = gcd (b % a, a, x1, y1);
 	x = y1 - (b / a) * x1;
 	y = x1;
 	return d;
 }
 
 // Iterative version of Extended Euclidean algorithm
 
 int gcd_iterative(int a, int b, int& x, int& y) {
     x = 1, y = 0;
     int x1 = 0, y1 = 1, a1 = a, b1 = b;
     while (b1) {
         int q = a1 / b1;
         tie(x, x1) = make_tuple(x1, x - q * x1);
         tie(y, y1) = make_tuple(y1, y - q * y1);
         tie(a1, b1) = make_tuple(b1, a1 - q * b1);
     }
     return a1;
 }
 
 int main()
 {
     int x = 0, y = 0, a, b;
     cout<<""Enter the numbers whose GCD is to be found:""<<endl;
     cin>>a>>b;
 	
     cout<<""GCD of ""<<a<<"" and ""<<b<<"" is:""<<endl;
     cout<<gcd(a, b, x, y)<<endl;
     cout<<""GCD (iterative method) is : ""<<endl;
     cout<<gcd_iterative(a,b,x,y)<<endl;
     return 0;
 }
 
 /*
 Input:
 Enter the numbers whose GCD is to be found:
 36
 60
 
 Output:
 GCD of 36 and 60 is:
 12
 GCD (iterative method) is : 
 12
 
 Time Complexity: O(Log min(a, b))
 Space Complexity: O(1)
 */
",C-Plus-Plus
"def encode(s):
  
     j = 0
     #lenght of the input string
     length = len(s)
 
     while (j < length- 1):
  
        # counter for keeping the track of character  
         counter = 1
         while (j < length - 1 and s[j] == s[j + 1]):
             counter += 1
             j += 1
         j += 1
         # printing the encoded value
         print(s[j - 1] + str(counter), end = "" "")
              
 
 s = input(""Enter the string to encode \n"")
 print(""Encoded string"")
 encode(s)
 
 '''
 Time complexity : O(N)
 Space complexity  O(1)
 '''
 
 '''
 Test Case :
  Input :
     Enter the string to encode 
     tttyyss
  Output :   
     Encoded string
     t3 y2 s2 
 '''",Python
"""""""Julia program to implement Painting Fence algorithm
 Given a fence with n posts and k colors
 Find out the number of ways of painting the fence
 such that at most 2 adjacent posts have the same color.
 
 """"""
 
 function painting_fence(n, k)
     if (k < (n  2) || n < 2)
         return -1
     end
     tot = [0 for i in 1:(n - 1)]
     same = [0 for i in 1:(n - 1)]
     diff = [0 for i in 1:(n - 1)]
 
     same[1] = k
     diff[1] = k * (k - 1)
     tot[1] = k * k
     for i in 2:(n-1)
         same[i] = diff[i-1]
         diff[i] = tot[i-1] * (k-1)
         tot[i] = same[i] + diff[i]
     end 
     return tot[n-1]
 end
 
 print(""Enter the number of posts: "")
 n = readline()
 n = parse(Int, n)
 print(""Enter the number of colours available: "")
 k = readline()
 k = parse(Int, k)
 ans = painting_fence(n, k)
 if( ans == -1)
     println(""The given posts cannot be painted with the given colours satisfying the given conditions"")
 else
     println(""The number of ways to paint the given posts is $ans"")
 end
 
 
 """"""
 Time Complexity: O(n), where 'n' is the number of posts
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number of posts: 10
 Enter the number of colours available: 4
 The given posts cannot be painted with the given colours satisfying the given conditions
 
 SAMPLE 2
 
 Enter the number of posts: 3
 Enter the number of colours available: 5
 The number of ways to paint the given posts is 120
 """"""
",Julia
"""""""
 When given a list of integers,
 we have to find the pair of adjacent
 elements that have the largest product
 and return that product.
 """"""
 
 
 def MaxAdjacentProduct(intList):
     max = intList[0]*intList[1]
     a = 0
     b = 1
     for i in range(1, len(intList) - 1):
         if(intList[i]*intList[i+1] > max):
             a = i
             b = i+1
             max = intList[i]*intList[i+1]
     return(a, b, max)
     
 if __name__ == '__main__':
     intList = list(map(int, input(""\nEnter the numbers : "").strip().split()))
     pos1, pos2, max = MaxAdjacentProduct(intList)
     print(""Max= "", max, "" product of elements at position "", pos1, "","", pos2)
 
 """"""
 Sample Input - Output:
 
 Enter the numbers : -5 -3 -2
 Max=  15  product of elements at position  0 , 1
 
 Time Complexity : O(n)
 Space Complexity : O(1)
 
 """"""
",Python
"/*
  C Program to check whether a given number is Strong number or not.
  Strong number is a special number whose sum of factorial of digits is equal to the original number.
 Eg: 145 is strong number. Since, 1! + 4! + 5! = 145
 */
 
 #include <stdio.h>
 
 int factorial (int num)
 {
   int i = 0;
   int fact = 1;
   for (i = 1; i <= num; i++)
     {
       fact = fact * i;
     }
   return fact;
 }
 
 int main ()
 {
   int sum = 0;
   int lastDigit, number;
   printf (""Enter the number to be checked\n"");
   scanf (""%d"", &number);
   int originalNumber = number;
   while (number > 0)
     {
       lastDigit = number % 10;
       sum = sum + factorial (lastDigit);
       number = number / 10;
     }
   if (sum == originalNumber)
     {
       printf (""Strong number!"");
     }
   else
     {
       printf (""Not a strong number!"");
     }
   return 0;
 }
 
 /*
 Sample Input-Output:
 Example 1-
 Enter the number to be checked
 145
 Strong number!
 Example 2-
 Enter the number to be checked
 456
 Not a strong number!
 */
",C
"/*
 Matrix is a 2-D array.
 The transpose of a matrix is simply a flipped version of the original matrix.
 Transpose of a matrix can be computed by switching its rows with its columns.
 This code gives output as transpose of input matrix.
 */
 
 #include<iostream>
 using namespace std ;
 
 //Function that computes transpose.
 void transpose(int frows, int fcolumns, int **finput_matrix, int **ftranspose_matrix)
 {
     int i = 0, j = 0 ;
     for(i=0 ; i<fcolumns ; ++i)
     {
         for(j=0 ; j<frows ; ++j)
         {
             //According to definition of transpose, each element of transpose matrix is assigned.
             ftranspose_matrix[i][j] = finput_matrix[j][i] ;
         }
     }
 }
 
 int main(void)
 {
     int **input_matrix = NULL, **transpose_matrix = NULL ;
     int rows = 0, columns = 0, i = 0, j = 0 ;
 
     //Taking input as number of rows and columns.
     cout << ""Enter the number of rows in matrix : "" << endl ;
     cin >> rows ;
     cout << ""Enter the number of columns in matrix : "" << endl ;
     cin >> columns ;
 
     //Assigning the memory to the 2_D array according to input matrix size.
     input_matrix = new int*[rows] ;
     for(i=0 ; i<rows ; ++i)
     {
         input_matrix[i] = new int[columns] ;
     }
 
     cout << ""Enter the elements of matrix in row wise manner separated by space : "" << endl ;
     //Taking user input as each element of matrix.
     for(i=0 ; i<rows ; ++i)
     {
         for(j=0 ; j<columns ; ++j)
         {
             cin >> input_matrix[i][j] ;
         }
     }
 
     //Assigning the memory to the transpose matrix. It will have reversed rows and columns as that of input matrix.
     transpose_matrix = new int*[columns] ;
     for(i=0 ; i<columns ; ++i)
     {
         transpose_matrix[i] = new int[rows] ;
     }
 
     //Call to the function that computes the transpose.
     transpose(rows , columns , input_matrix , transpose_matrix) ;
 
     //Display input matrix on the screen.
     cout << ""The i",C-Plus-Plus
"/* Below code is an implementation of binary search in CPP using
 recursive method. An array is taken as input from the user, followed
 by the element the user wants to search in the array. The search function
 is called. If the element is present in the array, then print the index
 of the element in the array.
 NOTE : For binary search to work, the input array must be SORTED*/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // This function recursively searches for element in array
 int search(int array[], int left, int right, int element) {
 
 	// If left pointer exceeds the right pointer
 	if(left > right) {
 		return -1;
 	}
 	else {
 		// Find the middle index
 		int middle = left + (right - left) / 2;
 
 		// If element is found return index
 		if(array[middle] == element) {
 			return middle;
 		}
 		/* If middle element is greater than the given element 
 		to search, then, recursively search in the left half of
 		the array.*/
 		else if(array[middle] > element) {
 			return search(array, left, middle - 1, element);
 		}
 		/* If middle element is less than the given element to
 		search, then, recursively search in the right half of
 		the array.*/
 		else if(array[middle] < element) {
 			return search(array, middle + 1, right, element);
 		}
 	}
 	// If not found, return -1
 	return -1;
 }
 
 int main() {
 
 	// Take length of array as input from the user
 	cout << ""Enter the length of array: "";
 	int length;
 	cin >> length;
 
 	// Take elements of array as input from the user
 	cout << ""Enter "" << length << "" elements followed by spaces: "";
 	int array[length];
 	for(int i = 0; i < length; i++) {
 		cin >> array[i];
 	}
 
 	// Take element to search as input from the user
 	cout << ""Enter the element you want to search: "";
 	int element;
 	cin >> element;
 
 	// Call search function to find the index
 	int index = search(array, 0, length - 1, element);
 	
 	// New line
 	cout << endl;
 
 	// If index is -1, the element is not present
 	if(index ==",C-Plus-Plus
"/*
 BFS stands for Breadth-first
 search, is an algorithm for 
 traversing tree or graph data
 structures. It starts at the 
 tree root (or some arbitrary 
 node of a graph, sometimes
 referred to as a 'search key'[1]),
 and explores all of the neighbor
 nodes at the present depth prior
 to moving on to the nodes at the
 next depth level. This Program
 is to print BFS traversal from a
 given source vertex. BFS(int s)
 traverses vertices reachable 
 from s.
 */
 
 #include <iostream>
 
 #include <list>
 
 using namespace std;
 
 class Graph {
     int V;
 
     list<int>* adj;
 
 public:
     Graph(int V);
 
     void addEdge(int v, int w);
 
     void BFS(int s);
 };
 
 Graph::Graph(int V)
 {
     this->V = V;
     adj = new list<int>[V];
 }
 
 void Graph::addEdge(int v, int w)
 {
     adj[v].push_back(w);
 }
 
 void Graph::BFS(int s)
 {
     bool* visited = new bool[V];
     for (int i = 0; i < V; i++)
         visited[i] = false;
 
     list<int> queue;
 
     visited[s] = true;
     queue.push_back(s);
 
     list<int>::iterator i;
 
     while (!queue.empty()) {
         s = queue.front();
         cout << s << "" "";
         queue.pop_front();
 
         for (i = adj[s].begin();
              i != adj[s].end(); ++i) {
             if (!visited[*i]) {
                 visited[*i] = true;
                 queue.push_back(*i);
             }
         }
     }
 }
 
 int main()
 {
     // Create a graph given in the above diagram
     int V, E, i, S, A, B;
 
     cout << ""Enter the No of Vertex \n"";
     cin >> V;
     Graph g(V);
 
     cout << ""Enter the No of Edges \n"";
     cin >> E;
 
     for (i = 0; i < E; i++) {
         cin >> A >> B;
         g.addEdge(A, B);
     }
 
     cout << ""Enter the Vertex to traverse Graph\n"";
     cin >> S;
 
     cout << ""The BFS Traversal of given Graph is : ""
          << ""(starting from vertex )"" << S << "" \n"";
 
     g.BFS(S);
 
     return 0;
 }
 
 /*
 Time Complexity-O(|V|+|E|)
 Space Complexity-O(|V|)
 where V is the no o",C-Plus-Plus
"//***************************** CODE ************************************
 #include <stdio.h>   
 int countingSort(int A[], int k, int n){
  int i, j;
  int B[15], C[100];
  for (i = 0; i <= k; i++){
    C[i] = 0;
  }
  for (j = 1; j <= n; j++){
    C[A[j]] = C[A[j]] + 1;
  }
  for (i = 1; i <= k; i++){
    C[i] = C[i] + C[i-1];
  }
  for (j = n; j >= 1; j--){
    B[C[A[j]]] = A[j];
    C[A[j]] = C[A[j]] - 1;
  }
  printf(""The Sorted array is : "");
  for (i = 1; i <= n; i++){
    printf(""%d "", B[i]);
  }
  return 0;
 }
 int main(){
  int n, k = 0, A[15], i;
  printf(""Enter the number of input : "");
  scanf(""%d"", &n);
  printf(""\nEnter the elements to be sorted :\n"");
  for (i = 1; i <= n; i++){
    scanf(""%d"", &A[i]);
    if (A[i] > k) {
       k = A[i]; }   
  }
  countingSort(A, k, n);
  printf(""\n"");
  return 0;
 }
 
 //*************************** SAMPLE OUTPUT ******************************
 /*
 Enter the number of input : 12
 Enter the elements to be sorted : 76 54 32 90 87 55 32 65 77 88 42 10
 The Sorted array is : 10 32 32 42 54 55 65 76 77 87 88 90 
 */
 
 //************************* COMPLEXITIES **********************************
 /*
 Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers i.e; it is an integer sorting algorithm. It operates by counting the number of objects that have each distinct key value, and using arithmetic on those counts to determine the positions of each key value in the output sequence. 
 Worst complexity: O(n+k)
 Average complexity: O(n+k)
 Space complexity: O(n+k)
 where n is the number of elements in input array and k is the range of input.
 */
 
 //*********************************************************************
 //This code is by japneetbhatia for submission in DWOC
",C
"/**
  * Count Occurrences of Anagrams
  * Java program to find the count of occurrences of anagrams
  * of an entered word, in an entered text (given that
  * length of word <= length of text). Both Strings contain
  * only lower case alphabets. 
  */
 
 import java.io.*;
 public class CountAnagrams {
     
     private static int countAnagrams(String text, String word) {
 
         //Integer arrays to store count of characters in word and text
         int wordCharCount[] = new int[26];
         int textCharCount[] = new int[26];
  
         int len = word.length(); 
         for(int i=0; i<len; i++) {
             wordCharCount[word.charAt(i) - 'a']++;
             
             //To obtain count of each character in first window of text
             //The size of window is the length of word
             textCharCount[text.charAt(i) - 'a']++; 
         }
 
         //If current window of text and given word are anagrams, difference
         //will be 0. Non-zero difference indicates that the count of atleast
         //one of the 26 characters in not equal in text and word.
         int difference = 0;
         for(int i=0; i<26; i++) {
             difference += Math.abs(wordCharCount[i] - textCharCount[i]); 
         }
 
         //For first window
         int anagramCount = 0; 
         if(difference == 0)
             anagramCount++;
 
         //To obtain value of difference for each subsequent window of size len
         for(int i=len; i<text.length(); i++) {
 
             //Previous value associated with character that has exited window 
             //is subtracted. This character's count is updated and the new value 
             //of difference in added to overall difference.  
             difference -= Math.abs(wordCharCount[text.charAt(i-len)-'a'] - 
                                 textCharCount[text.charAt(i-len)-'a']);
             textCharCount[text.charAt(i-len) - 'a']--; 
             difference += Math.abs(wordCharCount[text.charAt(i-len)-'a",Java
"/*
 Introduction 
 Given two Binary Trees , Check whether they are  quasi isomorphic or not.
 Two trees say Tree1 and Tree2 are quasi-isomorphic if Tree1 can be transformed into Tree2 by
 swapping the left and right children of some of the nodes of root1 ,structurally.
 Data values of node's doesn't matter in this case.
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 /* Function to create a node with 'value' as the data stored in it. 
   Both the children of this new Node are initially null. */
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     /*Interlink all created nodes to create a tree
       Use two pointers using int to store indexes
       One to keep track of parent node and one for children nodes */
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         /* Connect the two children nodes to parent node
            First left and then right nodes */
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Function to check whether given two binary trees are quasi",C-Plus-Plus
"/*
 Infix expression:-  The expression of the form a op b. 
 When an operator is in-between every pair of operands.
 
 Postfix expression:-  An expression is called the postfix expression
 if the operator appears in the expression after the operands. 
 
 This program is for evaluating infix expression.
 In this first we have to convert the infix expression into postfix expression.
 Then evaluate postfix expression using stack. Give an evaluated value.
 */ 
 
 // creating stackarr 
 var stackarr=[];
 
 // Initialize topp variable with -1
 var topp=-1;
 
 // creating evalstack
 var evalstack=[];
 
 // function for evaluating postfix expression
 function postfixevaluator(evalst)
 {
     eval=evalst.split(""$"");
    for(var i=0;i<eval.length-1;i++)
    {
        if(!operator(eval[i]))
        {
            push(eval[i]);
        }
        else
        {
            var op1=parseInt(pop());
            var op2=parseInt(pop());
            
            if(eval[i]==""+"")
            {
                push(op2+op1);
            }
            else if(eval[i]==""-"")
            {
                push(op2-op1);
            }
            else if(eval[i]==""*"")
            {
                push(op2*op1);
            }
            else
            {
                push(op2/op1);
            }
        }
    }
    console.log(pop());
 }
 
 // function for push 
 function push(e)
 {
    topp++;
    stackarr[topp]=e;
 }
 
 // function for pop out
 function pop()
 {
     if(topp==-1)
     return 0;
     else
     {
         var popped_ele=stackarr[topp];
         topp--;
         return popped_ele;
     }
 }
 
 // function for checking whether operator or not 
 function operator(op)
 {
     if(op=='+' || op=='-' || op=='^' || op=='*' || op=='/' || op=='(' || op==')')
     {
         return true;
     }
     else
     return false;
 }
 
 // function for checking precedency
 function precedency(pre)
 {
     if(pre=='@' || pre=='(' || pre==')')
     {
         return 1;
     }
     else if",JavaScript
"/*This program finds the total number of possible combinations that can be used to
 climb statirs . EG : for 3 stairs ,combination and output will be 1,1,1 , 1,2 , 2,1 i.e 3 . */
 import java.util.Scanner;
 
 class Staircase_problem{
     public static void main(String args[]){
         int count_stairs=0;
         Scanner input = new Scanner(System.in);
         System.out.println(""Enter total number of Stairs:""); 
         count_stairs = input.nextInt();
         Staircase_problem sp = new Staircase_problem();
         int final_steps = sp.possibilities_count(count_stairs); 
         System.out.println(""Total Number of possible Combinations = ""+final_steps);
     }
 
     int possibilities_count(int a){
         int result = a;
         /*Using Recursion to find the total number of stairs as f(a) = f(a-1) + a(a-2) 
         where f(a) is the final result */
         if(result <= 1){
             result =  1;
         }else{
             result = possibilities_count(a-1) + possibilities_count(a-2);
         }
         return result;
     }
 }
 /* Output 
 Enter total number of Stairs:
 4
 Total Number of possible Combinations = 5
 */
 // Time Complexity : O(2^n)
 // Space Complexity :O(1)
 // Created by Shubham Patel on 16-12-2020 on WoC
",Java
"/**
  * Ciruclar Queue is a Data Structure which operates on the FIFO (First In First Out) Principle.
  * The pointers to the first and last element are dynamic. 
  *                               
  *          First element -> O - O                   Last element -> O - O <- First element
  *                          /     \                                 /     \
  *          Last element -> O     O      may also be                O     O
  *                          \     /                                 \     /
  *                           O - O                                   O - O 
  * 
  * 
  *       O - O - O - O - O - O           may also be         O - O - O - O - O - O
  *       ^                   ^                               ^   ^
  *      first               last                           last first
  * 
  * In a normal Queue, we can insert elements until queue becomes full. But once queue becomes full, 
  * we can not insert the next element even if there is a space in front of queue. This is possible
  * in Circular Queues and hence is a optimizes space consumption.
  */
 
 import java.util.*;
 public class CircularQueue
 {
     int cq[];
     int first, last;
 
     CircularQueue(int size)
     { 
         //This is a default constructor to declare Circular Queue and global parameters first and last.
         cq = new int[size];
         first =-1;
         last = -1;
     }
 
     public void insert(int value)
     {
         /**
          * This function is used to insert an element into the circular queue. 
          * In a circular queue, the new element is always inserted at last position. 
          * Steps:
          * 1. Check if Circular Queue cq is full (first==0 && last==cq.length-1 || first==last+1).
          * 2. If it is full then display ""Overflow"" and return to main function. If Circular Queue is not full then go to Step 3. 
          * 3. Check if (first==-1).
          *    If it is, then set first=last=0.
          *    El",Java
"/*
 
 Timsort is a hybrid stable sorting algorithm, derived from merge sort and insertion sort, designed to perform well on many kinds of real-world data.
 Algorithm - First sort small pieces using Insertion Sort, then merges the pieces using merge of merge sort.
 Time Complexity - O(n log n)
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 const RUN = 32;
 
 // Perform merge sort
 function mergeSort(array, left, mid, right) {
   // get the left array
   let leftArray = array.slice(left, mid + 1);
 
   // get the right array
   let rightArray = array.slice(mid + 1, right + 1);
 
   let arr = [];
 
   // compare the elements in leftArray & rightArray
   while (leftArray.length && rightArray.length) {
     if (leftArray[0] < rightArray[0]) {
       arr.push(leftArray.shift());
     } else {
       arr.push(rightArray.shift());
     }
   }
 
   // replace sorted arr with array elements
   array.splice(left, right + 1, [...arr, ...leftArray, ...rightArray]); // [...arr, ...leftArray, ...rightArray] - resultant sorted array
   let merged = [].concat.apply([], array); // concat array containing array
   array = merged; // assign this as new array
 
   return array;
 }
 
 // perform insertion sort
 function insertionSort(array, left, right) {
   for (let i = left + 1; i <= right; i++) {
     let temp = array[i];
 
     let j = i - 1;
     while (j >= left && array[j] > temp) {
       array[j + 1] = array[j];
       j--;
     }
 
     array[j + 1] = temp;
   }
 }
 
 function timSort(array, length) {
   // for array less than the length of RUN i.e 32
   for (let i = 0; i < length; i += RUN)
     insertionSort(array, i, Math.min(i + RUN - 1, length - 1));
 
   // perform mergeSort for array length greater than RUN
   for (let size = RUN; size < length; size = 2 * size) {
     for (let left = 0; left < length; left += 2 * size) {
       // find the mid point
       let mid = left + size - 1;
       let right = M",JavaScript
"/*
 This problem is solved using dp.In this problem we will have array and difference.
 We have to divide array into two subsets in such a way that difference of both subsets 
 will become equal to given difference.If equal then we will increase count by 1.
 and if there is no such subset then will return 0 else will return count.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 // This function is for checking whther the subset of array sum is equal to value or not
 int minDiff(int arr[], int n, int sum){
 
      // We will create matrix t of size (n+1)*(sum+1)
     int t[n+1][sum+1];
     /* if j is 0 i.e. sum is 0 and i i.e. arr has whatever values it will always return true
     because if sum is 0 then we don't need to find if subset of array is equal to sum or not */
     for(int i=0;i<n+1;i++){
         t[i][0] = 1;
     }
     /* But if i is 0 i.e array has no value and sum has some value then we can nver make 
     subset of array value equal to sum so it will always give false */
     for(int i=1;i<sum+1;i++){
         t[0][i] = 0;
     }
     for(int i=1;i<n+1;i++){
        for(int j=1;j<sum+1;j++){
           // if subset sum value grater than sum then we will proceed further
           if(arr[i-1] <= j){
             t[i][j] = t[i-1][j-arr[i-1]] + t[i-1][j];
            }
            // if subset sum value less than sum then we will proceed further and we add value to it
            else{
             t[i][j] = t[i-1][j];
            }
         }
     }
     
     // return total count
     return t[n][sum];
 }
 
 //driver code
 int main() {
     int n,diff;
     cin>>n>>diff;
     int arr[n+1];
     for(int i=0;i<n;i++){
         cin>>arr[i];
     }
 
     int total = 0;
     for(int i=0;i<n;i++){
         total += arr[i];
     }
     int sum = (total + diff)/2;
 
     cout<<minDiff(arr,n,sum);
     return 0;
 }
 /*
 Input - 
 4 1
 1 1 2 3
 Output - 3
 Time Complexity - O(n*sum)
 Space Complexity - O(n*sum)
 */
",C-Plus-Plus
"// algorithm for merging two sorted array in O(1) space complexity and in
 // Nlog(N) + Mlog(M) time complexity
 #include <stdio.h>
 #include <stdlib.h>
 int i, j;
 
 void swap(int &x, int &y)    // swapping the elements
 { 
     int temp = x; 
     x = y; 
     y = temp; 
 } 
 
 void mergesort(int a[], int b[], int n, int m) {
   int min = min(n, m);
   for (i = 0; i < min; i++)  // we are swapping the elements of both the array
     // which should be there in the result
   {
     if (a[n - i - 1] > b[i]) 
     {
        swap(a[n - i - 1], b[i]);   
     }
   }
   // sorting the first array
   int x = n;
   int round1 = x / 2 + x % 2;
   while (round1 > 0 && x > 1) {
     for (int i = 1; i + round1 <= n; i++)  // Comparing elements in the first array
       if (a[i - 1] > a[i + round1 - 1])
       {
         swap(a[i - 1], a[i + round1 - 1]);
       }
 
     x = round1;
     round1 = x / 2 + x % 2;
   }
   // Sorting  the second array
   int y = m;
   int round2 = y / 2 + y % 2;
   while (round2 > 0 && y > 1) {
     for (i = 1; i + round2 <= m; i++)  // Comparing elements in the second array
       if (b[i - 1] > b[i + round2 - 1]) 
       {
         swap(b[i - 1], b[i + round2 - 1]);
       }
 
     y = round2;
     round2 = y / 2 + y % 2;
   }
 }
 
 void print(int a[], int b[], int n, int m) {
   for (i = 1; i <= n;
        i++)  // printing the elements of the first and second array
     printf(""%d "", a[i - 1]);
   for (i = 1; i <= m; i++) printf(""%d "", b[i - 1]);
 }
 
 int main() {
   int n, m;
   printf(
     ""please enter the number of elements for the first array\n"");  // taking
   // input
   // from the
   // user
   scanf(""%d "", &n);
   printf(""please enter the number of elements for the second array\n"");
   scanf(""%d "", &m);
   int capacity = 100;
   int used = 0;
   int *a = (int *)malloc(sizeof(int) * capacity);
   int *b = (int *)malloc(sizeof(int) * capacity);
 
   printf(""please enter the elements of the first array\n"");
   for (i = 1; i <= n; i++)",C
"import java.util.Scanner;
 public class Bilinear_Search
 {
     static int findElement(int arr[], int size, int search){
         /* l for left index; r for right index
         found==-1 means element not found
         found other than -1 will be location of the element */
         int l=0, r=size-1;
 	    int found=-1;
 	    while(l<=r){
 	        if(arr[l]==search){
 	            found=l;
 	            break;
 	        }else if(arr[r]==search){
 	            found=r;
 	            break;
 	        }
 	        else{
 	            l++;
 	            r--;
 	        }
 	    }
 	    return found;
     }
 	public static void main(String[] args) {
 	    Scanner sc = new Scanner(System.in);
 	    System.out.print(""Enter number of elements : "");
 	    int n = sc.nextInt();
 	    int[] arr = new int[n];
 	    System.out.print(""Enter the elements: "");
 	    for(int i=0; i<n; i++){
 	        arr[i] = sc.nextInt();
 	    }
 	    System.out.print(""Enter element to search: "");
 	    int search = sc.nextInt();
 	    int found = findElement(arr, n, search);
 	    if(found!=-1){
 	        // found+1 because index starts from 0.
 	        System.out.println(""element found at location : ""+(found+1));
 	    }else{
 	        System.out.println(""element not found"");
 	    }
 	}
 }
 /*
 Sample input and output
 Enter number of elements : 7
 Enter the elements: 4 3 6 8 2 1 9
 Enter element to search: 2
 element found at location : 5
 
 
 time complexity: O(n)
 space complexity: O(n)
 */
",Java
"import java.util.HashMap;
 import java.util.Scanner;
 
 public class UniqueIII {
 
     public static void main(String[] args) {
 
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter number of elements:"");
         int size = scanner.nextInt();
         int[] arr = new int[size];
         System.out.println(""Enter array elements:"");
         for (int i = 0; i < size; i++) {
             arr[i] = scanner.nextInt();
         }
         scanner.close();
 
         int result = findUnique(arr, size);
 
         if (result == -1) {
             System.out.println(""No unique number found."");
         } else {
             System.out.println(""Unique number:"" + result);
         }
     }
 
     private static int findUnique(int[] arr, int length) {
         HashMap<Integer, Integer> freq = new HashMap<Integer, Integer>();
         for (int i = 0; i < length; i++) {
             if (freq.containsKey(arr[i])) {
                 freq.put(arr[i], freq.get(arr[i]) + 1);
             } else {
                 freq.put(arr[i], 1);
             }
         }
 
         for(Integer i : freq.keySet()) {
             if (freq.get(i) == 1) {
                 return i;
             }
         }
         return -1;
     }
 }
 /*
  * Enter number of elements:
  * 7
  * Enter array elements:
  * 6 2 5 2 2 6 6
  * Unique number:5
  *
  * Time complexity: O(n)
  * Space complexity: O(n)
  */
",Java
"/*
 Write a program to check whether a given number is palindrome or not.
 Palindrome is a number which reads the same backward as forward.
 */
 
 //In-Built readline module
 const readline = require(""readline"");
 const rl = readline.createInterface({
   input: process.stdin,
   output: process.stdout,
 });
 
 const getLine = (function () {
   const getLineGen = (async function* () {
     for await (const line of rl) {
       yield line;
     }
   })();
   return async () => (await getLineGen.next()).value;
 })();
 
 function palindromechecker(no) {
   let temp = no;
   let reverse = 0;
 
   //To reverse the number
   while (temp !== 0) {
     reverse = reverse * 10 + (temp % 10);
     temp = parseInt(temp / 10);
   }
 
   if (no === reverse) console.log(""Entered Number is a Palindrome"");
   else console.log(""Entered Number is not a Palindrome"");
 }
 
 const main = async () => {
   //Taking Input of Number
   console.log(""Enter the Number"");
   var no = Number(await getLine());
 
   //Calling palindrome checker function
   palindromechecker(no);
 
   //To close the program
   process.exit(0);
 };
 
 main();
 
 /*
 
 Time Complexity: O(N)
 Space Complexity: O(1)
 
 Input 1:
 1234321
 
 Output 1:
 Entered Number is a Palindrome
 
 Input 2:
 12345
 
 Output 2:
 Entered Number is not a Palindrome
 
 */
",JavaScript
"/** 
 Radix sort is based on counting sort
 This sort is used for non-negative elements
 Assuming the range is fixed, as int capacity
 is limited in any language, this sort takes
 
 MAX_INT contains 10 decimal values
 If range is not fixed, this sort takes O(kn) time
 where k is #decimal places in the number
 This works because of the nature of counting sort
 Counting sort is a stable sort
 **/
 
 #include <stdio.h>
 #include <math.h>
 #include <limits.h>
 
 #define K 10
 #define M 10
 
 void counting_sort(int arr[], int  n, int p) {
 	int element = pow(10, p), i;
 	int divs = element / 10;
 	int count[M];
 	for(i = 0; i < M; i++)
 		count[i] = 0;
 	for(i = 0; i < n; i++)
 		count[(arr[i] % element) / divs] ++;
 	for(i = 1; i < M; i++)
 		count[i] += count[i-1];
 	int op[n];
 	for(i = n-1; i >= 0; i--) {
 	    op[count[(arr[i] % element) / divs] - 1] = arr[i];
 	    count[(arr[i] % element) / divs] --;
 	}
 	// copying the array back
 	for(i = 0; i < n; i++)
 		arr[i] = op[i];
 }
 
 void radix_sort(int arr[], int n) {
 	int i;
 	// apply counting sort for all decimal places
 	for(i = 1; i <= K; i++)
 		counting_sort(arr, n, i);
 }
 
 int main() {
 	int n, i;
 	scanf("" %d"", &n);
 	int arr[n];
 	// taking ip
 	for(i = 0; i < n; i++)
 		scanf("" %d"", &arr[i]);
 	// perform the sort
 	radix_sort(arr, n);
 	for(i = 0; i < n; i++)
 		printf(""%d "", arr[i]);
 	printf(""\n"");
 	return 0;
 }
 
 /**
 Input : 
 8
 175 45 75 90 802 24 2 66
 Output :
 2 24 45 66 75 90 175 802
 
 Time complexity : O(n)
 Space complexity : O(n)
 **/
",C
"/*
 Given an array find out whether it is possible to partition the array into equal sum.
 */ 
 import java.util.*;
 
 class Main
 {
     static boolean equalPartitionSubset(int a[],int n, int sum)
     {
         boolean [][] dp = new boolean[sum+1][n+1];
         
         //Base conditions
         for(int i=0;i<n+1;i++)
         dp[0][i]=true;
 
         for(int j=0;j<sum+1;j++)
         dp[j][0]=false;
 
         for(int i=1;i<sum+1;i++)
         {
             for(int j=1;j<n+1;j++)
             {
                 if(a[j-1]>i)
                 dp[i][j]=dp[i][j-1];
                 if(a[j-1]<=i)
                 dp[i][j]=dp[i][j-1] || dp[i-a[j-1]][j-1];
             }
         }
         return dp[sum][n];
     }
 
     public static void main(String args[])
     {
         Scanner scanner = new Scanner( System.in );        
         System.out.println(""Enter number of elements: "");
         int n = scanner.nextInt();
         System.out.println(""Enter the elements: "");
         int a[]=new int[n];
         int sum=0;
         for(int i=0;i<n;i++)
         {
             a[i]=scanner.nextInt();   
             sum+=a[i]; 
         }
 
         if(sum%2!=0)
         System.out.println(""Equal sum partition not possible"");
         else 
         {
             boolean res=equalPartitionSubset(a,n,sum/2);
             if(res)
             System.out.println(""Equal sum partition possible"");
             else 
             System.out.println(""Equal sum partition not possible"");
         }
     }
 }
 
 /*
 Time Complexity: O(n*sum)
 
 Space Complexity: O(sum)
 
 Input:
 
 Enter number of elements: 
 4
 Enter the elements: 
 1 3 4 6
 
 Output:
 
 Equal sum partition possible
 */
",Java
"/*Problem Statement: 
 In a hotel,there is exactly one room for every integer, including zero and negative integers.
 Even stranger, the hotel is currently at full capacity, meaning there is exactly one guest in every room. 
 The hotel's manager,
 decides he wants to shuffle the guests around because he thinks this will create a vacancy (a room without a guest).
 For any integer k and positive integer n, let kmodn denote the remainder when k is divided by n. 
 More formally, r=kmodn is the smallest non-negative integer such that kr is divisible by n. 
 It always holds that 0kmodnn1. For example, 100mod12=4 and (1337)mod3=1.
 Then the shuffling works as follows. There is an array of n integers a0,a1,,an1. 
 Then for each integer k, the guest in room k is moved to room number k+akmodn.
 After this shuffling process, determine if there is still exactly one guest assigned to each room. 
 That is, there are no vacancies or rooms with multiple guests. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 string strange_hotel(int len,int arr[],vector<int> vis)
 {
     for (int i = 0;i < len; ++i)
     {
         int x = (arr[i] % len + len) % len;
         x = (x + i) % len;
         vis[x]++;
     }
     string ans = ""YES"";
     for (int i = 0; i < len; ++i)
     {
         if (vis[i] == 0)
         {
             ans = ""NO"";
         }
     }
     return ans;
 }
 
 int main()
 {
         int len; 
         cout<<""Enter length of the array: ""<<endl;
         cin >> len;
         int *arr=new int[len];
         vector<int> vis(len, 0);
         cout<<""Enter array: ""<<endl;
         for (int i = 0; i < len; ++i)
         {
             cin >> arr[i];
         }
         string str=strange_hotel(len,arr,vis);
         cout << ""Is only one guest staying in one room? "" << str << endl;
         return 0;
 }
 /*Example:-
 
 Input:-
 Enter length of the array:
 1
 Enter array:
 14
 
 Output:-
 Is only one guest staying in one room? YES
 
 Time Complexity: O(",C-Plus-Plus
"/*
   The Playfair cipher( Playfair square ) encrypts pairs of letters (digraphs),
   instead of single letters as in the simple substitution cipher. The Playfair
   is thus significantly harder to break since the frequency analysis used for 
   simple substitution ciphers does not work with it.
 */
 
 import java.util.*;
 
 class PlayFairCipher{
      
      //This function will form the 5x5 key Matrix 
      static void keyTable(String key,int size2,char[][] keyMatrix){
 
          int i=0;
          int j=0;
          int c = 0;
          char[] alph = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k','l',
          'm','n', 'o','p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
          int[] index = new int[26];
 
          //initializing the array to 0 as it stores garbage values
          for(int z=0;z<26;z++){
              index[z] = 0;
          }
 
          int[] hash = new int[size2];
          //marking the alphabets in key
          for(i=0;i<size2;i++){
             if(key.charAt(i) != 'j'){
                for(j=0;j<26;j++){
                    if(key.charAt(i) == alph[j]){
                       index[j] = 2;
                       hash[c] = j;
                       c++;
                    }
                }
             }
          }
 
         //marking alphabetic j
         index[9] = 1;
         i = 0;
         j = 0;
 
         //adding the marked alphabets  
         for(int k=0;k<size2;k++){
 
            if(index[hash[k]] == 2){
               index[hash[k]] -= 1;
               keyMatrix[i][j] = key.charAt(k);
               j++;
               if(j==5){
                  i++;
                  j=0;
               }
            }
         }
 
         //adding the remaining alphabets
         for(int k=0;k<26;k++){
 
            if(index[k] == 0){
               keyMatrix[i][j] = alph[k];
               j++;
               if(j==5){
                  i++;
                  j=0;
               }
            }
         }
 
    ",Java
"/* A star graph is an undirected graph that has n nodes in which one is center node and  has exactly n - 1 edges.
 
     4
     |
     2
    / \
   1   3 
   
  Here 2 is the answer.
  
  Approach: Store the nodes in vector that are connected to partciular node, if size of that vector equals to nodes-1 then print it is the centre. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int findCenter(vector<vector<int>>& edges)
 {
         int n=edges.size()+1;
         
         vector<int>l[n+1];
         
         // Store the destintaion edges into source node vector
         for(int i=0;i<edges.size();i++)
         {
                 l[edges[i][0]].push_back(edges[i][1]);
                 l[edges[i][1]].push_back(edges[i][0]);
         }
          
         // Check if vector size is equal to nodes-1, to find the center
         int center;
         for(int i=0;i<=n;i++)
         {
             if(l[i].size()==n-1)
                 center=i;
         }
         return center;
 }
 
 int main()
 {
     int src,dest,no_of_edges;
     cout<<""Enter number of edges""<<endl;
     cin>>no_of_edges;
     vector<vector<int>>edges;
     
     for(int i=0;i<no_of_edges;i++)
     {
         vector<int>temp;
         
         cout<<""Enter source of edge""<<endl;
         cin>>src;
         temp.push_back(src);
         cout<<""Enter destination of edge""<<endl;
         cin>>dest;
         temp.push_back(dest);
         
         edges.push_back(temp);
     }
     cout<<(findCenter(edges));
     return 0;
 }
 
 
 /* 
 INPUT:
 Enter number of edges
 3
 Enter source of edge
 1
 Enter destination of edge
 2
 Enter source of edge
 2
 Enter destination of edge
 3
 Enter source of edge
 4
 Enter destination of edge
 2
 OUTPUT:
 2
 
 Time Complexity: O(no_of_edges)
 Space Complexity: O(no_of_edges)
 */
",C-Plus-Plus
"import java.util.*;
 
 class SubSequences {
     static void get_sequence(String str, String ans, int i) {
         // Base condition
         if (i == str.length()) {
             System.out.println(""'"" + ans + ""'"");
             return;
         }
         // Before character gets added to final
         get_sequence(str, ans, i + 1);
         // after character gets added to ans
         get_sequence(str, ans + str.charAt(i), i + 1);
 
     }
 
     public static void main(String arg[]) {
         Scanner sc = new Scanner(System.in);
         String str;
         System.out.println(""Enter the string"");
         str = sc.nextLine();
 
         System.out.println(""All possible subsequences are:"");
         get_sequence(str, """", 0);
     }
 }
 
 
 /*
 output:
 Enter the string
 abcd
 All possible subsequences are:
 '' 'd' 'c' 'cd' 'b' 'bd' 'bc' 'bcd' 'a' 'ad' 'ac' 'acd' 'ab' 'abd' 'abc' 'abcd'
 
 Time complexity : O(n^2)
 space complexity : O(n)
 */
",Java
"/* Caesar Cipher Algorithm
 
 Caesar Cipher Algorithm is an old encryption methodology used for encryption of data. Also known as Caesar Shift or
 Caesars Code, it is one of the most straightforward and prevalent encryption technique. This Caesar Cipher
 encryption algorithm is a kind of substitution cipher wherein every character in the plain-text or the user
 input is replaced by another character which is defined with a fixed number of positions away from the existing character.
 It is a method in which every letter or character in the plain text is altered and shifted. Every text character replaced
  by a specific character depending upon the algorithm.
 
 The Caesar Cipher Algorithm is one of the oldest and easiest algorithms for encryption and decryption algorithm
 in C programming language.
 
 */
 
 #include<stdio.h>
 #include<stdlib.h>
 
 char data[50], temp;
 int key, count;
 
 /* Cipher_Caesar Encryption */
 void encryption()
 {
 	for (count = 0; data[count] != '\0'; count++) {
 		temp = data[count];
 		if (temp >= 'a' && temp <= 'z') {
 			temp = temp + key;
 			if (temp > 'z') {
 				temp = temp - 'z' + 'a' - 1;
 			}
 			data[count] = temp;
 		} else if (temp >= 'A' && temp <= 'Z') {
 			temp = temp + key;
 			if (temp > 'Z') {
 				temp = temp - 'Z' + 'A' - 1;
 			}
 			data[count] = temp;
 		}
 	}
 	printf(""Encrypted Message:\t%s\n"", data);
 }
 
 /* Cipher_Caesar Decryption */
 void decryption()
 {
 	for (count = 0; data[count] != '\0'; count++) {
 		temp = data[count];
 		if (temp >= 'a' && temp <= 'z') {
 			temp = temp - key;
 			if (temp < 'a') {
 				temp = temp + 'z' - 'a' + 1;
 			}
 			data[count] = temp;
 		} else if (temp >= 'A' && temp <= 'Z') {
 			temp = temp - key;
 			if (temp < 'A') {
 				temp = temp + 'Z' - 'A' + 1;
 			}
 			data[count] = temp;
 		}
 	}
 	printf(""Decrypted Message:\t%s\n"", data);
 }
 
 int main()
 {
 	printf(""Enter a String:\t"");
 	scanf(""%[^\n]s"", data);
 
 	printf(""Enter a Key:\t"");
 	scanf(""%d"", &key);
 
 	enc",C
"import java.util.*;
  class abc
 {   static long findMaxSumArray(long arr[],int x)
     {   long currentSum=0,maxSum=0;int i;
         
         for(i=0;i<x;i++)
         {currentSum+=arr[i];
             if(currentSum<0)
             currentSum=0;
         maxSum=Math.max(currentSum,maxSum);}
         
        
         return maxSum;
     }
     public static void main()
     {
         Scanner sc=new Scanner(System.in);
         int i,j,k,l,m,n;
         n=sc.nextInt();long sum=0,maxSum=0;
         long a[]=new long[n];
         for(i=0;i<n;i++)
         a[i]=sc.nextLong();
         
         sum=findMaxSumArray(a,n);
         System.out.println(sum);
     }
 }
 /* Input/Output-
 5
 4 2 -3 -1 8
 10 */
",Java
"/*
 In mathematics, matrix addition is the operation of adding two matrices by adding 
 the corresponding entries together.This program takes two matrices of order n*m and 
 stores it in two-dimensional array. Then, the program adds these two matrices and 
 displays it on the screen.
 */
 
 function matrix_addition(a_1, n1, m1, a_2) {
     //res is the result array
     let res = new Array(n1);
     for (let i = 0; i < n1; i++) {
         res[i] = new Array(m1);
     }
     for (let i = 0; i < n1; i++) {
         for (let j = 0; j < m1; j++) {
             res[i][j] = a_1[i][j] + a_2[i][j];
         }
     }
     return res;
 }
 
 const readline = require('readline');
 
 const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
 
 const getLine = (function () {
     const getLineGen = (async function* () {
         for await (const line of rl) {
             yield line;
         }
     })();
     return async () => ((await getLineGen.next()).value);
 })();
 
 const main = async () => {
     console.log(""Enter the number of rows in the first matrix"");
     let n1 = Number(await getLine());
     console.log(""Enter the number of columns in the first matrix"");
     let m1 = Number(await getLine());
     console.log(""Enter the elements of the first matrix"");
     //initializing array
     let a_1 = new Array(n1);
     for (let i = 0; i < n1; i++) {
         a_1[i] = new Array(m1);
     }
     for (let i = 0; i < n1; i++) {
         for (let j = 0; j < m1; j++) {
             console.log(""Enter the element at position "" + i + "" , "" + j);
             a_1[i][j] = Number(await getLine());
         }
     }
     console.log(""Enter the number of rows in the second matrix"");
     let n2 = Number(await getLine());
     console.log(""Enter the number of columns in the second matrix"");
     let m2 = Number(await getLine());
     console.log(""Enter the elements of the second matrix"");
     //initializing array
     let a_2 = new Array(n2);
     for (let",JavaScript
"/*Below is an implementation of keyword cipher in Go. It is a form of
 monoalphabetic substitution. A encryption is formed of alphabets from
 [a-z] such that the first part of encrption contains unique letters of
 the keyword and the rest are the remaining alphabets from [a-z]. That is,
 until the keyword is used up, whereupon the rest of the ciphertext letters
 are used in alphabetical order, excluding those already used in the key.*/
 
 package main
 
 import (
 	""fmt""
 	""unicode""
 	""bufio""
 	""os""
 	""strings""
 )
 
 // This function generates the pad using the keyword
 func padgen(key string) string {
 
 	pad := [26]string{}
 	count := 0
 	i := 0
 
 	for i < len(key) {
 
 		// Ignoring the spaces in the given keyword
 		if(string(key[i]) == "" "") {
 			i = i + 1
 			continue
 		}
 
 		// Checking keyword alphabet-wise
 		missing := 0
 		for j := 0; j < len(key); j++ {
 			if(string(key[i]) != string(pad[j])) {
 				missing += 1
 			}
 		}
 
 		// Adding the unique words of key to pad
 		if(missing == len(key)) {
 			pad[count] = string(key[i])
 			count += 1
 		}
 		i = i + 1
 	}
 	// Till here we get the first half of the pad
 
 	// Declaring ciphertext string
 	var enc string
 	var alphabet string = ""abcdefghijklmnopqrstuvwxyz""
 
 	i = 0
 	// This while loop forms the remaining pad
 	for i < 26 {
 
 		not_present := 0
 		for j := 0; j < 26; j++ {
 			if(string(alphabet[i]) != string(pad[j])) {
 				not_present += 1
 			}
 		}
 
 		/* Whatever alphabets from [a-z] are not present
 		in the pad till now, add them to the pad.*/
 		if(not_present == 26) {
 			pad[count] = string(alphabet[i])
 			count = count + 1
 		}
 		i += 1
 	}
 
 	for i := 0; i < len(pad); i++ {
 		if(pad[i] != "" "") {
 			enc += pad[i]
 		}
 	}
 
 	// Return the length 26 pad
 	return enc
 }
 
 // This is the encryption function
 func encryption(plaintext, key string) string {
 
 	// Generate the pad using the above function
 	var pad string = padgen(strings.ToLower(key))
 	var alphabet string = ",Go
"/* 
 
 You have been given a singly linked list of integers along with an integer 'N'.
 Write a function to append the last 'N' nodes towards the front of the singly linked list and returns the new head to the list.
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // create a class node
 
 class Node {
 public:
 	int data;
 	Node *next;
 	Node(int data) {
 		this->data = data;
 		this->next = NULL;
 	}
 };
 
 
 // taking input from the user for linked list
 
 Node *takeinput() {
 	int data;
 	cin >> data;
 	Node *head = NULL, *tail = NULL;
 	while (data != -1) {
 		Node *newnode = new Node(data);
 		if (head == NULL) {
 			head = newnode;
 			tail = newnode;
 		} else {
 			tail->next = newnode;
 			tail = newnode;
 		}
 		cin >> data;
 	}
 	return head;
 }
 
 
 //printing the linked list if head is given 
 
 void print(Node *head) {
 	Node *temp = head;
 	while (temp != NULL) {
 		cout << temp->data << "" "";
 		temp = temp->next;
 	}
 	cout << endl;
 }
 
 
 //finding the length of the linked list
 
 int length1(Node *head) {
 	
     // Write your code here
 	
     if(head == NULL)
         return 0;
     if(head->next == NULL)
         return 1;
     Node* temp = head;
     return 1 + length1(temp->next);
 }
 
 
 // function to append last n elements of linked list at front
 
 Node *appendLastNToFirst(Node *head, int n) {
     Node * temp = head;
     int length = length1(temp);
     if(temp == NULL) {
         return temp;
       } else {
          while( temp->next != NULL) {    
          
         // finding the last node
 		 
         temp = temp->next;                   
     }
 	    
      // connecting the head to the last node
 	    
     temp->next = head;                         
     temp = head;
 	    
     // finding the node that is supposed to be the new head
 	    
     for(int i = 1; i<=length-n-1; i++) {
         temp = temp->next;                   
     }
     head = temp->next ;                       
     temp->next = NULL;
     retu",C-Plus-Plus
"/**
  * Given a n x n matrix. The problem is to sort the given matrix in strict order. 
  * Here strict order means that matrix is sorted in a way such that all elements
  * in a row are sorted in increasing order and for row i,
  * where 1 <= i <= n-1, first element of row 'i' is greater than or equal to the last element of row 'i-1'.
  * Input:
  * First line of input contains dimension n of the matrix.
  * Next n line form n rows with n elements each.
  * Output:
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int main()
 {
     int n;
     cout << ""Enter the size of an array : "" << endl;
     cin >> n;
     int arr[1000][1000];
     cout << ""Enter the elements in an array : "" << endl;
     for (int i = 0; i < n; i++)
     {
         for (int j = 0; j < n; j++)
         {
             cin >> arr[i][j];
         }
     }
     // Array to store all the elements in 1_D for sorting
     int oneD_arr[n * n + 2];
     int pos = 0;
     for (int i = 0; i < n; i++)
     {
         for (int j = 0; j < n; j++)
         {
             oneD_arr[pos++] = arr[i][j];
         }
     }
     // Using inbuilt sort
     sort(oneD_arr, oneD_arr + pos);
     pos = 0;
     cout << ""\n Sorted 2-D Matrix is:""
          << ""\n"";
     for (int i = 0; i < n; i++)
     {
         for (int j = 0; j < n; j++)
         {
             // changing value of intial array with sorted values
             arr[i][j] = oneD_arr[pos++];
             // displays output
             cout << arr[i][j] << "" "";
         }
         cout << ""\n"";
     }
     return (0);
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Case :
   Input:
   Enter the size of an array : 
   3
   Enter the elements in an array : 
   5 4 7
   1 3 8
   2 9 6
  
   Output:
   Sorted 2-D Matrix is:
   1 2 3
   4 5 6
   7 8 9
 */
 
",C-Plus-Plus
"'''
 Purpose: To place N queens in a N*N Chessboard such that no two queens
         attack each other. A queen is said to be attacked by another queen
         if they share same diagonal(right/left), Row or Column.
 Problem Link:- https://en.wikipedia.org/wiki/Eight_queens_puzzle
 Method: Backtracking
 Intution: Since there could be only one queen in each row, we can assume the
           N*N chessboard to be a 1d array which each index denotes one of the
           row and the row value denotes the column. Now in each row, we will
           put a queen and check whether it is possible or not. If possible, then
           we recursively check for the next row. If its not possible to place
           a queen in any of the column is a particular row, then we backtrack
           and try next Column.
 
 Time Complexity:  O(2^N)
 Space Complexity: O(N)
 
 Argument: Integer ( Size of the Chessboard)
 Return  : List    ( Position of individual queens)/ False
 '''
 
 
 # Main function argument =size of the board
 def n_queens(board_size):
 
     # Occupied Diagonals and Columns
     # For right and left Diagonal respectively
     diagonal1 = {}
     diagonal2 = {}
     Col = {}
 
     ans = place_queen(0, [], board_size, diagonal1, diagonal2, Col)
 
     return ans
 
 # Recursive Function to check and place the queens
 def place_queen(row, a, n, diagonal1, diagonal2, Col):
 
     # If the answer is found, row will be equal to the size of the board i.e. n
     if(row == n):
         return a
     R = row + 1
 
     for C in range(1, n + 1):
         # Check that particular Column is free to place a queen or not
         if((C not in Col) and ((R + C) not in diagonal1) and ((R - C) not in diagonal2)):
 
             # Add the Column and their respective Diagonals to the dictionary
             # to mark they are Occupied
             Col[C] = 0
             diagonal1[R + C] = 0
             diagonal2[R - C] = 0
             chk = place_queen(
                 row + 1, a +",Python
"# Julia program to check if a number is a power of two.
 
 function power_of_two(n)
     # 0 is not a power of 2
     if(n != 0)
         if((n & (n-1)) == false)
             return true
         end
     end
     return false
 end
 
 
 print(""Enter a number: "")
 n = readline()
 n = parse(Int, n)
 res = power_of_two(n)
 if(res)
     print(""The given number is a power of 2."")
 else
     print(""The given number is not a power of 2."")
 end
 
 
 """"""
 Time Complexity - O(1)
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 Enter a number: 4
 The given number is a power of 2.
 
 SAMPLE II
 Enter a number: 0
 The given number is not a power of 2.
 """"""
",Julia
""""""" Julia program to find the Length of Longest Increasing Subsequence
 
 In this problem, given an array we have to find the length of the longest increasing subsequence that array can make.
 The problem can be solved using Dynamic Programming
 """"""
 
 function length_longest_increasing_subsequence(arr, n)
     max_len = 0
     # Initialize the dp array with the 1 as value, as the maximum length
     # at each point is atleast 1, by including that value in the sequence
     dp = ones(Int, n)
 
     """""" Now Lets Fill the dp array in Bottom-Up manner
     Compare Each i'th element to its previous elements from 0 to i-1, 
     If arr[i] > arr[j](where j = 0 to i-1), then it qualifies for increasing subsequence and
     If dp[i] < dp[j] + 1, then that subsequence  qualifies for being the longest one""""""
     for i in 1:n
         for j in 1:(i-1)
             if(arr[i] > arr[j] && dp[i] < dp[j] + 1)
                 dp[i] = dp[j] + 1
             end
         end
     end
 
     # Now Find the largest element in the dp array 
     max_len = findmax(dp)[1]
     return max_len
 end
 
 
 print(""What is the length of the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""No numbers present in the array!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 res = length_longest_increasing_subsequence(arr, n)
 print(""The length of the longest increasing subsequence of the given array is $res"")
 
 
 """"""
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 What is the length of the array? 5 
 Enter the numbers: 5 4 3 2 1
 The length of the longest increasing subsequence of the given array is 1
 
 """"""
",Julia
"//C++ program to implement Selection Sort
 
 include<bits/stdc++.h>
 using namespace std;
 
 void selection_sort(vector <int> &arr, int n) 
 {
    int i=0;
    while(i<n)
    {
       //Initilizing mini as i
       int mini=i;
       int j=i+1;
       while(j<n)
       {
          //If element at j is smaller than mini then change mini to j
          if(arr[j]<arr[mini])mini=j;
          j++;
       }
       //swapping elements at mini and i
       swap(arr[mini],arr[i]);
       i++;
    }   
 }
 
 int main() {
    int n;
    cout << ""Enter the size of array:"";
    cin >> n;
    vector <int> arr(n);
    cout << ""Enter the elements of array:"";
    for(auto &e:arr)cin>>e;
    selection_sort(arr, n);
    for(auto e:arr)cout<<e<<"" "";
 
    return 0;
 }
 
 /*
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 INPUT
 Enter the size of array: 5
 Enter the elements of array: 5 4 3 2 1
 
 OUTPUT
 1 2 3 4 5
 
 */",C-Plus-Plus
"import java.util.Scanner;
 
 /*
 Calculating the set bits(number of 1's in binary form) of an integer
 */
 
 public class SetBitsInInteger
 {
     private static Scanner sc  =new Scanner(System.in);
     public static void main(String[] args) {
         
         //asking the user for input and storing the input in int variable n
         System.out.println(""Kindly enter the number: "");
         int n= sc.nextInt();
 
         //converting the entered input(integer) into binary and storing it in string variable binary
         String binary = Integer.toBinaryString(n);
         
         //printing the binary form of the integer
         System.out.println(""Binary form: ""+binary);
 
         //we store the number of 1's in count variable
         int count=0;
 
         //now we iterate through the string and check for the presence of 1's
         for(int i=0;i<binary.length();i++)
         {
             //comparing each character present in the string to '1'
             if(binary.charAt(i)=='1'){
                 count++;
             }
         }
         System.out.println(count);
     }
 }
 
 /*
 Sample Outputs:
 
 Kindly enter the number: 
 3
 Binary form: 11
 2
 
 
 Kindly enter the number:
 2
 Binary form: 10
 1
 
 
 Kindly enter the number: 
 16
 Binary form: 10000
 1
 
 
 Kindly enter the number: 
 -12
 Binary form: 11111111111111111111111111110100
 29
 
 */
",Java
"/*
 Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
 You may assume no duplicates in the array.
 */
 
 #include <iostream>
 using namespace std;
 
 int search_insert_position(int arr[], int n, int target) {
 	int l = 0, r = n - 1;
 	int mid;
 	while (l <= r) {
 		mid = l + ((r - l) / 2);
 		if (target > arr[mid])
 			l = mid + 1;
 		else if (target < arr[mid])
 			r = mid - 1;
 		else
 			return mid;
 	}
 	return l;
 }
 
 int main() {
 	int n;
 	cin >> n;
 	int arr[n];
 	for (int i = 0; i < n; i++)
 		cin >> arr[i];
 	int target;
 	cin >> target;
 	int ans = search_insert_position(arr, n, target);
 	cout << ans;
 	return 0;
 }
 
 
 /*
 TIME COMPLEXITY:- O(log2n)
 SPACE COMPLEXITY:- O(n)
 
 OUTPUT:-
 5
 2 3 4 5 6
 4
 2
 */
",C-Plus-Plus
"''' Stock Span Problem
 Given a list of prices of a stock for N number of days,
 find stock span for each day.
 '''
 
 
 def calcSpan(price):
     day = len(price)
     stack = []
     span = [0 for i in range(0, day)]
 
     span[0] = 1
     stack.append(0)
 
     for i in range(1, day):
 
         while (len(stack) > 0 and price[stack[-1]] <= price[i]):
             stack.pop()
 
         if len(stack) <= 0:
             span[i] = i + 1
         else:
             span[i] = i - stack[-1]
 
         stack.append(i)
 
     print(span)
 
 
 prices = list(map(int, input().strip().split()))
 calcSpan(prices)
 
 '''
 sample Input:
 10 30 20 50 20
 sample output:
 1 2 1 4 1
 
 Time complexity: O(n)
 space complexity:O(n)
 '''
",Python
"/*
 minimum no. of swaps needed to sort the array in ascending
 order having integer in range 1 to N. For example:
 array is 1 2 3 5 4 ,here it can be easily sorted by 
 swapping 5 and 4. Therefore, 1 swap needed here.
 */
 #include<iostream>
 using namespace std;
 
 int min_swap_needed(int a[],int n)
 {
     int swap=0;
     for(int i=0;i<n-1;i++)
     {
         int j=a[i],temp;
     	  if((i+1)!=a[i])
     	  {
 	        temp=a[i];
 	        a[i]=a[j-1];
             	a[j-1]=temp;
 	        swap++;
     	  }
     }
     return swap;
 }
 
 int main()
 {
     int n;
     cin>>n;
     int a[n];
     for(int i=0;i<n;i++)cin>>a[i];
     int swap;
     swap=min_swap_needed(a,n);
     cout<<swap;
     return 0;
 }
 /*
 input:
 6
 6 5 3 4 2 1
 output:
 2
 */
 
 /*
 Time-Complexity=O(N)
 Space-Complexity=O(N)
 */
",C-Plus-Plus
"/*
 Problem Statement:
  Given a stack, sort the given stack using recursion such that the greatest element is on the top. 
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 void printStack(stack<int> st)
 {
   while (!st.empty())
   {
     int x = st.top();
     st.pop();
 
     cout << x << "" "";
   }
 
   return;
 }
 
 void insert(stack<int> &st, int temp)
 {
   // base condition
   if (st.size() == 0 || st.top() < temp)
   {
     st.push(temp);
     return;
   }
 
   int val = st.top();
   st.pop();
 
   insert(st, temp);
   st.push(val);
 
   return;
 }
 
 void sortStack(stack<int> &st)
 {
 
   // base condition
   if (st.size() == 0)
     return;
 
   int temp = st.top();
   st.pop();
 
   // recursion
   sortStack(st);
 
   // function to insert element in stack
   insert(st, temp);
 
   return;
 }
 
 int main()
 {
   // input number of element in stack
   int n;
   cin >> n;
 
   stack<int> st;
 
   // input stack elements
   for (int i = 0; i < n; i++)
   {
     int x;
     cin >> x;
 
     st.push(x);
   }
 
   // function to sort stack
   sortStack(st);
 
   // function to print stack element
   printStack(st);
 
   cout << endl;
 
   return 0;
 }
 
 /*
   Time Complexity: O(N*N)
   Space complexity: O(N)
 
 */
 
 /*
    Test Case:
 
   Input:  10 
           9 2 5 6 0 1 7 3 4 8
   OutPut: 9 8 7 6 5 4 3 2 1 0
 
   Input: 5
          11 2 32 3 41
   Output: 41 32 11 3 2              
 
 */
 
",C-Plus-Plus
" /*
   * It's the use of two different pointers (usually to keep track of array or string indices)
   * to solve a problem involving said indices with the benefit of saving time and space.
   *
   */
  import java.util.Scanner;
  public class two_pointer {
    public two_pointer(int array[], int k) {
      int j = array.length - 1;
      while (j > 0) {
        for (int i = 0; i < j; i++) {
          if (array[i] + array[j] > k) {
          --j;
            if (i == j) {
              break;
             }
           }
          /*
           * Check if sum of two digit is equal to k or not.
           * if it is equal to the value of k then print those digits.
           */
            if (array[i] + array[j] == k) {
              System.out.println(""The sum of these two digit "" + array[i] + "","" + array[j] + ""will be equal to k"");
              break;
           }
           j--;
        }
     }
   }
   public static void main(String[] args) {
     Scanner scan = new Scanner(System.in);
     System.out.println(""Please enter length of the array : "");
     int l = scan.nextInt();
     System.out.println(""Please enter value the sum you want to be : "");
     int k = scan.nextInt();
     int array[] = new int[l];
     for (int n = 0; n < l - 1; n++) {
       array[n] = scan.nextInt();
     }
     two_pointer obj = new two_pointer(array, k);
   }
 }
  /*
   * Time complexity is O(n)
   * Space complexity is O(n)
   *
   * Input :
   * Please enter length of the array :
   * 10
   * Please enter value the sum you want to be :
   * 10
   * enter array
   * 2 3 4 4 5 6 7 8 9 1
   *
   * OUTPUT :
   * The sum of these two digit 4,6 will be equal to 10
   * */",Java
"import java.util.*;
 public class CheckForSubSequence
 {
     public boolean CheckForSubSequenceFunc(String st1, String st2){
 	    char[] ch1 = st1.toCharArray();
 	    char[] ch2 = st2.toCharArray();
 	    int count2=0, count1=0;
 	    for(count2=0; count2<ch2.length && count1<ch1.length; count2++){
 	        if(Character.compare(ch1[count1], ch2[count2]) == 0) count1++;
 	    }
 	    return (count1 == ch1.length);
     }
 	public static void main(String[] args) {
 	    Scanner sc = new Scanner(System.in);
 	    System.out.print(""Enter first string: "");
 	    String st1 = sc.next();
 	    System.out.print(""Enter second string: "");
 	    String st2 = sc.next();
 	    CheckForSubSequence cfs = new CheckForSubSequence();
 	    if(cfs.CheckForSubSequenceFunc(st1, st2)) System.out.print(st1+"" is a subsequence of ""+st2);
 	    else System.out.print(st1+"" is a not subsequence of ""+st2);
 	}
 }
 
 /*Sample input and output
 
 # 1
 Enter first string: pogy
 Enter second string: appology
 pogy is a subsequence of appology
 
 # 2
 Enter first string: race
 Enter second string: horse
 race is a not subsequence of horse
 
 Complexities
 time: O(n)
 space: O(n)*/",Java
"""""""
 Purpose: From a list of integers, check and return a set of
         integers whose sum will be equal to the target value K.
 Problem Link:- https://en.wikipedia.org/wiki/Subset_sum_problem
 
 Method: Backtracking
 Time Complexity:  O(2^n)
 Space Complexity: O(n)
 
 Argument: List, Target
 Return:   List
 """"""
 
 
 # Main Recursive function to find the desired Subset Sum
 def Subset_Sum(li, target, ans=[]):
 
     # Base Cases
     if target == 0 and ans != []:
         return ans
 
     elif li == []:
         return False
 
     # li[0] is not included in the answer Subset
     temp = Subset_Sum(li[1:], target, ans)
     if temp:
         return temp
 
     # li[0] included in the answer Subset
     temp = Subset_Sum(li[1:], target - li[0], ans + [li[0]])
 
     return temp
 
 # --------------------------- DRIVER CODE------------------------------
 
 
 if __name__ == ""__main__"":
 
     li = [int(i) for i in input(""Enter the List of Integers: "").split()]
     Target = int(input(""Enter the Target value: ""))
 
     ans = Subset_Sum(li, Target)
     if not ans:
         print(""No Subset Sum matched to the Target"")
     else:
         print(""The Required Subset is : "", *ans)
 
 """"""
 Sample Input / Output
 
 Enter the List of Integers: 7 9 -3 9 7 4 5 -4 -6 -2 -5
 Enter the Target value: -1
 The Required Subset is :  5 -6
 
 
 Enter the List of Integers: 1 2 3 4 5 6 7 8 9
 Enter the Target value: 19
 The Required Subset is :  5 6 8
 
 Enter the List of Integers: -1 2 6 7 -4 7 5 -2 
 Enter the Target value: 0
 The Required Subset is :  6 -4 -2
 """"""
",Python
"class circular_llist:
 
     
     # constructor function called during object creation
     def __init__(self,node):
         self.head = node
         self.tail = self.head
         self.size = 1
 
     # creates the list by values entered by user at the time of creation
     def create(self,node):
         
         self.tail.next = node
         self.tail = node
         node.next = self.head
         self.size = self.size+1
 
 
     # Insert node given as argument to the end of the list
     def append(self,node):
         '''Insert node given as argument to the end of the list'''
         self.tail.next = node
         self.tail = node
         node.next = self.head
         self.size = self.size+1
         print(""Value"",node.value,""adding at the END of list"")
         self.printAll()
         
 
     # Insert node given as argument to the start of the list
     def prepend(self,node):
         '''insert node given as argument to the start of the list'''
         node.next = self.head
         self.head = node
         self.tail.next = self.head
         self.size = self.size+1
         print(""Value"",node.value,""adding at the START of list"")
         self.printAll()
 
     # Prints the no of nodes or size of linked list
     def getSize(self):
         '''Prints the no of nodes or size of linked list'''
         print(""Total No of Nodes :"",end="" "")
         print(self.size)
 
 
     # Print all the nodes of list
     def printAll(self):
         '''Print all the nodes of list'''
         node = self.head
 
         print(""Your Current List: "")
 
         while node.next!=self.head:
 
             print(node.value,end='')
             print(""--->"",end='')
             node = node.next
 
         else:
             print(node.value)
 
 
     # Insert node at position passed in argument
     def insert(self,n,index):
         '''Insert node at position passed in argument
 
         usage : insert(Node,position)
 
         '''
         i = 0
         node = self.h",Python
"/*
 Problem statement:
 Given an integer array, we need to display a new array 
 such that array[index] is equal to the product of all the 
 elements of the array except array[index].
 */
 
 class Solution {
     public static int[] productExceptSelf(int[] nums) {
       
         //find the product of all elements of the matrix
         int product = 1; 
         for(int index=0;index<nums.length;index++){
             product = product*nums[index];
         }
         
         //case when product 0
         //if product=0, find the index that has 0 element
         int zeroindex=0;
         if(product==0){
             for(int index=0;index<nums.length;index++){
                 if(nums[index]==0){
                     zeroindex=index;
                 }
             }
         
             //find the new product excluding 0 element  
             int newproduct=1;
         
             for(int index=0;index<nums.length;index++){
                 if(index!=zeroindex){
                     newproduct = newproduct*nums[index];
                 }
             }
         
             for(int index=0;index<nums.length;index++){
                 if(index==zeroindex){
                     nums[index]=newproduct;
                 }else{
                     nums[index]=0;            
                     }
                 }
         
                 return nums;
             }
         
             //case when product not zero
             for(int i=0;i<nums.length;i++){
                 nums[i]=product/nums[i];
             }
         
             return nums;
         }
     
     //main method
     public static void main(String args[]){
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter length of array: "");
         int n = sc.nextInt();
         int nums[] = new int[n];
         System.out.println(""Enter the array elements: "");
         for(int index=0;index<n;index++){
             nums[index]=sc.nextInt();
         }
         
",Java
"/*
 Problem Description: For a given unsorted array, your task is to return 
 the length of longest sub-sequence such that elements in the subsequence 
 are consecutive integers.
 
 For example: For an array [3, 6, 10, 2, 4] the longest sequence of 
 consecutive elements is 2, 3, 4 so the length will be 3.
 */
 
 import java.io.*;
 import java.util.*;
 
 class Longest_Consecutive_Sequence {
     static int longestSeq(int[] arr){
 
         //Base case
         if(nums == null || nums.length == 0){
             return 0;
         }
         //Sort the given array
         Arrays.sort(nums);
 
         //Initializing count and maximum count 
         int count = 1, max = 1;
 
         //Traverse  the array
         for(int i=0 ; i<nums.length-1 ; i++){
 
             //Check for duplicate elements
             //Skip duplicates
             if(nums[i] == nums[i+1]){
                 continue;
             }
 
             //Check if previous elements is one less than the current element,
             //if true increase count by one
             else if(nums[i+1] - nums[i] == 1){
                 count++;
                 //update the maximum
                 max = Math.max(max, count);
             }
 
             else{
                 count = 1;
             }
         }
         //Return the maximum length
         return max;
     }
     
     //driver method
     public static void main(String[] args){
         Scanner sc = new Scanner(System.in);
         System.out.pritln(""Enter number of elements: "");
         int n = sc.nextInt();
         int[] arr = new int[n];
         System.out.println(""Enter elements: "");
         for(int i=0 ; i<n ; i++){
             arr[i] = sc.nextInt();
         }
         System.out.printn(""Length of longest consecutive sequence: "" + longestSeq(arr));
     }
 }
 
 /*
 Time Complexity: O(n)
 Space Complextiy: O(1)
 
 Sample Case: 
 Input-
 Enter number of elements:
 4
 Enter elements:
 1 2 0 1
 
 Output-
 Length of longest consecu",Java
"//C++ Program to print all subsets of a given distinct array of positive integers
 #include <bits/stdc++.h>
 using namespace std;
 
 void GetSubsets(vector<int> inputArray, vector<int> subsetArray, int pos)
 {
 	if (pos == inputArray.size())
 	{
 		//the input array has been traversed when pos = array size
 		cout << ""["";
 		for (int i = 0; i < subsetArray.size(); i++)
 		{
 			if (subsetArray[i] != 0)	//ignoring empty values
 				cout << subsetArray[i] << "","";
 		}
 
 		cout << ""]\n"";
 	}
 	else
 	{
 		GetSubsets(inputArray, subsetArray, pos + 1);	//Recursion tree branch 1
 
 		subsetArray[pos] = inputArray[pos];
 		GetSubsets(inputArray, subsetArray, pos + 1);	//Recursion tree branch 2
 	}
 }
 
 //DRIVER FUNCTION
 int main()
 {
 	int size;
 	cout << ""Enter size of the array: "";
 	cin >> size;
 	vector<int> inputArray(size);	//initializing input array with user-given size
 	for (int i = 0; i < size; i++)
 	{
 		cin >> inputArray[i];
 	}
 
 	vector<int> subsetArray(size);	//empty array for storing subsets
 	cout << ""["";
 	GetSubsets(inputArray, subsetArray, 0);	//prints the subsets
 	cout << ""]"";
 }
 
 /*Sample IO
 
 Input:
 3
 1 2 3
 Output:
 [
 [3],
 [1],
 [2],
 [1,2,3],
 [1,3],
 [2,3],
 [1,2],
 []
 ] 
 
 TIME COMPLEXITY - O(2^n)
 SPACE COMPLEXITY - O(n)
 
 /*",C-Plus-Plus
"def array_rotation(): 
     save = []
     rest_arr = []
     for i in arr:
         if i == Start_element or i < Start_element:
             save.append(i)
         else:
             rest_arr.append(i)
 
     rest_arr.extend(save)
     print('rest arry =', rest_arr)
 
 arr = list(input(""Enter the no. elements:\n"").split())
 Start_element = input(""Stating from which element:\n"")
 ending_element = input(""Enter the ending element:\n"")
 array_rotation()
 
 '''
 >>Time & Space Complexity is O(n) 
 
 INPUT
 
 >>Enter the no. elements:
   1 2 3 4 5 6 7
 >>Stating from which element:
   2  
 >>Enter the ending element:
   7
 
 OUTPUT 
 >>rest arry = ['3', '4', '5', '6', '7', '1', '2']
 
 
 '''",Python
"/*
 Next Smallest Element to the right using stacks in C++ 
 ALGORITHM:
 * Use stack to find out the next smallest element of each element in the array
 */
 #include <bits/stdc++.h>
 using namespace std;
 void nextSmallestToRight(int a[],int n)
 {
     stack<int> s;
     vector<int> v;
     for(int i=n-1;i>=0;i--)
     {
         if(s.empty())
         v.push_back(-1);
         else if(s.empty()!=true && s.top()<a[i])
         v.push_back(s.top());
         else if(s.empty()!=true && s.top()>a[i])
         {
             while(s.empty()!=true && s.top()>a[i])
             s.pop();
 
             if(s.empty())
             v.push_back(-1);
             else if(s.top()>a[i])
             v.push_back(s.top());
         }
         s.push(a[i]);
     }
     reverse(v.begin(),v.end());
 
     for(int i=0;i<n;i++)
     cout<<v[i]<<"" "";
 }
 int main()
 {
     int n;
     cin >> n;
     int a[n];
     for (int i = 0; i < n; i++)
         cin >> a[i];
     nextSmallestToRight(a, n);
 }
 /*
 Time Complexity:O(n^2)
 INPUT:
 5
 1 3 4 2 1
 OUTPUT:
 2 2 1 -1 -1
 */
",C-Plus-Plus
"package main
 
 import ""fmt""
 
 func Search(array []int, number int) int {
 	low := 0
 	high := len(array) - 1
 
 	for {
 		var key int
 		var size int
 		var first int
 		var last int
 		var value int
 
 		first = array[low]
 		last = array[high]
 
 		if high == low {
 			key = high
 		} else {
 			size = high - low
 			value = int((float64(size-1) * (float64(number-first) / float64(last-first))))
 			key = low + value
 		}
 		if array[key] == number {
 			return key
 		}
 		if array[key] > number {
 			high = key - 1
 		} else {
 			low = key + 1
 		}
 	}
 }
 
 // Input
 
 func main() {
 	items := []int{1, 16, 28, 37, 49, 52, 60, 75, 85, 99, 105}
 	fmt.Println(Search(items, 85))
 }
 
 // Output = 8
 
 // Time Complexity = O(n), Space Complexity = O(n)
",Go
"//Implementation of Kosaraju's Algorithm to find out the strongly connected components (SCCs) in a graph.
 
 #include<bits/stdc++.h>
 using namespace std;
 
 class Graph {
   list<int> *l;
   list<int> *rl;
   int V;
   vector<int> order;
   int vis[1000], comp[1000];
 
 public:
 
   Graph(int V) {
     this->V = V;
     l = new list<int>[V];
     rl = new list<int>[V];
 
   }
 
   void addEdge(int x, int y) {
     l[x].push_back(y);
     rl[y].push_back(x);
   }
 
   void dfs(int cur) {
     vis[cur] = 1;
     for (auto x : l[cur]) {
       if (!vis[x]) {
         dfs(x);
       }
     }
     order.push_back(cur);
   }
 
   void dfs_reverse(int cur, int col) {
     vis[cur] = 1;
     comp[cur] = col;
     for (auto x : rl[cur]) {
       if (!vis[x]) {
         dfs_reverse(x, col);
       }
     }
 
   }
 
   //for finding the strongly connected components
   void solve() {
     memset(vis, 0, V);
     for (int i = 0; i < V; i++) {
       if (!vis[i]) {
         dfs(i);
       }
     }
     for (int i = 0; i < V; i++) {
       vis[i] = 0;
     }
     int col = 1;
     for (int i = V - 1; i >= 0; i--) {
       if (!vis[order[i]]) {
         dfs_reverse(order[i], col);
         col++;
       }
 
     }
 
     for (int i = 0; i < V; i++) {
       cout << i + 1 << "": "" << comp[i] << endl;
     }
 
   }
 };
 
 int main() {
   int n, e;
   cout << ""Enter number of vertices and edges:"";
   cin >> n >> e;
   Graph g(n);
   cout << ""Enter edges:"";
   for (int i = 0; i < e; i++) {
     int x, y;
     cin >> x >> y;
     x--; y--;
     g.addEdge(x, y);
   }
   g.solve();
   return 0;
 }
 
 /*
 Sample input-output:
 
 Input:
 6 7
 1 2
 2 3
 3 1
 3 4
 4 5
 5 6
 6 4
 Output:
 1: 1
 2: 1
 3: 1
 4: 2
 5: 2
 6: 2
 
 Time Complexity: O(n+e)
 n: Number of vertices
 e: Number of edges
 Space Complexity: O(1)
 */
",C-Plus-Plus
"/*
 For a string S. The task is to print all possible permutations of a given string.
 A permutation, also called an order, is a rearrangement of the elements of a string 
 into a one-to-one correspondence with S itself. A string of length n has a maximum of n! permutations possible. 
 */
 
 import 'dart:io';
 
 // List to store all permutations possible
 List allPermutations = [];
 
 // Function to backtrack and find all possible combinations of a input string
 void permute(List word, int current_letter) {
   // when the cursor gets this far, we've found one permutation, so save it
   if (current_letter == word.length) {
     allPermutations.add(word);
     return;
   }
 
   for (int count = current_letter; count < word.length; count++) {
     List permutation = new List.from(word);
     permutation[current_letter] = word[count];
     permutation[count] = word[current_letter];
     permute(permutation, current_letter + 1);
   }
 }
 
 // Function to call recursive function and return the list of permutations
 List<String> getPermutations(String input_string) {
   // Pass input string to recursive function
   permute(input_string.split(''), 0);
 
   //Join individual letters from all permutations and return as list
   List<String> permutations = [];
   for (List permutation in allPermutations) {
     permutations.add(permutation.join());
   }
   return permutations;
 }
 
 // Main function with driver code
 void main() {
   // Get user input
   print(""Enter String:"");
   String str = stdin.readLineSync()!;
 
   // pass arguments into function
   List<String> permutations = getPermutations(str);
   print(""All possible permutations for $str are: "");
 
   Set<String> set = new Set<String>.from(permutations);
   for (var permutation in set) {
     print(permutation);
   }
 }
 
 /*
 Time Complexity:  O(n^2 * n!)
 Space Complexity: O(1)
  
 Sample I/O:
 
 Enter String:
 fun
 All possible permutations for fun are:
 fun
 fnu
 ufn
 unf
 nuf
 nfu
 */
 
",Dart
"/*
 Given n , array of size n (arr[n]) and target, your task is to print
 all unique quadruplets [arr[a],arr[b],arr[c],arr[d]] ,such that:
 arr[a]+arr[b]+arr[c]+arr[d]=target and a,b,c,d are distinct
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 vector<vector<int>> fourSum(vector<int> &nums, int target)
 {
 
     vector<vector<int>> ans;
     if (nums.size() < 4)
         return ans;
     set<vector<int>> s;
     int n = nums.size();
     sort(nums.begin(), nums.end());
     for (int i = 0; i < n; i++)
     {
         for (int j = i + 1; j < n; j++)
         {
             int newt = target - nums[i] - nums[j];
             int l = j + 1, h = n - 1;
             while (l < h)
             {
                 if (nums[l] + nums[h] == newt)
                 {
                     s.insert({nums[i], nums[j], nums[l], nums[h]});
                     l++;
                     h--;
                 }
                 else if (nums[l] + nums[h] < newt)
                     l++;
                 else
                     h--;
             }
         }
     }
     for (auto x : s)
     {
         ans.push_back(x);
     }
     return ans;
 }
 int main()
 {
     int n;
     cout << ""Enter number of elements:"";
     cin >> n;
     cout << ""Enter elements:"";
     vector<int> arr;
     for (int i = 0; i < n; i++)
     {
         int a;
         cin >> a;
         arr.push_back(a);
     }
     int target;
     cout << ""Enter target:"";
     cin >> target;
     cout << ""Unique quadruplets are:\n"";
     vector<vector<int>> ans = fourSum(arr, target);
     for (int i = 0; i < ans.size(); i++)
     {
         cout << ""["";
         for (int j = 0; j < ans[i].size(); j++)
         {
             cout << ans[i][j] << "" "";
         }
         cout << ""]\n"";
     }
 }
 
 /*
 Sample Input:
 Enter number of elements:6
 Enter elements:1 0 -1 0 -2 2
 Enter target:0
 
 Sample Output:
 Unique quadruplets are:
 [-2 -1 1 2 ]
 [-2 0 0 2 ]
 [-1 0 0 1 ]
 
 
 Time-Complexity:O(n^3)
 Space-Com",C-Plus-Plus
"/*
 AIM ::TO IMPLEMENT ASCENDING PRIORITY QUEUE
 
 WHAT IS ASCENDING PRIORITY QUEUE ?
 
 In ascending order priority queue, a lower priority number is given as a higher priority.
 For example, 1 to 5 arranged in an ascending order like,
 then, the smallest number, i.e., 1 is given as the highest priority in a Ascending priority queue.
 
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 #define size 5
 
 //Front for insertion an Rear for deletion
 int Front = -1;
 int Rear = -1;
 int Queue[size];
 
 //for checking whether Priority Queue is full or not
 int q_full()
 {
     if (Rear == size - 1)
         return 1;
 
     return 0;
 }
 
 //for checking whether Priority Queue is empty or not
 int q_empty()
 {
     if (Front == -1 || Front > Rear)
         return 1;
 
     return 0;
 }
 
 //to display the data in Priority Queue
 void display()
 {
     if (q_empty())
         printf(""\nqueue is empty\n"");
     else
     {
         printf(""\n"");
         for (int i = Front; i <= Rear; i++)
             printf(""%d  "", Queue[i]);
         printf(""\n"");
     }
 }
 
 //for performing insertion
 void enq()
 {
     if (q_full())
         printf(""\nQUEUE OVERFLOW"");
     else
     {
         int element, i;
         printf(""\nenter the element: "");
         scanf(""%d"", &element);
 
         //if inserting for firs time then do increment front also
         if (Front == -1)
             Front++;
 
         //find appropriate place for the element and insert
         for (i = Rear; i >= 0 && element < Queue[i]; i--)
             Queue[i + 1] = Queue[i];
         Queue[i + 1] = element;
         Rear++;
 
         display();
     }
 }
 
 //for performing deletion
 void deq()
 {
     if (q_empty())
         printf(""\nQUEUE UNDERFLOW\n"");
     else
     {
         int element = Queue[Front];
 
         //if front and rear is equal means there was only one element left
         if (Front == Rear)
             Front = Rear = -1;
         else
             Front++;
 
         display();
  ",C
"#include<bits/stdc++.h>
 using namespace std;
 
 /* 
 Normal power algorithm would take O(power) time to calculate the answer.
 But here we use the fact that every number can be represented in power of 2!
 Consider 3^25
 
 Normal calculation = (3*3*... 14 Times)
 Modular exponentiation = (3^8)*(3^4)*(3^2)*(3^1)
 
 We use this power of 2s to our advantage.
 (3^2)=(3^1)^2
 (3^4)=(3^2)^2 
 (3^8)=(3^4)^2 
 So, this reduces the number of multiplication, as we only need to sqaure the number (squaring is just single multiplication operation).
 */
 
 long long modular_exponentiation(long long base,long long power,long long mod)
 {
     base=base%mod;
     long long answer=1;
     while(power>0)
     {
         if(power%2==1)
         { 
             answer=(answer*base)%mod;
         }
         base=(base*base)%mod;
         power=power/2;
     }
     return answer;
 }
 
 int main()
 {
     long long base,power,mod;
     cout<<""Enter base: "";
     cin>>base;
     cout<<""Enter power: "";
     cin>>power;
     cout<<""Enter mod: "";
     cin>>mod;
     cout<<""(power^base)%mod = ""<<modular_exponentiation(base,power,mod)<<""\n"";
 }
 
 /*
 Sample I/0
 
 1. 
     INPUT
     Enter base: 2
     Enter power: 10 
     Enter mod: 8000 
     OUTPUT
     (power^base)%mod = 1024
 
 2.
     INPUT
     Enter base: 3
     Enter power: 6
     Enter mod: 1 
     OUTPUT
     (power^base)%mod = 0
 */
 
 /*
 Time Complexity: O(log(power))
 Space Complexity: O(1)
 */
 
",C-Plus-Plus
"/*
     Steps to be followed:
  	1.we will create an empty hash table and initialize all of its value as -1 which represent empty cells.
  	2.Then we will iterate over the input array and compute the hash value of all the keys to be inserted,
  	 put it in appropriate cells if that cell is already filled we will add square of a constant value to find
  	 an empty cell if we found one we will put the key in the cell otherwise we will increment the constant value
  	 and then put the key.
  	3.We have taken hash function as arr[i]%hashSize
 */
 import java.util.Scanner;
 public class quadraticProbing {
 	
 static void quadraticProbing(int[] hashTable, int hashSize, int arr[], int arraySize){
 	
     for(int i=0;i<hashSize;i++) {
     	hashTable[i] = -1;
     }
     
     for(int i=0;i<arraySize;i++){
         if(hashTable[arr[i]%hashSize]==-1){
             hashTable[arr[i]%hashSize]=arr[i];
         }
         else{
             int k=arr[i]%hashSize;
             int power=1;
             while( hashTable[(k+power*power)%hashSize] != -1){
                  power++;
             }
             hashTable[(k+power*power)%hashSize]=arr[i];
         }
     }
 }   
 
 public static void main(String[] args) {
 	
 	Scanner sc = new Scanner(System.in);
 	System.out.println(""Enter hash size :"");	
 	int hashSize = sc.nextInt();
 	
 	System.out.println(""Enter array size :"");	
 	int arraySize = sc.nextInt();
 	
 	int array[]=new int[arraySize];
 	
 	System.out.println(""Enter elements of array :"");
 	for(int i=0;i<arraySize;i++) {
 	    array[i]=sc.nextInt();
 	}	
 	
 	int hashTable[] = new int[hashSize];
 	quadraticProbing(hashTable,hashSize,array,arraySize);	
 	
 	for(int i=0;i<hashSize;i++) {
 	    System.out.print(hashTable[i]+"" "");
 	}		
     }
 }
 /*
 Sample input :
 Enter hash size :
 11
 Enter array size :
 4
 Enter elements of array :
 21 10 32 43
 
 Sample output :
 10 -1 -1 32 -1 -1 -1 -1 43 -1 21 
 */
 //Time complexity - O(n)
 //Space complexity - O(1)
",Java
"// Euler's Totient Function represented by F(n)
 // denotes the no. of coprime of n from 1 to n
 #include <bits/stdc++.h>
 using namespace std;
 int F(int n){
     int arr[n + 1], i, j;
     arr[0] = 0, arr[1] = 1;     // as 1 is coprime with itself
     for(i = 2; i <= n; i ++){
      arr[i] = i;    // initialising arr[i] with i
      }  
     for(i = 2; i <= n; i ++){
         if(arr[i] == i){
             for(j = i; j <= n; j += i){
                 arr[j] -= (arr[j] / i); // just like sieve of eratosthenes we are decreasing values of multiple of primes
             }  
         }
     }
     return arr[n];  //  here each arr[i] is giving number of coprimes of i from 1 to i
 }
 
 int main(){
     int n;
     cout<<""Enter a integer: "" ;
     cin>>n;   // taking input as integer n
     cout<<F(n); // printing Euler's Totient Function for int n
 return 0;
 }
 // time complexity O(nloglogn) same as sieve of eratosthenes
 /*
 Sample Input: 4
 Sample Output: 2
 Explanation: As 4 is coprime with 1 and 2 only so its Euler's Totient function value is 2;
 
 Sample Input: 5
 Sample Output: 4
 Explanation: As 5 is a prime no. so it is coprime with all 1, 2, 3 & 4.
              So, its Euler's Totient Function value is 4;
 
 */
",C-Plus-Plus
"//This  algorithm is used to select i_th order statistic from the given data in O(n) time complexity and O(1) space complexity
 #include <stdio.h>
 #include <stdlib.h>
 int arr[100000];
 
 int part(int arr[], int lower, int upper) 
 {
     int z = arr[upper];
     int i = lower - 1;
     for (int j = lower; j <= upper - 1; j++)
     {
         if (arr[j] <= z)
         {
             ++i;
             int change = arr[i]; // Now we are swapping arr[i] and arr[j]
             arr[i] = arr[j];
             arr[j] = change;
         }
     }
     int change2 = arr[i + 1]; // now we are swapping arr[i+1] and arr[upper]
     arr[i + 1] = arr[upper];
     arr[upper] = change2;
     return i + 1;
 }
 int random_type(int minimum, int maximum) 
 {                    //this function is used to generate a random number in the given range
     int type = maximum - minimum + 1;
     int number = minimum + (rand() % type);
     return number;
 }
 
 int Randomized_type(int arr[], int lower, int upper) 
 {
     int i = random_type(lower, upper);
     int change = arr[upper];
     arr[upper] = arr[i];
     arr[i] = change;
     return part(arr, lower, upper);
 }
 
 int Randomized_select_algo(int arr[], int lower, int upper, int i) 
 {
     if (lower == upper)  //if the array has only one element
         return arr[lower];
     
     int x= Randomized_type(arr, lower, upper);
     int y= x+1-lower ;
 
     if (i == y)     // The value obtained is the answer
         return arr[x];
     else if (i > y) // the  value required lies on the upper side 
          return Randomized_select_algo(arr, x + 1, upper, i - y);
     else            // the  value required lies on the lower side 
         return Randomized_select_algo(arr, lower, x- 1, i);
 }
 
 int main()
 {
     int n, i;
     printf(""Enter number of elements: \n"");
     scanf(""%d"",&n);
     
     for (int i = 0; i < n; i++)
          scanf(""%d"",&arr[i]);
 
     printf(""Enter i: \n"");
     scanf(""%d"",&i);
     printf(""%d"",Randomiz",C
"/**
 Cycle detection in a directed graph
 using DFS. Here, status array shows if the node is in the path that we are currently on. This is used to detect any presence of back edges.
 backedge present <=> cycle present
 **/
 
 import java.io.*;
 import java.util.*;
 
 public class DirectedCycleDetection {
 	private static boolean cycle;
 	private static void dfs_visit(ArrayList<ArrayList<Integer> > graph, int src, boolean[] status, boolean[] visit) {
 		visit[src] = true;
 		status[src] = true;
 		for(int i = 0; i < graph.get(src).size(); i++)
 			if(visit[graph.get(src).get(i)] == false)
 			    dfs_visit(graph, graph.get(src).get(i), status, visit);
 			else
 			    if(status[graph.get(src).get(i)] == true)
 				    cycle = true;
 	    status[src] = false;
 	}
 
 	private static void dfs(ArrayList<ArrayList<Integer> > graph, int vertex, boolean[] status) {
 		boolean[] visit = new boolean[v];
 		for(int i = 0; i < vertex; i++)
 			if(visit[i] == false)
 				dfs_visit(graph, i, status, visit);
 	}
 
 	private static void detect_cycle(ArrayList<ArrayList<Integer> > graph, int vertex) {
 		boolean[] status = new boolean[vertex];
 		dfs(graph, vertex, status);
 		if(cycle == false)
 		    System.out.println(""No cycle exits in the given graph"");
 	    else
 		    System.out.println(""Cycle exists in the given graph"");
 	}
 
 	public static void main(String[] args) {
 		cycle = false;
 		// vertex denotes number of vertices
 		// edge denotes number of edges
 		// a, b are temporary variables to take input
 		int vertex, edge, a, b;
 		// all vertices are labelled from 0 to v-1
 		Scanner sc= new Scanner(System.in);
 		vertex = sc.nextInt();
 		edge = sc.nextInt();
 		ArrayList<ArrayList<Integer> > graph = new ArrayList<ArrayList<Integer> >(vertex);
 		for (int i = 0; i < vertex; i++)
             graph.add(new ArrayList<Integer>());
 		// all directed edges
 		for(int i = 0; i < edge; i++) {
 			a = sc.nextInt();
 			b = sc.nextInt();
 			// edge a -> b
 			graph.get(a).",Java
"/* Reverse a number using stack */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function for Reversing a number using stack */
 int solve()
 {
     int no;
     cin >> no;
 
     /* Craete an empty stack */     
     stack<int> s;
 
     /* Push number into the stack */
     while (no != 0)  
     { 
         s.push(no % 10); 
         no = no / 10; 
     }
 
     int reverse = 0;
     int r = 1;
 
     /* Pop the number and form reverse number*/
     while (s.empty() == 0) 
     {
         reverse = reverse + (s.top() * r);
         s.pop();
         r = r * 10;
     }
 
     /* Return the reverse number*/
     return reverse;
 }
 
 int main()
 {
     int k = solve();
 
     cout << ""Reverse Number is : "" << k << endl;
     return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
         
         365
 
     Output 1 :
 
         Reverse Number is : 563   
 
     Input 2 :
 
         6899
     
     Output 2 :
     
         Reverse Number is : 9986
     
     Time complexity: O(logn)
     Space Complexity: O(1)
 */
",C-Plus-Plus
"#Sine Algorithm
 #Written by XZANATOL
 
 """"""
 Algorithm that explains how to calculate the Sine of an angle
 """"""
 
 import math
 pi = 3.141592653589793238462643383279502884197169399375105 #Constant
 
 def conv_to_rad(angle):
     """"""Converts degree angles to radians""""""
     return angle/180 * pi
 
 
 def factorial(n):
     """"""Factorial function. This will be used in the power series""""""
     if n==1:
         return 1
     return n * factorial(n-1)
 
 
 def conv_if_neg(x):
     """"""returns abs of an angle if it's negative""""""
     #sin(-x) = -sin(x)
     if x<0:
         return abs(x), True
     return x,False
 
 
 def reduce_angle(angle):
     """"""Reduces the angle if it is bigger than pi/2""""""
     """"""
     sin(pi - X) = sin(x)
     We do know that every quadrant has the same range of sines results which is from [0-1] \
     but every quadrant has it's own sign according to the ASTC rule.
     So by reducing the angle to it's equivalent in the first quadrant \
     we will get the same result, all what's left is to determine in which quadrant the angle \
     lies. This can be determined using a counter where if it is divisble by 2 then it is in \
     second/fourth quadrant, and it increases with every reduction loop.
     """"""
     count = 1 #used to determine the angles quadrant
     while(angle>=pi/2):
         angle -= pi
         count += 1
     return angle, count
 
 
 def sin(x):
     res = x - x**3/factorial(3) + x**5/factorial(5) - x**7/factorial(7) + \
           x**9/factorial(9) - x**11/factorial(11)
 
     return res
 
 
 #Start checkpoint
 if __name__ == ""__main__"":
     #Get inputs
     angle = float(input(""Enter angle > ""))
     mode  = input(""Enter angle mode [deg\\rad] > "")
 
     #convert to rad if the input is deg
     if mode == ""deg"":
         angle = conv_to_rad(angle)
 
     angle, neg_flag = conv_if_neg(angle) #check if negative
     angle, count = reduce_angle(angle) #reduces the angle value if it's bigger than pi/2
     res = sin(angle) #calc",Python
"""""""Python program to implement Minimum XOR value.
 Given an array of integers, we have to find the minimum XOR value, a pair in the array makes.""""""
 
 import sys
 
 def minimumXOR(arr, n):
     # Sort the array, so that elements with minimum bit difference are present consecutive.
     arr.sort()
     minXOR = sys.maxsize
     val = 0
 
     # Compute the XOR values of the consecutive elements of the array.
     for i in range(0, n-1):
         val = arr[i] ^ arr[i+1]
         minXOR = min(minXOR, val)
 
     return minXOR
 
 
 if __name__ == '__main__':
     print(""How many numbers are present in the array? "", end="""")
     n = int(input())
     if (n <= 0):
         print(""No numbers are present in the array!!!"")
         exit()
     print(""Enter the numbers: "", end="""")
     arr = [int(x) for x in input().split(' ')]
     res = minimumXOR(arr, n)
     print(""The minimum XOR value present in the given array is {}"".format(res))
 
 
 """"""
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 How many numbers are present in the array? 8
 Enter the numbers: 25 45 36 458 651 89 52 95 
 The minimum XOR value present in the given array is 9
 
 SAMPLE II
 
 How many numbers are present in the array? 5
 Enter the numbers: 5 4 3 2 1
 The minimum XOR value present in the given array is 1
 
 """"""
",Python
"/* 
    Program to print the boundary traversal of a Binary Search Tree.
    The given approach uses iterative method to print the boundary nodes of 
    the given Binary Search Tree.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 struct Node
 {
     int data;
     struct Node * left;
     struct Node * right;
 };
 Node* root = NULL;
 
 // Utility function to create a new Tree Node
 Node* newNode(int val)
 {
     Node *temp = new Node;
     temp->data = val;
     temp->left = NULL;
     temp->right = NULL;
 
     return temp;
 }
 
 // Function to insert item in a BST
 void insertItem(int item)
 {
     Node *newnode = newNode(item);
     if(!root) {
         root = newnode;
         return;
     }
     Node *cur, *prev;
     cur = root;
     while(cur!= NULL) {
         prev = cur;
         if(cur->data > item)
             cur = cur->left;
         else
             cur = cur->right;
     }
     if(prev->data > item)
         prev->left = newnode;
     else
         prev->right = newnode;
 }
 
 // Function to add leaf nodes of the Binary Search Tree
 void addLeafNodes(Node* root, vector<int>& boundary) {
         if (root->left == NULL && root->right == NULL) {
             boundary.push_back(root->data);
             return;
         }
         if(root->left) addLeafNodes(root->left, boundary);
         if(root->right) addLeafNodes(root->right, boundary);
     }
 
 // Function to print to boundary of a BST
 vector<int> boundaryTraversal() {
     if(root == NULL)
         return {};
 
     vector<int> boundary;
 
     if(root->left != NULL && root->right != NULL)
         boundary.push_back(root->data);
 
     Node *curr = root->left;
     while(curr != NULL) {
         if(curr->left != NULL && curr->right != NULL)
             boundary.push_back(curr->data);
         if(curr->left)
             curr = curr->left;
         else
             curr = curr->right;
     }
 
     addLeafNodes(root, boundary);
 
     curr = root->right;
 
     vector<int> rightBo",C-Plus-Plus
"/*
 Given a sorted array of N elements and a value, find the first and last index position of the value number.
 We can do this with the help of Binary Search.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int f_indx(int ar[], int N , int value)
 {
     int low = 0;
     int high = N;
     while (low < high)
     {
         int mid =  low + (high - low) / 2;
         /* here if the mid contains value greater than or equal to our targeted value
         we set that position as high */
         if (value <= ar[mid])
         {
             high = mid;
         }
         else
         {
             low = mid + 1;
         }
     }
     return low;
 }
 
 int l_indx(int ar[], int N , int value)
 {
     int low = 0;
     int high = N;
     while (low < high)
     {
         int mid =  low + (high - low) / 2;
          /* here if the mid contains value greater than or equal to our targeted value
         we set that position as low */
         if (value >= ar[mid])
         {
             low = mid + 1;
         }
         else
         {
             high = mid;
         }
     }
     return low - 1;
 }
 
 int main()
 {
     cout << ""Enter the size of the array : \n"";
     int N;
     cin >> N;
     cout << ""Enter the target value\n"";
     int value;
     cin >> value;
     int ar[N + 1];
     cout << ""Enter array elements :\n"";
     for(int i = 0; i < N; i++)
     {
         cin >> ar[i];
     }
     int first_index = f_indx(ar, N , value);
     int last_index = l_indx(ar, N , value);
     cout << ""First index position is : "";
     cout << first_index << endl;
     cout << ""Last index position is : "";
     cout << last_index << endl;
 }
 
 /*
 Standard Input and Output
 
 Enter the size of the array :
 10
 Enter the target value
 12
 Enter array elements :
 1 2 4 6 8 10 12 12 12 12
 First index position is : 6
 Last index position is : 9
 
 Time Complexity : O(logN)
 Space Complexity : O(1)
 
 */
",C-Plus-Plus
"/*
 WORST FIT MEMORY ALLOCATION
 Available memory blocks are accepted as input from the user
 Allocates largest block available in storage list
 This aims to reduce the production of small blocks, 
 which is common in best fit strategy
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 //structure to represent memoryblock with id and size
 typedef struct MemoryBlock
 {
     int id;
     int size;
 } MemoryBlock;
 
 //to print the id of allocated memory block
 void print_block(MemoryBlock block)
 {
     if (block.id != -1 && block.size != -1 && block.size != 0)
         printf(""Block #%d \n"", block.id);
     else
         printf(""Invalid Memory Block\n"");
 }
 
 //linked list to store memory blocks
 typedef struct MemoryManager
 {
     MemoryBlock b;
     struct MemoryManager *llink, *rlink;
 } MemoryManager;
 
 //worst fit memory allocation
 MemoryBlock worst_fit(MemoryManager *m, int memory)
 {
     MemoryBlock bl;
     //if the list is empty
     if (m == NULL)
     {
         bl.id = -1;
         bl.size = -1;
     }
     else
     {
         MemoryManager *ptr = m, *ptr1, *ptr2, *p;
         MemoryBlock worst;
         worst.id = -1;
         worst.size = -1;
         //to find the largest memory block
         while (ptr != NULL)
         {
             if (ptr->b.size >= memory && ptr->b.size > worst.size)
             {
                 worst.id = ptr->b.id;
                 worst.size = ptr->b.size;
             }
             ptr = ptr->rlink;
         }
         worst.size = memory;
         bl = worst;
         ptr = m;
         //to remove the memory allocated from the block
         while (ptr->rlink != NULL)
         {
             if (ptr->b.id == worst.id)
             {
                 ptr->b.size -= memory;
                 break;
             }
             ptr = ptr->rlink;
         }
     }
     return bl;
 }
 
 //to add available memory blocks to linked list
 void deallocate(MemoryManager *m, MemoryBlock memory)
 {
     MemoryManager *ptr = m;
 ",C
"
 //Given two sorted arrays nums1 and nums2 of size m and n 
 //respectively, return the median of the two sorted arrays.
 
 import java.io.*;
 import java.util.*;
 
 class Median_of_2_sorted_array {
     static double findMedianSortedArrays(int[] arr1, int[] arr2) {
     // length of the merged array
     int arr3length = arr1.length + arr2.length;
         int arr3[] = new int[arr3length];
         int j=0;
         //storing the elements of both arrays into nums3
         for(int i =0;i<arr1.length;i++)
         {
             arr3[j++] = arr1[i];
         }
         for(int i =0;i<arr2.length;i++)
         {
             arr3[j++] = arr2[i];
         }
         //sorting nums3 array
         Arrays.sort(arr3);
     double mid;
     //checking if length of merged array is odd
     
     if(arr3length % 2 != 0) {
         //return the median
         mid = arr3[arr3length / 2>>0];
         return mid;
     } 
     //if the length is odd
     else {
         //median is the average of two mid elements
         double first = arr3[arr3.length / 2>>0];
         double second = arr3[(arr3.length / 2 >> 0 )-1];
         mid =  first + second;
         return( mid ) / 2;
     }
 
     }
 
     public static void main(String args[]) 
     {
         Scanner sc = new Scanner(System.in);
         int n = sc.nextInt();
         int m = sc.nextInt();
         int arr1[] = new int[n];
         int arr2[] = new int[m];
         for(int i = 0;i < n; i++)
           arr1[i] = sc.nextInt();
 
         for(int i = 0;i < m; i++)
             arr2[i] = sc.nextInt();
 
         System.out.println(findMedianSortedArrays(arr1,arr2));
         
     }
 }
 
 
 /*
 Time complexity: O(n)
 Space complexity: O(n)
 
 Example 1:
 
 Input:
 2 1
 1 3
 2
 
 Output:
 2.00000
 
 Example 2:
 
 Input:
 5 3
 1 5 7 8 9
 2 4 4
 
 Output:
 4.50000
 
 */
 
 
",Java
"class Stack {
   //Initializing stack with an empty array
   constructor() {
     this.arr = [];
     var top = 0;
   }
   //push_back is used to push the elements in the stack
   push_back(num) {
     arr[top] = num;
     top++;
   }
   //peek is used to return the element which is on the top of stack
   peek() {
     return arr[top];
   }
 
   //pop returns the element which is at the top and also removes it from the stack
   pop() {
     if (this.isEmpty()) {
       console.log(""UnderFlow"");
       return 0;
     } else {
       var temp = arr[top];
       top--;
       console.log(""One element has been removed from the stack"");
       return temp;
     }
   }
   //isEmpty is used to check whether the stack is empty or not
   isEmpty() {
     if (top == 0) {
       return true;
     } else {
       return false;
     }
   }
   // print is used to print all the elements of the stack
   print() {
     var output = """";
     for (var i = 0; i < top; i++) {
       output += arr[i] + "" "";
     }
     return output;
   }
   //size is used to return the size of the stack
   count() {
     return top;
   }
 }
 //Implementation
 
 //Taking input from the user that how many values he/she wants to push into the stack
 var input = prompt(
   ""Enter the number of values you want to push into the stack""
 );
 
 var another_arr = []; //Declaring the array
 
 input = parseInt(input);
 
 for (var i = 0; i < input; i++) {
   //Taking array values as an input from the user
   another_arr[i] = prompt(""Enter Element "" + (i + 1));
 }
 
 /*I will be taking the value of input be 3 and array values as 56,75,24 for explanation. */
 var input = 3;
 
 const another_arr = [56, 75, 24];
 
 //Making an object of the stack class
 var mystack = new Stack();
 
 //Checking whether the stack is empty or not by isEmpty()
 if (mystack.isEmpty() == true) {
   console.log(""The stack is empty right now"");
 } else {
   console.log(""The stack has elements in it"");
 }
 
 //We can check it by count() also but",JavaScript
"//Given N activities with their start and finish times. Select the maximum number of activities that can be performed by a single person, assuming that a person can only work on a single activity at a time.
 //
 //        Note : The start time and end time of two activities may coincide.
 //
 //        Input:
 //        The first line contains T denoting the number of testcases. Then follows description of testcases. First line is N number of activities then second line contains N numbers which are starting time of activies.Third line contains N finishing time of activities.
 //
 //        Output:
 //        For each test case, output a single number denoting maximum activites which can be performed in new line.
 //
 //        Constraints:
 //        1<=T<=50
 //        1<=N<=1000
 //        1<=A[i]<=100
 //
 //        Example:
 //        Input:
 //        2
 //        6
 //        1 3 2 5 8 5
 //        2 4 6 7 9 9
 //        4
 //        1 3 2 5
 //        2 4 3 6
 //
 //        Output:
 //        4
 //        4
 //
 //        Explanation:
 //        Test Case 1: The following activities can be performed (in the same order):
 //        (1, 2)
 //        (3, 4)
 //        (5, 7)
 //        (8, 9)
 
 
 
 import java.util. * ;
 import java.lang. * ;
 import java.io. * ;
 
 class Main {
   public static void main(String[] args) {
     //code
 
     Scanner s = new Scanner(System. in );
     int t = s.nextInt();
     while (t-->0) {
       int n = s.nextInt();
       int[] start = new int[n];
       int[] finish = new int[n];
 
       for (int i = 0; i < n; i++) {
         start[i] = s.nextInt();
 
       }
       for (int i = 0; i < n; i++) {
         finish[i] = s.nextInt();
 
       }
       for (int i = 0; i < n - 1; i++) {
         for (int j = 0; j < n - 1; j++) {
           if (finish[j] > finish[j + 1]) {
             int temp = finish[j];
             finish[j] = finish[j + 1];
             finish[j + 1] = temp;
 
             int te = start[j];
             s",Java
"/*Relative Sort Array (Sorting an array according to the other) 
 
 Given two integer arrays A1[ ] and A2[ ] of size N and M respectively. Sort the first array A1[ ] such that all the relative 
 positions of the elements in the first array are the same as the elements in the second array A2[ ].
 Note: If elements are repeated in the second array, consider their first occurance only.
 */
 
 
 //Initial template for C++
 #include <bits/stdc++.h> 
 using namespace std;
 
 class Solution{
     public:
     //Function to sort an array according to the other array.
     vector<int> sortA1ByA2(vector<int> A1, int N, vector<int> A2, int M) 
     {
         map<int,int>mp;
         //storing all the elements of first array in map.
         for(int i=0;i<N;i++)
         {
             mp[A1[i]]++;
         }
         int j=0;
         for(int i=0;i<M;i++)
         {
             //if any element of second array has value more than 0 in map, we
             //store those elements in array and decrement the count in map.
             while(mp[A2[i]]>0)
             {
                 A1[j++]=A2[i];
                 mp[A2[i]]--;
             }
         } 
         //iterating over the map which helps in storing
         //elements in increasing order.
         for(auto it:mp)
         {
             //we store the elements if their frequency is more than 0.
             if(it.second>0)
             {
                 //storing elements as many times as their count in output array.
                 while(it.second>0)
                 {
                     A1[j++]=it.first;
                     it.second--;
                 }
             }
         }
         //returning the output.
         return A1;
     } 
 };
 int main() 
 { 
 	    int n, m;
 	    cout<<""Enter size of both array: \n"";
 	    cin >> n >> m;                
 	    vector<int> a1(n);
 	    vector<int> a2(m);
 	    cout<<""Enter elements of array A1: \n"";
 	    for(int i = 0;i<n;i++){
 	        cin >> a1[i];      ",C-Plus-Plus
"import java.util.*;
 
 class MinimumSwapsForNIntegers {
 
     private static int minSwaps(int[] arr) {
         int countSwaps = 0;
 
         for(int i=0; i<arr.length; i++) {
 
             //swapping elements if not in their right positions
             if (arr[i] != i+1) {
                 while (arr[i] != i+1) {
                     int temp = arr[arr[i]-1];
                     arr[arr[i]-1] = arr[i];
                     arr[i] = temp;
                     countSwaps++;
                 }
             }
         }
 
         return countSwaps;
     }
 
     public static void main(String[] args) {
         Scanner sc =new Scanner(System.in);
 
         // taking input array
         System.out.println(""Enter size of array:"");
         int size = sc.nextInt();
         int arr[] = new int[size];
         System.out.println(""Enter array elements:"");
         for (int i=0; i<size; i++) {
             arr[i] = sc.nextInt();
         }
         sc.close();
 
         // initial array
         System.out.println(""Array before sorting:"");
         for (int i=0; i<size; i++) {
             System.out.print(arr[i] + "" "");
         }
         System.out.println();
 
         int minSteps = minSwaps(arr);
 
         // final array
         System.out.println(""Array after sorting:"");
         for (int i=0; i<size; i++) {
             System.out.print(arr[i] + "" "");
         }
         System.out.println();
 
         System.out.println(""Minimum number of swaps required to sort:"" + minSteps);
     }
 }
 
 /*
 Sample input/output:
 
 Enter size of array:
 7
 Enter array elements:
 2
 3
 7
 4
 6
 1
 5
 Array before sorting:
 2 3 7 4 6 1 5 
 Array after sorting:
 1 2 3 4 5 6 7 
 Minimum number of swaps required to sort:5
 
 Time Complexity: O(N) where N is the size of array.
 Auxiliary Space: O(1)
 */
",Java
"/*
    Monoalphabetic substitution cipher basically replaces
    each letter of a plaintext by another letter or symbol,
    depending only on the letter. The same plaintext letter
    is always replaced by the same ciphertext letter and 
    the same letter can be replaced by letter itself.
    
    Example if a is there we replace it with B to Z .....so on.
 
    Here in this particular case we use the cipherer as a => z
    b => y .... so on. The user can change depending upon his/her
    requirment
 
 */
 
 package main
 
 import (
 
   ""fmt""
   ""unicode""
   ""bufio""
   ""os""
   ""strings""
 
 )
 
 //Global Variables
 var plaintext string
 var ciphertext string
 
 /* We use this list of alphabets to check what letter we have
    in plaintext*/
 var list string = ""abcdefghijklmnopqrstuvwxyz""
 
 /* We use this list of alphabets as the corresponding cipher  
    letters for corresponding input letters in plaintext */
 var cipherer string = ""zyxwvutsrqpomnlkjihgfedcba""
 
 var output string
 
 /*
  This function formats the given ciphertext according to
  the orginal plaintext recieved from the user as input.
  In the monoalphabeticcipher function below, we converet
  the given plaintext into lowercase for our cinvinence of 
  checking. So, the ciphertext we get is also in all 
  lowercase. Here, we format the ciphertext so that wherever
  there is capital letter in the plaintext, same follows 
  in the ciphertext.*/
 func format(temp string) {
 
 
     /* Checking if the given letter in plaintext is capital 
        or not and changint it to capttal if it was*/
     for i:=0; i < len(temp); i++ {
 
        if (unicode.IsUpper (rune(temp[i]) ) ) {
 
            output += strings.ToUpper(string(ciphertext[i]))
 
        }else {
 
           output += string(ciphertext[i])
 
        }
 
     }
 
 }
 
 /* This is the function where we cipher the plaintext using 
    the cipherer into small letters */
 func monoaplhabeticcipher() {
 
       // Converting the plaintext to sma",Go
"/*Finding huge factorials such as !100, !1000 is sometimes required but in languages such as C++
 the datatypes are not even capable of storing such a big number. We could achieve calculation of
 such a number via going back to the basis of how we used to muiltiply two numbers back in school days. 
 We used to muiltiply numbers and would add the summation and get the final result. 
 This program here uses a vector to store each particular digit in a single index of the vector. 
 The carry is forwarded as basic maths and in the end the complete result gets stored in the vector*/
 
 //The length of vector should be >= length of the resultant factorial
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /*The function takes a number and muiltiplies the number in the school's old fashioned way 
 where we muiltiply the complete digit by one digit and then add the results to get the final 
 resultant. The carry is carried forwarded and in the end the final result gets stored in the 
 array/vector. */
 
 void factorial(int val)
 {
     int carry = 0;       
     vector <int> arr(10000, 0);   
     arr[0] = 1;                   
     int k = 0;                         
 
     for(int i = 1; i <= val; i++) {
         for(int j = 0;j <= k; j++) {      
             arr[j] = arr[j] * i + carry;
             carry = arr[j] / 10;
             arr[j] = arr[j] % 10;
         }
         while(carry) {        
             k++;
             arr[k] = carry % 10;
             carry /= 10;
         }   
     }
     for(int i = k; i >= 0; i--) {  
         cout<<arr[i];
     }
     cout << ""\n"";
 }
 int main() {
     int num;
     cin>>num;
     factorial(num);
     return 0;
 }
 
 /*Sample test case 
 Input: 15
 Output: 1307674368000
 
 Time Complexity = O(N)
 Space Complexity = O(1)
  */
 
",C-Plus-Plus
"/* This is the code for converting postfix expression to corresponding infix expression. The input is postfix expression(Eg: ab+).
  * This code gives output as the corresponding infix expression with parenthesis(a+b). This approach uses stack data structure.
  */
 
 #include<stdio.h>
 #include<stdlib.h>
 #include<stdio_ext.h>
 #include<string.h>
 
 //SIZE is the size of character array 'data' that holds intermediate expressions.
 #define SIZE 50
 
 /* Here, stack is implemented using linked list. Each node in linked list represents one element in stack. This is the definition of
  * each node of that linked list.
 */
 struct stackNode
 {
 	/* In process of converting postfix expression to infix expression, we need to push intermediate expressions in stack. To store
 	 * those expressions, character array 'data' is used. 'next' is the pointer pointing towards the next element in the stack.
 	 */
 	char data[SIZE];
 	struct stackNode *next;
 };
 
 //The function to check whether stack is empty or not.
 int isEmpty(struct stackNode *ftop)
 {
 	int rval = 0;
 	if (ftop == NULL)
 	{
 		rval = 0;
 	}
 	else
 	{
 		rval = 1;
 	}
 	return rval;
 }
 
 //The function to check whether stack is full or not.
 int isFull(struct stackNode *fnewnode)
 {
 	int rval = 0;
 	if (fnewnode == NULL)
 	{
 		rval = 0;
 	}
 	else
 	{
 		rval = 1;
 	}
 	return rval;
 }
 
 //Function to push element in the stack.
 int push(struct stackNode **ftop, char fidata[])
 {
 	struct stackNode *top = NULL, *newnode = NULL;
 	int rval = 0;
 	top = *ftop;
 
 	//Memory is assigned to element to be pushed.
 	newnode = (struct stackNode*) calloc(1, sizeof(struct stackNode));
 
 	//Check if stack is full or not. If not then push the character/expression.
 	rval = isFull(newnode);
 	if (rval == 1)
 	{
 		strcpy(newnode->data , fidata);
 		if (top == NULL)
 		{
 			top = newnode;
 		}
 		else
 		{
 			newnode->next = top;
 			top = newnode;
 		}
 	}
 	*ftop = top;
 
 	//rval=1 indicates successful push, else s",C
"'''
 Python program to find triplets in a given  array whose sum is zero
 '''
 # function to print triplets with 0 sum
 
 
 def find_Triplets_with_zero_sum(arr, num):
 
     ''' find triplets in a given  array whose sum is zero
 
         Parameteres :
             arr : input array
             num = size of input array
 
         Output :
             if triplets found return their values
             else return ""No Triplet Found""
 
     '''
     # bool variable to check if triplet found or not
     found = False
 
     # sort array elements
     arr.sort()
 
     # Run a loop until l is less than r, if the sum of array[l], array[r]
     # is equal to zero then print the triplet and break the loop
     for index in range(0, num - 1):
 
         # initialize left and right
         left = index + 1
         right = num - 1
 
         curr = arr[index]  # current element
 
         while (left < right):
 
             temp = curr + arr[left] + arr[right]
 
             if (temp == 0):
                 # print elements if it's sum is zero
                 print(curr, arr[left], arr[right])
 
                 left += 1
                 right -= 1
 
                 found = True
 
             # If sum of three elements is less  than zero
             # then increment in left
             elif (temp < 0):
                 left += 1
 
             # if sum is greater than zero than decrement in right side
             else:
                 right -= 1
 
     if (found is False):
         print("" No Triplet Found"")
 
 # DRIVER CODE STARTS
 
 if __name__ == ""__main__"":
 
     n = int(input('Enter size of array\n'))
     print('Enter elements of array\n')
 
     arr = list(map(int, input().split()))
 
     print('Triplets with 0 sum are as : ')
 
     find_Triplets_with_zero_sum(arr, n)
 
 '''
 SAMPLE INPUT 1 :
     Enter size of array : 5
     Enter elements of array : 0, -1, 2, -3, 1
 OUTPUT :
     Triplets with 0 sum are as :
                     -3 1 2
               ",Python
"
 /**
  * Implementing Stacks Using Arrays.
  * 
  * A stack is a linear Data Structure while follows LIFO (Last In First Out).
  * An element in a stack is always pushed (inserted) or popped (deleted) from the top.
  * 
  * Visualizing:
  * 
  *            O - O
  *            |   | <- top
  *            O - O
  *            |   |
  *            O - O
  *            |   |
  *            O - O
  *            
  * This code has four methods:
  * void push (int) - to insert an element in the stack
  * void pop() - to delete an element from the stack
  * void display() - to dispaly the stack
  * void main() - driver code to execute all the methods
  * 
  * In addition to the methods, the code also has a default constructor 
  * StackUsingArrays(int) to initialize the global parameters:
  * integer array stack[] - to store the elements
  * integer variable top - to point at the top of the stack
  * 
  * To take input from the user, Scanner class has been instantiated.
  * 
  */
 
 import java.util.*;
 
 public class StackUsingArrays
 {
     int stack[];
     int top;
 
     StackUsingArrays(int size)
     {
         stack = new int[size];
         top = -1;
     }
 
     public void push(int value)
     {
         /* Algorithm:
          * 1. Check if the queue is full (top == stack.length-1).
          *      If true, queue is full, print ""Overflow"" and exit.
          *      If false, queue is not full, go to Step 2.
          * 2. Increment the top by 1.
          * 3. Assign the memory space pointed by top the value received as formal parameter.
          */
         if(top == stack.length-1)
         {
             System.out.println(""Overflow"");
         }
         else
         {
             top++;
             stack[top] = value;
         }
     }
 
     public void pop()
     {
         /* Algorithm:
          * 1. Check if the queue is empty (top == -1).
          *      If true, queue is full, print ""Underflow"" and exit.
          *      If false, queue is n",Java
"/*
 This is singly linked list implementation in which 
 a unique key has to be given while entering the new node to the linked list,
 and you cannot give same key to the different node.
 */
 
 #include <iostream>
 using namespace std;
 
 class Node
 {
 public:
 	int key; //key = index of particular node in linked list
 	int data;
 	Node *next;
 
 	Node()
 	{
 		key = 0;
 		data = 0;
 		next = NULL;
 	}
 	Node(int k, int d)
 	{
 		int key = k;
 		int data = d;
 	}
 };
 
 class sll
 {
 public:
 	Node *head;
 
 	sll()
 	{
 		head = NULL;
 	}
 	sll(Node *n)
 	{
 		head = n;
 	}
 
 	// nexist : checks wether node exist in the linked list or not
 	Node *nexist(int k) //k= key value
 	{
 		Node *temp = NULL;
 		Node *ptr = head;
 
 		while (ptr != NULL)
 		{
 			if (ptr->key == k)
 			{
 				temp = ptr;
 			}
 			ptr = ptr->next;
 		}
 		return temp;
 	}
 
 	// appendnode : adds the new node at the end of the linked list
 	void appendnode(Node *n) //n= new node
 	{
 		if (nexist(n->key) != NULL)
 		{
 			cout << ""Entered node exist "" << n->key << endl;
 		}
 		else
 		{
 			if (head == NULL) //assuming that node is empty
 			{
 				head = n;
 				cout << ""Node appended"" << endl;
 			}
 			else //assuming that node stores some data
 			{
 				Node *ptr = head;
 				while (ptr->next != NULL)
 				{
 					ptr = ptr->next;
 				}
 				ptr->next = n;
 				cout << ""Node appended "" << endl;
 			}
 		}
 	}
 
 	// prependnode : adds the node at the head of the linked list
 	void prependnode(Node *n)
 	{
 		if (nexist(n->key) != NULL)
 		{
 			cout << ""Node already exist = "" << n->key << endl;
 		}
 		else
 		{
 			n->next = head;
 			head = n;
 			cout << ""Node prepended "" << endl;
 		}
 	}
 
 	// insertnode : insert new node in the middle of the linked list.
 	void insertnode(int k, Node *n)
 	{
 		Node *ptr = nexist(k);
 		if (ptr == NULL) //checking wether the entered key node exist or not
 		{
 			cout << ""No node exist with this key value = "" << k << endl;
 		}
 		else
 		{
 ",C-Plus-Plus
"/*
 
 Gnome sort is a simple algorithm which is similar to Insertion sort. The key idea of Gnome is to swap adjacent elements.
 Inspired by the standard Dutch Garden Gnome sorting the flower pots. A garden gnome sorts the flower pots as :
 Algorithm : 1) If the flower pot just before and after him are in correct order, then he moves one step forward.
             2) If it is not in correct order, he swaps the pots and moves back one step
             3) At the starting when there is no pot before him, he stpes forward and on reaching the end of the pot line, the list is sorted
 
 Time Complexity : O(n ^ 2)
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Perform gnomeSort
 function gnomeSort(array) {
   let start = 0;
 
   // While the start (position counter) is less than array length
   while (start < array.length) {
     if (start === 0) start++;
 
     // If adjacent elements are sorted, increment
     if (array[start] >= array[start - 1]) start++;
     // If not sorted, swap the elements & decrement the start
     else {
       [array[start], array[start - 1]] = [array[start - 1], array[start]];
       start--;
     }
   }
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered value is number or not
   if (array.includes(NaN)) return console.log(""Only numbers are allowed"");
 }
 
 console.log(""Your array - "", array);
 
 // Call the algorithm
 gnomeSort(array);
 console.log(""Sorted array - "", array);
 
 // Sample I/O
 
 /*
 
 > node Gnome
 
 Enter array length - 7
 Enter 1 element - 40
 Enter 2 element - 50
 Enter",JavaScript
"/*
 DESCRIPTION -
 Threaded binary tree are used to make faster inorder traversal without using stack or recursion.
 It stores the inorder successor, if the right node is empty.
 And stores the inorder predecessor if left node is empty.
 - There are functions to add, delete and search for an element.
 - Also the inorder for the tree. 
 */
 #include <iostream>
 #include <algorithm>
 #include <cstdlib>
 #include <math.h>
 #define COUNT 10
 using namespace std;
 
 typedef struct Node
 {
 	int data;
 	// 1 for address of child, 0 address of parent
 	int leftflag, rightflag;
 	struct Node *left, *right;
 
 }
 
 Node;
 void add(Node **p, int v)
 {
 	Node *newnode = (Node*) malloc(sizeof(Node));
 	newnode->data = v;
 	// by default both the flags will be 0
 	newnode->leftflag = 0;
 	newnode->rightflag = 0;
 	// if its the root node it will have no inorder predecessor or successor
 	if (*p == NULL)
 	{
 		newnode->left = NULL;
 		newnode->right = NULL;
 		*p = newnode;
 	}
 	else
 	{
 		Node *temp = *p;
 		// This loop will find the inorder predecessor or successor
 		while (1)
 		{
 			if (temp->data > v && temp->leftflag == 1)
 				temp = temp->left;
 			else if (temp->data < v && temp->rightflag == 1)
 				temp = temp->right;
 			else
 				break;
 		}
 
 		// temp is now the inorder predecessor or successor
 		// This will update the new node that is created with the links to its inorder predecessor or successor
 		if (temp->data < v)
 		{
 			newnode->right = temp->right;
 			// points at the child
 			temp->right = newnode;
 			temp->rightflag = 1;
 			// points at the parent
 			newnode->left = temp;
 		}
 		else
 		{
 			newnode->left = temp->left;
 			// points at the child
 			temp->left = newnode;
 			temp->leftflag = 1;
 			// points at the parent
 			newnode->right = temp;
 		}
 	}
 }
 
 void inorder(Node *p)
 {
 	while (1)
 	{
 		// goes to left most
 		while (p->leftflag)
 			p = p->left;
 		cout << p->data << "" "";
 		// right flag must be 0 so that it goes to",C-Plus-Plus
"# To find the contiguous sub-array with the largest sum in
 # a one-dimensional array of numbers
 
 
 def kadane(nums):
 
     current_max = global_max = nums[0]
 
     for i in range(1, len(nums)):
 
         current_max = max(nums[i], nums[i] + current_max)
 
         if current_max > global_max:
             global_max = current_max
     return global_max
 
 if __name__ == '__main__':
     print(kadane([-2, -3, -1, -5]))             # Output: -1
     print(kadane([-2, 1, -3, 4, -1, 2, 1, -5, 4]))   # Output: 6
",Python
"// Cycle Detection in Undirected Graph using BFS
 #include <bits/stdc++.h>
 using namespace std;
 
  //Adjacency List storing the graph
 vector<int> arr[100000];   
 //Visited array, it stores wheather the node is visited or not
 vector<int> vis(100000, 0); 
 
 bool checkCycle(int src)
 {
     //Initialize  a quueue and insert a pair of node and parent in it
     queue<pair<int, int>> q;
     vis[src] = 1;
     q.push(make_pair(src, -1));
     while (!q.empty())
     {
         //Pop out the front element of queue
         auto pair = q.front();
         int node = pair.first;
         int prev = pair.second;
         q.pop();
         //Iterate over every chilf of popped pair
         for (auto child : arr[node])
         {
             //If the child is not visited then mark it visited and insert in queue
             if (vis[child] == 0)
             {
                 vis[child] = 1;
                 q.push(make_pair(child, node));
             }
             /*If the node is visited and child is not the previour element
             then it means the child is already reached using other path,
             hence there exist a cycle and we return true*/
             else if (child != prev)
             {
                 return true;
             }
         }
     }
     return false;
 }
 
 int main()
 {
     int n, m, res = 0;
     cout << ""Enter the nodes and edges: \n"";
     cin >> n >> m;
     cout << ""Enter the edges\n"";
     while (m--)
     {
         int a, b;
         cin >> a >> b;
         arr[a].push_back(b);
         arr[b].push_back(a);
     }
 
     for (int i = 1; i <= n; i++)
     {
         if (vis[i] == 0)
             if (checkCycle(i))
                 res = 1;
     }
     if (res)
     {
         cout << ""There exists a cycle in this graph"";
     }
     else
     {
         cout << ""There does not exists a cycle in this graph"";
     }
     return 0;
 }
 
 /*
 Sample Input Output :-
 Enter the nodes and edges: 
 11 10
 Enter the edges
 1 2
 2",C-Plus-Plus
"/*
 Given an array of N elements.
 Find MEX ( Minimum Excluded Element ) of input array.
 Mex of an array is the minimum positive integer that doesn't appear in this array.
 For example, MEX of the array containing 1, 3 and 4 is equal to 2.
 */
 
 #include <stdio.h>
 #include <string.h>
 
 // this get_MEX_of_array function will give us MEX of input array
 int get_MEX_of_array(int ar[],int N)
 {
     /* we will use a visited_array[]
     check if visited_array[ar[i]] == 0 means
     ar[i] is visited or not if is not visited then we will increment it
     visited_array[ar[i]]++
     */
     int visited_array[N + 1];
     memset(visited_array, 0, sizeof(visited_array));
     for(int i = 0; i < N; i++)
     {
         if(visited_array[ar[i]] == 0)
         {
             visited_array[ar[i]]++;
         }
 
     }
 
     /* set MEX as 1
     then will start from 1 index and check if visited_array[i] == 0
     means that element is not present in array , hence that is the MEX
     */
     int MEX = 1;
     for(int i = 1; i < N; i++)
     {
         if(visited_array[i] == 0)
         {
             MEX = i;
             break;
         }
     }
     return MEX;
 }
 
 int main()
 {
     printf(""Enter the size of the array : \n"");
     int N;
     scanf(""%d"", &N);
     int ar[N + 1];
     printf(""Enter array elements :\n"");
     for (int i = 0; i < N; i++)
     {
 	    scanf(""%d"", &ar[i]);
     }
     int MEX_of_array = get_MEX_of_array(ar , N);
     printf(""MEX of the Array is : \n"");
     printf(""%d \n"",MEX_of_array);
 
 }
 
 /*
 
 Standard Input and Output
 
 Enter the size of the array :
 8
 Enter array elements :
 8 2 7 4 6 2 1 4
 
 MEX of the Array is :
 3
 
 Time Complexity : O( N )
 Space Complexity : O(N)
 
 */
",C
"/* Union of arrays- Print all the elements that are present in both the arrays
 Intersection of arrays- Print all the elements that are common in both the arrays  
 NOTE: Element in the output should be distinct */
 
 using namespace std;
 #include<iostream>
 #include<algorithm>
 
 /* The array are unsorted */
 
 void Intersection(int arr1[], int arr2[], int n1, int n2)
 {
     int i = 0, j = 0;
     
     while (i < n1 && j < n2)
       {
         if (i > 0 && arr1[i] == arr1[i - 1])
 	     {
 	         i += 1;
 	         continue;
 	     }
         else if (j > 0 && arr2[j] == arr2[j - 1])
 	     {
 	        j += 1;
 	        continue;
 	     }
 	 // Increase both the iterating variable when common element is found
         else if (arr1[i] == arr2[j])
 	    {
 	        cout << arr1[i] << "" "";
 	        i += 1;
 	        j += 1;
 	    }
         else if (arr2[j] < arr1[i])
 	    { 
 	       j += 1;
 	    }
         else
 	    {
 	       i += 1;
 	    }
     }
 }
 
 
 void Union( int arr1[], int arr2[], int n1, int n2 )
 {
     int i = 0, j = 0;
  
    //
     while (i < n1 && j < n2)
       {
         if (i > 0 && arr1[i] == arr1[i - 1]) 
 	     {
 	         i += 1;
 	         continue;
 	     }
 	 
         else if (j > 0 && arr2[j] == arr2[j - 1])
 	     {
 	        j += 1;
 	        continue;
 	     }
         else if (arr1[i] < arr2[j])
 	    {
 	        cout << arr1[i] << "" "";
 	        i += 1;
 	    }
         else if (arr2[j] < arr1[i])
 	    { 
 	       cout << arr2[j] << "" "";
 	       j += 1;
 	    }
         else
 	    {
 	       cout << arr1[i] << "" "";
 	       i += 1;
 	       j += 1;
 	    }
     }
     // To print remaining elements from arr1
     while (i < n1)
     {
         if (i > 0 && arr1[i] == arr1[i - 1])
 	    {
 	        i += 1;
 	        continue;
 	    }
         else
 	    {
 	        cout << arr1[i] << "" "";
 	        i += 1;
 	    }
     }
 	
     // To print remaining elements from arr2
     while (j < n2)
     {
         if (j > 0 &&",C-Plus-Plus
"// C program to implement Binary Search using Iterative Approach i.e Using Loop
 #include <stdio.h>
 
 /*(l is leftmost index , r the rightmost index and val is the element we are
    searching for) If value is present return the index else return -1
     */
 int binarySearch(int arr[], int l, int r, int val) {
   int mid = 0;
   while (l <= r) {
     // Storing the middle index of the array
     mid = (l + r) / 2;
     // value matched with X i.e searched element
     if (arr[mid] == val) {
       return mid;
     }
     /* If val is less than the mid element
             Check the left sub-array */
     else if (val < arr[mid]) {
       r = mid - 1;
     }
     /* If val is greater than the mid element
     Check the right sub-array */
     else {
       l = mid + 1;
     }
   }
   /* value not found in the array
   return with -1 response */
   return -1;
 }
 
 int main() {
   int arr[] = {-2, 5, 14, 17, 19, 27};
   // searched value assuming to be val=19
   int val = 19;
   int n = sizeof(arr) / sizeof(arr[0]);
   int index = binarySearch(arr, 0, n - 1, val);
 
   if (index == -1) {
     printf(""\nThe element %d is not present in the array"", val);
   } else {
     printf(""\nThe element %d is present at index: %d"", val, index);
   }
   return 0;
 }
 
 // Time Complexity: O(logn)
 // Space Complexity: O(n)
 
 /* Sample Test Case:
 Test-1:
         IF searched value is 19
         i.e val=19
         ------
         Output
         ------
         The element 19 is not present at index: 4
 
 Test-2:
         IF searched value is 29
         i.e val=29
         ------
         Output
         ------
         The element 29 is not present in the array
  */
",C
"import numpy as np
 
 
 def wPrefersM1OverM(prefer, w, m, m1):
     for i in range(N):
         if (prefer[w][i] == m1):
             return True
         if (prefer[w][i] == m):
             return False
 
 
 def stableMarriage(prefer):
     wPartner = [-1 for i in range(N)]
     mFree = [False for i in range(N)]
 
     freeCount = N
     while (freeCount > 0):
         m = 0
         while (m < N):
             if mFree[m] == False:
                 break
             m += 1
         i = 0
         while i < N and mFree[m] == False:
             w = prefer[m][i]
             if (wPartner[w - N] == -1):
                 wPartner[w - N] = m
                 mFree[m] = True
                 freeCount -= 1
 
             else:
                 m1 = wPartner[w - N]
                 if (wPrefersM1OverM(prefer, w, m, m1) == False):
                     wPartner[w - N] = m
                     mFree[m] = True
                     mFree[m1] = False
             i += 1
     print(""Woman "", "" Man"")
     for i in range(N):
         print(i + N, ""\t"", wPartner[i])
 
 N = int(input(""Enter the number of men/women: ""))
 print(""Enter preferences:"")
 entries = list(map(int, input().split()))
 prefer = np.array(entries).reshape(2*N, N)
 stableMarriage(prefer)
 
 """"""
 Time Complexity:O(n2)
 Sample Input:
 Enter the number of men/women: 4
 Enter preferences: 7 5 6 4 5 4 6 7 4 5 6 7 4 5 6
                    7 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3
 Output:
 Woman  Man
 4     2
 5 	 1
 6 	 3
 7 	 0
 """"""
",Python
"/******************************************************************************
 Author: @Suvraneel Bhuin
 
 Inorder Traversal of a Binary Tree
 
 Definition: Process all nodes of a tree by recursively processing the left subtree, then processing the root, and finally the right subtree
 In-order traversal is mainly used to print the values, stored in the nodes of a binary search tree, in ascending order. 
 Algorithm of Inorder(tree) Traversal
 1.Traverse the left subtree, i.e., call Inorder(left-subtree)
 2.Visit the root.
 3.Traverse the right subtree, i.e., call Inorder(right-subtree)
 *******************************************************************************/
 #include <stdio.h>
 #include <stdlib.h>
 
 struct node
 {
 int key;
 struct node *lt;
 struct node *rt;
 }*root = NULL, *temp = NULL;
 //root & temp are made global so that we dont need to pass those again & again
 
 // Function to search the appropriate position to insert the new node
 void search(struct node *t)
 {
     if ((temp->key > t->key) && (t->rt != NULL))            //key > root node move down more right
         search(t->rt);
     else if ((temp->key > t->key) && (t->rt == NULL))       //if right node NULL, insert key
         t->rt = temp;
     else if ((temp->key < t->key) && (t->lt != NULL))       //key < root node move down more left */
         search(t->lt);
     else if ((temp->key < t->key) && (t->lt == NULL))       //if left node NULL, insert key
         t->lt = temp;
 }
 
 /* To insert a node in the tree */
 void insert()
 {
     int data;
     printf(""Enter data of node to be inserted : "");
     scanf(""%d"", &data);
     temp = (struct node *)malloc(1*sizeof(struct node));
     temp->key = data;
     temp->lt = temp->rt = NULL;             //initialise lt & rt child as null
 
     if (root == NULL) 
     root = temp;
     else    
     search(root);    
 }
 
 /* recursive function to perform inorder (L-V-R) traversal of tree */
 void inorder(struct node *t)
 {
 if (root == NULL)",C
"/*
 AIM :: TO IMPLEMENT DESCENDING PRIORITY QUEUE 
 
             WHAT IS DESCENDING PRIORITY QUEUE ?
  In descending order priority queue, a higher priority number is given as a higher priority in a priority. For example, 
  we take the numbers from 1 to 5 arranged in descending order like 5, 4, 3, 2, 1; 
  therefore, the largest number, i.e., 5 is given as the highest priority in a priority queue.
 
 */
 
 #include <iostream>
 using namespace std;
 
 //Prototypes
 void enq(int *, int &, int &, int); // for insertion
 void deq(int *, int &, int &, int); // for deletion
 void display(int *, int, int);      // for display
 
 // for checking queue is full or not
 int q_full(int, int);
 // for checking queue is empty or not
 int q_empty(int, int);
 
 int main()
 {
     int size = 100, choice;
     int Q[size];
 
     /*
     Initially front and rear will be at -1
     deletion will be done from front end & insertion will be done from rear end
     */
     int front = -1;
     int rear = -1;
 
     cout << ""\t\t\nDESCENDING PRIORITY QUEUE"" << endl;
 
     while (true)
     {
         cout << ""\n1. ENQ\n2. DEQ\n3. DISPLAY\n4. EXIT"" << endl;
         cout << ""Enter your choice :: "";
         cin >> choice;
 
         switch (choice)
         {
         case 1:
             enq(Q, front, rear, size);
             break;
 
         case 2:
             deq(Q, front, rear, size);
             break;
 
         case 3:
             display(Q, front, rear);
             break;
 
         case 4:
             cout << ""\nexiting..."" << endl;
             exit(0);
             break;
 
         default:
             cout << ""\nInvalid choice :("" << endl;
             break;
         }
     }
     return 0;
 }
 
 void enq(int Q[], int &front, int &rear, int size)
 {
     int data, temp;
 
     if (q_full(front, size))
         cout << ""QUEUE OVERFLOW"" << endl;
     else
     {
         cout << ""Enter the data :: "";
         cin >> data;
 
         //inserting for first time
      ",C-Plus-Plus
"/**
 To find whether is it possible to
 reach target by taking sum of any subset
 of the given set.
 */
 
 import java.util.Scanner;
 
 public class SubsetSumToTarget {
 
     private static boolean subsetSumBottomUP(int[] ar, int target) {
 
 		boolean[][] dp = new boolean[ar.length + 1][target + 1];
 
 		// base case :
 		// when target=0 then always true.
 		// when no element is taken then always false.
 
 		for (int i = 0; i < ar.length + 1; i++) {
 			for (int j = 0; j <= target; j++) {
 
 				if (i == 0 && j == 0) {
 					dp[i][j] = true;
 					
 				} else if (i == 0) {
 					// when no element is considered
 					dp[i][j] = false;
 					
 				} else if (j == 0) {
 					// when target itself is 0
 					dp[i][j] = true;
 					
 				} else {
 					// when ith element is not included
 					boolean a = dp[i - 1][j]; 
 					boolean b = false;
 					
 					if (j >= ar[i - 1]) {
 						// when ith element is included.
 						b = dp[i - 1][j - ar[i - 1]]; 
 					}
 
 					dp[i][j] = a || b;
 				}
 			}
 		}
 
 		return dp[ar.length][target];
 	}
 
 	public static void main(String[] args) {
 
 		Scanner sc = new Scanner(System.in);
 		
 		System.out.print (""Enter no. of elemnets in the set - "");
 		int n = sc.nextInt();
 
 		int[] ar = new int[n];
 		System.out.print (""Enter elemnets in the set - "");
 		for (int i = 0; i < n; i++) {
 			ar[i] = sc.nextInt();
 		}
 		
 		System.out.print (""Enter target - "");
 		int target = sc.nextInt();
 
 		boolean isPossible = subsetSumBottomUP(ar, target);
 		
 		System.out.print (""Is it possible to reach target ? "");
 		if (isPossible) {
 			System.out.println (""Yes."");
 		} else {
 			System.out.println (""No."");
 		}
 
 	}
     
 }
 
 /**
 Time Complexity  : O(N*T) -> N:length of array, T:value of target
 Space Complexity : O(N*T)
 
 Input-1 :
 
 Enter no. of elemnets in the set - 5
 Enter elemnets in the set - 1 2 3 4 5
 Enter target - 6
 
 Output-1 :
 
 Is it possible to reach target ? Yes.
 
 Input-2 :
 
 Enter no. of elemne",Java
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# QUESTIONS TO SUBJECT CLASSIFICATION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [Questions Data](https://www.kaggle.com/mrutyunjaybiswal/iitjee-neet-aims-students-questions-data)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [
     {
      ""name"": ""stderr"",
      ""output_type"": ""stream"",
      ""text"": [
       ""[nltk_data] Downloading package stopwords to\n"",
       ""[nltk_data]     C:\\Users\\DELL\\AppData\\Roaming\\nltk_data...\n"",
       ""[nltk_data]   Package stopwords is already up-to-date!\n""
      ]
     }
    ],
    ""source"": [
     ""import pandas as pd\n"",
     ""from sklearn import preprocessing\n"",
     ""import nltk \n"",
     ""nltk.download('stopwords')                 # download the stopwords from NLTK\n"",
     ""\n"",
     ""import re                                  # library for regular expression operations\n"",
     ""import string                              # for string operations\n"",
     ""\n"",
     ""from nltk.corpus import stopwords          # module for stop words that come with NLTK\n"",
     ""from nltk.stem import PorterStemmer        # module for stemming\n"",
     ""from nltk.tokenize import TweetTokenizer   # module for tokenizing strings\n"",
     ""\n"",
     ""from sklearn.tree import DecisionTreeClassifier \n"",
     ""from sklearn.feature_extraction.text import CountVectorizer  \n"",
     ""from sklearn.model_selection import train_test_split \n"",
     ""from sklearn.metrics import confusion_matrix\n"",
     ""import matplotlib.pyplot as plt            # library for visualization\n"",
     ""import seaborn as sns""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting our Data""
    ]",Python
"/*
 Check for balanced parenthesis
 ==============================
 Given an expression containing parenthesis, check if it is well-formed or balanced.
 A balanced parenthesis means for every opening bracket there must be equivalent closing brackets.
 Application: Stack data structure
 Author: @gargvader
 Edit by: @Mohim-Singla
 */
 
 #include <iostream>
 #include <stack>
 #include <string>
 using namespace std;
 
 // function to check if brackets are balanced
 bool areBracketsBalanced(string expr)
 {
     stack<char> s;
     char x;
 
     // Traversing the Expression
     for (int i = 0; i < expr.length(); i++)
     {
         if (expr[i] == '(' || expr[i] == '[' || expr[i] == '{')
         {
             // Push the element in the stack
             s.push(expr[i]);
             continue;
         }
 
         // IF current current character is not opening
         // bracket, then it must be closing. So stack
         // cannot be empty at this point.
         if (s.empty())
             return false;
 
         switch (expr[i])
         {
         case ')':
 
             // Store the top element in a
             x = s.top();
             s.pop();
             if (x == '{' || x == '[')
                 return false;
             break;
 
         case '}':
 
             // Store the top element in b
             x = s.top();
             s.pop();
             if (x == '(' || x == '[')
                 return false;
             break;
 
         case ']':
 
             // Store the top element in c
             x = s.top();
             s.pop();
             if (x == '(' || x == '{')
                 return false;
             break;
         }
     }
 
     // Check Empty Stack
     return (s.empty());
 }
 
 // Driver code
 int main()
 {
     string expr;
     cout << ""Enter a expression "" << endl;
     cin >> expr;
 
     // Function call
     if (areBracketsBalanced(expr))
         cout << ""Balanced Parenthesis"";
     else
         cout << ""Unbalanced Par",C-Plus-Plus
"/*
 A Queue is a linear structure which follows a particular order in which the operations are performed. 
 The order is First In First Out. The below program reverses a queue using stack data structure.
 Here stack and queue are implemented using linked list.
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 //Struct for the stack
 typedef struct Stack
 {
     int data;
     struct Stack *next;
 } Stack;
 //Struct for the queue
 typedef struct Queue
 {
     int data;
     struct Queue *next;
 } Queue;
 Stack *top = NULL;
 Queue *front = NULL;
 Queue *rear = NULL;
 //push function pushes an element onto the top of the stack
 void push(int n)
 {
     Stack *New = (Stack *)malloc(sizeof(Stack));
     if (top == NULL)
     {
         top = New;
         top->data = n;
         top->next = NULL;
     }
     else
     {
         New->next = top;
         top = New;
         top->data = n;
     }
 }
 // pop function pops out an element from the top of the stack
 int pop()
 {
     if (top != NULL)
     {
         Stack *ptr = top;
         top = top->next;
         return ptr->data;
     }
 }
 //isStackEmpty function checks whether the stack is empty
 int isStackEmpty()
 {
     if (top == NULL)
     {
         return 1;
     }
     return 0;
 }
 //isQueueEmpty function checks whether the queue is empty
 int isQueueEmpty()
 {
     if (front == NULL)
     {
         return 1;
     }
     return 0;
 }
 // The enqueue function inserts an element into the queue
 void enqueue(int n)
 {
     Queue *New = (Queue *)malloc(sizeof(Queue));
     if (front == NULL)
     {
         front = New;
         rear = front;
         front->data = n;
         rear->next = NULL;
     }
     else
     {
         rear->next = New;
         New->data = n;
         rear = New;
         rear->next = NULL;
     }
 }
 //dequeue function deletes an element from the queue
 int dequeue()
 {
     if (front != NULL)
     {
         Queue *ptr = front;
         front = front->next;
         return ptr->data;
 ",C
"""""""
 Python Program to implement a stack using two queues
 by making the push operation costly
 """"""
 
 
 class my_stack:
     def __init__(self):
         self.my_queue1 = my_queue()
         self.my_queue2 = my_queue()
     """"""
     push method takes an argument and enqueues it in my_queue1
     After enqueuing in my_queue1 every element of my_queue2 is
     dequeued and enqueued in my_queue1.
     The names of my_queue1 and my_queue2 are then swapped.
     """"""
 
     def push(self, value):
         self.my_queue1.enqueue(value)
         while not self.my_queue2.isempty():
             y = self.my_queue2.dequeue()
             self.my_queue1.enqueue(y)
         temp_name = self.my_queue1
         self.my_queue1 = self.my_queue2
         self.my_queue2 = temp_name
 
     # pop method dequeues from my_queue2 and returns the dequeued value
     def pop(self):
         return self.my_queue2.dequeue()
 
     # isempty method returns false if my_queue2 is not empty else it returns true
     def isempty(self):
         return self.my_queue2.isempty()
 
  
 class my_queue:
     # initialize the instance variable item_list of class Queue to an empty list
     def __init__(self):
         self.item_list = []
         
     # enqueue method adds data to items.
     def enqueue(self, value):
         self.item_list.append(value)
         
     # dequeue method dequeues the first element in item_list.
     def dequeue(self):
         return self.item_list.pop(0)
 
     # isempty method returns false if item_list is not empty else it returns true
     def isempty(self):
         return self.item_list == []
 
  
 if __name__ == '__main__':
     object1 = my_stack()
     print('Enter the size of the numbers you want to push')
     n = int(input())
     print('Enter', n, 'nubmers that you want to push into stack')
     for i in range(0, n):
         m = int(input())
         object1.push(m)
     print('')
     for i in range(0, n+1):
         if object1.isempty():
             prin",Python
"// C program to implement Matrix Addition
 #include <stdio.h>
 void matrix_add(int [][10],int [][10],int [][10],int,int,int,int);
 int main()
 {
     int r1, c1, r2, c2;
     printf(""Enter the number of rows and columns of the first matrix:  "");
     scanf(""%d %d"", &r1, &c1);
     printf(""Enter the number of rows and columns of the second matrix: "");
     scanf(""%d %d"", &r2, &c2);
 
     //If the given matrices differ in thier number of rows and columns, they cannot be added
     if ((r1 != r2) || (c1 != c2))
     {
         printf(""Given Matrices cannot be added!!!"");
         return 0;
     }
     int A[10][10], B[10][10], C[10][10];
     // Input the values of the matrices
     printf(""Enter the values of the first matrix\n"");
     for (int i = 0; i < r1; i++)
     {
         for (int j = 0; j < c1; j++)
             scanf(""%d"", &A[i][j]);
     }
     printf(""Enter the values of the second matrix\n"");
     for (int i = 0; i < r2; i++)
     {
         for (int j = 0; j < c2; j++)
             scanf(""%d"", &B[i][j]);
     }
     matrix_add(C,A,B,r1,r2,c1,c2);
     printf(""The resultant matrix is:\n"");
     for (int i = 0; i < r2; i++)
     {
         for (int j = 0; j < c2; j++)
             printf(""%d "", C[i][j]);
         printf(""\n"");
     }
     return 0;
 }
 void matrix_add(int C[][10],int A[][10],int B[][10],int r1,int r2,int c1,int c2)
 {
     for (int i = 0; i < r1; i++)
     {
         for (int j = 0; j < c2; j++)
         {
             // Add the corresponding values of both the matrices
             C[i][j] = A[i][j] + B[i][j];
         }
     }
 }
 
 /*
 Time Complexity: O(r * c), where 'r' is the number of rows and 'c' is the number of columns 
 Space Complexity: O(r * c)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number of rows and columns of the first matrix:  2 2
 Enter the number of rows and columns of the second matrix:  2 2
 Enter the values of the first matrix
 2 2
 2 2
 Enter the values of the second matrix
 2 2
 2 2
 The resultant matrix is:
 4 4",C
"/* SPARSE MATRIX REPRESENTATION USING LINKED LIST
     Representing a sparse matrix by a 2D array leads to wastage of lots of memory.
     A sparse matrix can be effectively represented by storing the non- zero elements
     Here a Linked list is used wherein each node stores
         1. row number
         2. column number
         3. non-zero value
     This representation reduces memory wastage
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 /* Declare node with row,column and data for storing non-zero term of
    sparse matrix.
    next points to the subsequent node
 */
 typedef struct node
 {
     int row, column, data;
     struct node *next;
 } node;
 node *head;
 
 //to represent and print sparse matrix
 void sparse_matrix(int rows, int cols, int mat[10][10])
 {
     // traverse the matrix row-wise
     for (int i = 0; i < rows; i++)
     {
         for (int j = 0; j < cols; j++)
         {
             //If a non-zero term is encountered
             if (mat[i][j] != 0)
             {
                 //Store the non-zero term in a new node of the linked list
                 node *new = malloc(sizeof(node));
                 new->row = i;
                 new->column = j;
                 new->data = mat[i][j];
                 new->next = NULL;
                 //If the list is empty insert as first node
                 if (head == NULL)
                     head = n;
                 else
                 {
                     node *ptr = head;
                     //Traverse till the end of the list
                     while (ptr->next != NULL)
                         ptr = ptr->next;
                     //insert as last node
                     ptr->next = new;
                 }
             }
         }
     }
     node *ptr = head;
     printf(""\nSPARSE MATRIX REPRESENTATION\nRow\tColumn\tValue\n"");
     //Traverse the linked list and print each node
     while (ptr != NULL)
     {
         printf(""%d\t%d\t%d\n"", ptr->row, ptr->column, ptr->",C
"#include<bits/stdc++.h>
 using namespace std;
 int Ackermann_Function(int m, int n) {
 	if (m == 0)
 		return n + 1;
 
 	else if (m > 0 && n == 0)
 		return Ackermann_Function(m - 1, 1);
 
 	else if (m > 0 && n > 0)
 		return Ackermann_Function(m - 1, Ackermann_Function(m, n - 1));
 }
 
 int main() {
 	int m, n;
 	cin >> m >> n;
 	cout << Ackermann_Function(m, n);
 	return 0;
 }
 
 /*
 time complexity:-O(mA(m, n)) to compute A(m, n)
 space complexity:- O(m) to compute A(m, n)
 Examples:-
 m=1,n=2
 output=4
 m=3,n=3
 output=61
 */
",C-Plus-Plus
"/*
  Program to print diagonal traversal of a binary tree.
  The idea is to use a queue to store only the left child of current node.
  After printing the data of current node make the current node to its right child, if present.
  A delimiter NULL is used to mark the starting of next diagonal.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 struct Node
 {
     int data;
     struct Node * left;
     struct Node * right;
 };
 Node* root = NULL;
 
 // Utility function to create a new Tree Node
 Node* newNode(int val)
 {
     Node *temp = new Node;
     temp->data = val;
     temp->left = NULL;
     temp->right = NULL;
 
     return temp;
 }
 
 // Function to insert item in a tree
 void insertItem(int item)
 {
     Node *newnode = newNode(item);
     if(!root) {
         root = newnode;
         return;
     }
     Node *cur, *prev;
     cur = root;
     while(cur!= NULL) {
         prev = cur;
         if(cur->data > item)
             cur = cur->left;
         else
             cur = cur->right;
     }
     if(prev->data > item)
         prev->left = newnode;
     else
         prev->right = newnode;
 }
 
 vector<int> diagonal(Node *root)
 {
    // your code here
    vector<int> ans;
    queue<Node *> q;
     q.push(root);
     while(!q.empty()){
         Node *t=q.front();
         while(t){
             ans.push_back(t->data);
             if(t->left)
                 q.push(t->left);
             t=t->right;
         }
         q.pop();
     }
     return ans;
 }
 
 int main()
 {
     int n;
     cin>>n;
     int arr[n];
     for(int i = 0; i < n; i++) {
         cin>>arr[i];
         insertItem(arr[i]);
     }
     vector<int> ans = diagonal(root);
     for(int i = 0; i < ans.size(); i++) {
         cout<<ans[i]<<"" "";
     }
     return 0;
 }
 
 /*
  Sample I/O
  Input format: The first line contains n - number of nodes in the tree
                The next line contains n spaced integers
  Output format: n spaced integers.
  Example:
  9
  8 11 2 1 6 14",C-Plus-Plus
"import java.util.*;
 
 class HeapSort {
 
     private static void heapSort(int arr[]) {
         int size = arr.length;
 
         System.out.println(""Time to make first max heap:"");
         long startTime = System.nanoTime();
         // calling buildHeap() to rearrange along with creating max heap
         for(int i = size/2 - 1; i>=0; i--) {
             buildHeap(arr, size, i);
         }
         long stopTime = System.nanoTime();
         System.out.println((stopTime - startTime)*0.000000001);
 
         System.out.println(""Time to make sort using max heaps and putting largest element in the end:"");
         startTime = System.nanoTime();
         // exchanging and extracting elements one by one from the final heap to sort the array
         for(int i = size-1; i>0; i--) {
 
             // swap the current root and last term
             swap(arr, i, 0);
 
             // doing max heap again
             buildHeap(arr, i, 0);
         }
         stopTime = System.nanoTime();
         System.out.println((stopTime - startTime)*0.000000001);
     }
 
     private static void buildHeap(int arr[], int size, int i) {
 
         int max = i;
         int leftNode = 2 * i + 1;
         int rightNode = 2 * i + 2;
 
         // for max heap root must be greater than both nodes, so we compare to check this
         if(leftNode<size && arr[leftNode]>arr[max]) {
             // left node larger than current root
             max = leftNode;
         }
 
         if(rightNode<size && arr[rightNode]>arr[max]) {
             // right node larger than left node and current root
             max = rightNode;
         }
 
         if (max != i) {
             // root is not greatest
             swap(arr, max, i);
 
             // since this sub-heap got rearranged we need to rearrange all sub-heaps before this recursively
             buildHeap(arr, size, max);
         }
     }
 
     private static void swap(int arr[], int pos1, int pos2) {
         int temp = arr[pos1];",Java
"/*
 Topological ordering of a directed graph is a linear ordering of its 
 vertices such that for every directed edge uv from vertex u to vertex v,
 u comes before v in the ordering. To perform this sorting the graph must 
 be Direct acyclic graph(DAG).
 
 */
 
 using System;
 using System.Collections.Generic;
 
 namespace Topoplogical_Sorting
 {
     public class Graph
     {
         //Number of vertices
         private int vertices;
         //Adjacency list
         List<int>[] adjList;
         public Graph(int v)
         {
             vertices = v;
             adjList = new List<int>[v];
             for (int i = 0; i < v; i++)
             {
                 adjList[i] = new List<int>();
             }
         }
         //Add direct edge from vertex u to vertex v
         public void AddEdge(int u, int v)
         {
             adjList[u].Add(v);
         }
         //Modified DFS algorithm to traverse the graph
         public void ModifiedDFS(int v, bool[] visited, Stack<int> stack)
         {
             visited[v] = true;
             List<int> connected_vertices = adjList[v];
             foreach (var vertex in connected_vertices)
             {
                 //if the vertex not visited recurse
                 if (!visited[vertex])
                 {
                     ModifiedDFS(vertex, visited, stack);
                 }
             }
             //add the vertex to stack after it is visited and its children
             stack.Push(v);
         }
         //Call Modified DFS and perform topological sorting
         public void TopologicalSort()
         {
             bool[] visited = new bool[vertices];
             Stack<int> stack = new Stack<int>();
             for (int i = 0; i < vertices; i++)
             {
                 if (!visited[i])
                     ModifiedDFS(i, visited, stack);
             }
             while(stack.Count != 0)
                 Console.Write(stack.Pop() + "" "");
         }
         public void To",C-Sharp
"/*
 A string of length n has 2^n different possible subsequences.
 A subsequence is a sequence that appears in the same relative order, but not necessarily contiguous.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 #define MAX 1005
 
 // Returns length of shortest common subsequence
 int shortestSeq(char *S, char *T) {
 	int m = strlen(S), n = strlen(T);
 
 	// declaring 2D array of m + 1 rows and
 	// n + 1 columns dynamically
 	int dp[m + 1][n + 1];
 
 	// T string is empty
 	for (int i = 0; i <= m; i++)
 		dp[i][0] = 1;
 
 	// S string is empty
 	for (int i = 0; i <= n; i++)
 		dp[0][i] = MAX;
 
 	for (int i = 1; i <= m; i++) {
 		for (int j = 1; j <= n; j++) {
 			char ch = S[i - 1];
 			int k;
 			for (k = j - 1; k >= 0; k--)
 				if (T[k] == ch)
 					break;
 
 			// char not present in T
 			if (k == -1)
 				dp[i][j] = 1;
 			else
 				dp[i][j] = min(dp[i - 1][j], dp[i - 1][k] + 1);
 		}
 	}
 
 	int ans = dp[m][n];
 	if (ans >= MAX)
 		ans = -1;
 
 	return ans;
 }
 
 int main() {
 	char S[100];
 	char T[100];
 	cout << ""Enter first string\n"";
 	cin >> S;
 	cout << ""Enter second string\n"";
 	cin >> T;
 	cout << ""Length of shortest subsequence is : "" << shortestSeq(S, T) << endl;
 }
 
 /*
 Example:
 
 Input:
 S = babab
 T = babba
 Output:
 Length of shortest subsequence is : 3
 The subsequence aab of length 3 is present in S but not in T.
 
 Time complexity: O(mn^2)
 Space Complexity: O(mn)
 */
",C-Plus-Plus
"// Converting min Heap to max Heap
 
 #include<bits/stdc++.h>
 using namespace std;
  
 // to heapify a subtree 
 void MaxHeap(int arr[], int x, int num)
 {
     int left = 2*x + 1;
     int right = 2*x + 2;
     int greatest = x;
     if (left < num && arr[left] > arr[x])
         greatest = left;
     if (right < num && arr[right] > arr[greatest])
         greatest = right;
     if (greatest != x)
     {
         swap(arr[x], arr[greatest]);
         MaxHeap(arr, greatest, num);
     }
 }
  
 
 void convertMaxHeap(int arr[], int n)
 {
     // Start from bottommost and rightmost
     // internal mode and heapify all internal
     // modes in bottom up way
     for (int i = (n-2)/2; i >= 0; --i)
         MaxHeap(arr, i, n);
 }
  
 // A utility function to print a given array
 // of given size
 void printArray(int* arr, int size)
 {
     for (int i = 0; i < size; ++i)
         printf(""%d "", arr[i]);
 }
  
 //Main Function
 int main()
 {
     // array with elements of Min Heap Tree
     int n;
     cout<<""Enter the size of the array:"";
     cin>>n;
     int arr[n];
     cout<<""Enter the array elements:"";
     for(int i=0;i<n;i++){
         cin>>arr[i];
     }
     printf(""Min Heap array : "");
     printArray(arr, n);
  
     convertMaxHeap(arr, n);
  
     printf(""\nMax Heap array : "");
     printArray(arr, n);
  
     return 0;
 }
 /*
 OUTPUT:
 Enter the size of the array:8
 
 Enter the array elements:10 19 20 23 25 16 26 51
 
 Min Heap array : 10 19 20 23 25 16 26 51 
 
 Max Heap array : 51 25 26 23 10 16 20 19 
 
 TIME COMPLEXITY: O(N)  [N here is number of elements in array]
 SPACE COMPLEXITY: O(N)
 */
",C-Plus-Plus
"#Extended Euclidean Algorithm
 
 def Extended_gcd(a, b, x, y):
     #Base Case
     if a == 0:
         x = 0
         y = 1
         return b
 
     x1, y1 = 0, 0
     gcd = Extended_gcd(b % a, a, x1, y1)
 
     x = y1 - int(b / a) * x1
     y = x1
 
     return gcd
 
 #Main code
 a = int(input())
 b = int(input())
 x, y = 0, 0
 print(""GCD of numbers "" + str(a) + "" and "" + str(b) + "" is "" + str(Extended_gcd(a, b, x, y)))
",Python
"#include <iostream>
 using namespace std;
 
 int Hash(int x, int s) {
 	return x % s;
 }
 //Function to insert in hashtable.
 void QuadProbe(int Q[], int s, int x) {
 	int index = Hash(x, s);
 	int i = 0;
 	while (Q[index] != 0 && Q[index] != -1) {
 		i++;
 		index = (Hash(x, s) + (i * i)) % s;
 
 	}
 	Q[index] = x;
 }
 //Function to Search for an element in hashtable.
 void QPSearch(int Q[], int s, int x) {
 	int index = Hash(x, s);
 	int i = 0;
 	while (Q[index] != 0) {
 		if (Q[index] == x) {
 			cout << ""Element found at index "" << index << endl;
 			return;
 		}
 		i++;
 		index = (Hash(x, s) + (i * i)) % s;
 
 	}
 	cout << ""Element not found "" << endl;
 }
 //Function to Delete an element from Hashtable.
 void QPDelete(int Q[], int s, int x) {
 	int index = Hash(x, s);
 	int i = 0;
 	while (Q[index] != 0) {
 		if (Q[index] == x) {
 			cout << ""Element deleted "" << endl;
 			Q[index] = -1;
 			return;
 		}
 		i++;
 		index = (Hash(x, s) + i) % s;
 
 	}
 	cout << ""Element not found hence cant be deleted "" << endl;
 
 }
 //Main Function
 //Space Complexity: O(n)
 //Time Complexity: O(m) - The algorithm would iterate through the array of size m to allocate the elements their proper positions.
 int main() {
 	int n, x;
 	cout << ""Hello world!"" << endl;
 	cout << ""Enter number of elements "" << endl;
 	cin >> n;
 	int s = 2 * n;
 	int p = s;
 	while (p > 0) {
 		if ( ( ((p - 1) % 6 == 0) && ((p + 1) % 6 != 0) )  || ( ((p + 1) % 6 == 0) && ((p - 1) % 6 != 0) ))
 			break;
 		p--;
 	}
 	int L[s] = {0}, Q[s] = {0}, D[s] = {0};
 	cout << ""Enter elements for quad probing "" << endl;
 	for (int i = 0; i < n; i++) {
 		cin >> x;
 
 		QuadProbe(Q, s, x);
 
 	}
 	cout << ""The hash table is"" << endl;
 	for (int i = 0; i < s; i++) {
 		cout << Q[i] << endl;
 	}
 
 	cout << ""Enter element to be searched in QP : "";
 	cin >> x;
 	QPSearch(Q, s, x);
 	cout << ""Enter element to be deleted in QP : "";
 	cin >> x;
 	LPDelete(Q, s, x);
 	cout << ""The hash table is "" << endl;
 	for (int i ",C-Plus-Plus
"// C++ program to find the Length of Longest Decreasing Subsequence
 /* In this problem, given an array we have to find the length of the longest decreasing subsequence that array can make.
 The problem can be solved using Dynamic Programming */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int length_longest_decreasing_subsequence(int arr[], int n)
 {
     int dp[n], max_len = 0;
 
     /* Initialize the dp array with the 1 as value, as the maximum length
        at each point is atleast 1, by including that value in the sequence  */
     for (int i = 0; i < n; ++i)
         dp[i] = 1;
 
     /* Now Lets Fill the dp array in Bottom-Up manner
        Compare Each i'th element to its previous elements from 0 to i-1, 
        If arr[i] < arr[j](where j = 0 to i-1), then it qualifies for decreasing subsequence and
        If dp[i] < dp[j] + 1, then that subsequence  qualifies for being the longest one */
     for (int i = 1; i < n; i++)
     {
         for (int j = 0; j < i; j++)
         {
             if (arr[i] < arr[j] && dp[i] < dp[j] + 1)
                 dp[i] = dp[j] + 1;
         }
     }
 
     //Now Find the maximum element in the 'dp' array
     for (int i = 0; i < n; i++)
     {
         if (dp[i] > max_len)
             max_len = dp[i];
     }
 
     return max_len;
 }
 
 int main()
 {
     int n, max_len;
     cout << ""\nWhat is the length of the array? "";
     cin >> n;
     int arr[n];
     cout << ""Enter the numbers: "";
     for (int i = 0; i < n; i++)
     {
         cin >> arr[i];
     }
     max_len = length_longest_decreasing_subsequence(arr, n);
 
     cout << ""The length of the longest decreasing subsequence of the given array is "" << max_len;
     return 0;
 }
 
 /*
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 5
 Enter the numbers: 1 2 3 4 3
 The length of the longest decreasing subsequence of the given array i",C-Plus-Plus
"/*Java program to find Minimum Element in a Stack in Constant Time i.e O(1).
     Maintain an additional stack that will keep track of the minimum element
     of the Original Stack.
 
     Every push to the primary STACK, compare the current value
     with the TOS of the temporary Stack and IF the current value is less
     than the TOS push the current value to the temporary STACK,such that
     the minimum element is always at the top of the STACK
 
 */
 
 import java.util.Scanner;
 import java.util.Stack;
 
 class Min_Element_In_Stack {
 
   //s1 will act as primary stack and s2 as temporary stack  
   Stack < Integer > s1 = new Stack < Integer > ();
   Stack < Integer > s2 = new Stack < Integer > ();
 
   //Push data to the top of the stack
   void insertData(int data) {
     //If both the stacks are empty add the item to both the stack
     if (s1.isEmpty() && s2.isEmpty()) {
       s1.push(data);
       s2.push(data);
     } else {
       s1.push(data);
       /* IF pushed value is less than TOS of the temporary stack i.e stack2(s2)
       push the value,such that minimum element is always at the TOS of stack2(s2)
       */
       if (s1.peek() <= s2.peek()) {
         s2.push(data);
       }
     }
 
   }
 
   //Find the minimum from top of the stack
   int findMinimum() {
     return s2.peek();
   }
 
   public static void main(String args[]) {
     Scanner inp = new Scanner(System.in);
 
     Min_Element_In_Stack mObj = new Min_Element_In_Stack();
     int n;
     System.out.print(""Enter the no of Elements in the Stack:"");
     n = inp.nextInt();
 
     System.out.println(""Enter the values of the stack:"");
     for (int i = 0; i < n; i++) {
       mObj.insertData(inp.nextInt());
     }
 
     //Find Minimun
     System.out.println(""Minimum element in the above stack is :"" + mObj.findMinimum());
 
   }
 }
 
 /*
   Time complexity: O(1) for finding the minimum
   Space complexity: O(n)
   
   Sample input/output:
   Enter the no of Elements in the Stack:5
 ",Java
"""""""
 This script takes two input strings and compare them to check if they are anagrams or not.
 """"""
 
 def check_anagrams(first_string, second_string):
     
     #If the length of both these words dont match then they cant be anagrams
     if len(first_string) == len(second_string):
         
         #Sort both the strings and check their equality
         first_string = sorted(first_string.lower())
         second_string = sorted(second_string.lower())
         
         if first_string == second_string:
             print(""These two words are anagrams"")
         else:
             print(""These two words are not anagrams"")
                
     else:
         print(""These two words are not anagrams"")
         
 def main():
     first_string = input(""Enter a word: "")
     second_string = input(""Enter another one: "")
 
     check_anagrams(first_string, second_string)
 
 main()    
 
 #Sample Input-Output:
 
 #Sample 1
 #Inputs: ""silent"" and ""listen""
 
 #Output: These two words are anagrams
 
 #Sample 2
 #Inputs: ""july"" and ""june""
 
 #Output: These two words are  not anagrams
",Python
"''' An integer x is said to be Noble given an array 
 if the number of integers greater than x are equal to x.
 If noble integer is not found output is -1. 
 '''
 # To find the noble integer from the given list
 def nobleint():
     x = 0
     lst.sort()
     for i in range(0, num - 1):
         if lst[i] == lst[i + 1]:
             continue
         if lst[i] == num - i - 1:
             x = 1
             return num - i - 1
     if x == 0:
         return -1
 
 if __name__ == '__main__':
     num = int(input('Enter the number of elements:'))
     lst = list(map(int, input('Enter the elements:').split()))
     print nobleint(lst, num)
 
 '''
 Sample Output
 
 Enter the number of elements:4
 Enter the elements:7 3 9 81
 3
 Enter the number of elements:3
 Enter the elements:2 2 2
 -1
 
 Complexities
 Time Complexity:O(nlogn)
 Space Complexity:O(1)
 '''
 
",Python
"/*
 Given a number. find it's lowest prime factor.
 we have to get the lowest factor of that number and
 that lowest factor has to be a prime number.
 */
 
 #include <stdio.h>
 
 // From this chech_prime function we will whether a number is prime or not
 int check_prime(int number)
 {
     /* check whether number is prime or not */
     int i = 0;
     for(i = 3; i * i <= number; i += 2)
     {
         if(number % i == 0)
         {
             return 0;
         }
     }
     return 1;
 }
 
 // From this function we will get lowest prime factor of a number
 int get_lowest_prime_factor(int number)
 {
     int get_factor = 0, i = 0;
     /*
     loop runs till sqrt( number )
     for not getting precision errors
     use i * i <= number
     */
     for(i = 3 ; i * i <= number; i += 2)
     {
         if(number % i == 0)
         {
             get_factor = 1;
             int prime = check_prime(i);
             if(prime)
             {
                 /* that means the number is lowest prime factor */
                 return i;
             }
         }
     }
     if(!get_factor)
     {
         /*
         that means the number itself it's lowest prime factor.
         Ex : 17
         so we can return the number.
         */
         return number;
     }
 }
 
 int main()
 {
     printf(""Enter the number : \n"");
     int number;
     scanf(""%d"", &number);
     /*
     if the number is even, we can say that the lowest prime factor
     is 2 for any even number.
     because 2 is prime and it's a factor of
     every even number.
     */
     if(number % 2 == 0)
     {
         printf(""Lowest prime factor for this number is : 2\n"");
     }
     else if(number % 2)
     {
         int lowest_prime_factor = get_lowest_prime_factor(number);
         printf(""Lowest prime factor for this number is : \n"");
         printf(""%d\n"" , lowest_prime_factor);
     }
 }
 
 /*
 Standard Input and Output
 1. Even number
 Enter the number :
 435346
 Lowest prime factor for this",C
"/*You are given positive integers n and k. You are currently at stair 0 and want to climb to stair n. 
 You can either climb 1, 2, or 3 stairs at a time, but you can only climb 3 stairs at most k times.
 Return the number of ways to climb to the nth stair.
 */
 
 const FlightOfStairs = (n, k) => {
     const memo = new Array(n + 1);
     for (let i = 0; i < n + 1; i++)
     {
         memo[i] = new Array(k + 1).fill(0);
     }
 
     /*passing to the utility function*/
     console.log(""The answer is "",solveUtil(n, k, memo));
 };
 
 const solveUtil = (n, k, memo) =>{
 
     /*base cases*/
     if (n == 0)
         return 1;
     else if (n < 0)
         return 0;
     else if (memo[n][k] != 0)
         return memo[n][k];
 
     /*calls for 1 and 2 steps*/
     memo[n][k] = solveUtil(n - 1, k, memo) + solveUtil(n - 2, k, memo);
 
     /*checking k before making calls for 3 steps*/
     if (k > 0)
         memo[n][k] += solveUtil(n - 3, k - 1, memo);
 
     return memo[n][k];
 };
 
 /*taking arguments using command line arguments*/
 console.log(""Enter the values of n and k: "");
 var arguments = process.argv;
 FlightOfStairs(parseInt(arguments[2]),parseInt(arguments[3]));
 
   
 /*
 Input:
 Enter the values of n and k: 
 4 1
 
 Output:
 The answer is 7
 */
 
 /*
 Time complexity: O(n*k)
 Space complexity: O(n*k)
 */
",JavaScript
"/*
  A linked list is a linear data structure, in which the elements are not stored at contiguous memory locations. It is a 
 collection of nodes.Nodes consists of 2 parts data part and address part. Address part contains the address of the next or the 
 successor node. In this program, duplicate elements present in sorted linked list is removed. 
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 struct Node
 {
   int data;
   struct Node *next;
 }*first=NULL,*second=NULL,*third=NULL;
 
 
 void Display(struct Node *p)
 {
     while(p!=NULL)
     {
         printf(""%d "",p->data);
         p=p->next;
     }
 }
 
 void create(int A[],int n)
 {
     int i;
     struct Node *t,*last;
     first=(struct Node *)malloc(sizeof(struct Node));
     first->data=A[0];
     first->next=NULL;
     last=first;
 
     for(i=1;i<n;i++)
     {
         t=(struct Node*)malloc(sizeof(struct Node));
         t->data=A[i];
         t->next=NULL;
         last->next=t;
         last=t;
     }
 }
 
 void removeDuplicate(struct Node *p)
 {
     struct Node *q=p->next;
 
     while(q!=NULL)
     {
         if(p->data!=q->data)
         {
                 p=q;
                 q=q->next;
         }
         else
         {
             p->next=q->next;
             free(q);
             q=p->next;
         }
     }
 }
 
 int main()
 {
     int A[]={10,20,20,40,50,50,50,60};
     clrscr();
     printf(""Sorted list with no duplicate elements is : "");
     create(A,8);
     removeDuplicate(first);
     Display(first);
     getch();
     return 0;
 }
 
 /*
 SAMPLE INPUT OUTPUT
  int A[]={10,20,20,40,50,50,50,60}
  output:
  Sorted list with no duplicate elements is : 10 20 40 50 60
   
   Time Complexity: O(n) 
   where n is the number of nodes in the given linked list
 
   Space Complexity: O(n) 
   where n is the number of nodes in the given linked list
   
   */
 
 
",C
"#Different Approaches to find the number of inverstion in a given list of number 
 #Brute force take O(n^2) 
 def BruteForce(listt):
     count=0
     for i in range(0,len(listt)-1):
         for j in range(1,len(listt)):
             if listt[i]> listt[j]:
                 count+=1
     print(""Number of inversion is ""+count)
 #Merge Sort O(n logn)
 def CountInversions(arr):
     result=MergeSort(arr)
     return result[1]
 def MergeSort(arr):
     if len(arr) == 1:
         return arr, 0
     else:
         a = arr[:int(len(arr)/2)]
         b = arr[int(len(arr)/2):]
         a, ai = MergeSort(a)
         b, bi = MergeSort(b)
         c = []
         i = 0
         j = 0
         inversions = 0 + ai + bi
     while i < len(a) and j < len(b):
         if a[i] <= b[j]:
             c.append(a[i])
             i += 1
         else:
             c.append(b[j])
             j += 1
             inversions += (len(a))
     c += a[i:]
     c += b[j:]
     return c, inversions
 if __name__ == ""__main__"":
     print(""Number of inversion is ""+CountInversions([6,5,4,3,2,1]))
",Python
"import matplotlib.pyplot as plt
 import math as mt
 import random as rand
 
 # X and Y axis co-ordinates
 xx = []
 yy = []
 
 # Function to be ploted i.e the value of y
 f = lambda x : 2*x*x+5*x+3
 
 # Diffrent function to try from
 
 #f = lambda x : x
 #f = lambda x : pow(x,2)
 #f = lambda x : pow(x,3)
 #f = lambda x : pow(x,4)
 #f = lambda x : abs(x)
 #f = lambda x : mt.sin(x)
 #f = lambda x : mt.cos(x)
 #f = lambda x : mt.tan(x)
 #f = lambda x : rand.randint(0,100)
 #f = lambda x : mt.sqrt(x)
 #f = lambda x: 1/x
 
 '''
 
 NOTE: While choosing the function, Do check whether the range of limit is within
     the domain of the function.
 
     For example:- f(x)=1/x
         Here 0 is not in the domain of the function, 
         Hence try to modify the for loop with one or more conditional statements
         accordingly.
         
 '''
 # Number of Y co-ordinates
 limit = 50
 
 # Calculation the X co-ordinated using the function declared above
 for i in range(-limit, limit):
     # if i==0:
     # continue
     xx.append(i)
     yy.append(f(i))
 
 # plotting the points
 plt.plot(xx, yy, linewidth=1)
 plt.grid(color='black', linestyle='-', linewidth=0.30)
 
 # Labeling the x axis
 plt.xlabel('x - axis')
 
 # Labeling the y axis
 plt.ylabel('y - axis')
 
 # giving a title to my graph
 plt.title('Graph for the function :')
 
 # function to show the plot
 plt.show()
",Python
"/*
 The longest bitonic subsequence is a sequence in which the sequence is first increasing then decreasing ,
 The below program finds the length of the longest bitonic subsequence.
 */
 
 import java.util.Scanner;
 
 class Code {
     static int longest_bitonic_subsequence(int[] v, int n) {
         // v_increase tracks the longest increasing subsequence
         int[] v_increase = new int[n + 1];
         for (int i = 0; i < n; i++) {
             v_increase[i] = 1;
         }
         for (int i = 1; i < n; i++) {
             for (int j = 0; j < i; j++) {
                 if (v[i] > v[j]) {
                     if (v_increase[i] <= v_increase[j]) {
                         v_increase[i] = v_increase[j] + 1;
                     }
                 }
             }
         }
         // v_decrease tracks the longest decreasing subsequence
         int[] v_decrease = new int[n];
         for (int i = 0; i < n; i++) {
             v_decrease[i] = 1;
         }
         for (int i = n - 2; i >= 0; i--) {
             for (int j = n - 1; j > i; j--) {
                 if (v[i] > v[j]) {
                     if (v_decrease[i] <= v_decrease[j]) {
                         v_decrease[i] = v_decrease[j] + 1;
                     }
                 }
             }
         }
         int max = 0;
         for (int i = 1; i < n; i++) {
             int temp = v_increase[i] + v_decrease[i] - 1;
             if (temp > max) {
                 max = temp;
             }
         }
         return max;
     }
 
     // Driver Code
     public static void main(String[] args) {
         System.out.println(""Enter the number of elements in the sequence"");
         Scanner sc = new Scanner(System.in);
         int n = sc.nextInt();
         int[] v = new int[n + 1];
         System.out.println(""Enter the elements of the sequence"");
         for (int i = 0; i < n; i++) {
             v[i] = sc.nextInt();
         }
         System.out.println(""The length of longest bitonic subsequen",Java
"import java.util.*;
 
 public class BFS {
 
 	public static void breadthFirst(int edges[][],int V) {
 //		A visited array to mark if the node is visited then not to go there again
 		boolean visited[]=new boolean[V];
 		
 		for(int i=0;i<V;i++) {
 			if(!visited[i]) {
 				breadthFirstHelper(edges,visited,i);
 			}
 		}
 	}
 	
 	public static void breadthFirstHelper(int edges[][],boolean visited[],int sv) {
 		
 		int V=edges.length;
 		
 		visited[sv]=true;
 		
 		Queue<Integer> queue=new LinkedList<Integer>();
 		queue.add(sv);
 		
 		while(!queue.isEmpty()) {
 			
 			int size=queue.size();
 			
 			for(int i=0;i<size;i++) {
 				int frontNode=queue.poll();
 				for(int j=0;j<V;j++) {
 					if(edges[frontNode][j]==1&&!visited[j]) {
 						queue.add(j);
 						visited[j]=true;
 					}
 				}
 				System.out.print(frontNode+"" "");
 			}
 		}
 		
 	}
 	
 	public static void main(String[] args) {
 		
 		Scanner sc=new Scanner(System.in);
 	
 		System.out.println(""Enter the number of vertices in Graph : "");
 		int V=sc.nextInt();
 		
 		System.out.println(""Enter the number of edges in the Graph : "");
 		int E=sc.nextInt();
 		
 //		Adjaceny Matrix :
 		int edges[][]=new int[V][V];
 		
 //		Taking edges as input :
 		System.out.println(""Enter the edges :"");
 		for(int i=0;i<E;i++) {
 			int sv=sc.nextInt();
 			int ev=sc.nextInt();
 			edges[sv][ev]=1;
 			edges[ev][sv]=1;
 		}
 		
 		System.out.println(""BFS Traversal : "");
 		breadthFirst(edges,V);
 
 	}
 	
 /*
 Sample Case : 
 
 Enter the number of vertices in Graph : 
 4
 Enter the number of edges in the Graph : 
 4
 Enter the edges :
 0 1
 1 2
 0 2
 2 3
 BFS Traversal : 
 0 1 2 3 
 */
 	 
 }
",Java
"/*
 About Autokey Cipher: Autokey (Autoclave) Cipher is a Symmetric polyalphabetic (Polyceaser) substitution cipher. 
                       This algorithm is about changing plaintext letters based on secret key letters. 
                       Each letter of the message is shifted along some alphabet positions. 
                       The number of positions is equal to the place in the alphabet of the current key letter.
 
 Formula for Encryption:
     Ei = (Pi + Ki) mod 26
 
 Formula for Decryption:
     Di = (Ei - Ki + 26) mod 26
 Where:
     Ei: Encrypted text
     Pi: Plain Text values
     Ki: Plain Text values after adding key.
 
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 void flush_stdin()
 {
     while (fgetc(stdin) != '\n')
         ;
 }
 
 void autokeycipher(char **text, char key, int encrypt)
 {
     int textsize;
     textsize = strlen((*text));
 
     /* The first step is to convert all letter in plaintext either to lowercase or uppercase.*/
     for (int i = 0; i < textsize; ++i)
     {
         if (isalpha((*text)[i]))
         {
             // Converting to Upper
             (*text)[i] = toupper((*text)[i]);
         }
     }
 
     int nextkey, keyvalue, result;
     // now get the equivalent alphabetic values of plaintext.
     nextkey = toupper(key) - 'A';
 
     /* Shift the values of plaintext towards right and add key at first.*/
     /* Now, add both the above number. */
     for (int i = 0; i < textsize; ++i)
     {
         if (isalpha((*text)[i])) // checking for text type
         {
             keyvalue = nextkey;
             if (encrypt)
             {
                 nextkey = (*text)[i] - 'A';
                 // if the number/sum exceed 26, then we will start from beginning.
                 (*text)[i] = ((*text)[i] - 'A' + keyvalue) % 26 + 'A';
             }
             else
             {
                 result = ((*text)[i] - 'A' - keyvalue) % 26 + 'A';
                 (*text)[i] = result < 'A'",C
"// C++ Program for implementation of counting sort  
 #include<bits/stdc++.h>  
 #include<string.h> 
 using namespace std;  
   
 //  function to sort the given char arr[] in alphabetical order  
 void countSort(char arr[])  
 {    
     char output[strlen(arr)];  
   
     //An array to store count of inidividul characters and initialize count array as 0  
     int count[255 + 1], i;  
     memset(count, 0, sizeof(count));  
   
     // Store count of each character  
     for(i = 0; arr[i]; ++i)  
         ++count[arr[i]];  
   
     // update count[i] so that count[i] now contains actual position of this character in output array  
     for (i = 1; i <= 255; ++i)  
         count[i] += count[i-1];  
   
     // Build the output character array  
     for (i = 0; arr[i]; ++i)  
     {  
         output[count[arr[i]]-1] = arr[i];  
         --count[arr[i]];  
     }  
      
     // Copy the output array to arr to have sorted characters  
     for (i = 0; arr[i]; ++i)  
         arr[i] = output[i];  
 }  
   
 int main()  
 {  
     char arr[] = ""datastructures""; 
     //calling the countsort function inside main function
     countSort(arr);  
     //output the sorted array
     cout<< ""Sorted character array is "" << arr;  
     return 0;  
 }  
",C-Plus-Plus
"/*
 A pronic number is a number which is the product of two consecutive integers.
 Such as 2=2*1 (2 and 1 are consecutive numbers)
         12=4*3
         
 This program will print the pronic numbers in the given range.        
 */
 
 
 #include <stdio.h>
 #include<math.h>
 
 /* Function to check whether number is pronic or not
 A number is pronic if the root of equation i^2+i-num=0 is real and integer.*/
 int is_pronic(int num){
     int dis=1+4*num,root;
     if(dis<=0)
       return 0;
     else{
     	 root=floor(sqrt(dis));
          if(root*root==dis && dis%2==1)
             return 1;
          else
 		   return 0;   
     }  
 }
 
 int main(){
     int ll,hl,i;
     printf(""Enter the range for which you want to print PRONIC NUMBERS:\n"");
     printf(""Enter lower limit:"");
     scanf(""%d"",&ll);
     printf(""Enter higher limit:"");
     scanf(""%d"",&hl);
     
     //Printing pronic numbers in given range
     printf(""PRONIC NUMBERS from %d to %d are:\n"",ll,hl);
     for(i=ll;i<=hl;i++){
         if(is_pronic(i))
            printf(""%d "",i);   
     }
 }
 
 /*
 
 Sample Input/Output:
 
 Input:
 Enter the range for which you want to print PRONIC NUMBERS:
 Enter lower limit:1
 Enter higher limit:1000
 
 Output:
 PRONIC NUMBERS from 1 to 1000 are:
 2 6 12 20 30 42 56 72 90 110 132 156 182 210 240 272 306 342 380 420 462 506 552 600 650 702 756 812 870 930 992
 
 Time Complexity:O(n) where n is total numbers in range.
 Time Complexity of is_pronic()=O(1) 
 Space Complexity:O(1)
 
 */
 
",C
"/*
     The MinMax Algorithm is used to find the maximum and minimum element of an Array 
     in less no of comparisons(3*(n/2) - 2 comparisons) as compared to the Brute Force method.
     It uses a Divide N Conquer algorithmic approach(recursively dividing the array) to find minimum 
     and maximum elements 
 */
 
 import java.util.Scanner;
 
 public class Min_Max_Algorithm_implementation {
     public static void main(String[] args) {
 
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the size of array:-"");
         
         int n = sc.nextInt();
         int arr[] = new int[n];
         
         System.out.println(""Enter elements of array"");
         
         for(int i = 0; i<n; i++){
             arr[i] = sc.nextInt();
         }
         
         //Least index of an array/subarrays
         int low = 0; 
         //Highest index of an array/subarrays
         int high = n - 1; 
         
         int output[] = MinMax(arr, low, high);
         System.out.println(""Output:"");
         System.out.println(String.format(""Min: %d Max: %d"", output[0], output[1]));
     }
 
     /* 
         Function that returns minimum and maximum out of 2 elements.
         It returns an array with first element as minimum and second element as maximum out of 2 elements.
     */ 
 
     public static int[] min_max_of_2_elements(int x, int y){
         int min_max[] = new int[2];
         if(x < y){
             min_max[0] = x;
             min_max[1] = y;
         }
         else{
             min_max[0] = y;
             min_max[1] = x;
         }
         return min_max;
     }
 
     public static int[] MinMax(int arr[], int low, int high){
         
         // If after dividing array, we have one element left or two elements then return min or max of those elements
         if(low == high || high == low + 1){
             return min_max_of_2_elements(arr[low], arr[high]);
         }
 
         // Else dividing array recursively into smalle",Java
"//finding nth ugly number using recursion
 import java.util.Scanner;
 class UglyRecursion
 {
    
        public static int ugly(int n) 
     { 
         
         if (n == 1)  //base cases
             return 1; 
         if (n <= 0) 
             return 0; 
         if (n % 2 == 0)  
             return (ugly(n / 2)); 
         
         if (n % 3 == 0) 
             return (ugly(n / 3)); 
         
         if (n % 5 == 0)  
             return (ugly(n / 5)); 
         
         return 0; 
     } 
   
        
     
     public static void main(String args[])
     {
         Scanner sc=new Scanner(System.in);
         System.out.print(""N= "");
         int n=sc.nextInt();
         int i=1;
         while(n>0)
         { if(ugly(i)==1)
             n-=1;
             i++;
         }
         System.out.println(i--); //to avoid the last increment,we decrement by one
     }
 }
 
 
 /* Sample Input
    Input:
 N = 10
 Output: 12
 Time Complexity : O(n)
 Space Complexity : O(1)*/",Java
"/*
 Problem Statement:
 Given 2 large numbers, represented as strings.
 Find the sum of those strings and print the answer in string format.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // trim function is used to remove the zero's at the front.
 string trim(string x)
 {
     if (x == ""0"")
         return x;
     while (x[0] == '0')
     {
         x.erase(0, 1);
     }
     return x;
 }
 
 // Sum function returns a string which is sum of two input strings
 string Sum(string x, string y)
 {
     int n = x.size(), m = y.size();
     // string res stores the result
     string res;
     // carry variable is used to take care of carry while adding two numbers.
     // variable i is pointing to the end of string x and j is pointing to the end of string y.
     int i = n - 1, j = m - 1, carry = 0, k = max(n, m) - 1;
     while (i >= 0 and j >= 0)
     {
         int value = x[i] + y[j] - 96;
         value += carry;
         char temp = 48 + (value % 10);
         res += temp;
         carry = value / 10;
         i--;
         j--;
         k--;
     }
     while (i >= 0)
     {
         int value = x[i] - 48 + carry;
         char temp = 48 + (value % 10);
         res += temp;
         carry = value / 10;
         i--;
         k--;
     }
     while (j >= 0)
     {
         int value = y[j] - 48 + carry;
         char temp = 48 + (value % 10);
         res += temp;
         carry = value / 10;
         j--;
         k--;
     }
     res = carry == 0 ? res : res + to_string(carry);
     reverse(res.begin(), res.end());
     return trim(res);
 }
 
 int main()
 {
     string input1, input2;
     cout << ""Enter the strings : \n"";
     cin >> input1 >> input2;
     string answer = Sum(input1, input2);
     cout << ""Sum of the given strings : "" << answer << endl;
 }
 
 /*
 Input:
 Enter the strings : 
 329549237582345455325
 329857327582358923593245
 Output:
 Sum of the given strings : 330186876819941269048570
 
 Time Complexity  : O(max(n,m))
 Space Complexity",C-Plus-Plus
"// C Program for Interpolation search algorithm
 #include <stdio.h>
 //Array size must be less tha MAX
 #define MAX 100
 /* Interpolation search function begin ::
 	Search for key element in array.
 	If key present in a[0..n-1],
 	then it return the index of that key element
 	else return -1
 */
 int interpolation_search(int a[], int low, int high, int key)
 {
 	int mid;
 	while (low <= high && key >= a[low] && key <= a[high])  {
 
 		if (low == high) {
 			if (a[low] == key) return low;
 			return -1;
 		}
 		//Finding the value of position
 		mid = low + ((key - a[low]) / (a[high] - a[low])) * (high - low);
 		// Condition of target found
 		if (key == a[mid])
 			return mid + 1;
 		// If key is greater then
 		// key must be in upper part
 		if (key < a[mid])
 			high = mid - 1;
 		// If key is smaller then
 		// key must be in lower part
 		else
 			low = mid + 1;
 	}
 	return -1;
 }
 /* End of interpolation_search() */
 /* The main() begins */
 int main()
 {
 	int a[MAX];
 	int i, num;
 	int key, pos;
 	printf(""\nEnter the size of array (num < %d) :"", MAX);
 	scanf(""%d"", &num);
 	//Interpolation search work best for uniform array
 	printf(""Enter %d Elements of array  :\n"", num);
 	for (i = 0; i < num; i++)
 		scanf(""%d"", &a[i]);
 	printf(""\nEnter the value to be Search : "");
 	scanf(""%d"", &key);
 	//Display the user inputs of element and searched key
 	printf(""\nELEMENTS ARE : \n "");
 	for (i = 0; i < num; i++)
 		printf(""%d\t"", a[i]);
 	printf(""\nElement to be search is : %d"", key);
 	pos = interpolation_search(&a[0], 0, num - 1, key);
 	//Check if the elemnet found in an array or not!
 	printf(""\n\nOutput -->\n"");
 	if (pos == -1)
 		printf(""\nElement %d not found\n"", key);
 	else
 		printf(""\nElement %d found at position %d\n"", key, pos);
 	return 0;
 }
 /* The main() end */
 /*Sample Input Output of above code
 Enter the size of array (num < 100) : 5
 Enter 5 Elements of array  :
 1
 2
 3
 4
 5
 Enter the value to be Search : 4
 ELEMENTS ARE :
 1    2    3 ",C
"# Fibonacci Sequence Using Recursion
 
 def fibo_rec(x):
     """"""
     >>fibo_rec(6)
     0 1 1 2 3 5
 
     >>fibo_rec(10)
     0 1 1 2 3 5 8 13 21 34
 
     """"""
     if x == 0:
         return 0
     elif x == 1:
         return 1
     else:
         return fibo_rec(x-1) + fibo_rec(x-2)
 
 if __name__ == ""__main__"":
     n = int(input(""Enter the number of terms: ""))
     for i in range(n):
         print(fibo_rec(i), end="" "")
",Python
"'''
 Problem Statement: Given an undirected graph and an integer M. 
 The task is to determine if the graph can be colored with at most M colors such that no two adjacent vertices of the graph are colored with the same color.
 
 Input formate:
 Line1: The number of testcases
 Line2: Number of nodes 
 Line3: Number of colors
 Line4: Number of edges 
 Line5: Edges seperated by spaces 
 
 Output Formate:
 Print 1 if it is possible to colour vertices and 0 otherwise.
 
 Method:
 Backtracking 
 
 Intuition:  We consider all the different combinations of the colors for the given graph using backtacking 
 
 Argument: Array,int,int
 Return: Boolean
 '''
 def isSafe(graph,v,n,temp,color):
     #This check wheather if it saf to color the given node with temp color i.e checking if the adjacent nodes are different from temp 
     for i in range(v):
         if (graph[n][i]==1 and color[i]==temp):
             return False
     return True
 def check(graph,m,v,n,color):
     #This function iteratively checks different combinations.
     if(n==v):# base case : if all the nodes are traversed return 
         return True
     for i in range(1,m+1):
         if(isSafe(graph,v,n,i,color)):#checking if it is safe to color 
             color[n]=i
             if(check(graph,m,v,n+1,color)):
                 return True
             color[n]=0
     return False
 def graphcoloring(graph,M,V):
     color=[0]*(V+1) # assigning colors to different nodes 
     return check(graph,M,V,0,color)
 #driver code 
 def main():
     for _ in range(int(input())):
         V=int(input())
         M=int(input())
         E=int(input())
         list=[int(x) for x in input().strip().split()]
         graph =[[0 for i in range(V)] for j in range(V)]
         cnt=0
         for i in range(E):
             graph[list[cnt]-1][list[cnt+1]-1]=1
             graph[list[cnt+1]-1][list[cnt]-1]=1
             cnt+=2
         if(graphcoloring(graph,M,V)==True):
             print(1,""/n"")
         else:
           ",Python
"/*
 JUMP SEARCH IN DART
 Jump search is a sorting algorithm suited for ordered lists. 
 It creates a block and tries to find the element in that block. 
 If the item is not in the block, it shifts the entire block. 
 The block size chosen is n, where n is the size of the array.
 */
 
 import 'dart:io';
 import 'dart:math';
 
 int jumpSearch(List arr, int len, int key) {
   int begin = 0;
   // Setting the size of each block as squareroot of length of array
   int block_size = sqrt(len).floor();
 
   // Finding the block in which the key may potentially lie
   while (arr[block_size] <= key && block_size < len) {
     // setting the beginning index for the next block
     begin = block_size;
     // setting the ending index for the next block
     block_size += sqrt(len).floor();
 
     // if the block_size index lies beyond the length of array
     // indicating the key may or may not lie in last block
     // if it lies then linear search will find it and if not
     // return -1
     if (block_size > len - 1) {
       block_size = len;
       break;
     }
   }
 
   // performing linear search in the block in which the key may lie
   for (int ind = begin; ind < block_size; ind += 1) {
     if (arr[ind] == key) return ind;
   }
   return -1;
 }
 
 void main() {
   var n, ele, key;
   print('Enter the number of elements (n): ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   List array = new List.filled(n, null, growable: false);
 
   for (int i = 0; i < n; i++) {
     print('Enter value for element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array[i] = ele;
   }
 
   print('Enter the element to be searched (key): ');
   key = stdin.readLineSync();
   key = int.parse(key);
 
   int index = jumpSearch(array, n, key);
 
   if (index >= 0)
     print('$key was found at index $index');
   else
     print('$key is not present in the given array');
 }
 
 /*
 TIME COMPLEXITY: O(n)
 SPACE COMPLEXITY: O(1)
 
 SAMPLE INPUT/OUTPUT:
 En",Dart
"#include<stdio.h>
 #include<conio.h>
 
 void insertAtBeginning(int);
 void insertAtEnd(int);
 void insertAtAfter(int,int);
 void deleteBeginning();
 void deleteEnd();
 void deleteSpecific(int);
 void display();
 
 struct Node
 {
    int data;
    struct Node *next;
 }*head = NULL;
 
 void main()
 {
    int choice1, choice2, value, location;
    clrscr();
    while(1)
    {
       printf(""\n*********** MENU *************\n"");
       printf(""1. Insert\n2. Delete\n3. Display\n4. Exit\nEnter your choice: "");
       scanf(""%d"",&choice1);
       switch()
       {
          case 1: printf(""Enter the value to be inserted: "");
          		 scanf(""%d"",&value);
                  while(1)
                  {
                  	printf(""\nSelect from the following Inserting options\n"");
                  	printf(""1. At Beginning\n2. At End\n3. After a Node\n4. Cancel\nEnter your choice: "");
                     scanf(""%d"",&choice2);
                     switch(choice2)
                     {
                        case 1: 	insertAtBeginning(value);
                        		break;
                        case 2: 	insertAtEnd(value);
                        		break;
                        case 3: 	printf(""Enter the location after which you want to insert: "");
                        		scanf(""%d"",&location);
                        		insertAfter(value,location);
                        		break;
                        case 4: 	goto EndSwitch;
                        default: printf(""\nPlease select correct Inserting option!!!\n"");
                     }
                  }
          case 2: while(1)
                  {
                  	printf(""\nSelect from the following Deleting options\n"");
                  	printf(""1. At Beginning\n2. At End\n3. Specific Node\n4. Cancel\nEnter your choice: "");
                     scanf(""%d"",&choice2);
                     switch(choice2)
                     {
                        case 1: 	deleteBeginning();
                        		br",C
"""""""
 matrix multiplication is a binary operation that produces a product matrix 
 from two matrices . To multiply two matrices, the number of columns of first 
 matrix should be equal to the number of rows to second matrix.
 This program finds the product of two given matrices
 """"""
 
 Row_1 = int(input(""Enter the number of rows for first matrix : ""))
 Col_1 = int(input(""Enter the number of columns for first matrix : ""))
 
 matrix_1 = []
 print(""Enter the entries rowwise:"")
 for i in range(Row_1):
     matrix_1.append([int(x) for x in input().split("" "")])
 
 Row_2 = int(input(""Enter the number of rows for second matrix : ""))
 Col_2 = int(input(""Enter the number of columns for second matrix : ""))
 
 matrix_2 = []
 print(""Enter the entries rowwise:"")
 for i in range(Row_2):
     matrix_2.append([int(x) for x in input().split("" "")])
 
 result = [[0 for i in range(Col_2)] for j in range(Row_1)]
 # Multiplying both matrices and storing in result
 for i in range(Row_1):
     for j in range(Col_2):
         for k in range(Col_1):
             result[i][j] += matrix_1[i][k] * matrix_2[k][j]
 
 print(""The result of the matrix multiplication is"")
 for i in range(Row_1):
     for j in range(Col_2):
         print(result[i][j], end="" "")
     print()
 
 """"""
 Sample I/O :
 
 Enter the number of rows for first matrix : 3
 Enter the number of columns for first matrix : 3
 Enter the entries rowwise:
 1 2 3
 4 5 6
 7 8 9
 Enter the number of rows for second matrix : 3
 Enter the number of columns for second matrix : 4
 Enter the entries rowwise:
 1 2 3 4
 5 6 7 8
 9 10 11 12
 The result of the matrix multiplication is
 38 44 50 56
 83 98 113 128
 128 152 176 200
 
 Time complexity : O(n^3)
 Space complexity : O(n^2)
 """"""
",Python
"/*
     Author: Sakshi Joshi (@Sakshi0401)
 
     A Linked List is a linear data structure which includes a series of connected nodes. Each node stores the data and the address of the next node.
     If any node is visited more than once while traversing the list then we can say that it contains cycle/loop.
      Example:
                 1 -> 2 -> 3
                     ^     |
                     |     v
                     5 <-  4   
      Output:
             true
 
     Method:In this method we will traverse the linkedlist using two pointers is slow and fast. 
     Move the slow pointer by one position and fast pointer by two positions.
     If these two pointers meet together at any point at same node then we can say that there is loop/cycle inside linkedlist. 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /* Link list node */
 class Node
 {
 public:
     int data;
     Node *next;
 };
 
 void push_node(Node **head_ref, int new_data)
 {
     /* allocate node */
     Node *new_node = new Node();
 
     /* put in the data */
     new_node->data = new_data;
 
     /* link the old list off the new node */
     new_node->next = (*head_ref);
 
     /* move the head to point to the new node */
     (*head_ref) = new_node;
 }
 
 int detectLoop(Node *list)
 {
     Node *slow_p = list, *fast_p = list;
 
     while (slow_p && fast_p && fast_p->next)
     {
         slow_p = slow_p->next;
         fast_p = fast_p->next->next;
         if (slow_p == fast_p)
         {
             return 1;
         }
     }
     return 0;
 }
 
 /* Driver code*/
 int main()
 {
     /* Start with the empty list */
     Node *head = NULL;
     int n = 0;
     cout << ""Enter size of linked list"" << endl;
     cin >> n;
     int i;
     int d;
     cout << ""Enter the elements of linked list"" << endl;
     for (int i = 0; i < n; i++)
     {
         cin >> d;
         push_node(&head, d);
     }
 
     /* Create a loop for testing */
     head->next->next->next->next = head;
     i",C-Plus-Plus
"import java.util.Scanner;
 // JAVA Implementation of recursive Interpolation Search
 
 public class InterpolationSearch {
   int findEleByInterSearching(int arr[], int low, int high, int key) {
     if (high >= low && key >= arr[low] && key <= arr[high]) {
       //if value of high and low ae same
       if (low == high) {
         // value of key compared with element at index low
         if (arr[low] == key) return low;
         else return - 1;
       }
       //determining the position of the key element in an array
       int pos = low + (((high - low) / (arr[high] - arr[low])) * (key - arr[low]));
       // value of key compared with element at index low
       if (arr[pos] == key) return pos;
       /* If element key  is smaller than pos value
                     then it can only be present in left subarray */
       if (arr[pos] > key) return findEleByInterSearching(arr, low, pos - 1, key);
       /* Else the element key  can only be present 
                    in right subarray */
       if (arr[pos] < key) return findEleByInterSearching(arr, pos + 1, high, key);
     }
     return - 1;
   }
   // Driver method to test above 
   public static void main(String args[]) {
     InterpolationSearch s = new InterpolationSearch();
     Scanner sc = new Scanner(System. in );
     System.out.println(""Input :"");
     System.out.println(""Enter the size of array: "");
     int size = sc.nextInt();
     sc.nextLine();
     int sortedarr[] = new int[size];
     System.out.println(""Enter the elements of array:"");
     for (int index = 0; index < size; index++) {
       sortedarr[index] = sc.nextInt();
     }
     System.out.println(""Enter the element to be searched:"");
     int searchKey = sc.nextInt();
     int position = s.findEleByInterSearching(sortedarr, 0, size - 1, searchKey);
     System.out.println(""Output :"");
     if (position == -1) System.out.println(""Element not found"");
     else System.out.println(""Element found at index "" + position);
   }
 }
 /*
    In",Java
"#include<stdio.h>
 #include<stdlib.h>
 
 typedef struct node
 {
 	int data;
 	struct node * next;
 }node;
 
 node * insert_at_beg(node *,int);
 node * insert_at_pos(node *,int,int);
 node * insert_at_end(node *,int);
 node * delete_at_beg(node *);
 node * delete_at_pos(node *,int);
 node * delete_at_end(node *);
 node * count_length(node *);
 node * display(node *);
 node * check_empty(node *);
 int search_element(node *,int);
 void sortList(node *);
 void reverseList(node **); 
 
 node * insert_at_beg(node *head,int value)
 {
     node *temp1=(node *)malloc(sizeof(node));
     temp1->data=value;
     if(head==NULL)
     {
         head=temp1;
         temp1->next=head;
     }
     else
     {
         temp1->next = head;
         node *ptr1 = head;
         while(ptr1->next != head)
         {
             ptr1= ptr1->next;
         }
         ptr1->next = temp1;
         head = temp1;
     }
     return head;
 }
 
 node * insert_at_pos(node *head,int value,int pos)
 {
     node *temp2=(node *)malloc(sizeof(node));
     temp2->data=value;
     if(head==NULL)
     {
         printf(""List is Empty.Inserting at beginning"");
         head=insert_at_beg(head,value);
     }
     else if(pos==1)
         head=insert_at_beg(head,value);
     else
     {
         node *ptr2 = head;
         for(int i=2; i<=pos-1; i++)
         {
             ptr2 = ptr2->next;
         }
         temp2->next = ptr2->next;
         ptr2->next = temp2;
     }
     return head;
 }
 
 node * insert_at_end(node *head, int value)
 {
     node *temp3=(node *)malloc(sizeof(node));
     temp3->data=value;
     node *ptr3=head;
     while(ptr3->next !=head)
         ptr3=ptr3->next;
     ptr3->next=temp3;
     temp3->next=head;
     return head;
 }
 
 node * delete_at_beg(node *head)
 {
     if(head==NULL)
         printf(""\n UNDERFLOW \n"");
     else
     {
         node * temp4=head;
         while(temp4->next != head)
             temp4=temp4->next;
         head=head->next;
         printf(""\n De",C
"class Solution(object):
     def trap(self, heights):
             if not heights or len(heights) < 3:
                 return 0
 
             level = water = 0
             i = 0
             j = len(heights) - 1
             while i < j:
                 it = heights[i if heights[i] < heights[j] else j]
                 if heights[i] < heights[j]:
                     i += 1
                 else:
                     j -= 1
 
                 if level > it:
                     water += level - it
                 else:
                     level = it
             return water
 
 
 sol = Solution()
 N = int(input(""Enter Number of elements: ""))
 ilist = list(map(int, input(""Enter non-negative numbers: "").split()))
 print(""Maximum units of water saved is "" + str(sol.trap(ilist)))
 
 """"""
 Time Complexity: O(n2)
 Space Complexity: O(1)
 
 Sample Input:
 Enter Number of elements: 10
 Enter non-negative element: 0 2 1 3 0 1 2 1 2 1
 
 Output: Maximum units of water saved is 5
 """"""
",Python
"/*
 Given a Number. Find it's Number of Divisors.
 The Number can be big such as 10^6 to 10^9
 So, If we do this in O(N) we will get Time Limit Exceeded [TLE]
 Better Approach is run a loop till sqrt(Number)
 Example square root of 10^9 is 31622 (approx), so iteration optimized a lot.
 */
 
 import java.util.Scanner;
 import java.lang.*;
 import java.math.*;
 
 public class NumberofDivisors
 {
    // this get_number_of_divisors will count the number of divisors of the numbe
    static long get_number_of_divisors(long number)
    {
       long number_of_divisors = 0, i = 0;
       int limit = (int) Math.sqrt(number);
       for(i = 1; i < limit; i++)
       {
          if(number % i == 0)
          {
             /* Here i is a divisor of that number
             ( Number / i ) is also a divisor
             */
             number_of_divisors += 2;
          }
       }
 	
 
     if(number % limit == 0)
     {
         if(limit * limit == number)
         {
             //means perfect square number
            number_of_divisors++;
         }
         else
         {
             number_of_divisors += 2;
         }
     }
     return number_of_divisors;
 	   
    }
 
     public static void main(String args[])  
     {
         Scanner scan = new Scanner(System.in);
 	System.out.print(""Enter the number : \n"");
 	long number = scan.nextLong();
         long number_of_divisors = get_number_of_divisors(number);
         
         System.out.print(""Number of Divisors of this Number is : "");
         System.out.print(number_of_divisors);
         scan.close();
     }
 }
 
 /*
 Standard Input and Output
 
 Enter the number :
 1000000000
 Number of Divisors of this Number is : 100
 
 Enter the number :
 4567323
 Number of Divisors of this Number is : 16
 
 Time Complexity : O( sqrt(N) )
 Space Complexity : O( 1 )
 
 */
",Java
"""""""
 Python program to implement Maximum Sum Increasing Subsequence
 In this problem, given an array we have to find the maximum sum an increasing subsequence of that array can make.
 This problem is a slight modification to the Longest Increasing subsequence problem.
 The problem can be solved using Dynamic Programming
 """"""
 
 
 def maximum_sum_increasing_subsequence(arr, n):
     max_sum = 0
     dp = [0 for i in range(n)]
 
    # Initialize the dp array with the array values, as the maximum sum
    # at each point is atleast as the value at that point
     for i in range(n):
         dp[i] = arr[i]
 
     for i in range(1, n):
         for j in range(i):
             if(arr[i] > arr[j] and dp[i] < dp[j] + arr[i]):
                 dp[i] = dp[j] + arr[i]
 
     # Now Find the maximum element in the dp array
     max_sum = max(dp)
     return max_sum
 
 
 if __name__ == '__main__':
     print(""What is the length of the array? "", end="""")
     n = int(input())
     if (n <= 0):
         print(""No numbers present in the array!!!"")
         exit()
     print(""Enter the numbers: "", end="""")
     arr = [int(x) for x in input().split(' ')]
     res = maximum_sum_increasing_subsequence(arr, n)
     print(""The maximum sum of an  increasing subsequence of the given array is {}"".format(res))
 
 
 """"""
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 10
 Enter the numbers: 23 14 5 84 24 222 321 43 123 432 
 The maximum sum of an increasing subsequence of the given array is 1082
 
 SAMPLE 2
 
 What is the length of the array? 5
 Enter the numbers: 5 4 3 2 1
 The maximum sum of an increasing subsequence of the given array is 5
 """"""
",Python
"/*
 Stack data structure is used to construct the binary tree.
 This is an iterative process for constructing the binary tree .
   
   -->state variable is providing this functionality for making the process iterative rather than using recursion.
         3 states are used-
         1. state==1 then add left child
         2. state==2 then add right child
         3. state==3 then pop the node from stack as both left and rigth child are added for this node.
 */
 
 #include <iostream>
 using namespace std;
 #include <vector>
 #include <stack>
 class Tree
 {
 public:
     int val;
     int state;
     Tree *left;
     Tree *right;
     Tree()
     {
         val = 0;
         state = 0;
         left = NULL;
         right = NULL;
     }
 
     Tree(int x, int s)
     {
         val = x;
         state = s;
         left = NULL;
         right = NULL;
     }
     Tree(int val, int state, Tree *left, Tree *right)
     {
         this->val = val;
         this->state = state;
         this->left = left;
         this->right = right;
     }
 
     // Function to display tree (preorder traversal)
     void display(Tree *root)
     {
         if (root == NULL)
             return;
 
         cout << root->val << "" "";
         display(root->left);
         display(root->right);
     }
 };
 
 int main()
 {
     int n;
     cout << ""Enter size of the array:"";
     cin >> n;
     cout << ""\nEnter the elements :"";
     int arr[n];
     for (int i = 0; i < n; i++)
     {
         cin >> arr[i];
     }
     cout << ""\n"";
     Tree t;
     stack<Tree *> st;
     //initially root is at state =1
     Tree *root = new Tree(arr[0], 1);
     st.push(root);
     int i = 1;
     while (st.size() > 0)
     {
         if (st.top()->state == 1)
         {
             if (arr[i] != -1)
             {
                 Tree *node = new Tree(arr[i], 1);
                 //state increased as left child added
                 st.top()->state++;
                 st.top()->left = node;
           ",C-Plus-Plus
"#include<iostream>
 using namespace std;
 
 //creating structure for node
 struct Node {
     char data;
     struct Node *left;
     struct Node *right;
 };
 
 // Insert Function
 Node* Insert(Node *root, char data) {
     //if root have no value
     //then create a node and insert values
     if (root == NULL) {
         root = new Node();
         root->data = data;
         root->left = root->right = NULL;
     }
     //check if data is less than root value
     //then insert into left subtree
     else if (data <= root->data)
         root->left = Insert(root->left, data);
     //check if data is less than root value
     //then insert into right subtree
     else
         root->right = Insert(root->right, data);
     return root;
 }
 
 //Postorder Function
 void Postorder(Node *root) {
 
     if (root == NULL) return;
     // if tree is empty then return
     //visit left and right subtree
     Postorder(root->left);
     Postorder(root->right);
     //otherwise print data
     printf(""%c "", root->data);
 }
 
 //Main Function began
 int main() {
     Node* root = NULL;
     //input values
     root = Insert(root, 'M');
     root = Insert(root, 'B');
     root = Insert(root, 'Q');
     root = Insert(root, 'Z');
     root = Insert(root, 'A');
     root = Insert(root, 'C');
     //Print Nodes in Preorder.
     cout << ""\tOUTPUT\n"";
     cout << ""Postorder traversal : "";
     Postorder(root);
     cout << ""\n"";
 }
 //Main Ends
 
 /*
 Sample Input Output:
 
 Input -> M B Q Z A C
 
 OUTPUT:
 Postorder traversal : A C B Z Q M
 
 Time Complexity: O(n)
 */
",C-Plus-Plus
"/*
 C++ program to find the n-th element from Stern's Diatomic Series
 Stern's diatomic series is the sequence which generates the integer sequence that arises
 in the Calkin-Wilf tree. This sequence can be computed by the fusc function.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 int sterns_diatomic_num(int n)
 {
     if (n == 0)
         return 0;
 
     int dp[n + 1];
     dp[0] = 0;
     dp[1] = 1;
 
     for (int i = 2; i <= n; i++)
     {
         if (i % 2 == 0)
             dp[i] = dp[i / 2];
         else
             dp[i] = dp[(i - 1) / 2] + dp[(i + 1) / 2];
     }
 
     return dp[n];
 }
 
 int main()
 {
     int n;
     cout << ""Enter the value of n(where you need the nth Stern's Diatomic number): "";
     cin >> n;
     if (n < 0)
     {
         cout << ""Invalid Value of n !!!"";
         return 0;
     }
     int res = sterns_diatomic_num(n);
     cout << ""The "" << n << ""'th Stern's Diatomic is "" << res;
     return 0;
 }
 
 /*
 Time Complexity: O(n), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the value of n(where you need the nth Stern's Diatomic number): 258
 The 258'th Stern's Diatomic is 8.
 
 SAMPLE 2
 Enter the value of n(where you need the nth Stern's Diatomic number): -98
 Invalid Value of n !!!
 */
",C-Plus-Plus
"/*Problem Statement: 
 You are given a number n, your job is to find all the n balanced parenthesis
 combinations possible */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /*Function description : 
 At any index i, 
 BASE CASE : 
 The combination of brackets can at maximum reach 2*n length
 therefore, if index reaches 2*n then print combination
 RECURSIVE CASE:
 1) If an open bracket is to be generated in the combination then,
 	count of(open) bracket should be less than n
 2) If a closed bracket is to be generated in the combination then,
 	count of(close) bracket should be less than count of(open) bracket */
 
 void FindValidParenthesis(char *out, int n, int index, int open, int close)
 {
 	if (index == 2 *n)
 	{
 		out[index] = '\0';
 		cout << out << endl;
 		return;
 	}
 
 	//If the number of open brackets is less than n
 	if (open < n)
 	{
 		out[index] = '(';
 		FindValidParenthesis(out, n, index + 1, open + 1, close);
 	}
 
 	//If the number of close brackets is less than the number of open brackets
 	if (close < open)
 	{
 		out[index] = ')';
 		FindValidParenthesis(out, n, index + 1, open, close + 1);
 	}
 
 	return;
 }
 
 int main()
 {
 	int n;
 	cin >> n;
 	char out[1000];
 	int index = 0;
 	FindValidParenthesis(out, n, 0, 0, 0);
 	return 0;
 }
 
 /*Examples : 
 1)Input : n = 2
 Output-
 (())
 ()()
 2)Input : n = 3
 Output-
 ((()))
 (()())
 (())()
 ()(())
 ()()()
 
 Time Complexity : O(2^n)
 Space Complexity : O(n) */
 
",C-Plus-Plus
"import java.util.*;
 
 public class Linear_search {
 	//It iterates through the array to find key.
 	//The average and worst case time complexity O(n).
 	//The worst case space complexity is O(1).
 	static int linSearch(int[] a, int k, int length) {
 		for (int i = 0; i < length; i++) {
 			if (a[i] == k)
 				return i + 1; //returns position
 		}
 		return -1; //returns -1 if not found
 	}
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 		System.out.print(""Enter the length of the array: "");
 		int length = sc.nextInt();
 		int arr[] = new int[length];
 		System.out.print(""Enter array values: "");
 		for (int i = 0; i < length; i++) {
 			arr[i] = sc.nextInt();
 		}
 		System.out.print(""Enter the value whose index needs to be searched: "");
 		int value = sc.nextInt();
 		System.out.println(""Index of "" + value + "" is: "" + linSearch(arr, value, length));
 	}
 }
 /*
 Input:
 Enter the length of the array: 5
 Enter array values: 2 7 8 9 1
 Enter the value whose index needs to be searched: 9 
 output:
 Index of 9 is: 4
 */
",Java
"/*
 AIM : A string is provided with some parenthesis and we need to print whether it is balanced or not.
 Approach : We will use a stack. We will push the starting parenthesis i.e. { or ( or [
 and we will pop the ending parenthesis. Now, if the popped parenthesis is not equivalent to the 
 starting one then the parenthesis is not matching else it's a match.
 Also, at the end of the traversal, if our stack is not empty then the parenthesis is not matching.
 */
 #include<stdio.h>
 #include<stdlib.h>
 
 /*Decleartion of stack-structure*/
 struct arraystack
 {
     int top;
     int capacity;
     char *ptr;
 };
 /*Function that creates a stack-node and returns pointer to the stack*/
 struct arraystack* createstack()
 {
     struct arraystack *stackblock;
     stackblock=malloc(sizeof(struct arraystack));
     stackblock->capacity=50;
     stackblock->top=-1;
     stackblock->ptr=malloc(sizeof(char)*stackblock->capacity);
     return(stackblock);
 }
 /*Function to return the top of the stack*/
 char stacktop(struct arraystack *stack)
 {
     return stack->ptr[stack->top];
 }
 /*Function to check if the stack is empty or not*/
 int isEmpty(struct arraystack *stack)
 {
     if(stack->top == -1)
         return 1;
     else
         return 0;
 }
 /*Function to check if the stack is full or not*/
 int isFull(struct arraystack *stack)
 {
     if(stack->top == stack->capacity-1)
         return 1;
     else
         return 0;
 }
 /*Function to push data into the stack*/
 void push(struct arraystack *stack,char data)
 {
     if(isFull(stack))
         printf(""\nStack overflow!\n"");
     else
     {
         stack->top++;
         stack->ptr[stack->top]=data;
     }
 }
 /*Function to pop or delete data from the stack*/
 char pop(struct arraystack *stack)
 {
     if(isEmpty(stack))
     {
         printf(""\nStack underflow!\n"");
         return -1;
     }
     else
     {
         char y;
         y=stack->ptr[stack->top];
         stack->top--;
         return y;
     }
 }
 /*",C
"/*
 
 A singly linked list is collection of nodes wherein each node has 2 parts: data and a pointer to the next node. 
 The list terminates with a node pointing at null. Below is the program to add nodes dynamically in Singly Linked List.
 
 In this program, user can provide a choice to perform operations on a Singly Linked List. It is created using a ES6 class syntax. 
 prompt & colors are node packages for taking user input and displaying text in different colors respectively. 
 
 */
 
 const prompt = require(""prompt-sync"")({ sigint: true });
 const colors = require(""colors"");
 
 // Setting the Color schema
 colors.setTheme({
   display: ""green"",
   insert: ""white"",
   delete: ""red"",
   leave: ""yellow"",
   end: ""rainbow"",
   wrong: ""america"",
 });
 
 // Creating the node class to create nodes
 class Node {
   constructor(value, next = null) {
     this.value = value;
     this.next = next;
   }
 }
 
 // Creating Linked List class to perform operations
 class LinkedList {
   constructor(value) {
     this.head = {
       value: value,
       next: null,
     };
 
     this.tail = this.head;
     this.length = 1;
   }
 
   // Looping to a given index in Linked List
   traverseToIndex(index) {
     let counter = 1;
     let currentNode = this.head;
 
     while (counter !== index) {
       currentNode = currentNode.next;
       counter++;
     }
 
     return currentNode;
   }
 
   // Appending (at the end) node in linked list
   append(value) {
     const newNode = new Node(value);
 
     this.tail.next = newNode;
     this.tail = newNode;
     this.length++;
 
     return this;
   }
 
   // Prepending ( at the beginning ) of linked list
   prepend(value) {
     const newNode = new Node(value);
 
     newNode.next = this.head;
     this.head = newNode;
     this.length++;
 
     return this;
   }
 
   // Inserting node at a given position in linked list
   insert(index, value) {
     if (index === 1) return this.prepend(value);
     else if (index > this.length) ret",JavaScript
"/*
 Given an ab rectangle, your task is to cut it into squares. On each move you can select a rectangle and cut it into two
 rectangles in such a way that all side lengths remain integers. What is the minimum possible number of moves?
 
 Input
 
 The only input line has two integers a and b.
 
 Output
 
 Print one integer: the minimum number of moves.
 
 Constraints
 
 1a,b500
 
 Example
 
 Input:
 3 5
 
 Output:
 3
 
 */
 
 /*
                                 APPROACH
             ----------------------------------------------------
             We will make all the horizontal cuts and try to find 
             after which move we have to make minimum moves to make 
             all squares,
             Similarly,
             We do the same with vertical moves,
             We will divide the recetanle in two parts and add the 
             result for both parts and find minimum among all moves
             which will be our ans.
 
 */
 #include <iostream>
 using namespace std;
 int dp[501][501]; //declaring dp array for memorization.
 int cutting(int a,int b)
 {
     //if side lengths are equal then no move required.
     if(a==b)
     return 0;
     //for a by 1 or 1 by b rectangle we have to make a-1 and b-1 cuts respectively.
     if(a==1 || b==1)
     return max(a,b)-1;
 
     //if the result is stored already return it.
     if(dp[a][b]!=-1)
     return dp[a][b];
 
     int ans=INT_MAX;
     
     //recursivly making cuts.
     //loop to make all the horizontal cuts
     /*
         iterate upto a/2 only wwwww
     */
     for(int i=1;i<=a/2;i++)
     {
         //making every position move and taking the minimum out of it.
         ans=min(ans,cutting(i,b)+cutting(a-i,b));
     }
     
     //loop to make all the vertical cuts
     for(int i=1;i<=b/2;i++)
     {
         //making every position move and taking the minimum out of it.
         ans=min(ans,cutting(a,i)+cutting(a,b-i));
     }
     return dp[a][b]=1+ans; //this 1 corressponds to one of",C-Plus-Plus
"""""""Julia program to check if a number is a Krishnamurthy number or not.
 Krishnamurthy Number is a number whose sum of the factorial of digits
 is equal to the number itself. The Number is named after Jiddu Krishnamurti.
 """"""
 
 # Helper function to return the factorial of a number
 function factorial(num)
     if ( num == 1 || num == 0 )
         return 1
     end
     return num * factorial( num - 1)
 end
 
 """""" Extract each digit of the given number and calculate the sum of the
     factorial of each digit present in the given number""""""
 function check_krishnamurthy_number(num)
     temp = num
     sum = 0
     while(temp > 0)
         rem = temp % 10
         sum = sum + factorial(rem)
         temp = temp  10
     end
     return sum
 end
 
 
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 sum = check_krishnamurthy_number(num)
 if sum == num
     println(""The given number $num is a Krishnamurthy Number."")
 else
     println(""The given number $num is not a Krishnamurthy Number."")
 end
 
 
 """"""
 Time Complexity: O(n*log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number: 3124
 The given number 3124 is not a Krishnamurthy Number.
 
 SAMPLE 2
 
 Enter the number: 145
 The given number 145 is a Krishnamurthy Number.
 """"""
",Julia
"/* Java Program to Find Laplacian Matrix of an Undirected Graph
 FORMULA USED :
 Laplacian matrix = Degree matrix  Adjacency matrix
 
 BASIC DEFINITIONS:
 Adjacency matrix: Value can be either 0 or 1 according to graph vertices are connected to each other. 
 Degree matrix: Number of vertices adjacent to a vertex.
 
 NOTE:
 This code contains pre defined values. To get the user defined values, use Scanner class.
 */
 public class LaplacianMatrix {
     class Edge {
         int src, dest;
     }
     int vertices, edges;
     Edge[] edge;
     LaplacianMatrix(int vertices, int edges)
     {
         this.vertices = vertices;
         this.edges = edges;
         edge = new Edge[edges];
         for (int i = 0; i < edges; i++) {
             edge[i] = new Edge();
         }
     }
     public static void main(String[] args)
     {
         int i, j;
         int numberOfVertices = 6;
         int numberOfEdges = 7;
         int[][] adjacency_matrix = new int[numberOfEdges][numberOfEdges];
         int[][] degree_matrix = new int[numberOfEdges][numberOfEdges];
         int[][] laplacian_matrix = new int[numberOfEdges][numberOfEdges];
         LaplacianMatrix g = new LaplacianMatrix(numberOfVertices, numberOfEdges);
         // Adding edges with source and destination
         g.edge[0].src = 1;
         g.edge[0].dest = 2; 
         g.edge[1].src = 1;
         g.edge[1].dest = 5;
         g.edge[2].src = 2;
         g.edge[2].dest = 3;
         g.edge[3].src = 2;
         g.edge[3].dest = 5;
         g.edge[4].src = 3;
         g.edge[4].dest = 4;
         g.edge[5].src = 4;
         g.edge[5].dest = 6;
         g.edge[6].src = 5;
         g.edge[6].dest = 4;
   
         // Adjacency Matrix
         for (i = 0; i < numberOfEdges; i++) {
             for (j = 0; j < numberOfEdges; j++) {
                 adjacency_matrix[g.edge[i].src][g.edge[i].dest] = 1;
                 adjacency_matrix[g.edge[i].dest][g.edge[i].src] = 1;
             }
         }
         System",Java
"/*
 Staircase Search is used to search for a key in a 2D Array whose row and column elements are sorted.
 	* The idea is to remove a row or a column in each comparison until an element is found. 
 	* Searching is started from the top-right corner of the matrix and has three possible cases: 
 		1. The key is greater than the current element, this means, that all the elements in the current row are smaller than the key.
        So, the row can be skipped and move to next row.
 		2. The key is smaller than the current number, this means, that all the elements in the current column are greater than the key.
        So, the column can be skipped and move to previous column.
 		3. The key is equal to the current number, this means, the key is found.
 	* If the bounds of the 2D Array are reached, this means, the key is not found.
 */
 
 #include<stdio.h>     
 #include<stdlib.h>    
 
 void staircase_search(int** matrix, int n, int m, int key) {
 
 	int is_found=0;
 	// Start from top right corner
 	int i = 0, j = m - 1;
 
 	// To search for a element until the indices satisfy the matrix bounds
 	while (i <= n - 1 && j >= 0) {
 
 		if (matrix[i][j] == key) {
 
 			// If key is found
 			printf(""Element fouund at : %d %d\n"",i,j);
 			is_found = 1;
 			break;
 
 		} else if (matrix[i][j] > key) {
 
 			// If current element is greater than the key, then the current column can be skipped and move to previous column
 			j--;
 
 		} else {
 
 			// If current element is lesser than th key, then the current row can be skipped and move to next row
 			i++;
 
 		}
 
 	}
 
 	// If the element is not found
 	if (!is_found)
 		printf(""Element not found\n"");
 }
 
 
 int main() {
 
 	// Take in input
 	int n, m,ele,i,j;
 	printf(""Enter the dimensions of the array: "");
 	scanf(""%d %d"",&n,&m);
   
 	printf(""Enter the element to be searched: "");
 	scanf(""%d"",&ele);
 	
   // Declare 2D Matrix dynamically
 	int** a = (int **)malloc(n*sizeof(int *));
 	for (i = 0; i < n; i++) {
 		a[i] = (in",C
"// C program to implement Matrix Multiplication
 #include <stdio.h>
 void matrix_mult(int [][10],int [][10],int [][10],int,int,int,int);
 int main()
 {
     int r1, c1, r2, c2;
     printf(""Enter the number of rows and columns of the first matrix:  "");
     scanf(""%d %d"", &r1, &c1);
     printf(""Enter the number of rows and columns of the second matrix: "");
     scanf(""%d %d"", &r2, &c2);
 
     //If the number of columns of the second matrix and the number of rows of first matrix differ, they cannot be added
     if (c1 != r2)
     {
         printf(""Given Matrices cannot be multiplyable!!!"");
         return 0;
     }
 
     int A[10][10], B[10][10], C[10][10];
     // Input the values of the matrices
     printf(""Enter the values of the first matrix\n"");
     for (int i = 0; i < r1; i++)
     {
         for (int j = 0; j < c1; j++)
             scanf(""%d"", &A[i][j]);
     }
     printf(""Enter the values of the second matrix\n"");
     for (int i = 0; i < r2; i++)
     {
         for (int j = 0; j < c2; j++)
             scanf(""%d"", &B[i][j]);
     }
     matrix_mult(C,A,B,r1,r2,c1,c2);
     printf(""The resultant matrix is:\n"");
     for (int i = 0; i < r2; i++)
     {
         for (int j = 0; j < c2; j++)
             printf(""%d "", C[i][j]);
         printf(""\n"");
     }
     return 0;
 }
 void matrix_mult(int C[][10],int A[][10],int B[][10],int r1,int r2,int c1,int c2)
 {
     // Multiply both the matrices
     for (int i = 0; i < r1; i++)
     {
         for (int j = 0; j < c2; j++)
         {
             C[i][j] = 0;
             for (int k = 0; k < c1; k++)
                 C[i][j] += A[i][k] * B[k][j];
         }
     }
 
 }
 
 /*
 Time Complexity: O(r1 * c2 * c1), where 'r1' is the number of rows of first matrix and 'c2' is the number of columns 
                  of second matrix and 'c1' is the number of columns of first matrix   
 Space Complexity: O(r1 * c2)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number of rows and columns of the first matrix:  2 2
 Ent",C
"/* Program to find the union of two unsorted array */
 
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Scanner;
 
 public class UnionUnsortedArray {
 
 	public static void main() {
 		Scanner sc = new Scanner(System.in);
 		System.out.println(""Enter n:"");
 		int n = sc.nextInt();
 		int[] array1 = new int[n];
 		int[] array2 = new int[n];
 
 		System.out.println(""Enter array1 elements:"");
 		for(int i = 0 ; i < n ; i++)
 			array1[i] = sc.nextInt();
 			
 		System.out.println(""Enter array1 elements:"");
 		for(int i = 0 ; i < n ; i++)
 			array2[i] = sc.nextInt();
 
 		unionArray(array1,array2);
 	}
 
 	static void unionArray(int[] array1, int[] array2) {
 		Map<Integer, Integer> map = new HashMap<Integer,Integer>();
 		// insert elements of array1 in the map
 		for(int i = 0 ; i < array1.length ; i++)
 			map.put(array1[i], i);
 		// insert elements of array1 in the map
 		for(int i = 0 ; i < array2.length ; i++)
 			map.put(array2[i], i);
 		System.out.print(""Union of two unsorted array : "");
 		for(Map.Entry mapElement : map.entrySet())
 			 System.out.print(mapElement.getKey() + "" "");		 
 	}
 }
 
 /*
 Input:
 Enter n:
 4
 Enter array1 elements:
 9 -3 -6 0
 Enter array2 elements:
 -1 -3 -6 1
 
 Output:
 Union of two unsorted array : 0 -1 1 -3 -6 9 
 */
",Java
"import java.util.Scanner;
 
 class Triplet{
 	
 	public int x,y,gcd;
 	public Triplet() {	
 	}
 	
 }
 public class ExtendedEuclidAlgo {
 	
 	public static int euclidAlgo(int a,int b) {
 		if(b==0) {
 			return a;
 		}
 		
 		return euclidAlgo(b, a%b);
 	}
 	
 	public static Triplet extendedEuclid(int a,int b) {
 		if(b==0) {
 			Triplet ans=new Triplet();
 			ans.x=1;
 			ans.y=0;
 			ans.gcd=a;
 			return ans;
 		}
 		
 		Triplet subAns=extendedEuclid(b, a%b);
 		Triplet ans=new Triplet();
 		ans.x=subAns.y;
 		ans.y=subAns.x-(a/b)*subAns.y;
 		ans.gcd=subAns.gcd;
 		
 		return ans;
 	}
 	
 	public static void main(String[] args) {
 		
 		Scanner sc=new Scanner(System.in);
 		int a=sc.nextInt();
 		int b=sc.nextInt();
 		Triplet ans=extendedEuclid(a, b);
 		System.out.println(""Gcd of (""+a+"" , ""+b+"") : ""+ans.gcd);
 	}
 	
 //Sample Input 5 10 
 //Sample Output : Gcd of (5 , 10) : 5
 
 //Sample Input 51 68
 //Sample Output : Gcd of (51 , 68) : 17	
 	
 }
",Java
"/* Insertion Sort using Iteration */
 
 public class InsertionSort{
  
      public static void insertionSort(int[] ar){
        
     //Starting index from index 1 to create sorted array at left side of the array
 
              for(int i = 1; i < ar.length; i++){
                   int j = i-1,k = i;                // Assigning j = i-1 and iterating to 0 in sorted part of the array
                  while(j >= 0 && ar[k] < ar[j]){   // checking if element at index i is smaller than elements in the sorted array and then swap them
                      swap(ar,k,j);                 // swapping elements in the same array by passing ar and indexes i and j
                      j--;
                      k--;
                 }
              }
           }
 
      public static void main(String args[]){
          int[] ar = {19,8,7,6,5,4,3,2,1};
          insertionSort(ar);
 
          for(int i = 0; i < ar.length; i++){
              System.out.print(ar[i]+"" "");
          }
      }
     
      public static void swap(int[] ar, int i , int j){   // swapping elements in the array 
          int temp = ar[i];
          ar[i] = ar[j];
          ar[j] = temp;
      }
 
 }
 
 /* It is an interesting algorithm so I challenge you to apply Insertion Sort using recursion */
 /* Good Luck */
",Java
"/*
 Given a list of cities numbered from 0 to N-1 and a matrix distances consisting of N rows and N columns 
 denoting the distances between each pair of cities, what is the shortest possible route that visits each 
 city exactly once and returns to the starting city?
 */
 
 #include <bits/stdc++.h>
 #include <vector>
 using namespace std;
 
 int getMinDistance(int mask, int currentCity, vector<vector<int>> &dp, vector<vector<int>> &distance)
 {
 	int n = distance.size();
 
 	// All cities being visited.
 	if (mask == (1 << n) - 1)
 	{
 		return distance[currentCity][0];
 	}
 
 	// If the current state (mask, currentCity) is visited before.
 	if (dp[mask][currentCity] != -1)
 	{
 		return dp[mask][currentCity];
 	}
 
 	int ans = 1e9 + 5;
 
 	// Trying for every possible city and computing the shortest possible route.
 	for (int city = 0; city < n; city++)
 	{
 		if ((mask & (1 << city)) == 0)
 		{
 			int tmpAns = distance[currentCity][city] + getMinDistance(mask | (1 << city), city, dp, distance);
 			ans = min(ans, tmpAns);
 		}
 	}
 
 	// Memorizing and return the ans.
 	return dp[mask][currentCity] = ans;
 }
 
 int shortestRoute(vector<vector<int>> &distance)
 {
 	int n = distance.size();
 
 	vector<vector<int>> dp((1 << n) + 1, vector<int>(n + 1, -1));
 
 	// Return the ans returned by getMinDistance.
 	return getMinDistance(1, 0, dp, distance);
 
 }
 
 int main()
 {
     int N;
     cout<<""Enter number of cities: ""<<endl;
     cin>>N;
     cout<<""Enter the distances: ""<<endl;
     vector<vector<int>> distance;
     int val;
     for(int i = 0; i < N; i++){
         vector<int> temp;
         for(int j = 0; j < N; j++){
             cin >> val;
             temp.push_back(val);
         }
         distance.push_back(temp);
         temp.clear();
     }
     cout<<""The shortest possible route that visits each city exactly once and returns to the starting city: ""<<endl;
     cout<<shortestRoute(distance);
 }
 
 /*
     Time Complexity : O(2^N * N)
     Space",C-Plus-Plus
"/*Problem Statement: 
 A robot is designed to move on a rectangular grid of M rows and N columns. 
 The robot is initially positioned at the top-left cell. 
 The robot has to reach the (M, N) grid cell. In a single step, 
 robot can move only to the cells to its immediate east and south directions. 
 That means if the robot is currently at (i, j), it can move to either (i + 1, j) or (i, j + 1) cell, 
 provided the robot does not leave the grid.
 Now somebody has placed several obstacles in random positions on the grid, 
 through which the robot cannot pass. The positions of the blocked cells are initialised to -1 in the matrix. 
 Your task is to count the number of paths that the robot can take to move from (0, 0) to (M, N). */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int numWays(int row,int col, int dp[10][10])
 {
     if(dp[0][0]==-1)
     {
         return 0;
     }
     for(int i=0;i<col;i++)
     {
         if(dp[0][i]==-1)
         {
             break;
         }
         dp[0][i]=1;
     }
     for(int j=0;j<row;j++)
     {
         if(dp[j][0]==-1)
         {
             break;
         }
         dp[j][0]=1;
     }
     for(int i=1;i<row;i++)
     {
         for(int j=1;j<col;j++)
         {
             if(dp[i][j]==-1)
             {
                 continue;
             }
             dp[i][j]=0;
             if(dp[i][j-1]!=-1)
             {
                 dp[i][j]=dp[i][j-1];
             }
             if(dp[i-1][j]!=-1)
             {
                 dp[i][j]=(dp[i][j]+dp[i-1][j]);
             }
         }
     }
     return dp[row-1][col-1];
 }
 
 int main()
 {
     int row,col;
     int arr[10][10],dp[10][10]={0};
     cout<<""Enter row and column respectively: ""<<endl;
     cin>>row>>col;
     cout<<""Enter matrix elements: ""<<endl;
     for(int i=0;i<row;i++)
     {
         for(int j=0;j<col;j++)
         {
             cin>>arr[i][j];
         }
     }
     cout<<""The number of paths: ""<<numWays(row,col,dp)<<endl;
     return 0",C-Plus-Plus
"/* This function written in Go sorts the array using shell sort algorithm.
 This algorithm is a generalized version of insertion sort. Shell sort first
 sorts the elements far apart from each other and successively reduces the
 interval between the elements to be sorted.*/
 
 package main
 
 import (
 	""fmt""
 )
 
 // This function prints the sorted array
 func printArray(array []int, number int) {
 	fmt.Print(""\nSorted array: "")
 	for i := 0; i < number; i++ {
 		fmt.Print(array[i], "" "")
 	}
 	fmt.Print(""\n"")
 }
 
 // This function sorts array using shell sort algorithm
 func ShellSort(array []int, number int) {
 
 	// Start with interval n / 2
 	var interval int = number / 2
 
 	// After each iteration, divide the interval by 2
 	for interval > 0 {
 		for i := interval; i < number; i++ {
 			// Value to be inserted
 			insert := array[i]
 			j := i
 			/* Shift heavier elements towards right making it easy
 			for further iterations*/
 			for j >= interval && array[j - interval] > insert {
 				array[j] = array[j - interval]
 				j = j - interval
 			}
 			// Insret the element
 			array[j] = insert
 		}
 		interval = interval / 2
 	}
 	// Print the final sorted array
 	printArray(array, number)
 }
 
 func main() {
 
 	// Take length of array as input from the user
 	var number int
 	fmt.Print(""Enter the length of the array: "")
 	fmt.Scan(&number)
 
 	// Take elements of array as input from the user
 	fmt.Print(""Enter the elements of the array followed by spaces: "")
 	array := make([]int, number)
 	for i := 0; i < number; i++ {
 		fmt.Scan(&array[i])
 	}
 
 	// Call the sorting function
 	ShellSort(array, number)
 }
 
 /*
 
 Sample I/O:
 
 Enter the length of the array: 7
 Enter the elements of the array followed by spaces: 7 2 4 9 3 5 1
 
 Sorted array: 1 2 3 4 5 7 9
 
 Time Complexity - O(n^2)
 
 Space Complexity - O(n)
 
 */
 
",Go
"//C program to implement Euclid's Algorithm to find greatest common divisor
 
 #include<stdio.h>
 
 // It is a recursive function that calculates greatest common divisor or hcf of 2 
 // integer numbers a and b 
 // GCD of two numbers is the largest number that divides both of them.
 // A simple way to find GCD is to factorize both numbers and multiply common factors.
 
 int gcd(int a,int b)
 { //base case
   if (a==0)
      return b;
   //recursive case
   else
      return gcd(b%a,a);
 }
 
 //initializing a and b.
 //Here a is always the smaller number and
 // b is always the bigger number between the two.
 
 int main()
 {  int a = 10, b = 15; 
     printf(""GCD(%d, %d) = %d\n"", a, b, gcd(a, b));  //should print 5
     a = 35, b = 10; 
     printf(""GCD(%d, %d) = %d\n"", a, b, gcd(a, b)); //should print 5
     a = 31, b = 2; 
     printf(""GCD(%d, %d) = %d\n"", a, b, gcd(a, b)); //should print 1
     return 0; 
 }
",C-Plus-Plus
"/*
 The next prime number p of a number n is a number such that
 - p is greater than n.
 - p is a prime number.
 - There are no prime numbers between n and p.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int next_prime(int n){
     int p = n + 1;
     if(p<=1){
         return 2;
     }
     while(true){
         //consider that p is not a composite number
         bool flag = false;
         for(int i=2; i<=floor(n/2)+1; i++){
             //found a factor other than 1 or p
             if(p%i==0){
                 p = p + 1;
                 //p is composite
                 flag = true;
                 break;
             }
         }
         //p is prime
         if(flag==false){
             return p;
         }
     }
 }
 
 int main(){
     int n;
     cout<<""Enter a number : "";
     cin>>n;
     cout<<""Next prime number is ""<<next_prime(n);
 }
 
 /* Sample I/O:
 Enter a number : 55
 Next prime number is 59
 
 Time Complexity : O(n^2)
 Space Complexity : O(1)
 */
",C-Plus-Plus
"/*
 
 Introduction 
 Given a Binary Tree , Print the level with maximum sum , and its corresponding sum.
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 A function which returns the level with maximum sum and its corresponding sum.
 
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h> 
 using namespace std;
 // Declare global variables
 long max_level;
 long max_sum;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Function to update level with maximum sum and its corresponding sum
 void FindMaxSum(struct Node* root)
 {
     //Initi",C-Plus-Plus
"/*Given an unweighted rooted tree which consists of N nodes, find the largest distance between 2 nodes in a tree.
 Since this is a tree, there will be a unique path between any 2 nodes.
 The tree is given in the form of an array A, there is an edge connecting A[i] and i.
 A[0] will be -1, since it denotes the root node
 
 The approach is to use DFS here, first we will find the node which is at farthest distance from the root node by DFS
 After this we will take this new node and run DFS from it to the farthest node.
 The distance between these 2 nodes is the answer
 It can be proven that the node found to be farthest from root node, has to be one of the end points of the largest distance path*/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /*We maintain a visited array to keep track of what all nodes have already been visited
   And an adjacency list(adj) can be formed using the given input array(A)*/
 int visited[40010];
 vector<int> adj[40010];
 vector<int> A;
 
 //mx stores the answer at all times
 int mx;
 
 /*DFS function runs a DFS from the source node (node), and keeps updating the max distance until all nodes are visited
   nd stores the node which is found to be at farthest distance from the source node (node)*/
 void dfs(int node, int dist, int& nd)
 {
     if (dist > mx) {
         mx = dist;
         nd = node;
     }
 
     visited[node] = 1;
     for (int i = 0; i < adj[node].size(); i++) {
         //If any node in the source node's adjacency list is found to be unvisited, we call a DFS with that node as a source and distance dist+1
         int s = adj[node][i];
         if (visited[s]) {
             continue;
         }
         dfs(s, dist + 1, nd);
     }
 }
 
 //solve function calls DFS twice as discussed above
 int solve(int n)
 {
 
     //If there is only one node, then the largest distance from that node is 0
     if (n == 1) {
         return 0;
     }
 
     //Call DFS from root node
     mx = 0;
     int nd = -1;
     dfs(0, 0, nd);",C-Plus-Plus
"import math
 '''RSA is an encryption algorithm, used to
 securely transmit messages over the internet.
 It is based on the principle that it is easy to multiply large numbers,
 but factoring large numbers is very difficult.
 '''
 
 
 def inverse_mod(p, m):
     p = p % m
     for i in range(1, m):
         if(p * i) % m == 1:
             return i
     return 1
 
 if __name__ == '__main__':
     '''p and q  are prime numbers. pt is plain text.
     e is derived number which lies between 1 and (p-1)*(q-1)
     '''
     p, q, e, pt = [int(x) for x in input(""Enter\
     p, q, e and plaintext: "").split()]
     n = p * q
     fn = (p-1) * (q-1)
     d = inverse_mod(e, fn)
     ct = pow(pt, e, n)
     print(f'Encryption for PlainText = {pt}, is CipherText = {ct}')
     new_pt = pow(ct, d, n)
     print(f'Decryption for CipherText = {ct}, is PlainText = {new_pt}')
 
 '''Sample input and output
 Enter p, q, e and plaintext: 7 13 5 10
 Encryption for PlainText = 10, is CipherText = 82
 Decryption for CipherText = 82, is PlainText = 10
 
 Complexities
 time: O(n)
 space: O(1)
 '''
",Python
"#include <bits/stdc++.h>
 using namespace std;
 /*
 Manacher's Algorithm is used to the find all the pairs (i,j) such that substring s[ij] is a palindrome.
 */
 
 int main() {
     string str;
     cin>>str;
     int n=str.size();
     vector<int> d1(n), d2(n); //d1 - odd length palindrome, d2 - even length palindrome
     for(int i=0, l=0, r=-1; i<n; ++i) {
         int k;
         if(i>r)
             k=1;
         else
             k=min(d1[l+r-i],r-i+1);
         while(0<=i-k && i+k<n && str[i-k]==str[i+k]){
             k++;
         }
         d1[i]=k--;
         if(i+k>r){
             l=i-k;
             r=i+k;
         }
     }
     for(int i=0, l=0, r=-1; i<n; ++i){
         int k;
         if(i>r)
             k=0;
         else
             k=min(d2[l+r-i+1],r-i+1);
         while(0<=i-k-1&&i+k<n&&str[i-k-1]==str[i+k]){
             k++;
         }
         d2[i]=k--;
         if(i+k>r){
             l=i-k-1;
             r=i+k ;
         }
     }
     int ans=0;
     cout<<""Following are the pairs which are palindromes: \n"";
     for(int i=0; i<n; ++i){
         int x=d1[i];
         while(x){
             ans=max(ans, 2*x-1);
             cout<<i-x+1<<"" ""<<i+x-1<<""\n"";
             x--;
         }
     }
     for(int i=0; i<n; ++i){
         int x=d2[i];
         while(x){
             ans=max(ans, 2*x);
             cout<<i-x<<"" ""<<i+x-1<<""\n"";
             x--;
         }
     }
     cout<<""Length of longest palindromic substring: ""<<ans;
     return 0;
 }
 
 /*
 Time Complexity: O(N)
 Space Complexity: O(N)
 
 INPUT
 abcba
 
 OUTPUT
 Following are the pairs which are palindromes: 
 0 0
 1 1
 0 4
 1 3
 2 2
 3 3
 4 4
 Length of longest palindromic substring: 5
 
 
 INPUT
 abba
 
 OUTPUT
 Following are the pairs which are palindromes: 
 0 0
 1 1
 2 2
 3 3
 0 3
 1 2
 Length of longest palindromic substring: 4
 */
",C-Plus-Plus
"/*
 __Rat In A Maze Problem__
 Given a maze in the form of a matrix of size m * n. Each cell is either clear or blocked denoted by 1 and 0 respectively.
 A rat sits at the top-left cell (matrix[0][0]) and there exists a block of cheese at the bottom-right cell (matrix[m-1][n-1]). Both these cells are guaranteed to be clear.
 Find if the rat can get the cheese if it can move only in one of the two directions - down and right. It cant move to blocked cells.
 
 Input:
 2 integers m and n denoting rows and columns
 Next m lines contain n space-separated integers which are either 0 or 1
 
 Output:
 single line containing 1 or 0 based on whether the rat can get the cheese or not respectively.
 */
 
 import java.util.*;
 
 public class RatInAMaze{
 
     //global variable to store whether possible to reach cheese
     static boolean solution = false;
 	
     //check if position maze[i][j] is free and lies on the grid
 	private static boolean safestate(int[][] maze, int m, int n, int i, int j){
 		if(i >= m || j>= n || maze[i][j]!=1) return false;
 		return true;
 	}
 
 	private static void CheeseFinder(int[][] maze, int m, int n, boolean[][] visited, int i, int j){
 		//base case
         if(i == m-1 && j == n-1){
             solution=true; 
             return;
         }
         //mark current position as visited
 		visited[i][j] = true;
         //move down (backtracking)
 		if(safestate(maze,m,n,i+1,j) && !visited[i+1][j]) CheeseFinder(maze, m,n,visited,i+1,j);
         //move right (backtracking)
 		if(safestate(maze,m,n,i,j+1) && !visited[i][j+1]) CheeseFinder(maze,m,n,visited,i,j+1);
 		visited[i][j] = false;
 		return;
 	}
 
 	public static boolean canGetCheese(int[][] maze){
 		solution = false;
 		int m = maze.length;
 		int n = maze[0].length;
 		boolean[][] visited = new boolean[m][n];
 		CheeseFinder(maze, m, n, visited, 0, 0);
 		if(!solution) return false;
 		return true;
 	}
 
     public static void main(String[] args){
         Scanner inp = new Scan",Java
"#The BoyerMoore majority vote algorithm is an algorithm for finding the majority of a sequence of elements using linear time and constant space.
 def counting_fun(array):
     count_temp = 0                       # stores occurence count
     for i in range(0, len(array)):
         count_temp = array.count(array[i])   # Counts the occurence
         if count_temp > number/2:
             print(f""Number occuring more than n/2 is :{array[i]}"")
             count_temp = ""True""
             break
     if(count_temp != ""True""):
         print(""No Element occuring more than n/2"")
 number = int(input(""Enter Number of values you will enter(eg.6): ""))
 i = 0
 list_1 = []                         # List Declaration
 print(f""Enter {number} values: "")
 for i in range(0, number):
     elements = int(input())
     list_1.append(elements)         # adding element to the list
 
 counting_fun(list_1)
 
 # Output:
 # Enter 6 values:
 # 1
 # 1
 # 1
 # 1
 # 4
 # 2
 # Number occuring more than n/2 is: 1
 # Time Complexity : o(n) , Space Complexity : o(1)
",Python
"#include <cstring>
 #include <iostream>
 using namespace std;
 
 #define INF 9999999
 
 // number of vertices in grapj
 #define V 5
 
 // create a 2d array of size 5x5
 //for adjacency matrix to represent graph
 
 int G[V][V] = {
   {0, 9, 75, 0, 0},
   {9, 0, 95, 19, 42},
   {75, 95, 0, 51, 66},
   {0, 19, 51, 0, 31},
   {0, 42, 66, 31, 0}};
 
 int main() {
   int no_edge;  // number of edge
 
   // create a array to track selected vertex
   // selected will become true otherwise false
   int selected[V];
 
   // set selected false initially
   memset(selected, false, sizeof(selected));
 
   // set number of edge to 0
   no_edge = 0;
 
   // the number of egde in minimum spanning tree will be
   // always less than (V -1), where V is number of vertices in
   //graph
 
   // choose 0th vertex and make it true
   selected[0] = true;
 
   int x;  //  row number
   int y;  //  col number
 
   // print for edge and weight
   cout << ""Edge""
      << "" : ""
      << ""Weight"";
   cout << endl;
   while (no_edge < V - 1) {
     //For every vertex in the set S, find the all adjacent vertices
     // , calculate the distance from the vertex selected at step 1.
     // if the vertex is already in the set S, discard it otherwise
     //choose another vertex nearest to selected vertex  at step 1.
 
     int min = INF;
     x = 0;
     y = 0;
 
     for (int i = 0; i < V; i++) {
       if (selected[i]) {
         for (int j = 0; j < V; j++) {
           if (!selected[j] && G[i][j]) {  // not in selected and there is an edge
             if (min > G[i][j]) {
               min = G[i][j];
               x = i;
               y = j;
             }
           }
         }
       }
     }
     cout << x << "" - "" << y << "" :  "" << G[x][y];
     cout << endl;
     selected[y] = true;
     no_edge++;
   }
 
   return 0;
 }
",C-Plus-Plus
"package main
 
 import (
 	""fmt""
 	""math""
 )
 
 // Surface area of a Cone
 
 func cone(r, l float64) float64 {
 	return (math.Pi * r * r) + (math.Pi * r * l)
 }
 
 // Surface area of a Cube
 
 func cube(a float64) float64 {
 	return 6.0 * a * a
 }
 
 // Surface area of a Cuboid
 
 func cuboid(a, b, c float64) float64 {
 	return 2.0 * ((a * b) + (b * c) + (c * a))
 }
 
 // Surface area of a Cylinder
 
 func cylinder(r, h float64) float64 {
 	return (2.0 * (math.Pi * r * r)) + (r * h)
 }
 
 // Surface area of a Pyramid
 
 func pyramid(l, b, h float64) float64 {
 	return (l * b) + (l * math.Sqrt((b/2.0*b/2.0)+(h*h))) + (b * math.Sqrt((l/2.0*l/2.0)+(h*h)))
 }
 
 // Surface area of a Rectangular Prism
 
 func rectangular_prism(l, b, h float64) float64 {
 	return 2.0 * (l*b + l*h + b*h)
 }
 
 // Surface area of a Sphere
 
 func sphere(r float64) float64 {
 	return 4.0 * math.Pi * r * r
 }
 
 // Surface area of a Hemisphere
 
 func hemisphere(r float64) float64 {
 	return (2.0 * math.Pi * r * r) + (math.Pi * r * r)
 }
 
 func main() {
 	fmt.Println(cone(3.0, 5.0))
 	fmt.Println(cube(4.0))
 	fmt.Println(cuboid(4.0, 6.0, 2.5))
 	fmt.Println(cylinder(3.5, 5.0))
 	fmt.Println(pyramid(4.0, 7.0, 5.5))
 	fmt.Println(rectangular_prism(4.0, 3.5, 6.5))
 	fmt.Println(sphere(4.0))
 	fmt.Println(hemisphere(4.5))
 }
 
 // Time Complexity - O(1)
 // Space Complexity - O(1)
",Go
"""""""
 Query : Arrange The String
 Task:
 Input a string S (assume lowercase letters) and arrange the letters of the string in such a way that no two adjacent letters are same.
 If multiple answers exist, output anyone of them.
 else print ""IMPOSSIBLE"".
 Input is a string S
 Output the organized string as per the algorithm.
 We will use :
  1) heap data structure thus importing heapq
     In python we dont have max heap thus implementing through min heap by 
     inserting the negation of the value
  2) OrderedDict to store the frequencies of the letters in the input string
 """"""
 import heapq
 from collections import OrderedDict
 
 if __name__ == ""__main__"":
     #Input the string
     input_string = input(""Enter a string:"")
     len_input = len(input_string)
     
     # Initialising an Output string
     output_string = """"
     
     # Initialising an OrderedDict
     od = OrderedDict()
     
     #Inserting the frequency of the corresponding letter as a key,value pair
     for ch in input_string:
         if ch not in od:
             od[ch] = -1
         else:
             od[ch] -= 1
         
     
     flag = True
     # Initialising a list of value , key pair
     freq_heap=[]
     
     # Heapify the list
     for key,value in od.items():
         heapq.heappush(freq_heap, (value , key))
     
     # Pop two elements and add it to the result.
     # Push the popped elements back into the priority_queue if absolute of their their frequencies are greater than 1 
     # and decrease the frequency of the popped elements by 1 (i.e. +1 as they are negative values)
     while len(freq_heap) > 1:
         char1 = heapq.heappop(freq_heap)
         char2 = heapq.heappop(freq_heap)
 
         output_string = output_string + char1[1]
         output_string = output_string + char2[1]
 
         if abs(char1[0]) > 1:
             heapq.heappush(freq_heap, (char1[0] + 1, char1[1]))
 
         if abs(char2[0]) > 1:
             heapq.heappush(freq_heap, (char2[0] + 1, char2[",Python
"/*
 Minimum Sum Partition using dp.
 In this problem we have to find minimum difference of two subset.
 We have to divide array in two subsets in such a way that difference of both subsets 
 will become minimum.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 int minimumSumPartition(int arr[], int sum, int N)
 {
     bool DP[N + 1][sum + 1];
 
     /* if j is 0 i.e. sum is 0 and i i.e. arr has whatever values it will always return true
     because if sum is 0 then we don't need to find if subset of array is equal to sum or not */
     for (int i = 0; i <= N; i++) 
         DP[i][0] = true; 
   
     /* But if i is 0 i.e array has no value and sum has some value then we can nver make 
     subset of array value equal to sum so it will always give false */
     for (int i = 1; i <= sum; i++) 
         DP[0][i] = false;
 
     for (int i = 1; i <= N; i++)
     {
         for (int j = 1; j <= sum; j++)
         {
             if (arr[i - 1] <= j)
                 DP[i][j] = DP[i-1][j-arr[i-1]] || DP[i-1][j];
             else 
                 DP[i][j] = DP[i-1][j];
         }
     }
     int i = sum;
     while(! DP[N][i])
         i--;
     
     // then we will return minimum difference
     return 2*sum - 2*i;
     
 }
 
 int main()
 {
     int N, ans;
 
     cout << ""Enter the value of N: \n"";
     cin >> N;
     int arr[N], sum = 0;
 
     //We will find the total sum of array to find the range of the array
     cout << ""Enter the value of array: \n"";
     for (int i = 0; i < N; i++)
     {
         cin >> arr[i];
         sum += arr[i];
     }
 
 
    ans = minimumSumPartition(arr, sum/2, N);
 
    if (sum & 1)
         ans++;
 
    cout << ans << ""\n"";
 
    return 0;
 }
 /*
 Sample Output:
 
 Input:
 Enter the value of N:
 4
 Enter the value of array:
 1 6 5 11
 
 Output: 
 1
 
 Time Complexity - O(N*sum)
 Space Complexity - O(N*sum)
 
 */
",C-Plus-Plus
"#include <algorithm>
 #include <iostream>
 #include <vector>
 using namespace std;
 
 #define edge pair<int, int>
 
 class Graph {
    private:
   vector<pair<int, edge> > G;  // graph
   vector<pair<int, edge> > T;  // mst
   int *parent;
   int V;  // number of vertices/nodes in graph
    public:
   Graph(int V);
   void AddWeightedEdge(int u, int v, int w);
   int find_set(int i);
   void union_set(int u, int v);
   void kruskal();
   void print();
 };
 Graph::Graph(int V) {
   parent = new int[V];
 
   //i 0 1 2 3 4 5
   //parent[i] 0 1 2 3 4 5
   for (int i = 0; i < V; i++)
     parent[i] = i;
 
   G.clear();
   T.clear();
 }
 void Graph::AddWeightedEdge(int u, int v, int w) {
   G.push_back(make_pair(w, edge(u, v)));
 }
 int Graph::find_set(int i) {
   // If i is the parent of itself
   if (i == parent[i])
     return i;
   else
     // Else if i is not the parent of itself
     // Then i is not the representative of his set,
     // so we recursively call Find on its parent
     return find_set(parent[i]);
 }
 
 void Graph::union_set(int u, int v) {
   parent[u] = parent[v];
 }
 void Graph::kruskal() {
   int i, uRep, vRep;
   sort(G.begin(), G.end());  // increasing weight
   for (i = 0; i < G.size(); i++) {
     uRep = find_set(G[i].second.first);
     vRep = find_set(G[i].second.second);
     if (uRep != vRep) {
       T.push_back(G[i]);  // add to tree
       union_set(uRep, vRep);
     }
   }
 }
 void Graph::print() {
   cout << ""Edge  :""
      << "" Weight"" << endl;
   for (int i = 0; i < T.size(); i++) {
     cout << T[i].second.first << "" - "" << T[i].second.second << "" : ""
        << T[i].first;
     cout << endl;
   }
 }
 int main() {
     int src, dest, weight;
   Graph g(6);
   for(int i = 0;i<8;i++){
     cout << ""Source : "";
     cin >> src;
     cout << ""Destination : "";
     cin >> dest;
     cout << ""Weight : "";
     cin >> weight;
     g.AddWeightedEdge(src,dest,weight);
     }
   g.kruskal();
   g.print();
   return 0;
 }
 
 /*
 Sample Input ",C-Plus-Plus
"/**
  * Longest Substring with K Distinct Characters
  * Given a string, print the longest possible substring that 
  * has exactly K unique characters. 
  */
 
 import java.io.*;
 public class LongestSubstringDistinctChar {
 
     static final int CHAR_COUNT = 26;
 
     public static String findLongestSubstring(String str, int K) {
 
         String result = """"; 
         int distinct = 0; //Counter for number of distinct letters encountered
 
         int charCount[] = new int[CHAR_COUNT]; //Array maintains current count of each letter
 
         //Variable len stores length of longest valid substring, while start and end
         //are limits of the current window (substring) being considered 
         int len = 0, start=0; 
         for(int end=0; end<str.length();) {
 
             //Updating count of distinct characters
             if(charCount[str.charAt(end) - 'a'] == 0) 
                 distinct++; 
 
             //Updating count of current letter
             charCount[str.charAt(end) - 'a']++; 
             end++;
 
             if(distinct == K) {
                 if((end-start) > len) {
                     len = end-start; 
                     result = str.substring(start, end); 
                 }
             } else if(distinct > K) {
 
                 //If number of distinct characters exceeds K, we shorten the 
                 //substring by removing characters from the front
                 while(distinct > K && start<end) {
                     if(charCount[str.charAt(start) - 'a'] == 1) {
                         distinct--; 
                     }
                     charCount[str.charAt(start) - 'a']--; 
                     start++;
                 }
                 if(distinct == K) {
                     if((end-start) > len) {
                         len = end-start; 
                         result = str.substring(start, end); 
                     }
                 }
 
             }
         }
 
         //In absence of any",Java
"/* The rail fence cipher (also called a zigzag cipher) 
    is a form of transposition cipher. It derives its 
    name from the way in which it is encoded. Given a
    plain-text message and a numeric key, it cipher the
    given text using Rail Fence algorithm(here key == 2). 
 */
 
 package main
 
 import (
 
   ""fmt""
   ""unicode""
   ""bufio""
   ""os""
   ""strings""
 
 )
 
 // Global variables
 var plaintext string
 var ciphertext string
 
 // In this array we store the elements in step wise 
 var array[2][100] string
 var output string
 
 /* This function formats the given ciphertext according to
    the orginal plaintext recieved from the user as input.
    In the monoalphabeticcipher function below, we converet
    the given plaintext into lowercase for our cinvinence of 
    checking. So, the ciphertext we get is also in all 
    lowercase. Here, we format the ciphertext so that wherever
    there is capital letter in the plaintext, same follows 
    in the ciphertext.*/
 func format(temp string) {
 
     /* Checking if the given letter in plaintext is capital 
        or not and changint it to capttal if it was*/
     for i:=0; i < len(temp); i++ {
 
        if (unicode.IsUpper (rune(temp[i]) ) ) {
 
            output += strings.ToUpper(string(ciphertext[i]))
 
        }else {
 
           output += string(ciphertext[i])
 
        }
 
     }
 
 }
 
 /* In this function we store the given plaintext in form of
    step in the 2D array then we concatenate the letters in 
    the first row and then the second row*/
 func railfencecipher() {
 
 
      // storing them step wise
      for i:=0;i<len(plaintext);i++ {
 
         for j:=0;j<2;j++ {
 
              array[j][i] = string(plaintext[i])
 
         }
 
      }
 
      k:=0
      // concatenating the 2 rows
      for k<len(plaintext) {
 
           for a:=0;a<2;a++ {
 
                b := a
                for b<len(plaintext) {
 
                     ciphertext += string(array[a][b])
                     k +=",Go
"#471
 #Pthon implementation of Radomised selection Algorithm
 """"""
 Time Complexity:O(n)
 Space Complexity:O(n)
 """"""
 import random as rand
 
 # This function returns the ith smallest element assuming that the elements are distinct
 def ithSmallestElement(arr, l, r, i):
     #Base condion:arr has just one element
     if l==r:
         return arr[l]
     # If k is smaller than number of
     # elements in array
     if (i > 0 and i <= r - l + 1):
 
         #get position of pivot element in sorted array
         pos = randomPartition(arr, l, r)
 
         # If position is same as k
         if (pos - l == i - 1):
             return arr[pos]
         if (pos - l > i - 1):  # If position is more
             return ithSmallestElement(arr, l, pos - 1, i)
 
             # Else recur for right subarray
         return ithSmallestElement(arr, pos + 1, r,
                            i - pos + l - 1)
 
 # swaping without an extra variable
 def swap(arr, a, b):
     arr[a] = arr[a] + arr[b]
     arr[b] = arr[a] - arr[b]
     arr[a] = arr[a] - arr[b]
 
 # Standard partition process of QuickSort().
 def partition(arr, low, high):
     i = (low - 1)  # index of smaller element
     pivot = arr[high]  # pivot
 
     for j in range(low, high):
 
         # If current element is smaller than the pivot
         if arr[j] < pivot:
             # increment index of smaller element
             i = i + 1
             arr[i], arr[j] = arr[j], arr[i]
 
     arr[i + 1], arr[high] = arr[high], arr[i + 1]
     return (i + 1)
 
 # Picks a random pivot element between l and r for partition of arr
 def randomPartition(arr, l, r):
     n = r - l + 1
     pivot = int(rand.random() % n)
     swap(arr, l + pivot, r)
     return partition(arr, l, r)
 
 # Driver Code
 if __name__ == '__main__':
     size = int(input(""Enter the total number of elements""))
     arr = []
     for i in range(0, size):
         arr.append(int(input(""Enter a element"")))
     i_pos = int(input(""Enter the i'th position""))
",Python
"/*
 
 Problem:
 You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. 
 If a string is longer than the other, append the additional letters onto the end of the merged string.
 Return the merged string.
 
 Input Format:
 The first line consists of an integer T which denotes the number of test cases.
 For each test case we enter two strings to be merged alternatively
 
 Output Format:
 For each test case we get a alternatively merged string.
 
 Explanation:
 First we alternatively add both the strings to the resultant string till the length of the smallest string (both strings can also be equal length). 
 After that we add the substring of the remaining longer string to resultant string if the length of both strings are not equal.
 
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* A function that will take 2 string as input and return the resultant merged string formed alternatively from the inputted strings */
 string mergeAlternately(string word1, string word2) {
     string ans="""";
 
     /* A variable that will take the size of the smallest string among word1 and word2 */
     int less=min(word1.length(),word2.length());    
     int i=0,j=0; 
 
     /* Loop to alternatively add word by word from each string to resultant string */
     while(i<less || j<less){    
         if(j>=i){
             ans+=word1[i];
             i++;
         }
         else{
             ans+=word2[j];
             j++;
         }
     }
 
     /* If both strings are of unequal sizes then add the rest of substring to the resultant string */
     if(word1.length()!=word2.length()){     
         if(word1.length()>less){
             ans+=word1.substr(less,word1.length());
         }
         else{
             ans+=word2.substr(less,word2.length());
         }
     }
 
     return ans;
 }
 
 int main(){
     int t;
     cin>>t;
     while(t--){
         string word1,word2;
         cin>>word1>>word2;
         ",C-Plus-Plus
"
 /* Java Program to implement a stack using two queue */
 
 import java.util.*; 
   
 class Stack_using_Queue { 
   
     static class Stack { 
         // Two inbuilt queues 
         static Queue<Integer> q1 = new LinkedList<Integer>(); 
         static Queue<Integer> q2 = new LinkedList<Integer>(); 
   
         // To maintain current number of elements 
         static int size; 
   
         Stack() 
         { 
             size = 0; 
         } 
   
         static void push(int x) 
         { 
            size++; 
   
             // Push x first in empty q2 
             q2.add(x); 
   
             // Push all the remaining 
             // elements in q1 to q2. 
             while (!q1.isEmpty()) { 
                 q2.add(q1.peek()); 
                 q1.remove(); 
             } 
   
             // swap the names of two queues 
             Queue<Integer> q = q1; 
             q1 = q2; 
             q2 = q; 
         } 
   
         static void pop() 
         { 
   
             // if no elements are there in q1 
             if (q1.isEmpty()) 
                 return; 
             q1.remove(); 
             size--; 
         } 
   
         static int top() 
         { 
             if (q1.isEmpty()) 
                 return -1; 
             return q1.peek(); 
         } 
   
         static int size() 
         { 
             return size; 
         } 
     } 
   
     // driver code 
     public static void main(String[] args) 
     { 
         Scanner sc = new Scanner(System.in);
         Stack s = new Stack(); 
 
         System.out.println(""Enter the limit"");
         int n = sc.nextInt();
         //accepting input from user
         for(int i = 1; i <= n; i++)  
           s.push(i); 
         
         //printing the output
         for(int i = 1; i <= n; i++){
            System.out.println(s.top()); 
            s.pop(); 
         }
   
     } 
 } 
 
 /* Time Complexity : O(n)
    Space Complexity : O(n)
 
    Input
    5
 
    Output
  ",Java
"class Queue {
   constructor() {
     this.items = [];
   }
 
   size() {
     return this.items.length;
   }
 
   enqueue(element) {
     this.items.push(element);
   }
 
   dequeue() {
     if (this.isEmpty()) throw Error(""Underflow"");
 
     return this.items.shift();
   }
 
   front() {
     if (this.isEmpty()) throw Error(""No elements in  the queue"");
 
     return this.items[0];
   }
 
   isEmpty() {
     return this.items.length === 0;
   }
 
   iterate(callback = null) {
     if (callback === null) {
       let str = """";
       for (let i of this.items) {
         str += i + "" "";
       }
       str.trim();
       return str;
     }
 
     const iterated = [];
     for (let i of this.items) {
       iterated.push(callback(i));
     }
 
     return iterated;
   }
 }
 
 // implementation
 let arr = [10, 20, 30, 40, 50];
 let queue = new Queue();
 
 console.log(""Empty size:"", queue.size()); // Returns 0
 
 console.log(""Is empty?"", queue.isEmpty()); // Returns true
 
 try {
   console.log(queue.dequeue()); // Will throw an error
 } catch (err) {
   console.error(""Error for attemtping to dequeue empty queue:"", err.message);
 }
 
 // Add items in the queue
 for (let i of arr) {
   queue.enqueue(i);
 }
 
 console.log(""Added values:"", queue.iterate()); // Displays all elements in the queue.
 
 console.log(""Front:"", queue.front()); // Returns 10
 console.log(""Dequeue:"", queue.dequeue()); // Removes 10 from the queue.
 console.log(""New Front:"", queue.front()); // Returns 20
 
 console.log(
   ""Iterate with callback:"",
   queue.iterate((element) => element / 10)
 ); // Maps the queue and returns an array.
",JavaScript
"'''
 Queue implementation using List in Python
 '''
 
 try:
     queue = []
 
     # For the queue to be dynamic it has been put in a loop
     # While the loop is true the user gets 5 options:
     # To insert element in queue,remove,
     # display all elelements,reverse queue or exit
 
     while True:
         op = int(input('''
         Press-->
          1 to insert into queue
          2 to  remove from queue
          3 to display values of queue
          4 to reverse the exisiting queue
          5 to exit '''))
         
         if op == 1:
             ele = int(input(""enter elem to insert ""))
             queue.append(ele)
 
         elif op == 2:
 
             if len(queue) == 0:
                 print(""The queue is empty, insert values if required"")
             else:
                 ele = queue.pop(0)
                 print(""Element removed is - "", ele)
 
         elif op == 3:
 
             if len(queue) == 0:
                 print(""The queue is empty, insert values if required"")
             else:
                 print(queue)
 
         elif op == 4:
             queue.reverse()
             print(queue)
 
         elif op == 5:
             break
 
         else:
             print(""invalid option"")
 
 except ValueError:
 
     print(""Please enter integer only"")
 
 except:
 
     print(""There's been some issue please check the data you've entered"")
 
 
 """"""
 Sample Input- Output
 dynamic_queue.py
         Press-->
          1 to insert into queue
          2 to  remove from queue
          3 to display values of queue
          4 to reverse the exisiting queue
          5 to exit 1
 enter elem to insert 3
         Press-->
          1 to insert into queue
          2 to  remove from queue
          3 to display values of queue
          4 to reverse the exisiting queue
          5 to exit 1
 enter elem to insert 4
         1 to insert into queue
          2 to  remove from queue
          3 to display values of queue
          4 to reverse t",Python
"/*Problem Statement: 
 Given integers N and M, 
 find the number of ordered pairs (a,b) such that 1a<bN and ((M mod a) mod b)=((M mod b) mod a). */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int special_pair(int total,int number)
 {
 	int count=0;
 	unordered_map<int,int> mp;
 	for(int i=1;i<=total;i++)
     {
         int pair1=number%i;
         mp[i]=pair1;
     }
     for(auto it: mp)
     {
         int k=it.first;
         for(int j=k+1;j<=total;j++)
         {
             int temp=number%j;
            	int pair1=temp%(it.first);
             int pair2=(it.second)%j;
             if(pair1==pair2)
            	{
                 count++;
             }
         }
     }
     return count;
 }
 
 int main()
 {
     int total,number;
     cout<<""Enter total number of integers and the number: ""<<endl;
     cin>>total>>number;
     cout<<""Total special pairs: ""<<special_pair(total,number)<<endl;
     return 0;
 }
 /*Example:-
 
 Input:-
 Enter total number of integers and the number: 
 3 5
 
 Output:-
 Total special pairs: 2
 
 Time Complexity: O(nlogn)
 Space Complexity: O(nlogn)
 */
 
",C-Plus-Plus
"/**
 Topological sort is linear ordering of vertices
 in a directed acyclic graph (DAG). This algorithm is useful in 
 solving many other applications on DAG
 **/
 
 import java.io.*; 
 import java.util.*;
 
 public class TopologicalSort {
 	private static void dfs_visit(ArrayList<ArrayList<Integer> > graph, int src, Stack<Integer> s, boolean[] visit) {
 		visit[src] = true;
 		for(int i = 0; i < graph.get(src).size(); i++)
 			if(visit[graph.get(src).get(i)] == false)
 			    dfs_visit(graph, graph.get(src).get(i), s, visit);
 	    s.push(new Integer(src));
 	}
 
 	private static void dfs(ArrayList<ArrayList<Integer> > graph, int v, Stack<Integer> s) {
 		boolean[] visit = new boolean[v];
 		for(int i = 0; i < v; i++)
 			if(visit[i] == false)
 				dfs_visit(graph, i, s, visit);
 	}
 
 	private static void topological_sort(ArrayList<ArrayList<Integer> > graph, int v) {
 		Stack<Integer> s = new Stack<Integer>();
 		dfs(graph, v, s);
 		while(s.empty() == false)
 			System.out.print(s.pop() + "" "");
 		System.out.println();
 	}
 
 	public static void main(String[] args) {
 		int v, e, a, b;
 		// all vertices are labelled from 0 to v-1
 		Scanner sc= new Scanner(System.in);
 		v = sc.nextInt();
 		e = sc.nextInt();
 		ArrayList<ArrayList<Integer> > graph = new ArrayList<ArrayList<Integer> >(v);
 		for (int i = 0; i < v; i++) 
             graph.add(new ArrayList<Integer>());
 		// all directed edges
 		for(int i = 0; i < e; i++) {
 			a = sc.nextInt();
 			b = sc.nextInt();
 			// edge a -> b
 			graph.get(a).add(b);
 		} 
 		topological_sort(graph, v);
 	}
 }
 
 /**
 Input :
 6 8
 0 3
 0 4
 0 5
 1 5
 1 0
 2 1
 3 4
 4 5
 Output :
 2 1 0 3 4 5
 Time Complexity : O(v+e)
 Space Complexity : O(v)
 **/
 
",Java
"/*
 Given a N * N square matrix. A matrix has two diagonals. One diagonal is principal which starts from the first row, first column
 another diagonal is secondary which starts from the first row, last column
 Find the sum of it's principal and secondary diagonal elements.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 int ar[500][500];
 
 /* From this get_principal_secondary_diagonal_sum() function we will compute matrix's principal,secondary diagonal sum */
 int get_principal_secondary_diagonal_sum(int N)
 {
     int principal_secondary_diagonal_sum = 0;
     for(int i = 0; i < N; i++)
     {
         for(int j = 0; j < N; j++)
         {
             if(i == j)
             {
                 /* here principal diagonal element is at cell [1 , 1] , [0 ,0],
                 [2 , 2] like this goes on
                 that's why condition is i == j
                  */
                 principal_secondary_diagonal_sum += ar[i][j];
             }
             else if( (i + j == (N - 1)) and i != j )
             {
                 /* here secondary diagonal element is at cell [1 , 4] , [2 ,3],
                 [3 , 2] like this goes on
                 that's why condition is i + j == ( n - 1) and i != j
                 */
                 principal_secondary_diagonal_sum += ar[i][j];
             }
         }
     }
     return principal_secondary_diagonal_sum;
 }
 
 int main()
 {
     cout << ""Enter the size of the matrix : \n"";
     int N;
     cin >> N;
     cout << ""Enter matrix elements :\n"";
     for (int i = 0; i < N; i++)
     {
         for(int j = 0; j < N; j++)
         {
             cin >> ar[i][j];
         }
 
      }
      int principal_secondary_diagonal_sum  = get_principal_secondary_diagonal_sum(N);
      cout << ""Sum of Principal and Secondary Diagonal of this matrix is : "";
      cout << principal_secondary_diagonal_sum << endl;
 }
 
 /*
 Standard Input and Output
 
 Enter the size of the matrix :
 4
 Enter matrix elements :
 1 2 3 4
 5 ",C-Plus-Plus
"'''
     Author : @anushkrishnav
     Built using :  networkx since it is a gold standard for Python DAGs (and other graphs). You can create a networkx directed graph with a list of tuples that represent the graph edges:
 '''
 import networkx as nx
 from matplotlib import pyplot as plt
 class DAG:
     def __init__(self):
         self.graph=nx.DiGraph()
     def addEdges(self,edges):
         """"""Function to add one edge at a time and check if the graph is acyclic post insertion""""""
         self.graph.add_edge(edges)
         if nx.is_directed_acyclic_graph(self.graph):
             pass
         else:
             raise ""Unable to insert ""+str(edges)+""This is an Acyclic graph""
             self.graph.remove_edge(edges)
     def AddSetofEdges(self,listt):
         """"""Function to all a list of edges and check is the graph is an DAG for furthur details refer networkx""""""
         self.graph.add_edges_from(listt)
         if nx.is_directed_acyclic_graph(self.graph):
             pass
         else:
             raise ""This is an acyclic graph check your edges""
             self.graph.remove_edge(listt)
     def Visualise(self,location=""home""):
         """"""It uses Matplotlib to visualise the DAG .
         The graph is stored in a PNG format . So name the file accourdingly
         eg 
         >>> DAG.Visualise(home/img.png)""""""
         if self.graph==None:
             return ""There is no graph consider adding edges to visualise"" 
         plt.tight_layout()
         nx.draw_networkx(self.graph,arrows=True,node_size=800)
         plt.savefig(location,format=""PNG"")
         plt.clf()
         return ""Graph generated""
 
 
 graph = DAG()
 graph.AddSetofEdges([(""root"", ""a""), (""a"", ""b""), (""a"", ""e""), (""b"", ""c""), (""b"", ""d""), (""d"", ""e"")])
 graph.Visualise(""Python/graphs/graph.png"")
 
",Python
"""""""
 An expression is called prefix , if the operator appears in the expression before the operands. (operator operand operand)
 An expression is called postfix , if the operator appears in the expression after the operands . (operand operand operator)
 The program below accepts an expression in prefix and outputs the corresponding postfix expression .
 """"""
 
 # prefixtopostfix function converts a prefix expression to postfix
 def prefixtopostfix(exp):
     stack = []
     n = len(exp)
     for i in range(n - 1, -1, -1):
         if exp[i].isalpha():
             stack.append(exp[i])
         else:
             op1 = stack.pop()
             op2 = stack.pop()
             stack.append(op1 + op2 + exp[i])
     print(""the postfix expresssion is : "" + stack.pop())
 
 
 # Driver Code
 if __name__ == ""__main__"":
     exp = input(""Enter the prefix expression : "")
     prefixtopostfix(exp)
 
 
 """"""
 Sample I/O:
 
 Enter the prefix expression : *+abc
 the postfix expresssion is : ab+c*
 
 Time complexity : O(n) 
 space complexity : O (n)
 """"""
",Python
"// TimSort implementation in C++
 
 #include<iostream>
 using namespace std;
 const int N = 32;
 
 // this function sorts array from left index to right index which is of size atmost RUN
 void insertionSort(int arr[], int left, int right)
 {
   for (int i = left + 1; i <= right; i++)
   {
     int temp = arr[i];
     int j = i - 1;
     while (arr[j] > temp && j >= left)
     {
       arr[j + 1] = arr[j];
       j--;
     }
     arr[j + 1] = temp;
   }
 }
 
 // merge function merges the sorted runs
 void merge(int arr[], int l, int m, int r)
 {
   // original array is broken in two parts
   // left and right array
   int len1 = m - l + 1, len2 = r - m;
   int left[len1], right[len2];
   for (int i = 0; i < len1; i++)
     left[i] = arr[l + i];
   for (int i = 0; i < len2; i++)
     right[i] = arr[m + 1 + i];
 
   int i = 0;
   int j = 0;
   int k = l;
 
   // after comparing, we merge those two array in larger sub array
   while (i < len1 && j < len2)
   {
     if (left[i] <= right[j])
     {
       arr[k] = left[i];
       i++;
     }
     else
     {
       arr[k] = right[j];
       j++;
     }
     k++;
   }
 
   // copy remaining elements of left, if any
   while (i < len1)
   {
     arr[k] = left[i];
     k++;
     i++;
   }
 
   // copy remaining element of right, if any
   while (j < len2)
   {
     arr[k] = right[j];
     k++;
     j++;
   }
 }
 
 // iterative Timsort function to sort the array[0...n-1]
 void timSort(int arr[], int n)
 {
   // Sort individual subarrays of size RUN
   for (int i = 0; i < n; i += N)
     insertionSort(arr, i, min((i + 31), (n - 1)));
 
   // start merging from size RUN (or 32). It will merge to form size 64, then 128, 256 and so on ....
   for (int size = N; size < n; size = 2 * size)
   {
     // pick starting point of left sub array. We are going to merge arr[left..left+size-1] and arr[left+size, left+2*size-1]
     // After every merge, we increase left by 2*size
     for (int left = 0; left < n; left += 2 * size)
     {
  ",C-Plus-Plus
"/**
 Function to sort list using bubble sort technique.
 We use one extra temporary variable to help us out in swapping. 
 isSorted checks if the list is already sorted.
  */
 import 'dart:io';
 
 // the function which runs the bubble sort algorithm
 List bubbleSort(List arr) {
   int len = arr.length;
   int temp = 0;
   for (int i = 0; i < len; i++) {
     bool isSorted = true;
     for (int j = 1; j < (len - i); j++) {
       if (arr[j - 1] > arr[j]) {
         // swap elements
         temp = arr[j - 1];
         arr[j - 1] = arr[j];
         arr[j] = temp;
         isSorted = false;
       }
     }
     if (isSorted) {
       break;
     }
   }
   return arr;
 }
 
 // Main function, entry point of the program
 void main() {
   print(""Enter the size of list:"");
   int size = int.parse(stdin.readLineSync()!);
   List arr = [];
   print(""Enter the numbers:"");
   for (int i = 0; i < size; i++) {
     arr.add(int.parse(stdin.readLineSync()!));
   }
   // sorting
   arr = bubbleSort(arr);
   print(""Sorted list:"");
   for (int i = 0; i < size; i++) {
     print(arr[i]);
   }
 }
 
 /**
  * Sample input/output
  * Enter the size of list:
  * 6
  * Enter the numbers:
  * 5
  * 4
  * 3
  * 2
  * 1
  * 0
  * Sorted list:
  * 0
  * 1
  * 2
  * 3
  * 4
  * 5
  *
  * Space complexity: O(1)
  * Time complexity: O(n^2) {worst} / O(n) {best}
  */
",Dart
"/*
 Description : Given a sorted array containing only 0s and 1s, find the transition point. 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int transitionPoint(int arr[], int n)
 {
     // code here
     if (arr[0])
         return 0;
     //using modified binary search
     //lb= lower bound
     //ub= upper bound
     int lb = 0;
     int ub = n - 1;
     while (lb <= ub)
     {
         int mid = (lb + ub) / 2;
         if (arr[mid] == 0)
         {
             lb = mid + 1;
         }
         else if (arr[mid] == 1)
         {
             if (arr[mid - 1] == 0)
                 return mid;
             else
                 ub = mid - 1;
         }
     }
     return -1;
 }
 
 int main()
 {
     //size of an array
     int n;
     cout << ""Enter the size of an array : "" << endl;
     cin >> n;
     int a[n];
     cout << ""Enter the data in the array : "" << endl;
     //taking input in array
     for (int i = 0; i < n; i++)
     {
         cin >> a[i];
     }
     cout << ""Transition point in array : "" << endl;
     cout << transitionPoint(a, n) << endl;
     return 0;
 }
 
 /*
 Time complexity : O(log n)
 Space complexity : O(n)
 */
 
 /*
 Test Case :
  Input :
  Enter the size of an array :
  5
  Enter the data in the array :
  0 0 0 1 1 
 
  Output :
  Transition point in array : 
  3
 */
 
",C-Plus-Plus
"/*
 BEST FIT MEMORY ALLOCATION
 Available memory blocks are accepted as input from the user
 This strategy will continue searching for a block whose 
 size is closest to the requested block size. Pointer to 
 the block is returned after retaining residual space
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 //structure to represent memoryblock with id and size
 typedef struct MemoryBlock
 {
     int id;
     int size;
 } MemoryBlock;
 
 //to print the id of allocated memory block
 void print_block(MemoryBlock block)
 {
     if (block.id != -1 && block.size != -1 && block.size != 0)
         printf(""Block #%d \n"", block.id);
     else
         printf(""Invalid Memory Block\n"");
 }
 
 //linked list to store memory blocks
 typedef struct MemoryManager
 {
     MemoryBlock b;
     struct MemoryManager *llink, *rlink;
 } MemoryManager;
 
 //best fit memory allocation
 MemoryBlock best_fit(MemoryManager *m, int memory)
 {
     MemoryBlock bl;
     //if the list is empty
     if (m == NULL)
     {
         bl.id = -1;
         bl.size = -1;
     }
     else
     {
         MemoryManager *ptr = m, *ptr1, *ptr2, *p;
         MemoryBlock best;
         best.id = -1;
         best.size = -1;
         int count = 0;
         //to find the most suitable memory block
         while (ptr->rlink != NULL)
         {
             if (count == 0)
             {
                 if (ptr->b.size >= memory)
                 {
                     best.id = ptr->b.id;
                     best.size = ptr->b.size;
                     count = 1;
                 }
             }
             else
             {
                 if (ptr->b.size >= memory && ptr->b.size < best.size)
                 {
                     best.id = ptr->b.id;
                     best.size = ptr->b.size;
                 }
             }
             ptr = ptr->rlink;
         }
         best.size = memory;
         bl = best;
         ptr = m;
         //to remove the memory allocated from the block
      ",C
"/* This program checks if a number is a prime number. A number is a
 prime number if it has no other factor than 1 and the number itself.*/
 
 package main
 
 import (
 	""fmt""
 	""os""
 )
 
 
 // This function checks if a number is a prime number
 func is_prime(n int) int {
 
 	// Iterate from 2 to number - 1
 	for i := 2; i < n; i++ {
 		if(n % i == 0) {
 			/* If the number is divisible by any of them
 			then return -1, it is not a prime number.*/
 			return -1
 		}
 	}
 	// Else return 1, the number is a prime number
 	return 1
 }
 
 func main() {
 
 	// Take number as input from the user
 	fmt.Print(""Enter a number to check if it's a prime number: "")
 	var n int
 	fmt.Scan(&n)
 
 	// If the number is less than equal to 1, exit.
 	if(n <= 1) {
 		fmt.Print(""The number "", n, "" is not a prime number.\n"")
 		os.Exit(0)
 	}
 
 	// Call the function
 	var result int = is_prime(n)
 	if(result == 1) {
 		fmt.Print(""\nThe number "", n, "" is a prime number.\n"")
 	} else {
 		fmt.Print(""\nThe number "", n, "" is not a prime number.\n"")
 	}
 }
 
 /* Sample I/O:
 
 a)
 Enter a number to check if it's a prime number: 11243
 
 The number 11243 is a prime number.
 
 b)
 Enter a number to check if it's a prime number: 12334
 
 The number 12334 is not a prime number.
 
 */
",Go
"
 /*
 An expression is called prefix , if the operator appears in the expression before the operands. (operator operand operand)
 An expression is called postfix , if the operator appears in the expression after the operands . (operand operand operator)
 The program below accepts an expression in prefix and outputs the corresponding postfix expression .
 */
 import java.util.Scanner;
 import java.util.Stack;
 
 class Code2 {
     // if operand function checks if the element is an operand
     static boolean ifoperand(char c) {
         if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
             return true;
         }
         return false;
     }
 
     // prefixtopostfix function converts a prefix expression to postfix
     static void prefixtopostfix(String expression) {
         Stack<String> s = new Stack<String>();
         int len = expression.length();
         for (int i = len - 1; i >= 0; i--) {
             if (ifoperand(expression.charAt(i))) {
                 s.push("""" + expression.charAt(i));
             } else {
                 String exp = """" + expression.charAt(i);
                 String op1 = s.peek();
                 s.pop();
                 String op2 = s.peek();
                 s.pop();
                 String temp = op1 + op2 + exp;
                 s.push(temp);
             }
         }
         System.out.println(""the postfix expresssion is : "" + s.peek());
     }
 
     // Driver code
     public static void main(String[] args) {
         String exp;
         System.out.println(""Enter the prefix expression "");
         Scanner sc = new Scanner(System.in);
         exp = sc.nextLine();
         prefixtopostfix(exp);
         sc.close();
     }
 
 }
 
 /*
 Sample I/O:
 
 Enter the prefix expression
 *+abc
 the postfix expresssion is : ab+c*
 
 Time complexity : O(n) 
 space complexity : O (n)
  */
",Java
"/*    Tribonacci Series:
    Tribonacci series is a generalisation of Fibonacci series where current element(greater than 0)
    is the sum of preceding three elements,
    i.e. T(n)=T(n-1)+T(n-2)+T(n-3).
 
       Approach:
 
    The sum of three preceding variables will be stored in ""sum"" variable.
    Variable ""first"" will be overrided by ""second"" which in turn will be overrided by ""third"" which
    will be overrided by ""sum"".
    This process will continue till n terms.  */
 
 import java.util.Scanner;
 
 public class Main {
     public static void main(String[] args) {
         Scanner scan = new Scanner(System.in);
         long num;
         System.out.println(""Enter the number upto which the series is to be printed"");
         num = scan.nextLong();
         printTribonacci(num);
     }
 
     public static void printTribonacci(long num) {
         long first = 0, second = 0, third = 1, sum = 0, count = 0;
         while (num > 0) {
             count++;
             if (count == 1)
                 System.out.print(0);
             else if (count == 2)
                 System.out.print("", "" + 0);
             else if (count == 3)
                 System.out.print("", "" + 1);
             else {
                 sum = first + second + third;
                 System.out.print("", "" + sum);
                 //Storing the values of succeeding terms in respective variables.
                 first = second;
                 second = third;
                 third = sum;
             }
             num--;    //Decreasing the value of total number of terms by one after each iteration.
         }
     }
 }
 
  /*                                              OUTPUT:
  Test Case 1:
  Enter the number upto which the series is to be printed
  23
  0, 0, 1, 1, 2, 4, 7, 13, 24, 44, 81, 149, 274, 504, 927, 1705, 3136, 5768, 10609, 19513, 35890, 66012, 121415
 
  Space Complexity: O(1)
  Time Complexity: O(n)
  */
 
",Java
"/*Taking input as array containing 2*N+2 positive numbers, out of which 2*N numbers exist in pairs whereas the other
 two number occur exactly once and are distinct. Find the other two numbers.
 
 Time Complexity: O(n) 
 Space Complexity: O(1)
 */
 
 #include <bits/stdc++.h>
 using namespace std;
  
 /*  To set the values of *a and *b to non-repeating elements*/
 
 void NonRepeatingInt(int arr[], int n, int *a, int *b)
 {
     int Xor = arr[0];
    
     int set_bit;
     int i;
     *a = 0;
     *b = 0;
      
     for(i = 1; i < n; i++)
     Xor ^= arr[i];
      
     set_bit = Xor & ~(Xor-1);
      
     /* dividing the elements in two sets by comparing rightmost set bit of Xor with bit
     at same position in each element. */
     for(i = 0; i < n; i++)
     { 
         
       if(arr[i] & set_bit)
         *a = *a ^ arr[i];
         
       else
       {
         *b = *b ^ arr[i];
       }
     }
 }
  
  
 int main()
 {
     int n;
     cout<<""Enter the size of the array:"";
     cin>>n;
     int arr[n];
     cout<<""Enter the array elements:"";
     for(int i=0;i<n;i++){
         cin>>arr[i];
     }
     int *a = new int[(sizeof(int))];
     int *b = new int[(sizeof(int))];
     NonRepeatingInt(arr, n, a, b);
     cout<<""The non-repeating elements in the array are ""<<*a<<"" and ""<<*b;
 }
  
 
 
 /*
 OUTPUT:
 Enter the size of the array:6
 
 Enter the array elements:1 2 3 1 2 5 
 
 The non-repeating elements in the array are 3 and 5
 
 */
",C-Plus-Plus
"/* Java implementation to convert infix expression to postfix */
 /* Time  Complexity - O(N) 
  * Space Complexity - O(N) */
 import java.util.Scanner;
 import java.util.Stack; 
 public class Infix_to_Postfix {
 	    //Given function returns the precedence of an operator,higher value indicates the higher precedence  
 	    public static int precedence(char ch) 
 	    { 
 	        switch (ch) 
 	        { 
 	             // operator '+' & '-' have same precedence and lower precedence than '+', '-' & '^' operator
 	          case '+': 
 	          case '-': 
 	                return 1; 
 	             // operator '*' & '/' have same precedence and greater precedence than '+' & '-' operator
 	          case '*': 
 	          case '/': 
 	                return 2; 
 	             // operator '^' have highest precedence
 	          case '^': 
 	               return 3; 
 	        } 
 	        return -1; 
 	    } 
 	    //Given method which converts infix expression to postfix
 	    public static String infixToPostfix(String exp) 
 	    { 
 	        // initializing empty String for result 
 	        String result = """"; 
 	          
 	        // initializing empty stack 
 	        Stack<Character> stack = new Stack<>(); 
 	          
 	        for (int i = 0; i<exp.length(); ++i) { 
 	            
 	        	char c = exp.charAt(i); 
 	              
 	            // If the scanned character is an 
 	            // operand, add it to output
 	            if (Character.isLetterOrDigit(c)) {
 	                result += c; 
 	               
 	            // If the scanned character is an '(' parenthesis, then  
 	            // push it to the stack 
 	            } else if (c == '(') {
 	                stack.push(c); 
 	              
 	            //  If the scanned character is an ')' parenthesis, then  
 	            // pop an output from the stack  
 	            // until an '(' parenthesis is encountered 
 	            } else if (c == ')') { 
 	                
 	     ",Java
"'''
 Cryptarithmetic problems are mathematical puzzles where digits are replaced by symbols. 
 And the aim is to find unique digits(0-9) that the letters should represent, such that 
 they satisfy the given constraints.
 
 The cryptarithmetic problem that is needed to be solved here is:
     
    SEND
  + MORE
 ---------
 = MONEY
 ---------
 
 Distinct variables are: S, E, N, D, M, O, R, Y
 Domain: {0,...,9}
 
 '''
 
 # importing the necessary libraries
 from typing import Generic, TypeVar, Dict, List, Optional
 from abc import ABC, abstractmethod
 
 # declaring a type variable V as variable type and D as domain type
 V = TypeVar('V') # variable type
 D = TypeVar('D') # domain type
 
 # this is a Base class for all constraints
 class Constraint(Generic[V, D], ABC):
     # the variables that the constraint is between
     def __init__(self, variables: List[V]) -> None:
         self.variables = variables
 
     # this is an abstract method which must be overridden by subclasses
     @abstractmethod
     def satisfied(self, assignment: Dict[V, D]) -> bool:
         ...
         
 # A constraint satisfaction problem consists of variables of type V
 # that have ranges of values known as domains of type D and constraints
 # that determine whether a particular variable's domain selection is valid
 class CSP(Generic[V, D]):
     def __init__(self, variables: List[V], domains: Dict[V, List[D]]) -> None:
         # variables to be constrained
         # assigning variables parameter to self.variables
         self.variables: List[V] = variables 
         # domain of each variable
         # assigning domains parameter to self.domains
         self.domains: Dict[V, List[D]] = domains
         # assigning an empty dictionary to self.constraints
         self.constraints: Dict[V, List[Constraint[V, D]]] = {}
         # iterating over self.variables
         for variable in self.variables:
             self.constraints[variable] = []
             # if the variable is not in doma",Python
"// C++ Program to find Binary Exponent Iteratively and Recursively.
 
 #include <iostream>
 
 // Iterative function to calculate exponent.
 
 int binExpo_iterate(int a, int b)
 {
     int res = 1;
     while (b > 0)
     {
         if (b % 2)
         {
             res = res * a;
         }
         a = a * a;
         b /= 2;
     }
     return res;
 }
 
 // Recursive function to calculate exponent.
 
 int binExpo_recurse(int a, int b)
 {
     if (b == 0)
     {
         return 1;
     }
     int res = binExpo_recurse(a, b / 2);
     if (b % 2)
     {
         return res * res * a;
     }
     else
     {
         return res * res;
     }
 }
 
 // Main function
 
 int main()
 {
     int a, b;
 
     std::cin >> a >> b;
 
     if (a == 0 && b == 0)
     {
         std::cout << ""Math Error"" << std::endl;
     }
     else if (b < 0)
     {
         std::cout << ""Exponent must be Positive"" << std::endl;
     }
     else
     {
         int resIterate = binExpo_iterate(a, b);
         int resRecurse = binExpo_recurse(a, b);
 
         std::cout << resIterate << std::endl;
         std::cout << resRecurse << std::endl;
     }
 }",C-Plus-Plus
"'''This code is an implementation of Hill Cipher. It
    is a polygraphic substitution cipher. It forms a 
    nxn matrix of key and nx1 matrix(s) of the plaintext
    and then multiplies the two matrices to obtains the
    matrix of ciphertext.'''
 
 import sys
 
 #This function builds key-Martix given the key
 def buildKeyMatrix(key):
    
    k = 0
    for i in range(n):
      for j in range(n):
        keyMatrix[i][j] = ord(key[k])%97
        k += 1
 
 #This function builds Message-Matrix given planetext   
 def buildMessageMatrix(plaintext):
    
    for i in range(n): 
      messageMatrix[i][0] = ord(plaintext[i])%97 
 
 '''This is the encryption function which takes planetext
    and key as input and returns us the ciphertext list.'''   
 def encription(plaintext,key):
    
    buildKeyMatrix(key)
    buildMessageMatrix(plaintext)    
    
    #matrix multiplication of key and message matrices
    for i in range(n):
      for j in range(n):
        cipherMatrix[i][0] += ( keyMatrix[i][j]*messageMatrix[j][0] )
      cipherMatrix[i][0]    = cipherMatrix[i][0] %26
    
    #storing all the result as a list
    cipherText = []
    for i in range(n):
      cipherText.append( chr(cipherMatrix[i][0]+97) )
 
    return cipherText 
      
 
 if __name__=='__main__':
    
    #Taking plaintext and key as input from user
    plaintext = input(""Enter the plaintext here :"")
    key       = input(""Enter the key here :"")
    
    n = len(plaintext)
    
    if len(key) != n*n :
       print(""Invalid Key"")
       sys.exit(0)
    
    #creating the matrices required
    keyMatrix     = [ [0]*n for i in range(n) ]
    messageMatrix = [ [0]   for i in range(n) ]
    cipherMatrix  = [ [0]   for i in range(n) ]
    
    for i in range(n):
       cipherMatrix[i][0] = 0
   
    '''calling the encryption function on the given plaintext
       and key''' 
    encrypted_message = encription(plaintext,key)
    
    #printing the ciphertext we got using the encryption method
    print(""",Python
"/*
 Given two Linked list, both of n size. The linked list is representing
 positive integer. As they are being pushed to linked list they are 
 given in reverse order. 
 Your task is two add the numbers represented as Linked List and return 
 the sum answer in the form of Linked List.
 
 For example: Linked List1: ->1->2->3 
              Linked List2: ->3->7->1
              Answer:       ->4->9->4    
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 class Node
 {
 public:
     int data;
     Node *next;
 };
 void push(Node **head, int data)
 {
     Node *new_node = new Node();
     new_node->data = data;
     new_node->next = (*head);
     (*head) = new_node;
 }
 void printLinkedlist(Node *temp)
 {
     while (temp != NULL)
     {
         cout << ""->"" << temp->data;
         temp = temp->next;
     }
 }
 Node *addtwonumbers(Node *l1, Node *l2)
 {
     Node *temp = new Node();
     Node *head = temp;
     int carry = 0;
     while (l1 != NULL || l2 != NULL)
     {
         int sum = carry;
         if (l1 != NULL)
         {
             sum += l1->data;
             l1 = l1->next;
         }
         if (l2 != NULL)
         {
             sum += l2->data;
             l2 = l2->next;
         }
         carry = sum / 10;
         push(&temp->next, sum % 10);
         temp = temp->next;
     }
     if (carry != 0)
     {
         push(&temp->next, carry);
     }
     return head->next;
 }
 int main()
 {
     int n;
     cout << ""Enter length of Linked List:"";
     cin >> n;
     cout << ""Enter Linked List 1:"";
     Node *head1 = NULL;
     for (int i = 0; i < n; i++)
     {
         int a;
         cin >> a;
         push(&head1, a);
     }
     cout << ""Enter Linked list 2:"";
     Node *head2 = NULL;
     for (int i = 0; i < n; i++)
     {
         int a;
         cin >> a;
         push(&head2, a);
     }
     Node *head = NULL;
     head = addtwonumbers(head1, head2);
     cout << ""\nLinked List 1:\n"";
     printLinkedlist(head1);
     cout << ""\nLinked ",C-Plus-Plus
"/*
 Given a number's base and power.
 return the number.
 base and power can be large as 10^6 to 10^9
 so we need to mod with some big number in order to get the number
 this can be done by bigmod algorithm
 */
 
 import java.util.Scanner;
 import java.lang.*;
 import java.math.*;
 
 public class NumberofDivisors
 {
    //this function will give us the new number according to our base and power
    static long get_new_number_by_bigmod(long base, long power, long  mod_number)
    {
     long new_number;
     if(power == 0)
     {
         // no matter what base is , as power is 0 answer 1
         return 1;
     }
     else if(power % 2 == 0)
     {
         /* as power is even,
         we will divide the power each step by 2
         9^18 will be 9^9 , 9^9
         and thus goes on  by recursive call */
         
         new_number = get_new_number_by_bigmod(base , power / 2, mod_number);
         return ((new_number * new_number) % mod_number);
     }
     else
     {
          /* as power is odd,
         we will  take power - 1
         9^15 = 9^14 , 9^1
         and thus goes on  by recursive call  */
         long temp = get_new_number_by_bigmod(base , power - 1 , mod_number);
         return ((( base % mod_number)* temp)% mod_number);
 
     }
    }
 
     public static void main(String args[])  
     {
         Scanner scan = new Scanner(System.in);
 	System.out.print(""Enter the base number and power number : "");
 	long base = scan.nextLong();
         long power = scan.nextLong();
         System.out.print(""Enter the mod number: "");
         long mod_number = scan.nextLong();
         long new_number = get_new_number_by_bigmod(base, power, mod_number);
 
         System.out.print(""After applying Bigmod algorithm the new number is : \n"");
         System.out.print(new_number);
         scan.close();
     }
 }
 
 /*
 
 Standard Input and Output
 
 Enter the base number and power number :
 45 67
 Enter the mod number: 1000456
 
 After applying Bigmod algorith",Java
"/*
 Given a binary array, binary means array's element will be 0 or 1.
 find the maximum number of consecutive 1's in this array.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int get_max_consecutive_ones(int ar[] , int N)
 {
     int max_consecutive_ones = 0 , count_1 = 0;
     for(int i = 0; i < N; i++)
     {
         if(ar[i] == 1)
         {
             count_1++;
             /* here we will keep the maximum value of consecutive
             1's  */
             max_consecutive_ones = max(max_consecutive_ones, count_1);
         }
         else if(ar[i] == 0)
         {
             count_1 = 0;
             /* as array's element is zero (0)
             we will set count_1 as zero */
 
         }
     }
     return max_consecutive_ones;
 }
 
 int main()
 {
     cout << ""Enter the size of the array : \n"";
     int N;
     cin >> N;
     int ar[N + 1];
     cout << ""Enter array elements :\n"";
     for (int i = 0; i < N; i++) 
     {
 	 cin >> ar[i];
     }
     int max_consecutive_ones = get_max_consecutive_ones(ar , N);
     cout << ""Maximum Consecutive Ones in this array is : "";
     cout << max_consecutive_ones << endl;
 }
 /*
 Standard Input and Output
 
 Enter the size of the array :
 6
 Enter array elements :
 1 1 0 1 1 1
 Maximum Consecutive Ones in this array is : 3
 
 Time Complexity : O( N )
 Space Complexity : O( 1 )
 
 */
",C-Plus-Plus
"// To find the rank of a string among all its lexicographically sorted permutations.
 #include <stdio.h>
 #include <string.h>
 
 int lexicographic_rank(char*);
 int fact(int);
 int smallerright(char *, int);
 int main()
 {
 	char string[100];
 	printf(""Enter the string:"");
 	scanf(""%s"", string);
 	printf(""Lexicographic Rank of the string=%d"", lexicographic_rank(string));
 }
 
 // Function to calculate the rank of the string
 int lexicographic_rank(char *string)
 {
 	int length = strlen(string);
 	int total_permutation = fact(length);
 	int i = 0;
 	int rank = 1;
 	int countsmallright;
 	while (*(string + i) != '\0')
 	{
 		total_permutation = total_permutation / (length - i);
 		countsmallright = smallerright(string, i);
 		rank = rank + (countsmallright *total_permutation);
 		i++;
 	}
 
 	return rank;
 }
 
 // Function to check if the element on the right side is smaller than the index ith element
 int smallerright(char *string, int index)
 {
 	int i = index;
 	int count = 0;
 	while (*(string + i) != '\0')
 	{
 		if (*(string + i)<*(string + index))
 		{
 			count = count + 1;
 		}
 		i++;
 	}
 
 	return count;
 }
 
 // To calculate factorial of a number using recursion
 int fact(int num)
 {
 	if (num == 0)
 		return 1;
 	else
 		return (num* fact(num - 1));
 }
 
 /*
 Sample Output
 Enter the string:rohan
 Lexicographic Rank of the string=117
 
 Complexities
 Time Complexity:O(n^2)
 Space Complexity:O(n)
 */
 
",C
"/*
 Given the Sorted Linked list head which contain duplicates, the task is
 to delete all the duplicate and make linked list such that every element
 appear just one time.
 Example:
 Original Linked list : 1 1 2 2 3
 Answer : 1 2 3
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Node
 {
 public:
     int data;
     Node *next;
 };
 void push(Node **head, int n_data)
 {
     Node *newdata = new Node();
     newdata->data = n_data;
     newdata->next = (*head);
     (*head) = newdata;
 }
 void printlinkedlist(Node *temp)
 {
     while (temp != NULL)
     {
         cout << ""->"" << temp->data;
         temp = temp->next;
     }
 }
 Node *delete_duplicates(Node *head)
 {
     Node *curr = head;
     while (curr && curr->next)
     {
         if (curr->next->data == curr->data)
         {
             curr->next = curr->next->next;
         }
         else
         {
             curr = curr->next;
         }
     }
     return head;
 }
 int main()
 {
     Node *head = NULL;
     int n;
     cout << ""Enter number of Elements:"";
     cin >> n;
     cout << ""Enter elements:"";
     for (int i = 0; i < n; i++)
     {
         int a;
         cin >> a;
         push(&head, a);
     }
     cout << ""Original Linked list:\n"";
     printlinkedlist(head);
     cout << ""\nNew Linked List:\n"";
     head = delete_duplicates(head);
     printlinkedlist(head);
 }
 
 /*
 
 Sample Input:
 Enter number of Elements:5
 Enter elements:1 1 2 2 3
 
 Sample Output:
 Original Linked list:
 ->3->2->2->1->1
 New Linked List:
 ->3->2->1
 
 Time-Complexity: O(n)
 Space-Complexity: O(1)
 
 */
",C-Plus-Plus
"/*
 Program by :: Anand Dasani
 Date :: 13-03-2021
 
 Aim :: To check the given number is Neon or not.
 
 What is Neon number ?
 A Neon number is a number where the sum of digits of square of the number is equal to that number.
 
                         ALGO
 1. Take a number from the user
 2. Find the square of the given number.
 3. By using loop , find the sum of the square of the all individual digits
 4. Check condition if our sum is equal to the user given number
         (a.) Return true
         (b.) Else return false.
 5. Exit
  */
 
 import java.util.Scanner; // for scanner class
 
 public class Neon_number {
 
     public static void main(String[] args) {
 
         System.out.print(""\nEnter the number :: "");
 
         Scanner sc = new Scanner(System.in);
         int n = sc.nextInt();
 
         if (isNeon(n)) // checking the number is Neon or not
             System.out.println(n + "" is Neon number :)"");
         else
             System.out.println(n + "" is not a Neon number :("");
 
     }
 
     /**
      * method to check the given number is Neon or not
      *
      * @param num for storing the value given by user
      * @return ture if number is Neon else return false
      */
     public static boolean isNeon(int num) {
 
         // Accumulator :-> A running total is a sum of numbers that accumulate with each iteration of a loop
         int n, sum = 0; // assuming sum as accumulator
 
         n = num * num;
         while (n != 0) { // running loop till we consider all the digits of the squared number
             sum += (n % 10); //getting the last digit & adding the last digit to sum
             n /= 10; // neglecting the last number which we have counted
         }
 
         if (sum == num)
             return true;
 
         return false;
     }
 }
 
 /*
 Test case :: T = 1
 Enter the number :: 9   // input
 9 is Neon number :)     // output
 
 Explanation :->
 1. square the number i,e.. 9 * 9 = 81
 2. add up all the individual digits ",Java
"""""""
 Function to print first n Fibonacci Numbers
 n takes the input of first n numbers to be printed
 """"""
 
 
 def fibonaccinumber(n):
     """"""
     >>fibonaccinumber(6)
     0 1 1 2 3 5
 
     >>fibonaccinumber(10)
     0 1 1 2 3 5 8 13 21 34 55
 
     """"""
     a, b = 0, 1
     if n < 1:
         return
     for x in range(0, n-1):
         print (b, end=' ')
         a, b = b, a + b
 
 if __name__==""__main__"":
     n = int(input(""Enter the number of terms: ""))
     print(0,end=' ')
     (fibonaccinumber(n))
",Python
"/*
 Given an array of N elements, each element's occurrence in the array can be more than once. Find all elements whose occurrence is more than 1.
 Formally find all duplicate elements of the array. This can be done with the help of map and set data structure.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void dupicate_elements(int ar[] ,int N)
 {
     /* we will insert the array elements into the map. if current element already in the map,
     then definitely that element's occurrence is more than 1. 
     Hence it is duplicate and will insert in the set*/
     map < int, int > unique_elements;
     set < int > duplicates;
     for(int i = 0; i < N; i++)
     {
         if(!unique_elements[ar[i]])
             unique_elements[ar[i]]++;
        else
        {
            // this is a duplicate
            duplicates.insert(ar[i]);
        }
     }
     cout << ""Duplicate elements are : "";
     for(auto i : duplicates)
         cout << i << ' ';
     cout << endl;
     return;
 }
 
 int main()
 {
     cout << ""Enter the size of the array : "";
     int N; 
     cin >> N;
     int ar[N + 1];
     cout << ""Enter array elements :\n"";
     for(int i = 0; i < N; i++)
     {
         cin >> ar[i];
     }
     dupicate_elements(ar , N);
 }
 
 /*
 Standard Input and Output
 
 Enter the size of the array : 12
 Enter array elements
 1 5 2 1 4 3 1 7 2 8 9 5
 Duplicate elements are : 1 2 5
 
 Time Complexity : O(logN)
 Space Complexity : O(N)
 
 */
",C-Plus-Plus
"/*
 Stock Span Problem
 ===================
 You are given the price of a stock for N consecutive days and are required to find the span
 of stock's price on ith day. The span of a stock's price on a given day i, is the maximum
 consecutive days before the (i+1)th day, for which the stock's price is less than equal to that on
 the ith day.
 
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 int main()
 {
 
 	// Input number of days
 	int n;
 	cin >> n;
 	int price[n];
 	int span[n];
 
 	// Input price for n days
 	for (int i = 0; i < n; i++)
 	{
 		cin >> price[i];
 	}
 
 	// Stack for keeping track of span of largest element till now
 	stack<pair<int, int>> s;
 	// Push first element in the stack
 	s.push({1, price[0]});
 	// Span for first day will always be 1
 	span[0] = 1;
 
 	// Looping through rest of the days
 	for (int i = 1; i < n; i++)
 	{
 		// Initally the curr span of a day will be 1, i.e, itself
 		int currSpan = 1;
 		int currPrice = price[i];
 
 		// Taking the topmost element in the stack
 		auto p = s.top();
 		int topSpan = p.first;
 		int topPrice = p.second;
 
 		// While we have elements in the stack and currPrice is greater than equal to topPrice
 		// keeping popping out elements and update the currSpan
 		while (s.size() && topPrice <= currPrice)
 		{
 
 			// Update currSpan
 			currSpan += topSpan;
 
 			// Pop out the topmost element as its price was less than currPrice
 			s.pop();
 
 			// Update top element after popping
 			if (s.size())
 			{
 				p = s.top();
 				topSpan = p.first;
 				topPrice = p.second;
 			}
 			else
 			{
 				// Stack is empty
 				break;
 			}
 		}
 
 		// Finally update ans
 		span[i] = currSpan;
 		// Push curr element into the stack
 		s.push({currSpan, currPrice});
 	}
 
 	// Print ans
 	for (int i = 0; i < n; i++)
 	{
 		cout << span[i] << "" "";
 	}
 }
 
 /*
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
 /*
 Sample Input :
 5
 30 35 40 38 35
 
 Sample Output :
 1 2 3 1 1
 */
",C-Plus-Plus
"/**
 Find total number of Squares in a N*N cheesboard.
  */
 
 import java.io.*;
 import java.util.*;
 
 class Code{
     public static void main(String args[]) throws IOException{
         // taking input 
         BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
         System.out.println(""Enter the num"")
         Long num = Long.parseLong(read.readLine());
         Sol obj = new Sol();
         System.out.println(""The square : "")
         System.out.println(obj.squares(num));
     }
 }
 class Sol {
     // using maths logic
     static Long squares(Long n) {
        return  (long) (n*(n+1)*(2*n+1))/6;
     }
 };
 
 /*
 Time complexity : O(N)
 Space complexity : O(1)
 */
 
 /*
 Input :
 Enter the number :  1
 Output :
 The square is : 1
 */
",Java
"""""""
 Python Program to implement the Cutting a Rod problem
 
 We are given a rod of length 'n' and the cost of the rod of different length from
 1 to n. We need to find the maximum sell price that can be obtained by cutting the rod
 at any lengths.
 
 This problem can be solved by using Dynamic Programming
 """"""
 
 # Build a dp Table in Botom-Up manner, such that the n'th element stores
 # the maximum price obtained by a rod of length 'n'
 
 
 def max_sell_price(m, cost):
     dp = [0 for i in range(n+1)]
 
     for i in range(1, n + 1):
         curr_max = -1
         for j in range(i):
             curr_max = max(cost[j] + dp[i-j-1], curr_max)
         #  Stores the maximum cost obtainable for a rod of length i
         dp[i] = curr_max
     return dp[n]
 
 
 if __name__ == '__main__':
     print(""What is the length of the rod? "", end="""")
     n = int(input())
     if (n <= 0):
         print(""The given rod length is Invalid!!!"")
         exit()
     print(""Enter the cost of the rod for length 1 to {} :  "".format(n), end="""")
     cost = [int(x) for x in input().split(' ')]
     max_price = max_sell_price(n, cost)
     print(""The maximized sell price of the: {}"".format(max_price))
 
 
 """"""
 Time Complexity- O(n^2), where 'n' is the length of the rod
 Space Complexity- O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the rod? 5
 Enter the cost of the rod for length 1 to 5: 2 5 7 8 10
 The maximized sell price of the: 12 
 
 SAMPLE 2
 
 What is the length of the rod? -3
 The given rod length is Invalid!!!
 """"""
",Python
"/*
 AIM - To take binary number from the user 
       and convert it into binary number.
 */
 #include <stdio.h>
 #include <stdlib.h>
 
 /*Function decleration*/
 int BinarytoDecimal (char s[]);
 
 int main()
 {
     char temp[100];
     printf(""Enter the binary number : "");
     gets(temp);
     printf(""Decimal equivalent = %d"",BinarytoDecimal(temp));
     return 0;
 }
 /*Function to convert binary to decimal*/
 int BinarytoDecimal (char temp[])
 {
     int i,decimal=0;
     for(i=0;temp[i];i++)
     {
         if(temp[i]=='0')
             decimal=decimal*2+0;
         else
             decimal=decimal*2+1;
     }
     return(decimal);
 }
 
 /*
 
 Sample Input/Output:
 
 Enter the binary number : 1111
 Decimal equivalent = 15
 
 
 Time Complexity : O(n)
 Space Complexity : O(n)
 
 */
",C
"/* 
 Problem: Solving Quadratic equations in Java-
 A program that prints all real solutions to quadratic equation ax^2+bx+c=0, if discriminant is negative displays a message ""roots are imaginary"". 
 */
 import java.util.*;
 import java.io.*;
 
 public class Quadratic_Equation {
   public static void quadraticroots()
   {
     // value a, b, and c
     double a, b, c;
     double root1, root2;
     Scanner sc = new Scanner(System.in);
     System.out.println(""Enter coefficients of the equation:"");
     System.out.print(""Enter a: "");
     a = sc.nextDouble();
     System.out.println();
     System.out.print(""Enter b: "");
     b = sc.nextDouble();
     System.out.println();
     System.out.print(""Enter c: "");
     c = sc.nextDouble();
     System.out.println();
     // If a is 0, then equation is not quadratic, but linear
     if (a == 0) {
         System.out.println(""Its a linear equation,Not a quadratic equation!"");
         return;
       }
     // calculate the discriminant (b^2 - 4ac)
     double discriminant = b * b - 4 * a * c;
     // discriminant is greater than 0, real and distinct roots
     if (discriminant > 0) {
         root1 = (-b + Math.sqrt(discriminant)) / (2 * a);
         root2 = (-b - Math.sqrt(discriminant)) / (2 * a);
         System.out.println(""Roots are real and distinct"");
         System.out.format(""root1 = %.2f and root2 = %.2f"", root1, root2);
       }
     // discriminant is equal to 0, real and equal roots
     else if (discriminant == 0) {
         root1 = root2 = -b / (2 * a);
         System.out.println(""Equal roots"");
         System.out.format(""root1 = root2 = %.2f;"", root1);
       }
     // discriminant is less than zero, imaginary roots
     else {
         double real = -b / (2 * a);
         double imaginary = Math.sqrt(-discriminant) / (2 * a);
         System.out.println(""Imaginary roots!"");
         System.out.format(""root1 = %.2f+%.2fi"", real, imaginary);
         System.out.format(""\nroot2 = %.2f-%.2fi"", real, imaginary",Java
"public class Merge_sort {
 //merge sort function to recursively break the array to one-one element
     static void merge_sort(int[] a,int l,int h){
         int mid;
         if(l<h){
             mid=(l+h)/2;
             merge_sort(a,l,mid);
             merge_sort(a,mid+1,h);
             merge(a,l,mid,h);
         }
     }
 //merge function to compare and merge to elements 
     static void merge(int[] a,int l,int mid,int h){
         int i=l,j=mid+1,k=l;
         int[] b=new int[100];
         while(i<=mid && j<=h){
             if(a[i]<a[j])
                 b[k++]=a[i++];
             else
                 b[k++]=a[j++];
         }
         for(;i<=mid;i++)
             b[k++]=a[i];
         for(;j<=h;j++)
             b[k++]=a[j];
         for(i=l;i<=h;i++)
             a[i]=b[i];
     }
     public static void main(String[] args){
         int[] a={11, 13,7,12,16,9,24,5,10,3};
         merge_sort(a,0,9);
         for(int i=0;i<10;i++)
             System.out.print(a[i]+"" "");
     }
 }
 /*output:
 3 5 7 9 10 11 12 13 16 24 
 */
 //for more better understanding of how this algorithm is working read the readme file for merge sort.
",Java
"/*
 This is C++ code for: Rotate the given matrix by 90 degree to right 
 For example:
           1 2 3                7 4 1
           4 5 6     ====>      8 5 2
           7 8 9                9 6 3
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 void rotate(vector<vector<int>> &ans)
 {
     int n = ans.size();
     for (int i = 0; i < n; i++)
     {
         for (int j = i; j < ans[i].size(); j++)
         {
             swap(ans[i][j], ans[j][i]);
         }
     }
     for (int i = 0; i < n; i++)
     {
         for (int j = 0; j < n / 2; j++)
         {
             swap(ans[i][j], ans[i][n - j - 1]);
         }
     }
 }
 int main()
 {
     int m,n;
     cout<<""Enter size of matrix(m n):"";
     cin>>m>>n;
     cout<<""Enter ""<<m*n<<"" elements:"";
     vector<vector<int>> arr;
     for(int i=0;i<m;i++)
     {
         vector<int> r;
         for(int j=0;j<n;j++)
         {
             int a;
             cin>>a;
             r.push_back(a);
         }
         arr.push_back(r);
     }
     cout << ""Matrix Before Rotation:\n"";
     for (int i = 0; i < arr.size(); i++)
     {
         cout << ""["";
         for (int j = 0; j < arr[0].size(); j++)
         {
             cout << arr[i][j] << "" "";
         }
         cout << ""]\n"";
     }
     rotate(arr);
     cout << ""Matrix After Rotation:\n"";
     for (int i = 0; i < arr.size(); i++)
     {
         cout << ""["";
         for (int j = 0; j < arr[0].size(); j++)
         {
             cout << arr[i][j] << "" "";
         }
         cout << ""]\n"";
     }
 }
 /*
 Sample Input: 
 Enter size of matrix(m n):3 3
 Enter 9 elements:1 2 3 4 5 6 7 8 9
 
 Sample Output:
 Matrix Before Rotation:
 [1 2 3 ]
 [4 5 6 ]
 [7 8 9 ]
 Matrix After Rotation:
 [7 4 1 ]
 [8 5 2 ]
 [9 6 3 ]
 
 Time-Complexity: O(m+n)
 Space-Complexity: O(1)
 
 */
",C-Plus-Plus
"  /* This is a java code of finding total number of
    words in given string.
   */
   import java.util.*;
   import java.lang.*;
   import java.io.*;
   import java.lang.String;
   public class count_words
   {
       public static int countWords(String str)
       {
              /* The java.util.StringTokenizer class allows
               you to break a string into tokens.
              */
               StringTokenizer tokens = new StringTokenizer(str);
               return tokens.countTokens();
       }
   public static void main(String[] args)
   {
       Scanner scan = new Scanner(System.in);
       System.out.print(""Enter your string : "")
       String str = scan.next();
       System.out.println(""No of words: "" + countWords(str));
   }
   }
    /*
   Time complexity is O(n)
   Space complexity is O(1)
 
   Input :
   Enter your string : I like to contribute here
 
   Output:
   No of words: 5
   */
",Java
""""""" Python program to find the Length of Longest Decreasing Subsequence
 
 Given an array we have to find the length of the longest decreasing subsequence that array can make.
 The problem can be solved using Dynamic Programming.
 """"""
 
 
 def length_longest_decreasing_subsequence(arr, n):
     max_len = 0
     dp = []
     # Initialize the dp array with the 1 as value, as the maximum length
     # at each point is atleast 1, by including that value in the sequence
     for i in range(n):
         dp.append(1)
 
     # Now Lets Fill the dp array in Bottom-Up manner
     # Compare Each i'th element to its previous elements from 0 to i-1,
     # If arr[i] < arr[j](where j = 0 to i-1), then it qualifies for decreasing subsequence and
     # If dp[i] < dp[j] + 1, then that subsequence  qualifies for being the longest one
 
     for i in range(0, n):
         for j in range(0, i):
             if(arr[i] < arr[j] and dp[i] < dp[j] + 1):
                 dp[i] = dp[j] + 1
 
     # Now Find the largest element in the dp array
     max_len = max(dp)
     return max_len
 
 if __name__ == '__main__':
     print(""What is the length of the array? "", end="""")
     n = int(input())
     if n <= 0:
         print(""No numbers present in the array!!!"")
         exit()
     print(""Enter the numbers: "", end="""")
     arr = [int(x) for x in input().split(' ')]
     res = length_longest_decreasing_subsequence(arr, n)
     print(""The length of the longest decreasing subsequence of the given array is {}"".format(res))
 
 
 """"""
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 What is the length of the array? 5
 Enter the numbers: 5 4 3 2 1
 The length of the longest decreasing subsequence of the given array is 5
 
 SAMPLE II
 
 What is the length of the array? 10
 Enter the numbers: 15 248 31 66 84 644 54 84 5 88
 The length of the longest decreasing subsequence of the given array is 4
 """"""
",Python
"/**
  * Length of Longest Substring Without Repeating Characters
  * Given a string, print the longest possible substring that has 
  * no repeating characters, i.e., all its characters are distinct. 
  * Consider a String contains upper and lower case alphabets.
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 int LongestSubstrNoRepeatingChar(string str)
 {
     //2 pointer which denotes limits of current window
     int start = 0, end = 0;
     int len = str.length();
     //Maintain count of each character
     map<char, int> charCount;
     //Variable ans stores length og longest substring without repeating characters
     int ans = 0;
     while (end < len) {
         charCount[str[end]]++;
         //If window size and no. of distict elements are same
         //update ans
         if (charCount.size() == end - start + 1) {
             ans = max(ans, end - start + 1);
             end++;
         }
 
         else if (charCount.size() < end - start + 1) { //If there are repeating characters, we shorten substring by removing
             //characters from start, till we get a distinct substring.
             while (charCount.size() < end - start + 1) {
                 charCount[str[start]]--;
                 if (charCount[str[start]] == 0)
                     charCount.erase(str[start]);
                 start++;
             }
             //move forward
             end++;
         }
     }
     return ans;
 }
 
 int main()
 {
     //Taking input from user
     string str;
     cout << ""Enter a string of alphabets: "";
     cin >> str;
     cout << ""Length of longest substring with no repeating characters: "";
     cout << LongestSubstrNoRepeatingChar(str);
 }
 
 /*
 	Test cases:
 
 	INPUT:
 	Enter a string of alphabets: xzvxzzvxxx
 	OUTPUT:
 	Length of longest substring with no repeating characters: 3
 
 	INPUT:
 	Enter a string of alphabets: PractisemakesanIndividualPerfect
 	OUTPUT:
 	Length of longest substring with no repeating characters: 10
 
",C-Plus-Plus
"/*
 AIM :: TO IMPLEMENT DESCENDING PRIORITY QUEUE 
 
 WHAT IS DESCENDING PRIORITY QUEUE ?
 
  In descending order priority queue, a higher priority number is given as a higher priority. 
  For example, from 1 to 5 arranged in descending order,
  the largest number, i.e., 5 is given as the highest priority in a Descending priority queue.
 
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 #define size 5
 
 //Front for insertion an Rear for deletion
 int Front = -1;
 int Rear = -1;
 int Queue[size];
 
 //for checking whether Priority Queue is full or not
 int q_full()
 {
     if (Rear == size - 1)
         return 1;
 
     return 0;
 }
 
 //for checking whether Priority Queue is empty or not
 int q_empty()
 {
     if (Front == -1 || Front > Rear)
         return 1;
 
     return 0;
 }
 
 //to display the data in Priority Queue
 void display()
 {
     if (q_empty())
         printf(""\nqueue is empty\n"");
     else
     {
         printf(""\n"");
         for (int i = Front; i <= Rear; i++)
             printf(""%d  "", Queue[i]);
         printf(""\n"");
     }
 }
 
 //for performing insertion
 void enq()
 {
     if (q_full())
         printf(""\nQUEUE OVERFLOW\n"");
     else
     {
         int element, i;
         printf(""\nenter the element: "");
         scanf(""%d"", &element);
 
         //if inserting for firs time then do increment front also
         if (Front == -1)
             Front++;
 
         //find appropriate place for the element and insert
         for (i = Rear; i >= 0 && element > Queue[i]; i--)
             Queue[i + 1] = Queue[i];
         Queue[i + 1] = element;
         Rear++;
 
         display();
     }
 }
 
 //for performing deletion
 void deq()
 {
     if (q_empty())
         printf(""\nQUEUE UNDERFLOW\n"");
     else
     {
         int element = Queue[Front];
         if (Front == Rear)
             Front = Rear = -1;
         else
             Front++;
         display();
     }
 }
 
 int main()
 {
     int choice;
     printf(""\n\n\tPRIORITY QUEUE ",C
"/**
  *  First Negative Integer in Every Window of Size K
  *  Cpp program to find first negative integer in each subarray
  *  of fixed size k, given an array of integers, using the 'Sliding
  *  Window Technique'. In case there is no negative integer in selected
  *  window, print 0.
  */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 /* function to find the first negative 
  integer in every window of size k*/
 void printFirstNegativeInteger(int len, int k, int arr[])
 {
     //A dynamic Array to store negative integers for current window of size k.
     vector<int> list;
     //Dynamic array to store 1st negative of each window
     vector<int> ans;
     int start = 0, end = 0;
     while (end < len) {
         //Add current element at the back of list if it is a negative integer
         if (arr[end] < 0)
             list.push_back(arr[end]);
         //When window size less than k, increase the size of window
         if (end - start + 1 < k)
             end++;
         //On reaching window size
         else if (end - start + 1 == k) { //If list is empty then the window does not have negative integer
             if (list.size() == 0)
                 ans.push_back(0);
             else { //Else is not empty then element at the front
                 //of list is the first negative integer of previous window
                 ans.push_back(list.front());
                 // Remove the elements which are out of this window
                 if (arr[start] == list.front())
                     list.erase(list.begin());
             }
             //slide the window
             start++;
             end++;
         }
     }
     //Print the first negative integer of each window
     for (int i = 0; i < ans.size(); i++)
         cout << ans[i] << "" "";
     cout << endl;
 }
 
 int main()
 {
     //taking input from user
     int len;
     cout << ""Enter the length of array of integers: "";
     cin >> len;
     int arr[len];
     cout << ""Enter array of in",C-Plus-Plus
"// Linear Search in Go
 // Return index of found element else return -1
 package main
 
 import (
 	""fmt""
 )
 
 func main() {
 	arr := []int{1, 5, 2, -5, 8, 4, 9, -12}
 	fmt.Printf(""Array: %v\n"", arr)
 	var find int
 	fmt.Printf(""Please enter element to be found: "")
 	fmt.Scan(&find)
 	result := search(arr, find)
 	fmt.Printf(""Result: %d"", result)
 }
 
 func search(list []int, item int) int {
 	for i := range list {
 		if list[i] == item {
 			return i
 		}
 	}
 	return -1
 }
",Go
"/* Purpose: To check whether it is possible for a Knight to visit each cell of the N*N chessboard without visiting any cell twice starting from (X, Y) position.
    Method: Backtracking Algorithm
    Intution: To visit each and every positions which are available from the current position and recursively repeat this until all the cells are covered */
 
 import java.io.*;
 import java.util.*;
 public class KnightsTour {
     public static void main(String[] args) throws Exception {
         Scanner scn = new Scanner(System.in);
         int n = scn.nextInt();
         int[][] chess = new int[n][n];
         int r = scn.nextInt();
         int c = scn.nextInt();
              //call the function
         knight( chess, r, c, 1 );      
     }
 
     public static void knight (int[][] chess, int r, int c, int jump) {
              //base case of recursion when the jump becomes equal to the length of check board
          if( jump == chess.length * chess[0].length ){
             //assign the jump number on the chess board
             chess[r][c] = jump;
              //call to display the feasible answer
             displayBoard( chess );
              //unvisit the cell
             chess[r][c] = 0;
             return;
         }
          //assign the jump number on the chess board
         chess[r][c] = jump;
          //recursive calls begins from here. It checks to see that the knight doesn't go out of the check board and also the cell should be unvisited
         if( r - 2 >= 0 && c + 1 < chess[0].length && chess[ r-2 ][c+1] == 0 ){
             knight( chess, r-2, c+1, jump+1 );
         }
         if( r - 1 >= 0 && c + 2 < chess[0].length && chess[ r-1 ][c+2] == 0 ){
             knight( chess, r-1, c+2, jump+1 );
         }
         if( r + 1 < chess.length && c + 2 < chess[0].length && chess[ r+1 ][c+2] == 0 ){
             knight( chess, r+1, c+2, jump+1 );
         }
         if( r + 2 < chess.length && c + 1 < chess[0].length && chess[ r+2 ][c+1] == 0 )",Java
"/*
 You are given an array arr containing 2N+2 positive numbers, out of which 2N numbers exist in pairs whereas the
 other two number occur exactly once and are distinct. You need to find the other two numbers and print them in
 ascending order.
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 // DRIVER FUNCTION
 int main()
 {
     int t, n, size;
     // Getting the Number of test cases as input
     cin >> t;
     while (t--)
     {
         //Getting the value N
         cin >> n;
         //The Array contains 2N+2 numbers
         size = 2 * n + 2;
         int arr[size], index;
         //Declare a vector for storing the result
         vector<int> res(2);
         //Declare a map for storing the frequency of numbers
         map<int, int> mp;
         //Getting the array input
         for (index = 0; index < size; index++)
             cin >> arr[index];
 
         //Storing the frequencies of the elements in the map
         for (index = 0; index < size; index++)
             mp[arr[index]]++;
 
         int resInd = 0;
         //Declare an iterator to traverse through the map
         map<int, int>::iterator it;
 
         for (it = mp.begin(); it != mp.end(); it++)
         {
             //Checking if the an element occurred odd number of times
             //if so, we will add that element to the resultant vector
             if ((it->second) % 2 != 0)
             {
                 res[resInd++] = it->first;
             }
         }
         //Since we need to print the other two numbers in ascending order,
         //the resultant vector is sorted
         sort(res.begin(), res.end());
         //print the two numbers stored in the resultant vector
         for (int ind = 0; ind < res.size(); ind++)
             cout << res[ind] << "" "";
     }
 
     return 0;
 }
 /*
 For example:
 
 Example 1:
 Input:
 1
 2
 1 2 3 2 1 4
 
 Output:
 3 4
 
 Example 2:
 Input:
 1
 1
 2 1 3 2
 
 Output:
 1 3
 */",C-Plus-Plus
"# Python program for implementation of heap Sort
 
 # To heapify subtree rooted at index.
 # length is size of heap
 
 def heapify(arr, length, index):
     # base case
     # we will call this function until the largest number is the index...
     largest_num_index = index
     left_index = (index * 2) + 1
     right_index = (index * 2) + 2
 
     if(left_index < length and arr[index] < arr[left_index]):
         largest_num_index = left_index
 
     if(right_index < length and arr[largest_num_index] < arr[right_index]):
         largest_num_index = right_index
 
     # if index is not the largest, make it the largest!
     # and run it again!
     if(largest_num_index != index):
         arr[index], arr[largest_num_index] = arr[largest_num_index], arr[index]
         heapify(arr, length, largest_num_index)
 
 
 def heap_sort(arr):
     # need array length to create indices
     length = len(arr)
 
     for index in range(length, -1, -1):
         # ask about functions modifying arrays without return value
         # build max heap
         heapify(arr, length, index)
 
     # for each sorted heap, swap the root and the last number
     for index in range(length - 1, 0, -1):
         arr[index], arr[0] = arr[0], arr[index]
         # then call heapify again with the new array
         heapify(arr, index, 0)
 
 
 # Taking Elements to be Sorted
 data = [int(input())
         for index in range(int(input(""Enter elements to be sorted : "")))]
 # Sending element to get sorted
 heap_sort(data)
 # Priting Elements after Getting Sorted
 print(data)
 
 '''
 Sample Output:
 Enter elements to be sorted : 5
 30
 50
 10
 20
 40
 [10, 20, 30, 40, 50]
 
 Building the max heap requires O(n) calls to the buildHeap function which
 takes O(log n) time to build the max heap
 Therefore, total time complexity = O(nlog n)
 In heap sort since we are only keeping data in the array and only
 rearranging it so no data needs to be stored anywhere else (other than the swap step)
 So, space comp",Python
"/* ADJACENCY LIST FOR REPRESENTING DIRECTED GRAPH
     It is a method of representing a digraph using 2 linked lists
         1. Node list
         2. Edge list corresponding to each node
     Edges arising from a node are stored in edge list of each node
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 /* Declare a structure for representing digraph with data and 2 links
  * link represents the edge between the parent node and next node (edge list)
  * pnext point to the next node from which new edges arise(node list)
  * g points to the graph
 */
 typedef struct AdjacencyList
 {
     int data;
     struct AdjacencyList *link, *pnext;
 } AdjacencyList;
 AdjacencyList *g;
 
 //to insert into the graph
 void insert_to_graph(AdjacencyList *g, int parent, int value)
 {
     //ptr points to the first node in the graph
     AdjacencyList *ptr = g->link, *p;
     //Check if the graph is empty
     if (g->link == NULL)
     {
         //Allocate memory for ptr to store the value of parent node
         ptr = malloc(sizeof(AdjacencyList));
         ptr->data = parent;
         ptr->pnext = NULL;
         ptr->link = NULL;
         // Set ptr as first node
         g->link = ptr;
     }
     else
     {
         //Search for parent in the node list
         while (ptr != NULL && ptr->data != parent)
         {
             p = ptr;
             ptr = ptr->pnext;
         }
         //If parent is not found in the node list insert as last node
         if (ptr == NULL)
         {
             ptr = malloc(sizeof(AdjacencyList));
             ptr->data = parent;
             ptr->pnext = NULL;
             ptr->link = NULL;
             p->pnext = ptr;
         }
     }
     //Allocate memory for node to insert value in the edge list of parent node
     AdjacencyList *node;
     node = (AdjacencyList *)malloc(sizeof(AdjacencyList));
     node->data = value;
     node->link = NULL;
     node->pnext = NULL;
     //Traverse till the end of the edge list
     while (ptr->link != ",C
"/*
  *	Author: Davide Pollicino (@omonimus)
  * Date: 26/06/2020
  *
  * Summary: Implement binary search algorithm in Javascript
  */
 
 // Search an element in using Binary Search algorithm O(log n) time;
 // It works just if the list is already sorted;
 function binary_search(arr, target) {
   // Define left and right index of the range where to search
   // our target
   let start = 0,
     end = arr.length - 1;
 
   // Iterate while start not meets end
   while (start <= end) {
     // Get middle index
     let middle = Math.floor((start + end) / 2);
 
     // If element is present at middle return True
     if (arr[middle] === target) return true;
     // Else look in left or right half accordingly
     else if (arr[middle] < target) start = middle + 1;
     else end = middle - 1;
   }
   // Target do not exists
   return false;
 }
 
 /*
  *   @Test
  *   output expected: 'false'
  */
 function element_do_not_exists_test() {
   var numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
   var target = 14;
   console.log(binary_search(numbers, target));
 }
 
 /*
  *   @Test
  *   output expected: 'true'
  */
 function element_exists_test() {
   var numbers = [1, 2, 3, 6, 9, 10];
   var target = 3;
   console.log(binary_search(numbers, target));
 }
 
 // Entry point of the application for testing purposes
 element_do_not_exists_test();
 element_exists_test();
",JavaScript
"/*
 Conversion of a decimal number to binary form can be achieved by continously dividing the number
 number by 2 until the quotient becomes zero. The remained obtained in each step is combined to form
 give the resultant binary form of the number
 */
 
 import 'dart:io';
 
 // Function to return binary conversion of number
 int toBinary(int num) {
   int binary = 0;
   int index = 1;
 
   // Iterate till all divisions complete
   while (num > 0) {
     binary = binary + ( num % 2 * index);
     num ~/= 2;
     index *= 10;
   }
   return binary;
 }
 
 // Main Function with driver code
 void main() {
   print(""Enter a number :"");
   int num = int.parse(stdin.readLineSync()!);
 
   // Call binary conversion function
   int binary = toBinary(num);
   print(""Binary conversion of $num is $binary"");  
 }
 
 /**
 Space Complexity O(1)
 Time Complexity  O(n)
 
 Sample input/output:
 Enter a number :
 13
 Binary conversion of 13 is 1101
 
 Enter a number :
 25
 Binary conversion of 25 is 11001
 */
 
",Dart
"/*  
 This code checks if a binary tree is symmetric or not,
 here we have a function ""Check_Symmetry"" which at first calculate the height of the given binary tree and then checks 
 if all the levels of the given Binary tree are forming a palindrome or not, using ""is_level_palindrome"" function.
 If all the level forms palindrome then it represent that the given binary tree is symmetric otherwise it is not symmetric.
 If at the given level if some value is 'NULL', then we consider it as 'INT_MIN' while checking if level is palindrome or not.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 struct TreeNode{
 	int value;
 	struct TreeNode* left;
 	struct TreeNode* right;
 };
 
 TreeNode* newNode(int n){
 	TreeNode* t = new TreeNode;
 	t->value = n;
 	t->left = NULL;
 	t->right = NULL;
 	return t;
 }
 
 //this function calculate the height of the Binary Tree  
 int height(TreeNode* A){		 
 	if(A==NULL){
 		return 0;
 	}
 	return 1 + max(height(A->left),height(A->right));
 }
 
 //This gives us the vector of values of all the nodes at the given height
 void level_order(TreeNode* A, int h, vector<int> &v){ 		 
 	if(A==NULL){
 		v.push_back(INT_MIN);
 		return;
 	}
 	if(h==1){
 		v.push_back(A->value);
 		return;
 	}
 	level_order(A->left,h-1,v);
 	level_order(A->right,h-1,v);
 }
 
 // This function checks if particular level of given binary tree forms palindrome
 bool is_level_palindrome(TreeNode* A, int h){		
 	vector<int> v;
 	level_order(A,h,v);
 	for(int i=0;i<v.size()/2;i++){
 		if(v[i]!=v[v.size()-1-i]){
 			return false;
 		}
 	}
 	return true;
 }
 
 //This function checks if given binary tree is symmetrical
 bool Check_Symmetry(TreeNode* A){		   
 	int h = height(A);
 	for(int i=1;i<=h;i++){
 		if(!is_level_palindrome(A,i)){
 			return false;
 		}
 	}
 	return true;
 }
 
 int main(){
 	TreeNode* T = newNode(5);
 	T->left = newNode(6);
 	T->right = newNode(6);
 	T->left->left = newNode(3);
 	T->left->right = newNode(8);
 	T->right->left = newNode(8);
 	T->ri",C-Plus-Plus
"// C++ Program to find the Number of Digits in a given number
 #include <bits/stdc++.h>
 using namespace std;
 
 int sum_of_digits(int num)
 {
     int cnt = 0;
     while (num != 0)
     {
         cnt++;
         // Removing the least significant digit
         num = num / 10;
     }
     return cnt;
 }
 
 int main()
 {
     int num, cnt;
     cout << ""\nEnter the number: "";
     cin >> num;
 
     // If the number is negative, convert it into positive
     if (num < 0)
     {
         num = num * -1;
     }
 
     // Call the function
     cnt = sum_of_digits(num);
     // Print the obtained count
     cout << ""The number of digits in the given number is: "" << cnt;
     return 0;
 }
 
 /*
 Time Complexity- O(log(num)), where 'num' is the given num
 Space Complexity- O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the number: 3241
 The number of digits in the given number is: 4
 */
",C-Plus-Plus
"/*
 Description : Given an array and size, the task is to add the minimum number
               (should be greater than 0) to the array so that the sum of the 
               array becomes even .
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Solution
 {
 public:
     // function is being used to find that minimum number
     int minNum(long long int arr[], int n)
     {
         long sum = 0;
         sum = accumulate(arr, arr + n, sum);
         if (sum == 0)
         {
             return 0;
         }
         else if (sum % 2 == 0)
         {
             return 2;
         }
         else
         {
             return 1;
         }
     }
 };
 
 int main()
 {
     //n = size of array
     int n;
     cout << ""Enter the size of the array : "" << endl;
     cin >> n;
     // array size can be big so used long long
     long long a[n];
     cout << ""Enter "" << n << "" number of elements : "" << endl;
     for (int i = 0; i < n; i++)
     {
         cin >> a[i];
     }
 
     Solution obj;
     cout << ""Minimum Number to be added in the array : "" << endl;
     cout << obj.minNum(a, n);
 
     return 0;
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Cases : 
 Test Case 1 : 
     Input :
     Enter the size of the array : 
     8
     Enter 8 number of elements : 
     1 2 3 4 5 6 7 8
 
     Output :
     Minimum Number to be added in the array : 
     2
 */
 
",C-Plus-Plus
"/* A program for warshall algorithm.It is a shortest path algorithm which is used to find the 
 distance from source node,which is the first node,to all the other nodes.
 If there is no direct distance between two vertices then it is considered as -1
 */
 #include <stdio.h>
 
 
 /*The size of graph*/
 int ver;
 
 
 void warshall(int g[ver][ver])
 {
   int i,j,k;
   /*A 2d matrix to store distance*/
   int dist[ver][ver];
   for (i = 0; i < ver; i++)
         for (j = 0; j < ver; j++)
 		/*Initially storing all the distance
 		in the dist matrix*/
             dist[i][j] = g[i][j];
  
     for (k = 0; k < ver; k++)
     {
 		for (i = 0; i < ver; i++)
         {
             for (j = 0; j < ver; j++)
             {
                /*To find the smallest distance between two vertex if it exists*/
                 if (dist[i][k] + dist[k][j] < dist[i][j] && dist[i][k]!=-1&& dist[k][j]!=-1)
                     dist[i][j] = dist[i][k] + dist[k][j];
             }
         }
     }
 	/*Printing the calculated distance matrix*/
 	printf(""The distance graph is:\n"");
   for(i=0;i<ver;i++)
     {
         for(j=0;j<ver;j++)
         {
             if(dist[i][j]>=0)
            printf(""%d "",dist[i][j]);
            else
            printf(""%d "",-1);
         }
         printf(""\n"");
     }
 }
 /*Main function*/
 int main()
 {
         printf(""Enter number of vertices\n"");
         scanf(""%d"",&ver);
         int graph[ver][ver];
 		/*Creation of graph*/
         printf(""Enter graph\n"");
         int i,j;
         for( i=0;i<ver;i++)
         {
             for(j=0;j<ver;j++)
             {
                scanf(""%d"",&graph[i][j]);
             }
         } 
 		/*Calling of function*/
         warshall(graph);
     return 0;
 }
 
 /*
 Time Complexity:O(Ver^3)
 Space Complexity:O(Ver^2)
 
 Input/Output:-
 Enter number of vertices
 4
 Enter graph
 0
 8
 -1
 1
 -1
 0
 1
 -1
 4
 -1
 0
 -1
 -1
 2
 9
 0
 The distance graph is:
 0 3 -1 1 
 -1 0 1 -1 
 4 -1 0 -1 
 -1 2 3 0 
 */
",C
"/*
 Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to 
 the other number. (A proper divisor of a number is a positive factor of that number other than the number itself.
 Given two Numbers A and B, find whether they are Amicable Numbers or not. Print 1 if they are Amicable else 0.
                     
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Sol
 {
 public:
     //  to get the sum of all proper divisors of a number.
     long long div_sum(int n)
     {
         long long result = 0;
         for (int i = 2; i <= sqrt(n); i++)
         {
             if (n % i == 0)
             {
                 if (i == (n / i))
                     result += i;
                 else
                     result += (i + n / i);
             }
         }
         return (result + 1);
     }
 
     int isAmicable(int A, int B)
     {
 
         // If and only if sum of proper divisors of A is equal to B
 
         if (A != B && div_sum(A) == B && div_sum(B) == A)
             return 1;
         else
             return 0;
     }
 };
 
 int main()
 {
     int a, b;
     cout << ""Enter the a and b"" << endl;
     cin >> a >> b;
     Sol obj;
     cout << ""Amicable Pair : "" << endl;
     cout << obj.isAmicable(a, b) << endl;
 
     return 0;
 }
 
 /*
 
 Time complexity : O(sqrt(A,B))
 Space complexity : O(1)
 
 */
 
 /*
 
 Test Case : 
      Test case 1 :
      Enter the a and b
       220  284
 
     Test case 2 : 
     Amicable Pair : 
     1
 */
 
",C-Plus-Plus
"/*
 ->Stack is used to display dfs traversal of the graph.
 ->Similar to bfs traversal , only the queue is replaced by stack.
 ->A vector list is returned containing the dfs traversal from source vertex as 0.
 ->Two stacks are maintained for printing dfs starting from Oth vertex from left to right.
 */
 
 #include <iostream>
 using namespace std;
 #include <list>
 #include <vector>
 #include <stack>
 class graph
 {
 public:
     int v;
     list<int> *l;
     graph(int v)
     {
         this->v = v;
         l = new list<int>[v];
     }
     void addEdge(int x, int y)
     {
         l[x].push_back(y);
         l[y].push_back(x);
     }
     /*
     Function to display the graph
     void printg()
     {
         for (int i = 0; i < v; i++)
         {
             cout << i << ""->"";
             for (int nbrs : l[i])
             {
                 cout << nbrs << "","";
             }
             cout << ""\n"";
         }
     }
     */
 };
 vector<int> iterative_dfs(graph g, vector<bool> &visited, int src)
 {
     stack<int> helper_st;
     stack<int> main_st;
     vector<int> dfs_ans;
 
     main_st.push(0);
     //loop until main stack is empty
     while (main_st.size() > 0)
     {
         if (visited[main_st.top()] == true)
         {
             main_st.pop();
             continue;
         }
         int t = main_st.top();
         dfs_ans.push_back(main_st.top());
 
         visited[main_st.top()] = true;
         main_st.pop();
 
         for (int nbrs : g.l[t])
         {
             if (visited[nbrs] == false)
             {
                 helper_st.push(nbrs);
             }
         }
         //Copying contents from helper to main stack for printing nbrs left to right
         while (helper_st.size() > 0)
         {
             main_st.push(helper_st.top());
             helper_st.pop();
         }
     }
     return dfs_ans;
 }
 int main()
 {
     int vertices, edges;
     //cout<<""Enter no of vertices and edges: "";
     cin >> vertices >> edge",C-Plus-Plus
"/*
   Program to Reverse a Circular Linked List.
  
   Algorithm explained:
   -> Three pointers are used - previous, current and next.
   -> previous points to null, current to start and next to start.address.
   -> Changing current.address to point to the previous node (null).
   -> previous now points to current.
   -> current now points to next.
   -> Iterating the previous steps until current points to start.
   -> Adjust start.address to point to previous.
   -> start now points to previous.
  */
 
 import java.util.*;
 
 class Node
 {
     public int data;
     public Node address;
     Node(int d) 
     {
         data = d;
         address = null;
     }
 }
 
 public class ReversingCircularLinkedList
 {
     static Node start;
     static int size;
 
     //Default constructor to initialize the global variables.
     ReversingCircularLinkedList()
     {
         start = null;
         size = 0;
     }
 
     //This function is to reverse the circular linked list.
     static Node reverse(Node start) 
     {  
         Node previous = null; 
         Node current = start; 
         Node next; 
         do 
         { 
             next = current.address; 
             current.address = previous; 
             previous = current; 
             current = next; 
         } while (current != (start)); 
         
         (start).address = previous; 
         start = previous; 
         return start;
     }  
 
     //This function is to create the circular linked list.
     public void create(Node node,int i) 
     {
         if (start == null)
         {
             start = node;
         }
         else 
         {
             Node temp = start;
             while (temp.address != null)
                 temp = temp.address;
             temp.address = node;
 
             if(i == size-1)
             {
                 temp.address.address = start;
             }
         }
     }
 
     //This function is to display the circular linked list.
     void displ",Java
""""""" Demonstartion of Priority Queue in Python.
 
 Priority Queue is an extension of queue with some additional properties-
 -> Every item has a priority associated with it.
 -> An element with high priority is dequeued before an element with low priority.
 -> If two elements have the same priority, they are served according to their order in the queue.
 
 A priority queue supports following main operations:
 -> insert_into(item, priority): Inserts an item with given priority.
 -> get_min(): Returns the lowest priority item.
 -> remove_min(): Removes the lowest priority item.
 """"""
 
 
 class PriorityQueueNode:
     """"""
     Node class for PriorityQueue.
     """"""
 
     def __init__(self, value, priority):
         self.value = value
         self.priority = priority
 
 
 class PriorityQueue:
     """"""
     PriorityQueue implementation using a list.
     A priority is attached with every value of the queue.
     """"""
 
     def __init__(self):
         self.pq = []
 
     def get_size(self):
         """"""
         Return the size of the priority queue.
         """"""
         return len(self.pq)
 
     def isEmpty(self):
         """"""
         Return boolean value.
         `True` if the priority queue is empty,
         esle, returns `False`.
         """"""
         return self.get_size() == 0
 
     def get_min(self):
         """"""
         Return the least priority element in the priority queue.
         """"""
         if self.isEmpty():
             return None
         return self.pq[0].value
 
     def insert_into_pq(self, value, priority):
         """"""
         Insert elements into the priority queue.
         """"""
         pq_node = PriorityQueueNode(value, priority)
         self.pq.append(pq_node)
 
         self.percolate_up()
 
     def percolate_up(self):
         """"""Find correct place for the element to be added
         into the priority queue, following Heap Order Property.
         """"""
         child_index = self.get_size() - 1
 
         while child_index > 0:
 ",Python
"/* C++ program to print the n'th term in the Golomb sequence
 Golomb sequence is a non-decreasing integer sequence where n'th
 term is  equal to the number of times n appears in the sequence */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int golomb_sequence(int n)
 {
     // Create a dp array, with value initialized as 0.
     int dp[n + 1];
 
     dp[1] = 1;
 
     // Identify the previous term 'prev' and go prev terms behind and find a number.
     // Now assign the current element with an incremented value of that element.
     for (int i = 2; i <= n; i++)
     {
         int prev = dp[i - 1];
         int back_index = i - dp[prev];
         dp[i] = 1 + dp[back_index];
     }
     return dp[n];
 }
 
 int main()
 {
     int n;
     cout << ""Enter the value of n?, where you need the n'th number in the golomb sequence."";
     cin >> n;
     if (n <= 0)
     {
         cout << ""The given value of n is invalid."";
         return 0;
     }
     int res = golomb_sequence(n);
     cout << ""The "" << n << ""'th term in the golomb sequence is "" << res;
     return 0;
 }
 
 /*
 Time Complexity: O(n), where 'n' is the given number
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 Enter the value of n?, where you need the n'th number in the golomb sequence. 5
 The 5'th term in the golomb sequence is 3.
 
 SAMPLE 2
 
 Enter the value of n?, where you need the n'th number in the golomb sequence. 867
 The 867'th term in the golomb sequence is 79.
 */
",C-Plus-Plus
"/*
 
 A neon number is a number where the sum of digits of the square of the number is equal to the number.
 Below is the implementation to check whether the given number is Neon number or not. 
 
 Time Complexity - O(log n)
 Space Complexity - O(1)
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // using loop
 function checkNeonLoop(number) {
   let num = number ** 2; // get the square
 
   let neon = 0; // store the sum of digits
 
   // calculat the sum
   while (num !== 0) {
     let rem = num % 10;
     neon += rem;
     num = Math.floor(num / 10);
   }
 
   // check is neon?
   if (number === neon)
     return console.log(""Using Loop result - Neon number!"");
   return console.log(""Using Loop result - Not a Neon number"");
 }
 
 // using built-in methods
 function checkNeon(number) {
   let num = number ** 2; // get the square
 
   // convert to string & then create array of strings of digits
   let neon = num.toString().split("""");
 
   // calculate the sum
   let getSum = neon.reduce((acc, item) => {
     return parseInt(item) + acc; // convert string digit to integer
   }, 0);
 
   // check is neon?
   if (getSum === number) return console.log(""Using Built-In methods result - Neon number!"");
   return console.log(""Using Built-In methods result - Not a Neon number"");
 }
 
 let number = +prompt(""Enter a number - "");
 
 // Check whether the entered value is number or not
 if (isNaN(number)) return console.log(""Only numbers are allowed"");
 
 // Check if the input number is negative
 if (Math.sign(number) === -1) return console.log(""Not a neon number"");
 
 // Call the algorithm
 checkNeon(number);
 checkNeonLoop(number);
 
 /*
 
 > node NeonNumber
 
 // Example 01
 Enter a number - 12
 Using Built-In methods result - Not a Neon number
 Using Loop result - Not a Neon number
 
 // Example 02
 Enter a number - 9
 Using Built-In methods result - Neon number!
 Using Loop result - Neon number!
 
 */
",JavaScript
"/* 
 Code Description:
 Through this C program ,we find the Bitonic Point in a Linked List.
 Bitonic Point is a point in bitonic sequence( Sequence of numbers which is first strictly increasing then after a point strictly decreasing) before
 which elements are strictly increasing and after which elements are strictly decreasing.
 */
 #include <stdio.h>
 #include <conio.h>
 #include <stdlib.h>
 
 /* Defining a Node */
 struct Node {
 	int data;
 	struct Node* next;
 };
 
 /* Header points to first node and Last points to last one */
 struct Node *header,*last;
 
 int Bitonic_Point()
 {
 	struct Node *t1 = header;
 	/* If list is empty or contains one Node */
 	if(header == NULL || header->next == NULL)
 	{
 		return -1;
 	}
 	/* Not in Bitonic sequence */
     if (t1->data > t1->next->data)
         return -1;	
         
 	while(t1->next != NULL)
 	{
 		/* If the data in current Node is greater than Next Node */
 		if(t1->data > t1->next->data)
 		{
 			break;			
 		}
 		/* Otherwise Traversal continues */
 		t1=t1->next;		
 	}
 	
 	/* Storing data (Bitonic Point )of the Current Node */
 	int val = t1->data;
 	
 	/* Updating to its Next Node */
 	t1=t1->next;
 	
 	while(t1->next != NULL)
 	{
 		/* If data in current Node is less than Next Node's data */
 		if(t1->data < t1->next->data)
 		{
 			/* Bitnoic Point doesn't exist */
 			return -1;		
 		}
 		t1=t1->next;
 	}
 	return val;
 }
 
 
 /* Function to create a Linked List */
 void create()
 {
 	struct Node *temp=(struct Node*)malloc(sizeof(struct Node));
   	
  	printf(""\nEnter value of node : "");
  	
   	scanf(""%d"",&temp->data);
   	temp->next=NULL;
   	
     if (header==NULL)
   	{
     	header=temp;
     	last=temp;
     	return;
   	}
   	else
   	{
     	last->next=temp;
     	last=temp;
     	return;
   	}
 }
 
 /* Function to print nodes in a given linked list */
 void show()
 {
   	struct Node *temp=header;
   	while(temp!=NULL)
   	{
 		printf(""-->%d"",temp->data);
     	temp=temp->next;
   	}
   	printf(",C
"/*
 Given a number's base and power.
 return the number.
 
 base and power can be large as 10^6 to 10^9
 so we need to mod with some big number in order to get the number
 this can be done by bigmod algorithm
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // this get_new_number_by_bigmod will give us the new number
 long long int get_new_number_by_bigmod(long long int base, long long int power, long long int mod_number)
 {
     long long int new_number;
     if(power == 0)
     {
         // no matter what base is , as power is 0 answer 1
         return 1;
     }
     else if(power % 2 == 0)
     {
         /* as power is even,
         we will divide the power each step by 2
         9^18 will be 9^9 , 9^9
         and thus goes on  by recursive call
         */
         new_number = get_new_number_by_bigmod(base , power / 2, mod_number);
         return ((new_number * new_number) % mod_number);
 
     }
     else
     {  /* as power is odd,
         we will  take power - 1
         9^15 = 9^14 , 9^1
         and thus goes on  by recursive call
         */
         long long int temp = get_new_number_by_bigmod(base , power - 1 , mod_number);
         return ((( base % mod_number)* temp)% mod_number);
 
     }
 }
 
 int main()
 {
     cout << ""Enter the base number and power number : "";
     long long int base , power;
     scanf(""%lld %lld"", &base, &power);
     cout << ""Enter the mod number: "";
     long long int mod_number;
     scanf(""%lld"", &mod_number);
 
     long long int new_number = get_new_number_by_bigmod(base, power, mod_number);
 
     cout << ""After applying Bigmod algorithm the new number is : \n"";
     cout << new_number << endl;
 }
 
 /*
 Standard Input and Output
 
 Enter the base number and power number :
 45 67
 Enter the mod number: 1000456
 
 After applying Bigmod algorithm the new number is :
 595941
 
 Time Complexity : O( log N )
 Space Complexity : O( 1 )
 
 */
",C-Plus-Plus
"/*
 SudokuSolver
 Given a partially filled 99 2D array grid[9][9], the goal is to assign digits (from 1 to 9) 
 to the empty cells so that every row, column, and subgrid of size 33 contains exactly one instance 
 of the digits from 1 to 9.
 */
 
 #include <stdio.h>
 #include <stdbool.h>
 #include <math.h>
 
 bool isSafeToPut(int mat[][9], int i, int j, int n, int number)
 {
     // Check the rows and cols
     for (int k = 0; k < n; k++)
     {
         if (mat[k][j] == number)
         {
             return false;
         }
     }
 
     for (int k = 0; k < n; k++)
     {
         if (mat[i][k] == number)
         {
             return false;
         }
     }
 
     n = sqrt(n);
     int starti = (i / n) * n;
     int startj = (j / n) * n;
 
     for (int k = starti; k < starti + n; k++)
     {
         for (int l = startj; l < startj + n; l++)
         {
             if (mat[k][l] == number)
             {
                 return false;
             }
         }
     }
     return true;
 }
 
 bool SudokuSolver(int mat[][9], int i, int j, int n)
 {
     if (i == n)
     {
         // Print the sudoku
         printf(""\nSolved Sudoku:\n"");
         for (int k = 0; k < n; k++)
         {
             for (int l = 0; l < n; l++)
             {
                 printf(""%d "", mat[k][l]);
             }
             printf(""\n"");
         }
         printf(""\n"");
         return true;
     }
     if (j == n)
     {
         return SudokuSolver(mat, i + 1, 0, n);
     }
     if (mat[i][j] != 0)
     {
         return SudokuSolver(mat, i, j + 1, n);
     }
     for (int number = 1; number <= n; number++)
     {
         if (isSafeToPut(mat, i, j, n, number))
         {
             mat[i][j] = number;
             bool t = SudokuSolver(mat, i, j + 1, n);
             if (t)
             {
                 return true;
             }
             mat[i][j] = 0;
         }
     }
     return false;
 }
 
 int main()
 {
     int mat[9][9];
     printf(""Enter elements and",C
"import java.util.*;
 public class Main 
 {
     static Node head;
     class Node{
     	public int data;
     	public Node next;
     	Node(int data){
     		this.data=data;
     	}
     }
     
     public void insert_At_beginning(int data) {
     	Node ptr = new Node(data);
     	if(head!=null)
           {
     		ptr.next=head;
     		head=ptr;
           }
     	else 
     	  {     
 		ptr.next=null;
     	        head=ptr;
        	  }
     }
     public boolean isEmpty()
     {
       if(head==null)
        return true;
       return false;
     }
     public void print() {
     	Node ctr=head;	
     	while(ctr!=null)
     	{
     		System.out.print(ctr.data);
     		ctr=ctr.next;
     	}
     	System.out.println();
     }  
     public void insert_At_End(int data)
     {    Node ctr=head;
     	 Node ptr = new Node(data);
     	 if(ctr==null)
     	 { head=ptr;
     	   ptr.next=null;
     	   return ;
     	 }
     	 else {
     	   while(ctr.next!=null)
     		 ctr=ctr.next;
     	   ctr.next=ptr;
            ptr.next=null;
     	 }
     } 
     public void delete_From_Beginning()
     {   if(head!=null)
     	  head = head.next;
         else 
     	System.out.println(""Linked list is empty"");
     }
     public void delete_From_End()
     {   
     	Node ctr=head;
     	if(ctr!=null && ctr.next!=null)
 	   {
     	     while(ctr.next.next!=null)
     		ctr=ctr.next;
     	     ctr.next=null;
     	  }
     	else if( ctr!=null && ctr.next==null)
     	   head = null;
     	else
     	  System.out.println(""Linked list is empty"");  
     }
     public void delete_At_Position(int c)
     {   
     	int i=1;Node ctr=head,ptr;
     	if(ctr!=null && ctr.next!=null) 
 	{
     	   while(i<c-1 && ctr.next!=null)
     		ctr=ctr.next;
     	   ptr=ctr.next;
     	   ctr.next=ptr.next;
         }
 	else if( ctr!=null && ctr.next==null)
     	   head = null;    
         else
     	 System.out.println(""Linked list is empty""); 
        return ;
    }
    public void ins",Java
"/*Problem Statement:
 There are n white and n black dots equally spaced in a line
 You want to connect each white dot with some one black dot,
 with a minimum total length of the wire.
 Find the total length needed. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int connectDots(int a1[],int a2[],int white,int black)
 {
     int ans=0;
     sort(a1,a1+white);
     sort(a2,a2+black);
     for(int i=0;i<white;i++)
     {
         int temp=abs(a1[i]-a2[i]);
         ans+=temp;
     }
     return ans;
 }
 
 int main()
 {
     int white,black;
     cout<<""Enter total number of white and black dots: ""<<endl;
     cin>>white>>black;
     int a1[100],a2[100];
     for(int i=0;i<white;i++)
     {
         cin>>a1[i];
     }
     for(int j=0;j<black;j++)
     {
         cin>>a2[j];
     }
     cout<<""Total length needed is: ""<<connectDots(a1,a2,white,black)<<endl;
     return 0;
 }
 /*
 Example: 
 
 Input:-
 Enter total number of white and black dots:
 3 3
 3 4 1
 2 5 6
 
 Output:-
 Total length needed is: 5
 
 Time Complexity: O(nlogn)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
"/*
   Intersection :
      We have to find intersection of two arrays :
      The intersection of two arrays is a list of numbers which are present in both the arrays
   For example :
      We have to input 2 arrays of integer, let first array be 1 4 3 2 and the second array be 1 3 2
      So, intersection means the numbers which are common in both the arrays
      here, 1 2 3 is common in both the arrays hence, it is the intersection of both the arrays
 
      If the number is repeating in the array, for example one array is 1 2 2 2 and second array is
      2 3 2 4 2 then the intersection would be 2 2 2 not just 2
 */
 
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class Intersection_of_Two_Arrays {
 
 	//method intersection
 	public void intersection(int[] array1, int[] array2) {
 
 		int x = 0, y = 0;
 
 		Arrays.sort(array1);
 		Arrays.sort(array2);
 
 		for(  ; x < array1.length && y < array2.length ;  )
 		{
 
 			if(array1[x] == array2[y])
 			{
 				System.out.print(array2[y]+"" "");
 				y = y+1;
 				x = x+1;
 			}
 			else if(array1[x] < array2[y])
 			{
 				x = x+1;
 			}
 			else if(array1[x] > array2[y])
 			{
 				y = y+1;
 			}
 		}
 	}
 
 	//Driver Code
 	public static void main(String[] args) {
 
 		Scanner sc = new Scanner(System.in);
 
 		System.out.print(""Enter the number of elements you want in the first array : "");
 		int first = sc.nextInt();
 
 		//Creating array
 		int[] array1 = new int[first];
 
 		System.out.print(""Enter the elements in the 1st array : "");
 		for(int i = 0 ; i < first ; i++) {
 			array1[i] = sc.nextInt();
 		}
 
 		System.out.print(""Enter the number of elements you want in the second array : "");
 		int second = sc.nextInt();
 
 		//Creating array
 		int[] array2 = new int[second];
 
 		//Putting elements in the array
 		System.out.print(""Enter the elements in the 2nd array : "");
 		for(int i = 0 ; i < second ; i++) {
 			array2[i] = sc.nextInt();
 		}
 
 		//Creating object
 		Intersection_of_Two_Arrays",Java
"/*
 Description : 
        Unique Number : In the given range, print all numbers having unique digits.
                        e.g. In range 10 to 20 should print all numbers except 11.
                        As ""11"" comprises of both same digit .
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class solution
 {
 public:
     bool func(int n)
     {
         //an empty variable
         int var;
         //an empty array ,currently filled with 0
         int A[10] = {0};
         while (n)
         {
             //taking out the last digit of number
             var = n % 10;
             A[var]++;
             n = n / 10;
         }
         //checking if any number in digit occured more than once or not
         for (int i = 0; i < 10; i++)
             if (A[i] > 1)
                 return 0;
 
         return 1;
     }
     vector<int> uniqueNumbers(int L, int R)
     {
         //result vector will contain unique digit numbers in given range
         vector<int> result;
         for (int i = L; i < R + 1; i++)
         {
             if (func(i))
                 result.push_back(i);
         }
         return result;
     }
 };
 
 int main()
 {
     //range of the number
     int start, end;
     cout << ""Enter start and end of the range : "" << endl;
     cin >> start >> end;
     solution ob;
     vector<int> number = ob.uniqueNumbers(start, end);
     cout << ""The unique digit number in the range are : "" << endl;
     //for displaying the answer
     for (int num : number)
     {
         cout << num << "" "";
     }
     return 0;
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 /*
 Test Cases: 
 Test case 1:
     Input : Enter start and end of the range : 10 20
 	Output : 10 12 13 14 15 16 17 18 19 20 21 
 
 Test Case 2: 
     Input : Enter start and end of the range : 1 9
 	Output : 1 2 3 4 5 6 7 8 9
 */
 
",C-Plus-Plus
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""XjITw8ZGTEHV""
    },
    ""source"": [
     ""# Churn Risk Score Prediction""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [Churn Risk Rate](https://www.kaggle.com/imsparsh/churn-risk-rate-hackerearth-ml?select=train.csv)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""from sklearn import preprocessing  \n"",
     ""from sklearn import metrics\n"",
     ""import seaborn as sns\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.tree import DecisionTreeClassifier\n"",
     ""from sklearn import tree\n"",
     ""from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n"",
     ""import matplotlib.pyplot as plt""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {
     ""colab"": {
      ""base_uri"": ""https://localhost:8080/"",
      ""height"": 640
     },
     ""id"": ""NTpYjZZiUYrM"",
     ""outputId"": ""03362eba-a49c-4f28-9d8e-38fb85760745""
    },
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n"",
        ""<table border=\""1\"" class=\""dataframe\"">\n"",
        ""  <thead>\n"",
        ""    <tr style=\""text-align: right;\"">\n"",
     ",Python
"/* In Columnar Cipher, we are given a plaintext and a key. The plaintext
 is written out in rows and the ciphertext is formed by reading out columns
 one by one according to the order of the key given. Key is converted to its
 corresponding numerical(Ex A-0, B-1, C-2, ...... , Z-25). Cipher text is formed
 by reading the columns corresponding to the lowest numerical value in the key to
 the highest numerical value. */
 
 package main
 
 import (
 	""fmt""
 	""bufio""
 	""os""
 )
 
 //Sort function, returns sorted integer array
 func sort(array []int, length int) {
 
 	//Bubble sort is used here
 	for i := 0; i < length - 1; i++ {
 		for j := 0; j < length - 1 - i; j++ {
 			if(array[j] > array[j + 1]) {
 				var temp int = array[j]
 				array[j] = array[j + 1]
 				array[j + 1] = temp
 			}
 		}
 	}
 }
 
 /*This function returns the corresponding numerical
 value of the key in the form of an array*/
 func order(key string) []int {
 
 	order_key := make([]int, len(key))
 
 	/*We find the numerical value of each
 	alphabet corresponding to the key*/
 	for i := 0; i < len(key); i++ {
 		order_key[i] = int(key[i])
 		order_key[i] -= 65
 	}
 
 	temp := make([]int, len(key))
 
 	//Storing the numerical value temporarily
 	for i := 0; i < len(key); i++ {
 		temp[i] = order_key[i]
 	}
 
 	/*Store according to relative numbering of
 	each alphaet in the key*/
 	sort(order_key, len(key))
 
 	index := make([]int, len(key))
 
 	for i := 0; i < len(key); i++ {
 		for j := 0; j < len(key); j++ {
 			if(temp[i] == order_key[j]) {
 				index[i] = j+1
 			}
 		}
 	}
 	/*Returning the array containing the numerical
         value of key in relative order*/
 	return index
 }
 
 /*This is the encrypt function that takes
 plaintext and key as input*/
 func encrypt(plaintext, key string) string {
 
 	decrypted_message := [26]string{}
 
 	var length_key int = len(key)
 	var length_message int = len(plaintext)
 
 	/*Replacing any spaces in the plaintext with
 	underscores*/
 	var message string
",Go
"""""""
 Tim Sort Algorithm implementation in Python3
 
 Introduction:
 TimSort is a sorting algorithm that is a hybrid of merge sort and
 binary insertion sort algorithm. It is a stable algorithm and works
 best on real-time data. In this, the list that needs to be sorted
 is first analyzed, and based on that it is divided into blocks known
 as Run. These runs are sorted using insertion sort one by one and
 then by merging these runs using the combine function used in merge
 sort. If the size of the Array is less than run, then Array gets
 sorted just by using Insertion Sort. The size of the run may vary
 from 32 to 64 depending upon the size of the array. Note that the
 merge function performs well when size subarrays are powers of 2.
 """"""
 
 MIN_MERGE = 32
 MAX_MERGE = 64
 
 # This function searches for the index where we can insert the key
 
 
 def binarySearch(arr, left, right, key):
     # If there is only 1 element
     if left == right:
         if arr[left] > key:
             return left
         else:
             return left+1
 
     # If we have searched in the whole array
     if left > right:
         return left
 
     # The middle index
     mid = (left + right - 1) // 2
 
     if arr[mid] <= key:
         if mid + 1 == right:
             return mid + 1
         return binarySearch(arr, mid + 1, right, key)
     elif arr[mid] > key:
         return binarySearch(arr, left, mid - 1, key)
 
 
 # This function sorts runs using binary search
 def InsertionSort(arr):
     """"""
     Returns the sorted run in place using binary search to find 
     the index where the element can be inserted.
     """"""
     # Initialise the left ans=d right index
     left, right = 0, len(arr) - 1
 
     # Intialise the key element
     key = arr[-1]
 
     # Binary Search to the find the index for key
     idx = binarySearch(arr, left, right, key)
 
     # shifting the elements to the right
     for i in range(right, idx, -1):
         arr[i] = arr[i-1]
 
     # Insert the key
",Python
"import java.util.*;
 
 class TowerOfHanoi {
 
     public static void shiftRings(int n, int fromRod, int toRod, int midRod) {
         if(n == 1) {
             System.out.println(""Shifting disk 1 from rod "" + fromRod + "" to rod "" + toRod);
             return;
         }
         shiftRings(n-1, fromRod, midRod, toRod);
         System.out.println(""Shifting disk "" + n + "" from rod "" + fromRod+ "" to rod "" + toRod);
         shiftRings(n-1, midRod, toRod, fromRod);
     }
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the number of rings:"");
         int n = sc.nextInt();
         sc.close();
 
         shiftRings(n, 1, 3, 2);
     }
 }
 /**
  * Sample input/output: 
  * Enter the number of rings:
  * 4
  * Shifting disk 1 from rod 1 to rod 2
  * Shifting disk 2 from rod 1 to rod 3
  * Shifting disk 1 from rod 2 to rod 3
  * Shifting disk 3 from rod 1 to rod 2
  * Shifting disk 1 from rod 3 to rod 1
  * Shifting disk 2 from rod 3 to rod 2
  * Shifting disk 1 from rod 1 to rod 2
  * Shifting disk 4 from rod 1 to rod 3
  * Shifting disk 1 from rod 2 to rod 3
  * Shifting disk 2 from rod 2 to rod 1
  * Shifting disk 1 from rod 3 to rod 1
  * Shifting disk 3 from rod 2 to rod 3
  * Shifting disk 1 from rod 1 to rod 2
  * Shifting disk 2 from rod 1 to rod 3
  * Shifting disk 1 from rod 2 to rod 3
  * 
  * Time complexity: O(2^n)
  * Space complexity: O(n)
  */
",Java
"// C program to implement Pigeon Hole  Sort
 #include <stdio.h>
 
 struct MaxAndMin
 {
     int maximum;
     int minimum;
 };
 
 //To find the Maximum and Minimum elements in an array with minimum comparisons
 struct MaxAndMin find_max_min_elements(int arr[], int n)
 {
     struct MaxAndMin pair;
     int i;
     //If there is only one element
     if (n % 2 == 1)
     {
         pair.minimum = arr[0];
         pair.maximum = arr[0];
         i = 1;
     }
     else //Else If there is more than one element
     {
         if (arr[0] > arr[1])
         {
             pair.minimum = arr[1];
             pair.maximum = arr[0];
         }
         else
         {
             pair.minimum = arr[0];
             pair.maximum = arr[1];
         }
         i = 2;
     }
 
     while (i < n - 1)
     {
         if (arr[i] > arr[i + 1])
         {
             if (arr[i] > pair.maximum)
                 pair.maximum = arr[i];
 
             if (arr[i + 1] < pair.minimum)
                 pair.minimum = arr[i + 1];
         }
         else
         {
             if (arr[i + 1] > pair.maximum)
                 pair.maximum = arr[i + 1];
 
             if (arr[i] < pair.minimum)
                 pair.minimum = arr[i];
         }
         i = i + 2;
     }
     return pair;
 }
 
 // Pigeon hole sort
 void pigeon_hole_sort(int arr[], int n)
 {
     struct MaxAndMin pair = find_max_min_elements(arr, n);
 
     // Find statistical range of the given array
     int range = pair.maximum - pair.minimum + 1;
 
     // Declare an array with the size of the range.
     int holes[range];
 
     //Initialize the new array with value 0.
     for(int i = 0;i < range;i++)
     {
         holes[i] = 0;
     }
 
     //Filling the 'holes' array with the input array values
     for (int j = 0; j < n; j++)
         holes[arr[j] - pair.minimum]++;
 
     // Put the elements back into the array in ascending occurence order.
     int j = 0;
     for (int i = 0; i < range; i++)
         while (hole",C
"#include<stdio.h>
 #include<stdlib.h>
 #include<unistd.h>
 
 
 #define MAX 20
 #define TRUE 1
 #define FALSE 0
 
 
 int g[MAX][MAX];
 int v[MAX];
 int n;
 
 void main()
 {
     int v1, v2;
     char ans;
     void create();
     void Dfs(int);
     create();
     printf(""The Adjacency Matrix for the graph is \n"");
     for (v1 = 0; v1 < n; v1++)
     {
         for (v2 = 0; v2 < n; v2++)
             printf(""%d"", g[v1][v2]);
         printf(""\n"");
     }
     getchar();
     do
     {
         for (v1 = 0; v1 < n; v1++)
         v[v1] = FALSE;
         printf(""Enter the Vertex from which you want to traverse "");
         scanf(""%d"", &v1);
         if (v1 >= MAX)
             printf(""Invalid Vertex\n"");
         else
         {
             printf(""The Depth First Search of the Graph is\n"");
             Dfs(v1);
         }
         printf(""\nDo you want to traverse By any other node?"");
         ans = getchar();
     } while (ans == 'y');
 }
 void create()
 {
     int ch, v1, v2, flag;
     char ans = 'y';
     printf(""\n\t\t This is a program to create a Graph"");
     printf(""\n\t\t The Display Is In Depth First Manner"");
     getch();
 
 
     printf(""\nEnter no. of nodes"");
     scanf(""%d"", &n);
     for (v1 = 0; v1 < n; v1++)
         for (v2 = 0; v2 < n; v2++)
             g[v1][v2] = FALSE;
     printf(""\nEnter no. of nodes"");
     scanf(""%d"", &n);
     printf(""\nEnter the vertices no. starting from 0"");
     do
     {
         printf(""\nEnter the vertices v1 & v2"");
         scanf(""%d%d"", &v1, &v2);
         if (v1 >= n || v2 >= n)
             printf(""Invalid Vertex Value\n"");
         else
         {
             g[v1][v2] = TRUE;
             g[v2][v1] = TRUE;
         }
         printf(""\n\nAdd more edges??(y/n)"");
         ans = getchar();
     } while (ans == 'y');
 }
 void Dfs(int v1)
 {
     int v2;
     printf(""% d"",v1);
         v[v1] = TRUE;
     for (v2 = 0; v2 < MAX; v2++)
         if (g[v1][v2] == TRUE && v[v2] == FALSE)
             Dfs(v2);
 }",C
"# Python program to find LCM of two numbers
 
 # using euclid method to find gcd of two numbers
 
 
 def euclidGCD(number1, number2):
     if number2 == 0:
         return number1
     return euclidGCD(number2, number1 % number2)
 
 # Calculating lcm of two numbers using GCD
 
 
 def lcm(number1, number2):
     return (number1 * number2) // euclidGCD(number1, number2)
 
 number1, number2 = [int(x) for x in input().split()]
 print(lcm(number1, number2))
 
 '''
 Sample I/O:
 
 Sample 1:
 Input:761457 614573
 Output:467970912861
 
 Sample 2:
 Input:6 8
 Output:24
 
 Time Complexity :O(logn)
 Space Complexity:O(1)
 '''
",Python
"// C++ program to implement Circle  Sort
 
 #include<bits/stdc++.h> 
 using namespace std; 
   
 /*
 Performs recursive circular swaps and returns true if atleast one swap occurs
 */
 bool rec_sort(int arr[], int beg, int end) 
 { 
     bool isSwap = false; 
   
     // If concerned array is empty, Return
     if (beg == end) 
         return false; 
   
     // Storing the values of beg, end to later use in the recursive call
     int begA, endA;
     for(begA = beg, endA = end; begA < endA; begA++, endA--) 
     { 
         //Compares the first and last elements 
         if (arr[begA] > arr[endA]) 
         { 
             swap(arr[begA], arr[endA]); 
             isSwap = true; 
         } 
         
     } 
   
     // If the array has odd number of elements
     if (begA == endA) 
         if (arr[begA] > arr[endA + 1]) 
         { 
             swap(arr[beg], arr[endA+1]); 
             isSwap = true; 
         } 
   
     int mid = (end - beg) / 2; 
     bool isSwapA = rec_sort(arr, beg, beg+mid); 
     bool isSwapB = rec_sort(arr, beg+mid+1, end); 
   
     return (isSwap || isSwapA || isSwapB); 
 } 
 
 void circle_sort(int arr[], int n) 
 {  
     while (rec_sort(arr, 0, n-1)) 
     {    
         
     } 
 } 
   
 
 int main()
 {
     int n;
     cout<<""\nHow many numbers do you want to sort? "";
     cin>>n;
     int arr[n];
 
     if (n <= 0)
     {
         cout<<""The array is Empty!!!"";
         return 0;
     }
     // Input the numbers to sort
     cout<<""Enter the numbers: "";
     for (int i = 0; i < n; i++)
         cin>>arr[i];
   
     //Call the sort function 
     circle_sort(arr,n);  
 
     cout<<""The numbers in sorted order is: "";
     // Print the sorted array
     for (int i = 0; i < n; i++)
         cout<<arr[i]<<"" "";
     cout<<endl;
     return 0;
 }
 
 /*
 
 Time Complexity: O(n*log(n))
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 How many numbers do you want to sort? 5
 Enter the numbers: 1 3 5 2 4
 The numbers in s",C-Plus-Plus
"import java.util.*; 
 
 class Exponential_Search 
 { 
     // Returns position of first occurrence of x in array 
     static int expoSearch(int input[], int n, int x) 
     { 
         // If x is present at firt location itself 
 	if (input[0] == x) 
 	    return 0; 
 	
 	// Find range for binary search by repeated doubling 
 	int i = 1; 
 	while (i < n && input[i] <= x) 
 	    i = i*2; 
 	
 	// Call binary search for the found range. 
 	return Arrays.binSearch(input, i/2, Math.min(i, n), x); 
     } 
 	
     // Driver code 
     public static void main(String args[]) 
     { 
 	
 	int n;
 	Scanner s = new Scanner(System.in);
 	n = s.nextInt();
         int arr[] = new int[n];
 	for (int i = 0; i < n; i++)
         {
             a[i] = s.nextInt();
         }
 	int x = s.nextInt();
 	int result = expoSearch(arr, arr.length, x); 
 		
 	System.out.println((result < 0) ? ""Element is not present in array"" : ""index "" + result); 
      } 
 } 
 
 /* 
 INPUT:
 n = 5
 arr[] = {4, 5, 15, 80, 90}
 x = 90
 OUPUT:
 index 4
 */
 
",Java
"/**
  * This program implements the KnuthMorrisPratt string-searching algorithm which searches
  * for occurrences of a ""word"" W within a main ""text string"" S by employing the observation
  * that when a mismatch occurs, the word itself embodies sufficient information to determine 
  * where the next match could begin, thus bypassing re-examination of previously matched 
  * characters.
  *
  * For more information visit: https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm
  *
  *
  * Time Complexity: O(n+m)                n -> Length of Text String
  * Space Complexity: O(m)                 m -> Length of Pattern String
  * 
  * 
  * Sample Input :- 
  *    	Text String - ""aabaacaadaabaaba""
  *    	Pattern String - ""aaba""
  *   
  * Expected Output :-
  *		Pattern found at index: 0
  *		Pattern found at index: 9
  *		Pattern found at index: 12
  */
 
 import java.util.Scanner;
 
 public class KMP_Algorithm {
 	
 	// To compute the longest prefix suffix array 
 	static int[] computeLPS(String patt)
 	{
 		// length of pattern String
 		int len = patt.length();
 		
 		int i, j;
 		int[] lps = new int[len];
 		
 		// LPS of length 1 String is always 0
 		lps[0] = 0;
 		
 		i = 1;
 		j = 0;
 		while(i < len)
 		{
 			if(patt.charAt(i) == patt.charAt(j))
 			{
 				lps[i] = j + 1;
 				i++;
 				j++;
 			}
 			else
 			{
 				if(j == 0)
 				{
 					lps[i] = 0;
 					i++;
 				}
 				else
 				{
 					j = lps[j - 1];					
 				}
 			}
 		}
 		
 		return lps;
 	}
 	
 	// Prints all starting index of pattern in text string 
 	static void KMPSearch(String txt, String patt)
 	{
 		int[] lps = computeLPS(patt);
 		int i, j;
 		int txt_len, patt_len;
 		
 		// Length of text string
 		txt_len = txt.length();
 		
 		// Length of pattern string
 		patt_len = patt.length();
 		
 		i = j = 0;
 		while(i < txt_len)
 		{
 			if(patt.charAt(j) == txt.charAt(i))
 			{
 				i++;
 				j++;
 			}
 			else
 			{
 				if(j == 0)
 					i++;
 				else
 					j = ",Java
"/*Finding all distinct subsets of a given set using BitMasking Approach
 Examples:
 
 Input:  S = {1, 2, 2}
 Output:  {}, {1}, {2}, {1, 2}, {2, 2}, {1, 2, 2}
 
 Explanation:
 The total subsets of given set are -
 {}, {1}, {2}, {2}, {1, 2}, {1, 2}, {2, 2}, {1, 2, 2}
 Here {2} and {1, 2} are repeated twice so they are considered only once in the output*/
 
 
 #include <bits/stdc++.h>
 using namespace std;
 
 vector<string> split(const string &s, char ch)
 {
     vector<string> elems;
     stringstream ss(s);
     string item;
     while (getline(ss, item, ch))
         elems.push_back(item);
 
     return elems;
 }
 
 // Function to find all subsets of given set(repeated subset is considered only once)
 int printPowerSet(vector<int> arr, int n)
 {
     vector<string> list;
 
     for (int i = 0; i < (int) pow(2, n); i++)
     {
         string subset = """";
         for (int j = 0; j < n; j++)
         {
             // Check if jth bit in the i is set. If the bit is set, we consider jth element from set
             if ((i & (1 << j)) != 0)
                 subset += to_string(arr[j]) + ""|"";
         }
 
         // if subset is encountered for the first time, If we use set<string>, we can directly insert
         if (find(list.begin(), list.end(), subset) == list.end())
             list.push_back(subset);
     }
 
     for (string subset : list)
     {
         // split the subset and print its elements
         vector<string> a = split(subset, '|');
         for (string str: a)
             cout << str << "" "";
         cout << endl;
     }
 }
 
 int main()
 {
     vector<int> arr;
     int n = arr.size();
 
     printPowerSet(arr, n);
 
     return 0;
 }
 
 /*Input: 10 12 12
 Output:
 10
 12
 10 12
 12 12
 10 12 12 */
 
 /*Time complexity
 For every index, we make 2 recursion calls and there are n elements so total time complexity is O(2^n).
 
 Space complexity
 There are 2^n-1 subsets and for every subset, we need O(n) space on average so total space complexity is",C-Plus-Plus
"/*
 Given a vector, return a vector
 where each element is equal to the product of all the elements
 of except that particular element.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 vector < int > get_Product_Except_Self(vector < int > &ar)
 {
         /* take a vector Product_ExceptSelf where each element is 1 */
         vector < int > Product_ExceptSelf( ar.size(), 1);
         int x = 1;
         for(int i = 1; i < ar.size() ; i++)
         {
             Product_ExceptSelf[i] = Product_ExceptSelf[i-1] * ar[i-1];
         }
         for(int i = Product_ExceptSelf.size() - 1 ; i >= 1 ; i--)
         {
             /* here we keep multiplied x with ar[i]
             and then multiply Product_ExceptSelf[i-1]
             with current x value */
             x *= ar[i];
             Product_ExceptSelf[i-1] *= x;
         }
         return Product_ExceptSelf;
 }
 
 int main()
 {
     cout << ""Enter the size of the vector : \n"";
     int N; 
     cin >> N;
     vector < int > ar(N , 0);
     cout << ""Enter vector elements :\n"";
     for (int i = 0; i < N; i++) 
     {
 	cin >> ar[i];
     }
     vector < int > Product_Except_Self = get_Product_Except_Self(ar);
     cout << ""The New vector is :\n"";
     for(auto i : Product_Except_Self)
     {
         cout << i << ' ';
     }
     cout << endl;
 }
 
 /*
 Standard Input and Output
 
 1.
 Enter the size of the vector :
 6
 Enter vector elements :
 4 53 23 9 3 2
 The New vector is :
 65826 4968 11448 29256 87768 131652
 
 2.
 Enter the size of the vector :
 5
 Enter vector elements :
 0 0 0 3 5
 The New vector is :
 0 0 0 0 0
 
 Time Complexity : O( N )
 Space Complexity : O( N )
 
 */
",C-Plus-Plus
"import 'dart:io';
 
 // Find sum of digits of number 
 int sum_digits(int number) {
   int sum = 0;
 
   // Extract individual digits and add to sum
   while (number > 0) {
     int digit = number % 10;
     number ~/= 10;
     sum += digit;
   }
   return sum;
 }
 
 // Main Function, with driver code
 void main() {
   print(""Enter a number:"");
   int input = int.parse(stdin.readLineSync()!);
 
   // Call sum of digits function
   int sum_of_digits = sum_digits(input);
   print(""Sum of digits in $input is $sum_of_digits"");
 }
 /**
 Time Complexity: O(log(n))
 Space Complexity: O(1)
 
 Enter a number:
 401
 Sum of digits in 401 is 5
 
 Enter a number:
 123
 Sum of digits in 123 is 6
 */
",Dart
"#include<iostream>
 using namespace std;
 
 void adjust(int a[] , int n ,int i){
     while(2*i+1<=n){
         int j = 2*i+1;
         if(j+1<=n && a[j+1]>a[j])
             j = j+1;
         if(a[i] >= a[j])
             break;
         else{
             int temp = a[i];
             a[i] = a[j];
             a[j] = temp;
             i = j;
         }
     }
 }
 void heapsort(int a[] , int n){
     for(int i = n/2 - 1;i>=0 ;i--){  //using this for loop for converting it into max heap
         adjust(a,n-1,i);
     }
     cout<<""the max heap is ""<<endl;
     for(int i = 0;i<n;i++){    //printing the max heap elements
         cout<<a[i]<<"" "";
     }
     cout<<endl;
 
     while(n>0){           //using this while for given no of elements
         int t = 0;
         t = a[0];            //first swapping of first and last element and then again converting to heap 
         a[0] = a[n-1];
         a[n-1]=t;
         n--;
         adjust(a,n-1,0);
     }
 
 
 }
 
 
 int main(){
     int n;
     cin>>n;
     int a[n];
     cout<<""Enter the elements in heap""<<endl;        //accepting the elements in heap
     for(int i=0;i<n;i++){         //heap with index starting from 0
         cin>>a[i];
     }
     heapsort(a,n);            //calling heapsort to sort and convert it into max heap too 
     cout<<""Sorted array is using heapsort is""<<endl;
     for(int i = 0;i<n;i++){
         cout<<a[i]<<"" "";
     }
     cout<<endl;
 
 }
 
 
 /*
 OUTPUT :- 
 10                                                                                                                
 Enter the elements in heap                                                                                        
 13                                                                                                                
 1                                                                                                                 
 2                                                                    ",C-Plus-Plus
"// C program to find to the length of the longest common subsequence
 #include <stdio.h>
 
 // Helper function to find the maximum of two elements
 int max(int a, int b)
 {
     if (a > b)
         return a;
     else
         return b;
 }
 
 // Length of Longest Common subsequence
 int lcs(char s1[], int n, char s2[], int m)
 {
 
     /* Builds a 2D table in a bottom Up manner, storing info regarding the 
     length of longest common subsequence of both strings till that index. */
     int dp[n + 1][m + 1];
 
     for (int i = 0; i <= n; i++)
     {
         for (int j = 0; j <= m; j++)
         {
             // If one of the string size is zero, then the length of LCS is also zero
             if (i == 0 || j == 0)
                 dp[i][j] = 0;
 
             // If the elements of both the strings match, then the value of LCS increments by one.
             else if (s1[i - 1] == s2[j - 1])
                 dp[i][j] = dp[i - 1][j - 1] + 1;
 
             /* Either include the last element from one string and exclude it from the other and 
             compare them and vice versa and pick the one giving the maximum length out of the two */
             else
                 dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
         }
     }
 
     return dp[n][m];
 }
 
 int main()
 {
     int n, m, ans;
     printf(""\nEnter the length of the first string? "");
     scanf(""%d"", &n);
     char s1[n];
     printf(""Enter the first string: "");
     scanf("" %s"", s1);
 
     printf(""\nEnter the length of the second string? "");
     scanf(""%d"", &m);
     char s2[m];
     printf(""Enter the second string: "");
     scanf("" %s"", s2);
 
     ans = lcs(s1, n, s2, m);
     printf(""\nThe length of the longest common subsequence is: %d"", ans);
     return 0;
 }
 
 /*
 
 Time Complexity: O(m*n), where m, n is the size of the input strings
 Space Complexity: O(m*n)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the length of the first string? 6
 Enter the first string: cuckoo
 Enter the length of th",C
"""""""
 Julia program to find the n-th element from Stern's Diatomic Series
 Stern's diatomic series is the sequence which generates the integer sequence that arises
 in the Calkin-Wilf tree. This sequence can be computed by the fusc function.
 """"""
 
 function stern_diatomic_num(n)
     if(n == 0)
         return 0
     end    
     
     dp = zeros(Int, n)
 
     dp[1] = 1
     # Traverse and Fill the `dp` array.
     for i in 2:n
         # If i is even
         if(i % 2 == 0)
             dp[i] = dp[i  2]
         # If i is odd
         else
             dp[i] = dp[(i - 1)  2 ] + dp[(i + 1)  2]
         end
     end
     return dp[n]
 end
 
 print(""Enter the value of n(where you need the nth Stern's Diatomic number): "")
 n = readline()
 n = parse(Int, n)
 if(n < 0)
     print(""Invalid Value of n !!!"")
     exit()
 end
 res = stern_diatomic_num(n)
 println(""The $n'th Stern's Diatomic is $res."")
 
 
 """"""
 Time Complexity: O(n), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the value of n(where you need the nth Stern's Diatomic number): 258
 The 258'th Stern's Diatomic is 8.
 
 SAMPLE 2
 Enter the value of n(where you need the nth Stern's Diatomic number): -98
 Invalid Value of n !!!
 """"""
",Julia
"import java.util.*;
 
 class BucketSort {
 
     private static void bucketSort(float[] arr, int k) {
         if (arr.length < 2)
             return;
         
         // getting upper limit for dividing numbers in buckets
         int length = arr.length;
         float max_val = arr[0];
         for (int i = 1; i<length; i++) {
             max_val = Math.max(max_val, arr[i]);
         }
         max_val += 1;
 
         //making bucket list and adding buckets in it
         ArrayList<ArrayList<Float>> bucketList = new ArrayList<ArrayList<Float>>();
         for (int i=0; i<k; i++) {
             bucketList.add(new ArrayList<Float>());
         }
 
         //dividing numbers in different buckets
         for (int i=0; i<length; i++) {
             int bucketIndex = (int) ((arr[i] * k) / max_val);
             bucketList.get(bucketIndex).add(arr[i]);
         }
 
         // sorting each bucket one by one
         for (int i=0; i<k; i++) {
             Collections.sort(bucketList.get(i));
         }
 
         //joining buckets
         int pos = 0;
         for (int i=0; i<k; i++) {
             for (int j=0; j<bucketList.get(i).size(); j++) {
                 arr[pos] = bucketList.get(i).get(j);
                 pos += 1;
             }
         }
     }
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
 
         //taking input array
         System.out.println(""Enter size of array:"");
         int size = sc.nextInt();
         float arr[] = new float[size];
         System.out.println(""Enter array elements:"");
         for (int i=0; i<size; i++) {
             arr[i] = sc.nextFloat();
         }
         System.out.println(""Enter number of buckets:"");
         int bucketNum = sc.nextInt();
 
         // before sorting
         System.out.println(""Array before bucket sort:"");
         for (int i=0; i<arr.length; i++) {
             System.out.print(arr[i] + "" "");
         }
         System.out.println();
 
        ",Java
"import java.util.*;
 import java.io.*;
 import java.lang.*;
 //nodes of Linked list
 class Node
 {
     int data;
     Node next;
     Node(int x)
     {
         data = x;
         next = null;
     }
 }
 public class DetectLoopLL
 {
     public static void makeLoop(Node head, Node tail, int x){
         if (x == 0) return;
         Node curr = head;
         for(int i=1; i<x; i++)
             curr = curr.next;
         tail.next = curr;
     }
     // } Driver Code Start
     public static void main (String[] args){
         Scanner sc = new Scanner(System.in);
         //size of linked list
         System.out.println(""Enter the size of Linked List:"");
         int n = sc.nextInt();
          System.out.println(""Enter the data of Linked List:"");
         //Input for the Linked list
         int num = sc.nextInt();
         Node head = new Node(num);
         Node tail = head;
         //Linked List created
         for(int i=0; i<n-1; i++)
         {
             num = sc.nextInt();
             tail.next = new Node(num);
             tail = tail.next;
         }
         //Position to check loop exists or not
          System.out.println(""Enter the Position to check:"");
         int pos = sc.nextInt();
         makeLoop(head, tail, pos);
         //Object of Solution class
         Solution x = new Solution();
         //True if loop exits otherwise False
         System.out.println(""\tOUTPUT"");
         System.out.println(""-----------------"");
         if( x.detectLoop(head) )
             System.out.println(""TRUE"");
         else
             System.out.println(""FALSE"");
     }
 }
 //  Driver Code Ends
 //Solution class to check detect the loop
 class Solution {
     public static boolean detectLoop(Node head){
         if(head==null||head.next==null)
             return false;
         Node slow = head;
         Node fast = head;
         while(fast != null && fast.next != null) {
             
             slow = slow.next;
             fast = fast.next.nex",Java
"/*
 
 Given n elements Linked List
 This code will implement insertion sort on Linked List
 Example
 n=5
 Linkedlist : 1 43 3 7 97
 Answer: 1 3 7 43 97
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Node
 {
 public:
     int data;
     Node *next;
 };
 void push(Node **root, int data)
 {
     Node *temp = new Node();
     temp->data = data;
     temp->next = (*root);
     *root = temp;
 }
 void print(Node *root)
 {
     if (root == NULL)
         return;
     while (root)
     {
         cout << root->data << ""->"";
         root = root->next;
     }
 }
 void sortlist(Node **answer, Node *current)
 {
     if (*answer == NULL || current->data <= (*answer)->data)
     {
         current->next = *answer;
         *answer = current;
     }
     else
     {
         Node *q = *answer;
         while (q->next != NULL && q->next->data < current->data)
         {
             q = q->next;
         }
         current->next = q->next;
         q->next = current;
     }
 }
 void insertionsort(Node **root)
 {
     Node *answer = NULL;
     Node *current = *root;
     while (current)
     {
         Node *next = current->next;
         sortlist(&answer, current);
         current = next;
     }
     *root = answer;
 }
 int main()
 {
     int n;
     cout << ""Enter Number of Elements:"";
     cin >> n;
     Node *root = NULL;
     cout << ""Enter Elements:"";
     for (int i = 0; i < n; i++)
     {
         int a;
         cin >> a;
         push(&root, a);
     }
     cout << ""\nOriginal Unsorted Linked List:"";
     print(root);
     cout << ""\nSorted Linked List:"";
     insertionsort(&root);
     print(root);
 }
 /*
 
 Sample Input/Output:
 Input:
 Enter Number of Elements:5
 Enter Elements:10 32 44 13 7
 
 Output:
 Original Unsorted Linked List:7->13->44->32->10->
 Sorted Linked List:7->10->13->32->44->
 
 Time-Complexity: O(n^2)
 Space-complexity: O(n)
 
 */
",C-Plus-Plus
"/*
 AboutRoundRobinScheduling:-
 ItisaCPUschedulingtechniqueinwhicheachprocessisgivenafixedtimequantum/slice.
 Once the time quantum is over for a process, the CPU gets preempted to another process in the ready queue.
     -It is a preemptive scheduling technique.
     -As all processes get fair share of CPU, it a starvation-free CPU scheduling algorithm.
     -The disadvantage of it is more overhead of context switching.
 
 Time related to each process-
 Arrival Time(AT)-The time at which process enters into the ready queue.
 Burst Time(BT)-The total time required by the CPU to execute the whole process.
 Completion Time(CT)-The time at which the process enters into completion state.
 Turn Around Time(TAT)-The total amount of time spent by the process from its completion.
                       It is calculated as - TAT=CT-AT
 Waiting Time(WT)-The total time for which the process waits for the CPU to be assigned.
                  It is calculated as - WT=TAT-BT
 Response Time(RT)-The difference between arrival time and the time at which the process first gets the CPU.
 */
 
 #include<stdio.h>
 #include<stdlib.h>
 
 //Structure for queue
 struct node
 {
     int data;
     struct node *next;
 };
 struct node *front=NULL;
 struct node *rear=NULL;
 
 //push function for queue
 void push(int x)
 {
     struct node *new=(struct node*)malloc(sizeof(struct node));  
     new->data=x;
     new->next=NULL;
     if(front==NULL && rear==NULL)
     {
         front=rear=new;
     }
     else
     {
         rear->next=new;
         rear=new;
     }
 }
 
 //pop function for queue
 int pop()
 {
     int x;
     if(front==rear)
     {
         struct node *t=front;
         x=t->data;
         free(t);
         front=rear=NULL;
         return x;
     }
     else
     {
         struct node *t=front;
         x=t->data;
         front=front->next;
         free(t);
         return x;
     }
 }
 
 void GanttChartFormation(int *b1,int *at,int *g",C
"/* A convex Hull is a polygon with vertices such that all the points in the plane are
    contained inside of the polygon.
     GrahamScan algorithm gives us the convex hull for the given points by focusing on the following:
 
    -> It pushes each point of the input set onto the stack one time,
        and then pops from the stack each point which is not a vertex.
     -> When, the function finishes stack contains exactly the vertices of
        all the convex hull in counterclock wise direction from their appearance
        of the boundary.
 */
 
 #include <bits/stdc++.h>
 #define e 1e-10
 #define x first
 #define y second
 
 using namespace std;
 //structure for the coordinates
 typedef struct point
 {
     // comparison is done first on y coordinate and then on x coordinate.
     double x, y;
 } point;
 
 vector<point> plane;
 
 stack<point> hull;
 
 double area(point a, point b, point c)
 {
     return (a.x - b.x) * (b.y - c.y) - (a.y - b.y) * (b.x - c.x);
 }
 //returns euclidean distance between two points.
 double dis(point a, point b)
 {
     return sqrt((a.x = b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
 }
 // for comparing points based on their orientation.
 bool cmp(point a, point b)
 {
     if (area(plane[0], a, b) < -e)
     {
         return 0;
     }
     if (area(plane[0], a, b) > e)
     {
         return 1;
     }
     return dis(a, plane[0]) < dis(b, plane[0]);
 }
 
 int main()
 
 {
     cout << ""enter the desired number of points\n"";
     // the number of coordinates to be entered
     int n;
     point tmp;
     cin >> n;
     cout << ""enter the points\n"";
     plane.resize(n);
     //entering the desired points for determining the convex hull
     for (int i = 0; i < n; i++)
     {
 
         cin >> plane[i].x >> plane[i].y;
         if (i)
         {
             if (plane[i].x < plane[0].x)
                 swap(plane[i], plane[0]);
         }
     }
     sort(plane.begin() + 1, plane.end(), cmp);
     hull.push(plane[0]);
     hull.push",C-Plus-Plus
"#include<stdio.h>
 
 main()
 {
     int n;
     printf(""Enter number of elements: "");
     scanf(""%d"",&n);
     int arr[n], i;
     printf(""\nEnter %d elements: "", n);
     for(i = 0 ;i < n ;i++)
     {
         scanf(""\n%d"",&arr[i]);
     }
     int one = 0;
     int two = 0;
     int n_t, x;
     for(i = 0; i < n; i++)
     {
         x = arr[i];
         two |=one & x;
         one ^= x;
         n_t  =~(one & two);
         one &= n_t;
         two &= n_t;
     }
     printf(""\nThe number that occurs only once is %d \n"", one);
 }
 
 /*
 Time complexity: O(n)
 Space complexity: O(n)
 
 Example 1:
 Sample input:
 Enter number of elements: 7
 Enter 7 elements: 6
 2
 5
 2
 2
 6
 6
 Output: The number that occurs only once is 5
 
 Example 2:
 Sample Input:
 Enter number of elements: 4
 Enter 4 elements: 3
 3
 1
 3
 Output: The number that occurs only once is 1
 */
",C
"#include <iostream>  //Header file
 using namespace std; //For cin and cout
 
 /*
     Sieve of Eratosthenes is an ancient algorithm for finding all prime numbers up to any given limit.
     It does so by iteratively marking as composite (i.e., not prime) the multiples of each prime, starting with
     the first prime number, 2. The multiples of a given prime are generated as a sequence of numbers starting from that prime,
     with constant difference between them that is equal to that prime.
 
     Sample Input : 
     10 
     Sample Output: 
     2 3 5 7
 
     @author Aditya Saxena
     @since 28-7-2020
 */
 
 //Implement prime sieve function, it will store 0 in the primes array if that index is composite and 1 if prime
 void prime_sieve(int primes[], int n)
 {
 
     //Make 2 as prime (only prime even number)
     primes[2] = 1;
 
     //Put 1 at all odd positions starting from 3
     for (int i = 3; i < n; i += 2)
     {
         primes[i] = 1;
     }
 
     //Make all multiples of odds as composite, i.e, 0
     for (int i = 3; i < n; i += 2)
     {
 
         //Check prime(i.e, 1){
         if (primes[i] == 1)
         {
 
             //Make all multiples of i as composite
             for (int j = i * i; j < n; j += i)
             {
                 primes[j] = 0;
             }
         }
     }
 
     return;
 }
 
 /**
  * This is the Optimized version of  Sieve of Eratosthenes using Dynamic Memory Allocation and using Boolean that finds the primes and eliminates
  * the multiples.
  */
 void sieve(int N, bool *isprime)
 {
     isprime[0] = true;
     isprime[1] = true;
     for (int i = 2; i * i <= N; ++i)
     {
         if (!isprime[i])
         {
             for (int j = i * i; j <= N; j = j + i)
             {
                 isprime[j] = true;
             }
         }
     }
 }
 
 //This function prints out the primes to STDOUT.
 void print(int N, bool *isprime)
 {
     for (int i = 1; i <= N; i++)
     {
         if (!isprime[i])
         {
  ",C-Plus-Plus
"/*
 Sort an array in wave form by using DART.
 
 Given an unsorted array of integers, sort the array into a wave like array.
 */
 import 'dart:io';
 
 void wave_sort_array(var array, int n) {
   for (int i = 0; i < n; i += 2) {
     if (i > 0 && array[i - 1] > array[i]) {
       int temp = array[i];
       array[i] = array[i - 1];
       array[i - 1] = temp;
     }
 
     // If current even element is smaller than next
     if (i < n - 1 && array[i] < array[i + 1]) {
       int temp = array[i];
       array[i] = array[i + 1];
       array[i + 1] = temp;
     }
   }
 }
 
 void main() {
   var data = [];
 
   // taking input from user and storing it in data array
   var n, ele, k;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   print(""Enter size of K: "");
   k = stdin.readLineSync();
   k = int.parse(k);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     data.add(ele);
   }
 
   print(""Entered List is: "");
   print(data);
 
   print(""\nElemnts after wave sorting are: "");
   wave_sort_array(data, n);
   print(data);
 }
 
 /*
 TIME COMPLEXITY: O(n)
 SPACE COMPLEXITY: O(1)
 
 Enter the number of Elements: 
 6
 Enter size of K: 
 34
 Enter Element 1: 
 56
 Enter Element 2: 
 54
 Enter Element 3: 
 2
 Enter Element 4: 
 9
 Enter Element 5: 
 0
 Enter Element 6: 
 43
 Entered List is: 
 [56, 54, 2, 9, 0, 43]
 
 Elemnts after wave sorting are:
 [56, 2, 54, 0, 43, 9] 
 */
",Dart
"#include <stdio.h>
 #include <math.h>
 //Bellman Ford Function
 int Bellman_Ford(int k, int *A, int *B, int n)
 {
     int i, j;
     for (i = 0; i < n; i++)
     {
         *(B + (k + 1) * n + i) = *(B + k * n + i);
         for (j = 0; j < n; j++)
         {
             if (*(B + (k + 1) * n + i) > *(B + k * n + j) + *(A + *(B + j) * n + *(B + i)))
                 *(B + (k + 1) * n + i) = *(B + k * n + j) + *(A + *(B + j) * n + *(B + i));
         }
     }
     if (k < n)
         Bellman_Ford(k + 1, A, B, n);
 }
 //Main Function Began
 int main()
 {
     int n, i, j, k, a;
     printf(""Please enter the number of vertices:"");
     scanf(""%d"", &n);
     int A[n][n], B[n + 2][n];
     printf(""\nEnter the value of Adjacency Matrix:\n"");
     for (i = 0; i < n; i++)
     {
         printf(""\n"");
         for (j = 0; j < n; j++)
         {
             scanf(""%d"", &A[i][j]);
         }
     }
     printf(""\nEnter the Source vertex number:"");
     scanf(""%d"", &a);
 
     /*Calculation for the first vertex*/
     B[0][0] = a - 1;
     B[1][0] = 0;
     for (j = 1; j < n; j++)
     {
         if (j > a - 1)
             B[0][j] = j;
         else
             B[0][j] = j - 1;
     }
     for (j = 1; j < n; j++)
         B[1][j] = 99;
     //calling bellman function
     Bellman_Ford(1, A, B, n);
     //check for negative cycle
     for (i = 0; i < n; i++)
     {
         if (B[n + 1][i] != B[n][i])
         {
             printf(""\n Negative edge-cycle Present"");
             return 0;
         }
     }
     //print the output
     printf(""\n\tOUTPUT:\n"");
     for (i = 1; i < n; i++)
         printf(""\nWeight of vertex no.%d is %d"", B[0][i] + 1, B[n + 1][i]);
 }
 //main ends here
 
 /* Sample Input Output
 Please enter the number of vertices: 5
 Enter the value of Adjacency Matrix:
 0
 3
 8
 99
 -4
 
 99
 0
 99
 1
 7
 
 99
 4
 0
 99
 99
 
 2
 99
 5
 0
 99
 
 99
 99
 99
 6
 0
 
 Enter the Source vertex number: 1
 
 OUTPUT:
 Weight of vertex no.2 is 3
 Weight of vertex n",C
"#include<iostream>
 #include<unordered_map>
 #include<vector>
 #include<algorithm>
 
 using namespace std;
 
 // MAX HEAP
 class pQueue {
 private:
   int heapSize;
   unordered_map <int, vector<int>> heapMap;
   vector <int> heapElements;
 
 public:
   pQueue() {
     heapSize = 0;
   }
 
   void add(int element) {
     heapSize++;
     heapElements.push_back(element);
     if (heapMap.find(element) == heapMap.end()) {
       heapMap[element] = vector <int> ({heapSize - 1});
     } else {
       heapMap[element].push_back(heapSize - 1);
     }
     maintainLoopVariant(heapSize - 1);
   }
 
   void remove(int element) {
     if (heapMap.find(element) != heapMap.end()) {
       int index = heapMap[element][0];
       int lastIndex = heapSize - 1;
       swapBubbles(index, lastIndex);
       heapElements.pop_back();
       vector <int> newIndexes({});
       for (int i = 0; i < heapMap[element].size(); i++) {
         if (heapMap[element][i] != lastIndex) newIndexes.push_back(heapMap[element][i]);
       }
       heapMap[element] = newIndexes;
       heapSize--;
       maintainLoopVariant(index);
     }
   }
 
   void poll() {
     // remove the first element from heap array
     remove(heapElements[0]);
   }
 
   void maintainLoopVariant(int index) {
     /*
         Check for heap-invariant
         First check with the parent element, then the maximum of the children and lastly the minimum
     */
     int indexMaxChild = -1, indexMinChild = -1;
     if (2 * index + 2 < heapSize) {
       // both child exist
       indexMaxChild = heapElements[2 * index + 1] >= heapElements[2 * index + 2] ? 2 * index + 1 : 2 * index + 2;
       indexMinChild = heapElements[2 * index + 1] < heapElements[2 * index + 2] ? 2 * index + 1 : 2 * index + 2;
     }
     else if (2 * index + 1 < heapSize) {
       // only left child exist
       indexMaxChild = 2 * index + 1;
     }
 
     if ((index - 1) / 2 >= 0 && heapElements[index] > heapElements[(index - 1) / 2]) {
       swapBubbles(i",C-Plus-Plus
"/*Problem Statement:
 Given a wall of size 4XN, and tiles of sizes(1,4) and (4,1).
 In how many ways can you build a wall */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int buildWall(int n)
 {
     if(n<=3)
     {
         return 1;
     }
     int ans1=buildWall(n-1);
     int ans2=buildWall(n-4);
 
     return ans1+ans2;
 }
 
 int main()
 {
     int n;
     cout<<""Enter the size of the wall: ""<<endl;
     cin>>n;
     cout<<""The number of ways are: ""<<buildWall(n)<<endl;
     return 0;
 }
 /*
 Example:
 Input:-
 Enter the size of the wall:
 4
 
 Output:-
 The number of ways are: 2
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
"// C++ program to implement Comb  Sort
 
 /*
 Comb sort is an improvised Bubble sort. Bubble sort removes its inversion one by one whereas In Comb sort,
 more than one inversion is removed by one swap and hence it is more efficient than Bubble sort.
 */
 
 #include <bits/stdc++.h> 
 using namespace std; 
 
 // Comb sort
 void comb_sort(int arr[], int n)
 {
     int flag= 1, space = n; 
     
     while (space > 1 || flag == 1) 
     {
         // Here empirically found shrink factor 1.3 is used.
         space = (space * 10) / 13;
         
         //Assigning space its minimum value of 1
         if(space < 1)
             space = 1;
     
         flag = 0;
         
         // Compare elements with the space value
         for (int i = 0; i < (n - space); i++) 
         {
             if (arr[i] > arr[i + space]) 
             {
                 swap(arr[i],arr[i+space]);
                 flag= 1;
             }
         }
     }
 }
 
 
 int main()
 {
     int n;
     cout<<""\nHow many numbers do you want to sort? "";
     cin>>n;
     int arr[n];
 
     if (n <= 0)
     {
         cout<<""The array is Empty!!!"";
         return 0;
     }
     // Input the numbers to sort
     cout<<""Enter the numbers: "";
     for (int i = 0; i < n; i++)
         cin>>arr[i];
   
     //Call the sort function 
     comb_sort(arr,n);  
 
     cout<<""The numbers in sorted order is: "";
     // Print the sorted array
     for (int i = 0; i < n; i++)
         cout<<arr[i]<<"" "";
     cout<<endl;
 
     return 0;
 }
 
 /*
 
 Time Complexity: O(n^2), though in average works better than bubble sort
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 How many numbers do you want to sort? 5
 Enter the numbers: 1 3 5 2 4
 The numbers in sorted order is:  1  2  3  4  5
 
 SAMPLE 2
 How many numbers do you want to sort? 0
 The array is Empty!!!
 
 */
",C-Plus-Plus
"/*
 Given an input string, write a code that returns the Run Length Encoded string for the input string.
 For example, if the input string is wwwwaaadexxxxxx, then the function should return w4a3d1e1x6
 */
 
 public class Encoding 
 {
     // for encoding
     public static void encodingString(String str)
     {
         // lenght of the string
         int len = str.length();
         // for traversing through the string
         for (int i = 0; i < len; i++) 
         {
  
             // counter occurrences of current character
             int counter = 1;
             while (i < len - 1 && str.charAt(i) == str.charAt(i + 1)) 
             {
                 counter++;
                 i++;
             }
 
             // printing the character and counter
             System.out.print(str.charAt(i));
             System.out.print(counter);
         }
     }
  
     public static void main(String[] args)
     {
         // taking input of the string 
         Scanner sc= new Scanner(System.in);
         System.out.print(""Enter a string: "");  
         String str= sc.nextLine();    
         System.out.println(""Encoded string : "");
         encodingString(str);
     }
 }
 
 /**
 Time complexity : O(N)
 Space complexity : O(1)
  */
 
 /**
 Test case :
  Input :
     Enter the string to encode 
     tttyyss
  Output :
     Encoded string
     t3 y2 s2 
 
 */ ",Java
"/*
 Given an array of integers, find the first missing positive integer in linear time and constant space. In other words, 
 find the lowest positive integer that does not exist in the array. The array can contain duplicates and negative numbers as well.
 
 For example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give 3.
 
 You can modify the input array in-place.
 
 */
 
 #include<bits/stdc++.h>
 
 using namespace std;
 
 // finding the first missing positive number
 int firstMissingNumber(int arr[], int n)
 {
     int index, temp;
     // traversing the array
     for (index = 0; index < n; index++)
     {
         // We will ignore the negative numbers and the numbers greater than the array size
         // Also, check if the elements are in correct position, if they is not then do swap
         // operation
         while (arr[index] != arr[arr[index] - 1] && arr[index] >= 1 && arr[index] <= n)
         {
             // Swap operation
             temp = arr[arr[index] - 1];
             arr[arr[index] - 1] = arr[index];
             arr[index] = temp;
         }
     }
     // traversing the array one more time
     for (index = 0; index < n; index++)
     {
         // checking if all the elements are in the correct position
         // The one which is not in the correct position is the first 
         // missing positive number
         if ((index + 1) != arr[index])
             return index + 1;
     }
     return n + 1;
 }
 
 // DRIVER FUNCTION
 int main()
 {
     // size of the array
     int n;
     cout<<""Enter the size of the array: \n"";
     // getting the size of the array
     cin >> n;
     int arr[n], index, res;
     cout<<""Enter the elements of the array: \n"";
     // getting the array elements
     for (index = 0; index < n; index++)
         cin >> arr[index];
     printf(""\n"");
     // finding the first positive missing number
     res = firstMissingNumber(arr, n);
     cout <<""The First Missing Positive Number in the ",C-Plus-Plus
"// Unique BSTs using DP
 // Given n, how many structurally unique BST's that store values 1 ... n?
 
 #include <stdio.h>
 
 int max(int num1, int num2) {
 	return (num1 > num2) ? num1 : num2;
 }
 
 int uniqueBST(int n) {
 	int count[n + 1];
 	for (int i = 0; i < n + 1; i++)
 		count[i] = 0;
 	// for each 'i' number of nodes
 	for (int i = 1; i <= n; ++i) {
 		for (int j = 0; j < i; ++j) {
 			// No. of trees if j is a root
 			count[i] += max(count[j], 1) * max(count[i - j - 1], 1);
 		}
 	}
 	return count[n];
 }
 
 int main() {
 	int n;
 	printf(""Enter the number: \n"");
 	scanf(""%d"", &n);
 	int num = uniqueBST(n);
 	printf(""Number of Unique BSTs %d is: \n"", num);
 	return 0;
 }
 
 /*
 input:
 Enter value:3
 output:
 Number of Unique BSTs 5
 Time complexity : O(n^2)
 */
",C
"/*
 Introduction 
 Given a non-empty vector of decimal digits representing a non-negative integer, increment one to the integer.
 The digits are stored such that the most significant digit is at the head of the list, 
 and each element in the array contains a single digit.
 You may assume the integer does not contain any leading zero, except the number 0 itself.
 
 Argument/Return Type
 Given a vector as input
 return answer as vector and print the result
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Function to print the elements of the given vector
 void printVector(vector<int>& digits)
 {
     //Print digits without space between them
     for(int i: digits)
       cout<<i;
 }
 
 //Function which adds 1 to the number given by 
 vector<int> plusOne(vector<int>& digits) 
 {
     /* If the last didgit is not 9 
     Add one to it and return the vector */
     if(digits[digits.size()-1]!=9)
     {
         digits[digits.size()-1]+=1;
         return digits;
     }
 
     /*Else traverse the vector from the end
      till we reach a non '9' digit */
     int index=digits.size()-1;
     while(digits[index]==9)
     {
         //Make each digit as '0'
         digits[index--]=0;
 
         /* If there are no more elements in vector
         insert a '1' at the beginning of the vector and return it */
         if(index<0)
         {
             digits.insert(digits.begin(),1);
             return digits;
         }
     }
 
     /*After crossing all digits which are '9'
       make the element at current index as digit '1' */
     digits[index]=digits[index]+1;
     return digits;  
 }
 
 
 // Driver code
 int main()
 {
     //Take the input of total no.of digits
     int n;
     cout<<""Enter the total no.of digits : "";
     cin>>n;
 
     //Take input of the digits as vector
     vector<int>digits;
     cout<<""Enter each digit of the number with space between them in order : "";
     for(int i=0;i<n;i++)
     {
         int digit;
         cin>>digit;
    ",C-Plus-Plus
"/* Find kth Element of two sorted array.
 
   Given two sorted arrays of size m and n respectively,
   your task is to finding the element that would be
   at the kth position of the final sorted array.
 
   Examples 1 : 
 
   Input 1 : Array 1 - 2 3 6 7 9
             Array 2 - 1 4 8 10
             k = 5
 
   Output 1 : 6
 
   Explanation: The final sorted array would be -
                1, 2, 3, 4, 6, 7, 8, 9, 10
                The 5th element of this array is 6.
 
 
   Examples 2 : 
     
   Input 2 : Array 1 - 100 112 256 349 770
             Array 2 - 72 86 113 119 265 445 892
             k = 7
 
   Output 2 : 256
 
   Explanation: Final sorted array is -
                72, 86, 100, 112, 113, 119, 256, 265, 349, 445, 770, 892
                The 7th element of this array is 256.
 
   Algorithm :-
 
   1) All two arrays are push into the vector.
   2) Then, sort the vector
   3) After Print the vector of (k - 1) index Element.
 
 */
 
 //CODE :-
 #include<bits/stdc++.h>
 using namespace std;
 
 
 // Function to find kth element of two sorted array
 int solve()
 {
     // Input m = size of arr1.
     // Input n = size of arr2.
     int m,n;
     cin>>m>>n;
 
     int arr1[m],arr2[n];
 
     // Input Elements in array 1
     for (int i = 0; i < m; ++i)
     {
         cin>>arr1[i];
     }
 
     // Input Elements in array 2
     for (int i = 0; i < n; ++i)
     {
         cin>>arr2[i];
     }
 
     int k;
     cin>>k;
 
     // Create a Vector and push arr1 and
     // arr2 elements in a vector
 
     vector<int> v;
     for (int i = 0; i < m; ++i)
     {
         v.push_back(arr1[i]);
     }
 
     for (int i = 0; i < n; ++i)
     {
         v.push_back(arr2[i]);
     }
 
     // Sort the Vector
     sort(v.begin(),v.end());
 
     // return v[k - 1] value
     return v[k - 1];
 
 }
 
 int main()
 {
     // Input the test cases.
     int t;
     cin>>t;
     while(t--)
     {
         int k = solve();
         cout<<""kth Element is : ""<<k<<endl;
     }
 ",C-Plus-Plus
"/*
 Given a string str, need to check if it is formed by an interleaving of two strings S and T.
 S = s1 + s2 + ... + sn
 T = t1 + t2 + ... + tm
 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
 
 Dynamic Programming is used to meet the objective.
 We will be checking each character of the given string which can come either from the first string or 
 from the second string.
 Eg- let s=aabcc
         t=dbbca
         str=aadbbcbcac
 aabcc  ,  dbbca  ,  aadbbcbcac  (str[0]==s[0])
 abcc   ,  dbbca  ,  adbbcbcac   (str[0]==s[0])
 bcc    ,  dbbca  ,  dbbcbcac    (str[0]==t[0])
 bcc    ,  bbca   ,  bbcbcac     (str[0]==s[0] as well as str[0]==t[0] hence two cases arise)
       case 1:        |      case 2: 
     cc,bbca,bcbcac   |  bcc,bca,bcbcac
                      
 If we go on cutting the strings in the same way then we will encounter multiple cases,
 some of them are overlapping cases also, hence dynamic programming is used.
 */
 #include <iostream>
 #include <vector>
 using namespace std;
 bool chkString(string s1, string s2, string s3)
 {
     int l1 = s1.length();
     int l2 = s2.length();
 
     /* if summation of length of two strings is not equal to given string's length then the given
     string can never be formed by interleaving the other two. */
     if (l1 + l2 != s3.length())
     {
         return false;
     }
 
     /* rows represent characters of string s1
        and columns represent characters of string s2 */
     vector<vector<bool>> dp(l1 + 1, vector<bool>(l2 + 1, false));
     dp[0][0] = true;
 
     /* Initialising first row and column of dp matrix */
     for (int j = 1; j < l2 + 1; j++)
     {
         if (s2[j - 1] == s3[j - 1])
 
         {
             dp[0][j] = dp[0][j - 1];
         }
     }
     for (int i = 1; i < l1 + 1; i++)
     {
         if (s1[i - 1] == s3[i - 1])
         {
             dp[i][0] = dp[i - 1][0];
         }
     }
 
     /* Filling the dp matrix 
        if last chara",C-Plus-Plus
"/*
   Program to sort a linked list containing zeros, ones and twos.
   The given approach counts the number of ones, twos and zeros and makes the
   required changes in the linked list
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 struct node {
     int info;
     node* next;
 };
 node* head = NULL;
 
 // Function to insert elements in the linked list
 void insert(int data) {
     node* newNode = new node;
     newNode -> info = data;
     newNode->next = NULL;
     if(head == NULL) {
         head = newNode;
         return;
     }
     node* temp = head;
     while(temp->next != NULL)
         temp = temp->next;
     temp->next = newNode;
 }
 
 // Function to sort the linked list
 void sortlist() {
     int zeros = 0, ones = 0, twos = 0;
     node* temp = head;
     // Calculating the number of zeros, ones and twos
     while(temp != NULL) {
         if(temp->info == 0)
             zeros++;
         else if(temp->info == 1)
             ones++;
         else
             twos++;
         temp = temp->next;
     }
     temp = head;
     for(int i = 0; i < zeros; i++)
     {
         temp->info = 0;
         temp = temp->next;
     }
     for(int i = 0; i < ones; i++)
     {
         temp->info = 1;
         temp = temp->next;
     }
     for(int i = 0; i < twos; i++)
     {
         temp->info = 2;
         temp = temp->next;
     }
 }
 
 // Function to print the linked list 
 void print() {
     node* temp = head;
     while(temp != NULL) {
         cout<<temp->info<<"" "";
         temp = temp->next;
     }
 }
 
 int main() {
     int n;
     cout << ""How many elements do you want to sort? "";
     cin >> n;
     int item;
     cout << ""Enter ""<<n<<"" spaced integers: "" << endl;
     for(int i = 0; i < n; i++) {
         cin >> item;
         insert(item);
     }
     cout << ""Sorted list is: "";
     sortlist();
     print();
 }
 
 /*
   Sample Input/Output:
   Input:
   The first line contains a single integer n - number of integers in the list
   The next",C-Plus-Plus
"/**
 N-Queens problem is a famous problem
 The paradigm used to solve the problem is backtracking
 The problem is to find a way to place n queens on nXn board
 such that no queen can kill the other
 **/
 
 import java.io.*;
 import java.util.*;
 
 public class NQueens {
     
   public static void solve(boolean[][] board, boolean[] cols, 
     boolean[] ndiag, boolean[] rdiag, int row, String asf) {
         
         if(row == board.length) {
             System.out.println(asf+'.');
             return;
         }
         
         for(int col=0; col<board.length; col++) {
             if(cols[col] == false && ndiag[row+col] == false && 
                 rdiag[row-col+board.length-1] == false) {
                     // place the queen
             	    // let the column get occpied
             	    // correspondingly ndiag and rdiag
             	    // matrices are populated
                     cols[col] = true;
                     ndiag[row+col] = true;
                     rdiag[row-col+board.length-1] = true;
                     board[row][col] = true;
                     solve(board, cols, ndiag, rdiag, row+1, asf+row+'-'+col+"", "");
                     // backtrack
                     // remove all the markings 
                     // made in the above step
                     cols[col] = false;
                     ndiag[row+col] = false;
                     rdiag[row-col+board.length-1] = false;
                     board[row][col] = false;
                 }
         }
     }
 
   public static void main(String[] args) throws Exception {
     Scanner scn = new Scanner(System.in);
     int n = scn.nextInt();
     boolean[][] board = new boolean[n][n];
     
     boolean[] cols = new boolean[n];
     boolean[] ndiag = new boolean[2*n-1];
     boolean[] rdiag = new boolean[2*n-1];
     
     solve(board, cols, ndiag, rdiag, 0, """");
   }
 
 }
 
 /**
 
 Input :
 4
 Output :
 0-1, 1-3, 2-0, 3-2, .
 0-2, 1-0, 2-3, 3-1, .
 
 Space Complexity : O(n^2)
 T",Java
"/**
  * Optimized Bubble Sort Algorithm
  *
  * In optimized version of bubble sort algorithm we keep track of an extra variable inside the
  * inner loop to check if there was even a single swap if in an iteration of outer loop no elements
  * were swapped in inner loop this means that array is sorted and any extra running of outer loop is
  * redundant.
  *
  * @author [Lakhan Nad](https://github.com/Lakhan-Nad)
  */
 
 import java.util.Scanner;
 
 public class OptimizedBubbleSort {
   /**
    * A main function to test the algorithm
    * 
    * Example Input: 2, 11, 5, -1, 0, 10, 20, 2, 8, 56, -34
    * Ouput: -34, -1, 0, 2, 2, 5, 8, 10, 11, 20, 56
    *
    * @param args the input arguments
    */
   public static void main(String[] args) {
     Scanner scan = new Scanner(System.in);
     System.out.print(""Enter size of array: "");
     int n = scan.nextInt();
     int[] array = new int[n];
     System.out.println(""Enter elements of array"");
     for(int i = 0; i < n; i++){
       array[i] = scan.nextInt();
     }
     bubbleSort(array);
     for (int i = 0; i < n; i++) {
       System.out.print(array[i] + "" "");
     }
   }
 
   /**
    * Implementation of optimized bubble sort
    *
    * @param arr the array to sort
    */
   public static void bubbleSort(int[] arr) {
     /* extra variable to see maintain if swap was done */
     boolean swapped;
     int n = arr.length;
     for (int i = 0; i < n - 1; i++) {
       /* At start of outer loop make it false */
       swapped = false;
       for (int j = 0; j < n - i - 1; j++) {
         if (arr[j] > arr[j + 1]) {
           swap(arr, j, j + 1);
           /* Even if a single swap occurs during inside loop make it true */
           swapped = true;
         }
       }
       /* If no swap occurred this variable is false and we can end our iterations */
       if (!swapped) {
         break;
       }
     }
   }
 
   /**
    * A utility to swap elements
    *
    * @param array the array whose elements need to be ",Java
"/*Problem Statement: 
 Piyush and Nimit are playing a coin game. They are given n coins with values x1, x2 . xn where 'n' is always even.
 They take alternate terms. In each turn, 
 a player picks either the first coin or the last coin from the row and removes it from the row.
 The value of coin is received by that player. 
 Determine the maximum value that Piyush can win with if he moves first. Both the players play optimally. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int dp[100][100]={};
 int optimalGameStrategy(int *coins,int i,int j)
 {
     if(i>j)
     {
         return 0;
     }
     //If sum already exists, then pick from the dp array
     if(dp[i][j]!=0)
     {
         return dp[i][j];
     }
     int sum=0;
     /* If the player 1 chooses, he will either choose from first or last,
     which will leave either of 2 options */
     int option1=min(optimalGameStrategy(coins,i+2,j),optimalGameStrategy(coins,i+1,j-1));
     int option2=min(optimalGameStrategy(coins,i,j-2),optimalGameStrategy(coins,i+1,j-1));
     sum+=max(coins[i]+option1,coins[j]+option2);
     return dp[i][j]=sum;
 }
 
 int main() 
 {
     int n;
     cout<<""Enter total coins: ""<<endl;
     cin>>n;
     int *coins=new int[n];
     int sum=0;
     cout<<""Enter coin values: ""<<endl;
     for(int i=0;i<n;i++)
     {
         cin>>coins[i];
         sum+=coins[i];
     }
     int ans=optimalGameStrategy(coins,0,n-1);
     cout<<""Maximum value for Piyush to win: ""<<max(ans,sum-ans)<<endl;
     return 0;
 }
 /*
 Example:-
 
 Input:-
 Enter total coins: 
 4
 Enter coin values: 
 1 2 3 4
 
 Output:-
 Maximum value for Piyush to win: 6
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
"**Fenwick Tree**
 
 #include <stdio.h>
 
 int FWtree[100] = {0};
 int SIZE;
 
 int get_sum(int i)
 {
 	int sum = FWtree[i];
 	while(i)
 	{
 		i -= (i & (-i));
 		sum += FWtree[i];
 	}
 	return sum;
 }
 
 void add(int i, int value)
 {
 	while(i < SIZE)
 	{
 		FWtree[i] += value;
 		i += (i & (-i));
 	}
 }
 
 void init_fw_tree(int my_array[], int start, int end)
 {
 	SIZE = end-start+2;
 	for(int i = 1; i <= end-start+2; i++)
 	{
 		add(i, my_array[ start+i-1 ]);
 	}
 }
 
 int main()
 {
 	int my_array[] = {1, 3, 2, 4, 5 ,9, 6, 5 ,0, 3, 4, 3, 2, 2};
 	init_fw_tree(my_array, 0, 13);
 
 	//get sum of all the numbers in the array
 	printf(""Sum of all  numbers in the array is = %d\n"",get_sum(14));
 	
 	// update 5th index with value 9
 	add(5,9);
 	printf(""New sum after updating 5th index with value 8 is = %d\n"",get_sum(14));
 
 	return 0;
 }
 
",C
"""""""Quadratic Probing is a collision resolution method in hashing.
 Quadratic probing says that whenever a collision occurs, search for i^2 position.
 It is more efficient algorith than linear probing since it avoids the clustering problem that can occur with linear probing.""""""
 #Function for Quadratic Probing.
 def QuadraticProbing(hash, hashSize, arr, N):  
     for i in range(N):
         hashVal = arr[i]%hashSize
         if hash[hashVal] == -1:
             hash[hashVal] = arr[i]
         else:
             k = arr[i]
             for j in range(1,hashSize):
                 hashVal = (k + pow(j,2))%hashSize
                 if hash[hashVal] == -1:
                     hash[hashVal] = arr[i]
                     break
                 else:
                     continue
 #  Driver Code Starts
 def main():
     T=int(input()) 
     while(T>0):   
         hashSize=int(input())
         sizeOfArray=int(input())
         arr=[int(x) for x in input().strip().split()]        
         hash = [-1]*hashSize
         QuadraticProbing(hash, hashSize, arr, sizeOfArray)       
         for i in hash:
             print(i,end="" "")
         print()
         T-=1
 if __name__==""__main__"":
     main()
 # } Driver Code Ends
 
 """"""
 Sample Input
 hashSize=11
 N = 4
 Array[] = {21,10,32,43}
 Sample Output
 10 -1 -1 32 -1 -1 -1 -1 43 -1 2
 Time Complexity:- Best case: O(1), Worst case: O(N)
 Space Complexity:- O(N)""""""
",Python
"'''
 Given two strings <target> and <text>, write a program to find the number
 of anagrams of <target> that can be found in the string <text>
 Length of the <target> <= length of <text> <= 10^5
 '''
 
 from collections import Counter
 
 
 def countAnagrams(target, text):
 
     '''
     This function returns the number of anagrams of string <target> which are
     present in the string <text>
 
     Parameters:
     target: string whose anagrams need to be counted
     text: string where the anagrams need to be counted
 
     '''
 
     k = len(target)
     n = len(text)
     # initialize a hashmap/ dictionary which stores the key value pairs
     # for frequencies of all the characters of the target string
     required = Counter(target)
     # similarly initialize the window with the first k characters
     # of the string <text>
 
     window = Counter(text[:k])
     # this variable will contain the number of anagrams
     answer = 0
     for i in range(n-k):
         # checking if all the characters of the current window are matching
         # with the characters of the target
         if window & required == required:
             answer += 1
         # decrementing the frequency of the character outside the window
         # incrementing the frequency of the character entering the window
         window[text[i]] -= 1
         window[text[i+k]] += 1
     # computing the answer for the last window
     if window & required == required:
         answer += 1
     return answer
 
 
 # Driver Code
 if __name__ == ""__main__"":
 
     s1 = input('Enter the target string : ')
     s2 = input('Enter the text string : ')
 
     print('The number of anagrams of ""{}"" in ""{}"" are: '.format(s1, s2))
     print(countAnagrams(s1, s2))
 
 problemDetails = '''
 Time Complexity:
 O(n) where n is the length of the string <text>
 additional time complexity : O(k) where k is length of the target string
 since n > k : overall time complexity of the code => O(n)
 
 Space complexity:
",Python
"/*
  This problem will be solved using dp.
  We will be given two strings and we have to find the shortest
  common superstring b/w two and will have to print it's superstring.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 int t[1001][1001];
 
 string longestSubsequence(string X,string Y,int m,int n){
     // if length of any string is 0 then we cannot find common string
     for(int i=0;i<m+1;i++){
         for(int j=0;j<n+1;j++){
             if(i==0 || j==0)
             t[i][j] = 0;
         }
     }
 
     for(int i=1;i<m+1;i++){
         for(int j=1;j<n+1;j++){
             //if letters of both string are equal then we will decrease row and column both by 1
             if(X[i-1] == Y[j-1]){
                 t[i][j] = t[i-1][j-1] + 1;
             }
             //if letters of both string are not equal then first we will decrease row by 1 and then column by 1 and find maximum value b/w two
             else{
                 t[i][j] = max(t[i-1][j], t[i][j-1]);
             }
         }
     }
     
     int i=m,j=n;
     string result;
     
     /*
      We will start from last cell of the matrix and will check
      if character od X and Y are equal then we will add character to the the element and will decrease both row and column by 1
      else we will check which cell has greater value if by decreasing row is greater we will decrease row by 1 and add both row and charater element
      else will decrease column by 1 and add both row and charater element.
      */
     while(i>0 && j>0){
         if(X[i-1] == Y[j-1]){
             result += X[i-1];
             i--;
             j--;
         }
         else{
         if(t[i-1][j] > t[i][j-1]){
             result += X[i-1];
             i--;
         }
         else{
             result += Y[j-1];
             j--;
         }
         }
     }
       
     // if second string length become 0 and first string left then we will traverse it's length and add first string charaters to the result
  ",C-Plus-Plus
"""""""
 Strongly Connected Components : A directed graph is strongly connected
         if there is a path between all pairs of vertices. A strongly
         connected component (SCC) of a directed graph is a maximal
         strongly connected subgraph.
 
 Purpose: To find all the Strongly Connected Components (SCC) in the
         given directed graph.
 Method: Tarjan's Algorithm / Depth First Search
 Intution: Tarjan Algorithm is based on following facts:
         1. DFS search produces a DFS tree/forest
         2. Strongly Connected Components form subtrees of the DFS tree.
         3. If we can find the head of such subtrees, we can print/store all
             the nodes in that subtree (including head) and that will be one SCC.
         4. There is no back edge from one SCC to another (There can be cross
         edges, but cross edges will not be used while processing the graph).
 
 Time Complexity:  O(N+M)
 Space Complexity: O(N)
 
 Argument: Dictionary ( Graph with each node is numbered from 1 to N)
 Reaturn : List       ( Strongly Connected Components)
 
 """"""
 from collections import defaultdict
 
 # Global variable to keep a track of finishing time of diffrent nodes
 Time = 0
 
 # Depth First Search recuresive function
 
 
 def DFS(graph, node, low, ids, visited, chk, stack, ans):
     global Time
 
     # Update the stack
     stack.append(node)
 
     # Mark the node visited and Checked
     chk[node] = 1
     visited[node] = 1
 
     # Initialize the id and low to the Time
     ids[node] = Time
     low[node] = Time
     Time += 1
 
     for i in graph[node]:
 
         # For each not visited node, recursievely call DFS()
         if not visited[i]:
             DFS(graph, i, low, ids, visited, chk, stack, ans)
 
         # If the node is already checked, Initialize the low to min value
         if chk[i]:
             low[node] = min(low[node], low[i])
 
     # After checking each adjacent vertex, if id == low, than the node is
     # the Head of a Stro",Python
"/* Given number of pages in n different books and m students.
    The books are arranged in Random order of number of pages.It is not compulsory to sort the Array.
    Every student is assigned to read some consecutive books.
    The task is to assign books in such a way that the maximum number of pages assigned to a student is minimum.
    Solution of this problem can be improved using the Binary Search Algorithm
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Utility function to check if current minimum value is feasible or not. */
 bool isValid(int arr[],int size,int students,int mid){
 	int student=1;
 	int sum=0;
 	for(int i=0;i<size;i++){
 		sum+=arr[i];
 		if(sum>mid){ /* If the sum exceeds the current minimum value then increase the count of students */
 			student++;
 			sum=arr[i]; //Reinitializing the sum with the current element of the Array
 		}
 		if(student >students) /* If the count of student till now becomes greater than the the students then return false */
 		return false;
 	}
 	return true;
 }
 
 /* function to find minimum pages */
 int findPage(int arr[],int size,int students){
 	/* Base Condition */
 	if(size<students) /* As mentioned in the condition , each student must have atleast one book */
 	   return -1;
 	
 	/* Finding maximum in array */
 	int maxi=INT_MIN;/*maxi will be the starting element of binary search for improving complexity */
 	for(int i=0;i<size;i++){
 		if(arr[i]>maxi)
 		maxi=arr[i];
 	}
 	
 	/* Finding sum of array */
 	int sum{0};/* sum represents the end element in the worst case */
 	for(int i=0;i<size;i++)
 	sum+=arr[i];
 	
 	int start=maxi;
 	int end=sum;
 	int res=-1; /* Initialising the result with -1 */
 	while(start<=end){
 		int mid=start+(mid-start)/2; /* to avoid integer overflow */
 		if(isValid(arr,size,students,mid)){
 			res=mid;
 			end=mid-1; /* to search the minimum number of pages */
 		}
 		else
 		start=mid+1;
 	}
 	return res;
 }
 
 /* Drivers Code */
 int main(){
 	int size; //size of ",C-Plus-Plus
"''' This program calculates nth Catalan number using Dynamic programming.
 The solutions to the nth Catalan number is calculated in bottom-up manner.
 There by reducing the time complexity.'''
 
 # This function returns nth catalan number
 def n_catalan(number):
 
     # Makes an array to store the catalan numbers
     array = [0] * (number + 1)
 
     # Base cases
     array[0] = 1
     if(number == 0):
         return array[0]
     array[1] = 1
 
     # Using DP recursive solution to get nth catalan number
     for i in range(2, number + 1):
         for j in range(0, i):
             array[i] += array[j] * array[i - j - 1]
 
     # Return the nth catalan number
     return array[number]
 
 
 ## Drivers code
 if __name__==""__main__"":
     
     ##Take number as input from the user
     number = int(input(""Enter a number: ""))
 
     ## Check if the number is non-negative.
     if(number < 0):
         print(""\nPlease enter a non-negative number."")
         exit()
 
     ## Call the function
     catalan = n_catalan(number)
     ## Print the nth catalan number
     print(""\nCatalan number at index "" + str(number) + "" is "" + str(catalan))
 
 ''' 
 Sample I/O:
 
 1)
 Enter a number: 10
 
 Catalan number at index 10 is 16796
 
 2)
 Enter a number: -2
 
 Please enter a non-negative number.
 
 '''
",Python
"/*
 We can use binary search to reduce the number of comparisons in normal insertion sort.
 Binary Insertion Sort uses binary search to find the proper location to insert the selected item at each iteration. 
 In normal insertion sort, it takes O(n) comparisons (at nth iteration) in the worst case.
 We can reduce it to O(log n) by using binary search.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 //searching element in array a by binary search algoritm
 int binarySearch(int a[], int element, int low, int high)
 {
     if (high <= low){
         return (element > a[low]) ? (low + 1) : low;
     }
     int mid = (low + high) / 2;
     if (element == a[mid]){
         return mid + 1;
     } 
     if (element > a[mid]){
         return binarySearch(a, element, mid + 1, high);
     }
     return binarySearch(a, element, low, mid - 1);
 }
 // sorting using insertion sort
 void insertionSort(int arr[], int n)
 {
     // initializing variables
     int i, place, j, k, selected;
     for (i = 1; i < n; ++i) 
     {
         j = i - 1;
         selected = arr[i];
 
         // location where selected sould be inseretd
         place = binarySearch(a, selected, 0, j);
 
         // Move all elements after location to create space
         while (j >= place) 
         {
             arr[j + 1] = arr[j];
             j--;
         }
         arr[j + 1] = selected;
     }
 }
 
 signed main()
 {
     //Taking Input
     int n; cin>>n;
     int arr[n];
     for(int i=0;i<n;i++){
         cin>>arr[i];
     }
 
     //Applying Sort
     //calling sort function
     insertionSort(a, n);
     cout<<""Sorted Array is :-"";
     for (int i = 0; i < n; i++){ 
         cout<<arr[i]<<"" "";
     }
     return 0;
 }
 /* Sample Input
 11
 35 23 12 17 12 72 31 46 180 88 54
 */
 /* Sample Output
 Sorted Array is:- 12 12 17 23 31 35 46 54 72 88 180
 */
 
 // Time Complexity -O(n^2)
 //Space Complexity -O(n)
",C-Plus-Plus
""""""" 
 Knapsack problem using the fractional/greedy method
 given the weights and their corresponding profit values, 
 fractional implementation allows filling knapsacks with parts/fractions of the items
 We fill knapsack of capacity W to obtain maximum possible value in bottom-up manner.
 Time Complexity = O(n logn)
 """"""
 def knapsack_fractional(weights,values,capacity):
     """""" takes weights and values of items and capacity of knapsack as input
     and returns the maximum profit possible for the given capacity of knapsack 
     using the fractional knapsack algorithm""""""
     #initialisaing the value of max_profit variable
     max_profit=0
     for pair in sorted(zip(weights,values),key=lambda x:-x[1]/x[0]): # sorting the pair of values in descending order
        #if weight of highest pair is greater than capacity, the amount is added in fractions
         if pair[0]>capacity:
            # while((pair[1]/(pair[0]/capacity))!=0)
             max_profit+=int(pair[1]/(pair[0]/capacity))
             capacity=0
         #if highest pair is lesser than capacity then the next pair is also added in fractions    
         elif pair[0]<= capacity:
             max_profit+=pair[1]
             capacity-=pair[0]
     #returns nearest possible integer value of profit
     return int(max_profit) 
 
 if __name__ == '__main__':
 
     print(""Enter Capacity:"")
     capacity = int(input())
    
     print(""Enter weights:"")
     weights = list(map(int, input().split()))
     
     print(""Enter values:"")
     values = list(map(int, input().split()))
 
     print('The maximum possible profit is ',knapsack_fractional(weights,values,capacity)) 
 
 """"""
 Sample Input:
 capacity = 50
 weights = 1 5 10
 values = 10 50 100
 Sample Output:
 160
 """"""          
",Python
"// Find a Fibonacci number that is greater than or equal to the size of the array in which we are searching for the key.
 // Compare the key with the predecessor of the Fibonacci number obtained in Step 1 and store it in index.
 // If the key and array element at index are equal then the key is present at position index + 1.        
 // If the key is less than array element at index, then search the left sub-tree to index.
 // If the given key is greater than the array element at index, then search the right sub-tree to index.  
 // If the key is not found, repeat the steps from Step 1 to Step 5 as long as index = 0, that is, Fibonacci number >= array_size. 
 // After each iteration the size of array array_size is reduced.
 
 package Java;
 import java.util.*;
 
 public class FibonacciSearch {
     public static int getFibanociNumber(int array_Size) {
         int fibk = 0;
         int fibk2 = 0;
         int fibk1 = 1;
         if (array_Size == 0 || array_Size == 1) {
             return 0;
         }
         while (fibk < array_Size) {
             fibk = fibk1 + fibk2;
             fibk2 = fibk1;
             fibk1 = fibk;
         }
         return fibk2;
     }
 
     public static void main(String[] args) {
         Scanner s = new Scanner(System.in);
         int sorted_Array[] = new int[100];
         int key, index, low, high, flag, location, array_Size;
 
         System.out.println(""Enter the size of the array: "");
         array_Size = s.nextInt();
         System.out.println(""Enter the elements of the array: "");
         for (int i = 0; i < array_Size; i++) {
             sorted_Array[i] = s.nextInt();
         }
  
         low = 0;
         location = -1;
         high = array_Size - 1;
         flag = 0;
 
         System.out.println(""Enter the element which is to be searched: "");
         key = s.nextInt();
         s.close();
 
         index = 0;
         while (flag != 1 && low <= high) {
             index = getFibanociNumber(array_Size);
   ",Java
"/* Program to find the minimum element of an array using stack in O(1) space complexity and time complexity.
   
   Given Array A[]={1,2,-1,4,5};
          
   Then we will first create a stack of array of elemnents by pushing array elements and then find minimum 
   of them:-
   We define a variable min that stores the current minimum element in the stack.To handle the case when minimum element is removed 
   we push 2x  minEle into the stack instead of x so that previous minimum element can be retrieved using current min and its value stored in stack.
   
 */
 #include <bits/stdc++.h>
 using namespace std;
 //Creating a user-defined structure for operation on stack;
 class UserStack
 { 
     private:
     stack<int> s; 
     int min;
     
     public:
     int getMin() 
     { 
         if (s.empty()) 
         {
           //Invalid operation hence returning INT_MAX;
             return INT_MAX;   
         } 
   
         else
         {
             return min;
         }
            
     } 
       void push(int x) 
     { 
        
         if (s.empty()) 
         { 
             min = x; 
             s.push(x); 
             return; 
         } 
           
      // If new number to be pushed is less than min
         if (x < min) 
         { 
             s.push(2*x - min); 
             min = x; 
         } 
 
         else
         {
              s.push(x); 
   
         }
           
     }
     
     
     void peek() 
     { 
         if (s.empty()) 
         { 
             cout << ""Stack is empty ""; 
             return; 
         } 
   
         int t = s.top();  
  
   // If t < min means min stores value of t.
   
         cout << ""Top Most Element is:""; 
            if(t<min)
            {
                cout<<min<<""\n"";
            }
            else
            {
                cout<<t<<""\n"";
            }
         
     } 
     
       void pop() 
     { 
         if (s.empty()) 
         { 
             cout << ""Stack is empty c",C-Plus-Plus
"/*An integer x is said to be Noble given an array 
 if the number of integers greater than x are equal to x.
 If noble integer is not found output is -1.
 */
 #include <stdio.h>
 
 int nobleint(int *, int);
 int main()
 {
 	int num, i, k, arr[1000], arr2[1000], m;
 	printf(""Enter the number of elements:"");
 	scanf(""%d"", &num);
 	printf(""Enter the elements:"");
 	for (i = 0; i < num; i++)
 	{
 		scanf(""%d"", &arr[i]);
 	}
 
 	m = nobleint(arr, num);
 	printf(""%d"", m);
 
 	return 0;
 }
 
 // To find the noble integer from the given array
 int nobleint(int *arr, int num)
 {
 	int count, i, j, x = 0;
 	for (i = 0; i < num; i++)
 	{
 		count = 0;
 		for (j = 0; j < num; j++)
 		{
 			if (*(arr + i)<*(arr + j))
 				count = count + 1;
 		}
 
 		if (count == *(arr + i))
 		{
 			x = 1;
 			return (count);
 		}
 	}
 
 	if (x == 0)
 		return (-1);
 }
 
 /*
 Sample Output
 
 Enter the number of elements:4
 Enter the elements:7 3 9 81
 3
 Enter the number of elements:3
 Enter the elements:2 2 2
 -1
 
 Complexities
 Time Complexity:O(n^2)
 Space Complexity:O(1)
 */
 
",C
"/*Below is the code which is used to find whether a cycle is present in a linked list.
 It uses 2 pointer slow and fast(which travels at speed twice that of slow).
 If they meet at any position while traversing the linked list then a cycle is
 present otherwise cycle is not present */
 #include <bits/stdc++.h>
 using namespace std;
 
 class node{
 public:
     int data;
     node* next;
     node(int d){
         data = d;
         next = NULL;
     }
 };
 
 void insertAtHead(node* &head,int d){
     if(head==NULL){
         head = new node(d);
         return;
     }
     node* n = new node(d);
     n->next = head;
     head = n;
     return;
 }
 
 void insertAtTail(node* &head,int d){
     if(head==NULL){
         insertAtHead(head,d);
         return;
     }
     node* tail = head;
     while(tail->next!=NULL){
         tail=tail->next;
     }
     tail->next = new node(d);
     return;
 }
 
 void makeCycle(node* &head,int pos){
     node* temp = head;
     node* startNode;
 
     int count = 1;
     while(temp->next != NULL){
          if(count == pos){
              startNode = temp;
          }
          temp = temp->next;
          count++;
     }
     temp->next = startNode;
 }
 
 bool detectCycle(node* head){
     node* slow = head;
     node* fast = head;
     while(fast!=NULL and fast->next!=NULL){
         fast = fast->next->next;
         slow = slow->next;
         if(fast==slow){
             return true;
         }
     }
     return false;
 }
 
 int main()
 {
     node* head = NULL;
     int n;
     cout<<""Enter the number of nodes:""<<endl;
     cin>>n;
     for(int i=0;i<n;i++){
        int x;
        cin>>x;
        insertAtTail(head,x);
     }
     int pos;
     cout<<""Enter the position where you want to make a cycle:""<<endl;
     cin>>pos;
 
     //cycle is created at position pos
     makeCycle(head,pos);
 
     //detect a cycle
     if(detectCycle(head)){
        cout<<""Cycle is present""<<endl;
     }
     else{
        cout<<""Cycle is not pr",C-Plus-Plus
"// Unique BSTs using DP
 // For given n, how many structurally unique BST's that store values 1 ... n?
 
 import java.io.*;
 import java.util.*;
 
 class Unique_BST {
     // function will return no. of unique bsts
     static int uniqueBST(int n) {
         int count[] = new int[n + 1];
         // for each 'i' number of nodes
         for (int i = 1; i <= n; ++i) {
             for (int j = 0; j < i; ++j) {
                 // No. of trees if j is a root
                 count[i] += Math.max(count[j], 1) * Math.max(count[i - j - 1], 1);
             }
         }
         return count[n];
     }
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the number:"");
         int num = sc.nextInt();
         System.out.println(""Number of Unique BSTs "" + uniqueBST(num));
     }
 }
 
 /*
 Input:
 Enter the number:
 3
 Output:
 Number of Unique BSTs 5
 Time complexity : O(n)
 */
",Java
"/*Problem Statement: 
 Usually, results of competitions are based on the scores of participants. 
 However, we are planning a change for the next year of IPSC. 
 During the registration each team will be able to enter a single positive integer : 
 their preferred place in the ranklist. We would take all these preferences into account, 
 and at the end of the competition we will simply announce a ranklist that would please all of you.
 But wait... How would that ranklist look like if it won't be possible to satisfy all the requests?
 Suppose that we already have a ranklist. 
 For each team, compute the distance between their preferred place and their place in the ranklist. 
 The sum of these distances will be called the badness of this ranklist. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int SumDistances(int n,int arr[],int rank)
 {
     int sum=0;
     int actual_rank=1;
     for(int i=1;i<=n;i++)
     {
         while(arr[i])
         {
             sum+=abs(actual_rank-i);
             arr[i]--;
             actual_rank++;
         }
     }
     return sum;
 }
 
 int main()
 {
     int n,rank,arr[1000]={0};
     string name;
     cout<<""Enter the number of teams participating: ""<<endl;
     cin>>n;
     cout<<""Enter the team names and preffered place respectively: ""<<endl;
     for(int i=0;i<n;i++)
     {
         cin>>name>>rank;
         arr[rank]++;
     }
     cout<<""The badness of the best ranklist: ""<<SumDistances(n,arr,rank)<<endl;
     return 0;
 }
 /*
 Example:
 Input:-
 Enter the number of teams participating:
 7
 Enter the team names and preffered place respectively:
 noobz 1
 llamas 2
 winn3rz 2
 5thwheel 1
 notoricoders 5
 strangecase 7
 whoknows 2
 
 Output:-
 The badness of the best ranklist: 5
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
 
",C-Plus-Plus
""""""" Julia program to Check if a number is a Palindrome Number or not.
 A palindrome number is a number such that the reverse of the number is equal to the number itself 
 """"""
 
 function check_palindrome(num)
     temp = num
     rev = 0
     while (temp > 0)
         rem = temp % 10
         rev = (rev * 10) + rem
         temp = temp  10;
     end
     if (num == rev)
         return true
     else
         return false
     end
 end
 
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 res = check_palindrome(abs(num))
 if res
     println(""The given number $num is a Palindrome Number."")
 else
     println(""The given number $num is not a Palindrome Number."")
 end
 
 
 """"""
 Time Complexity: O(log(num)), where 'num' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 121
 The given number 121 is a Palindrome Number.
 
 SAMPLE 2
 Enter the number: 1234
 The given number 1234 is not a Palindrome Number.
 
 """"""
",Julia
"/*
     This is a simple in go language to search 
     the given array using fibonacci numbers for
     a given number inputted.
 
     Note : we need to the give the input as a 
            sorted array 
 
     Here we use the fibonacci number starting 
     form 0 and so on.....
 
     i.e, 0,1,1,2,3,5,8,13,21 ....
 
 */
 
 package main
 
 import (
 
    ""fmt""
 
 )
 
 // global variables
 var array[100] int
 var number int
 var x int
 
 //  n,n-1 and n-1 th fibonacci numbers
 var a int = 0
 var b int = 1
 var c int = a+b
 var index int = 0
 var i int = -1
 
 // We print the result using this function
 func printfunction(res int) {
 
    if(res == 0) {
       fmt.Print(""The element not found!"")
    }else {
       fmt.Print(""The element is at the index position :"",res)
    }
 
 }
 
 /* We use this function to validate the n-1th 
    fibonacci number*/
 func validate() {
 
    if( a+i<number-1 ) {
         index = a+i
    }else{
         index = number-1
    }
 
 }
 
 /* This function calculates the nth n-1th and 
    n-2th fibonacci numbers where n is the 
    smallest fibonacci number greater tha or 
    equal to the input array size */
 func fibonaccinumber() {
 
      for(c<number){
          a = b
          b = c
          c = a+b
      }
 
 }
 
 /* This is the function where we search for 
    the inputted number*/
 func fibonaccisearch() int{
 
      for c>1 {
 
         // validating the n-2th fib number
         validate()
 
          /* if x is greater than array element 
             we recur for subarray after index*/
         if(array[index] < x ) {
 
             /* move the three Fibonacci variables 
                one Fibonacci down*/
             c = b
             b = a
             a = c-b
             i = index
 
         /* if x is smaller than the array element
            we recur for the subarray before index*/
         }else if (array[index] > x ) {
 
             /*move the three Fibonacci variables 
               two Fibonacci down */
  ",Go
"""""""
 Ugly Number : Ugly numbers are numbers whose only prime factors
          are 2, 3 or 5. By convention, 1 is included.The sequence
          1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15,  shows the first
          11 ugly numbers.
 
 Purpose: Return the Nth smallest Ugly Number
 Method:  Dynamic Programing
 Intution: The ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 
      because every number can only be divided by 2, 3, 5, one way to
      look at the sequence is to split the sequence to three groups as below:
 
         (1) 12, 22, 32, 42, 52, 
         (2) 13, 23, 33, 43, 53, 
         (3) 15, 25, 35, 45, 55, 
 
       We can find that every subsequence is the ugly-sequence itself
       (1, 2, 3, 4, 5, ) multiply 2, 3, 5. Then we use similar merge method as
       merge sort, to get every ugly number from the three subsequence.
       Every step we choose the smallest one, and move one step after.
 
 Time Complexity: O(N)
 Space Complexity: O(N)
 
 Argument: Integer
 Return  : Integer (Nth smallest Ugly Number)
 
 """"""
 
 
 def Ugly_Number(num):
 
     # Initilize the DP table for ugly Number
     # Base Case: 1 is considered to be the first Ugly Number
     ugly_num = [1]
 
     # Store the multiples of 2, 3, 5
     two = 2
     three = 3
     five = 5
 
     # start the indexing of the table from 0
     in2 = in3 = in5 = 0
 
     # Push the next N ugly number into the DP table
     for i in range(1, n):
 
         # Extract the next Ugly Number in the seriese
         next_ugly = min(two, three, five)
 
         # Push the next_ugly into the table
         ugly_num.append(next_ugly)
 
         # For all the three factors, check wether it is equal to the next_ugly
         # if yes then increase the top by 1 and assign the respective value
         if next_ugly == two:
             in2 += 1
             two = ugly_num[in2] * 2
 
         if next_ugly == three:
             in3 += 1
             three = ug",Python
"/*
 The longest bitonic subsequence is a sequence in which the sequence is first increasing then decreasing ,
 The below program finds the length of the longest bitonic subsequence.
 */
 #include <bits/stdc++.h>
 
 using namespace std;
 
 int longest_bitonic_subsequence(vector<int> v, int n)
 {
     // v_increase tracks the longest increasing subsequence
     vector<int> v_increase;
     for (int i = 0; i < n; i++)
     {
         v_increase.push_back(1);
     }
     for (int i = 1; i < n; i++)
     {
         for (int j = 0; j < i; j++)
         {
             if (v[i] > v[j])
             {
                 if (v_increase[i] <= v_increase[j])
                 {
                     v_increase[i] = v_increase[j] + 1;
                 }
             }
         }
     }
     // v_decrease tracks the longest decreasing subsequence
     vector<int> v_decrease;
     for (int i = 0; i < n; i++)
     {
         v_decrease.push_back(1);
     }
     for (int i = n - 2; i >= 0; i--)
     {
         for (int j = n - 1; j > i; j--)
         {
             if (v[i] > v[j])
             {
                 if (v_decrease[i] <= v_decrease[j])
                 {
                     v_decrease[i] = v_decrease[j] + 1;
                 }
             }
         }
     }
     int max = 0;
     for (int i = 1; i < n; i++)
     {
         int temp = v_increase[i] + v_decrease[i] - 1;
         if (temp > max)
         {
             max = temp;
         }
     }
     return max;
 }
 
 // Driver Code
 int main()
 {
     cout << ""Enter the number of elements in the sequence"" << endl;
     int n;
     cin >> n;
     vector<int> v;
     cout << ""Enter the elements of the sequence"" << endl;
     for (int i = 0; i < n; i++)
     {
         int temp;
         cin >> temp;
         v.push_back(temp);
     }
     cout << ""The length of longest bitonic subsequence is : "" << longest_bitonic_subsequence(v, n);
     return 0;
 }
 
 /*
 Sample I/O:
 
 Enter the number of elements in the vay
 10
 Enter",C-Plus-Plus
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# Building a decision tree from scracth ""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 88,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""#Okay using only pandas and numpy \n"",
     ""import pandas as pd\n"",
     ""import numpy as np""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Lets take a toy dataset to get the idea of a decision tree ""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 89,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""training_data = [\n"",
     ""    ['Green', 3, 'Apple'],\n"",
     ""    ['Yellow', 3, 'Apple'],\n"",
     ""    ['Red', 1, 'Grape'],\n"",
     ""    ['Yellow', 3, 'Lemon'],\n"",
     ""]""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 90,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/plain"": [
        ""[['Green', 3, 'Apple'],\n"",
        "" ['Yellow', 3, 'Apple'],\n"",
        "" ['Red', 1, 'Grape'],\n"",
        "" ['Yellow', 3, 'Lemon']]""
       ]
      },
      ""execution_count"": 90,
      ""metadata"": {},
      ""output_type"": ""execute_result""
     }
    ],
    ""source"": [
     ""training_data""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""    Lets calculate gini index first so that it tells us how impure the current distribution is. \n"",
     ""    A value close to 0 indicates that the data is relatively pure , \n"",
     ""    while data closer to >=0.5 indicates that the decision is impure (i.e:there is a mix of 2 or more classes).   ""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 91,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""def Gini_Index(data):\n"",
     ""    \""\""\""\n"",
     ""    Given some input data we calculate the percentage representation of each output class wrt the data \n"",
     ""    We always assume to last column is",Python
"""""""
 Problem Statement : To find the Hailstone Sequence for the number given.
 
 Problem Link:- https://wiki.formulae.org/Hailstone_sequence
 
 Intution: Print the value of n.
           If n is odd, calculate the next number as n*3+1.
           If n is even, calculate the next number as n/2.
           Append the last element of the sequence 1.
 
 Return  : Array of the hailstone sequence.
 
 Repl.it Link : https://replit.com/@batul02/hailstonesequence#main.py
 
 """"""
 
 def hailstone_sequence(n):
 
     #array to store the sequence
     sequence = []
 
     #loop will continue until the number > 1
     while n > 1:
 
         #appending the number
         sequence.append(n)
 
         #checking if the number is odd or even
         if n % 2 == 1:
             n = n * 3 + 1
         else:
             n = int(n / 2)
 
     #append 1 because every hailstone sequence ends with 1
     sequence.append(1)
 
     #return the array
     return sequence
  
 def main():
     #User input for a number to get its hailstone sequence
     n = int(input(""Enter a number: ""))
 
     #function call for getting hailstone sequence for the number
     print(""Hailstone Sequence: "", hailstone_sequence(n))
     
 
 main()
 
 """"""
 Sample Input / Output:
 
 Enter a number: 20
 Hailstone Sequence:  [20, 10, 5, 16, 8, 4, 2, 1]
 
 Enter a number: 31
 Hailstone Sequence:  [31, 94, 47, 142, 71, 214, 107, 322, 161, 484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155, 466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780, 890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566, 283, 850, 425, 
 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079, 3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102, 2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433, 1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1]
 
 Enter a number: 50
 Hailstone Sequence:  [50, 25, 76, 38, 19, 58, 29, 88, 44, 22, 11, 34, 17",Python
"// Calculating Factorial Using Big Integer
 // https://www.hackerearth.com/practice/notes/factorial-of-large-number/
 import java.math.BigInteger;
 import java.util.*;
 import java.io.*;
 import java.lang.*;
 
 class FactorialUsingBigInteger
 {
     //Main Method
     public static void main(String[] args) throws IOException
     {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the number of times you want to calculate Factorial:"");
         int t = sc.nextInt();
         HashMap<Integer,BigInteger> hashmap = new HashMap<>();
         int maxKey = -1;
         for(int i=0;i<t;i++){
             System.out.println(""Enter the value of N:"");
             int N = sc.nextInt();
             if(N>=0)
             {
                 BigInteger f = new BigInteger(""1""); // Or BigInteger assigned to ONE
                 // Multiply f with number till N
                 int initial = 2;
 		//Checking if inputted number exists in map or not
                 if (hashmap.containsKey(N)){
                     f = hashmap.get(N);
                 } else {
 		    // For a given number, Checking whether any sub factorial has some element present in hashmap
                     if (maxKey!=-1){
                         initial = maxKey;
                     }
                     for (int j = initial; j <= N; j++) {
                         if (hashmap.containsKey(j)) {
                             f = f.multiply(hashmap.get(j));
                         } else {
                             f = f.multiply(BigInteger.valueOf(j));
                             maxKey = j;
                             hashmap.put(j, f);
                         }
                     }
                 }
                 System.out.println(""Factorial of given number is :""+f);
             }else{
                 System.out.println(""Number Should be greater than 0"");
             }
         }
     }
 } 
 /*
 Time Complexity:O(t*N)
 Space Complexity:O(1)
 Input:
 Enter the",Java
"/* Below code checks if the given input string is
 a palindrome or not. The string is traversed till
 its middle index and beginning and end of the string
 is compared.*/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 // Define maximum length of input string
 #define MAXLENGTH 100
 
 // This function checks if string is a palindrome
 int check_palindrome(char* string) {
 	
 	// Iterate till the middle of the string
 	for(int i = 0; i < (strlen(string) - 1) / 2; i++) {
 		/* Check if character at beginning index of the
 		string matches the end of the string at same index*/
 		if(string[i] != string[strlen(string) - 2 - i]) {
 			// If it does not then return -1
 			return -1;
 		}
 	}
 	// If everything matches then return 1
 	return 1;
 }
 
 int main() {
 
 	// Take string as input from the user
 	char string[MAXLENGTH];
 	printf(""Enter a string to check if it is a palindrome: "");
 	fgets(string, MAXLENGTH, stdin);
 
 	// Calling the function to check
 	int result = check_palindrome(string);
 	
 	// If the string is a palindrome
 	if(result == 1) {
 		printf(""The given string is a palindrom.\n"");
 	}
 	// If the string is not a palindrome
 	else {
 		printf(""The given string is not a palindrom.\n"");
 	}
 	
 	return 0;
 }
 
 /* Sample I/O:
 	Enter a string to check if it is a palindrome: This is a si sihT
 	The given string is a palindrom.
 */
 
",C
"/*
 Description :  
         Palindrome Number : Given an integer x, return true if x is palindrome integer.
                             An integer is a palindrome when it reads the same backward as forward.
                             This code is implemented without using extra space.                       
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 bool checkPalindrome(int num)
 {
     // divi =  divisor
     int divi = 1;
 
     //finding the apt. divisor for the number
     while (num / divi >= 10)
     {
         divi *= 10;
     }
     while (num != 0)
     {
         int leading = num / divi;
         int trailing = num % 10;
         if (leading != trailing)
         {
             return false;
         }
         //reducing number to compare
         num = (num % divi) / 10;
         divi = divi / 100;
     }
     return true;
 }
 int main()
 {
     int num;
     cout << ""Enter the number to check : "" << endl;
     cin >> num;
     checkPalindrome(n) ? cout << ""True"" : cout << ""False"";
     return 0;
 }
 
 /*
 
 Time complexity : O(n2)
 Space complexity : O(1)
 
 */
 
 /*
 
 Test Case : 
     Test case 1 :
         Input : 1001
         Output : True
     Test case 2 : 
         Input : 1234
         Output : False
 
 */
 
",C-Plus-Plus
"// Java Program to find Binary Exponent Iteratively and Recursively.
 
 import java.util.Scanner;
 
 public class Binary_Exponentiation {
    // Iterative function to calculate exponent.
    public static int binExpo_iterate(int a, int b) {
       int res = 1;
       while (b > 0) {
          if (b % 2 == 1) {
             res = res * a;
          }
          a = a * a;
          b /= 2;
       }
       return res;
    }
    // Recursive function to calculate exponent.
    public static int binExpo_recurse(int a, int b) {
       if (b == 0) {
          return 1;
       }
       int res = binExpo_recurse(a, b / 2);
       res = res * res;
       if (b % 2 == 1) {
          return res * a;
       } else {
          return res;
       }
    }
    public static void main(String[] args) {
       Scanner sc = new Scanner(System.in);
 
       int a = sc.nextInt();
       int b = sc.nextInt();
       if (a == 0 && b == 0) {
          System.out.println(""Math error"");
       } else if (b < 0) {
          System.out.println(""Exponent must be Positive"");
       } else if (a == 0) {
          System.out.println(""0"");
       } else {
          int resIterate = binExpo_iterate(a, b);
          int resRecurse = binExpo_recurse(a, b);
          System.out.println(resIterate);
          System.out.println(resRecurse);
       }
    }
 }
",Java
""""""" Julia program to Check if a number is a Mystery Number or Not.
 
 A mystery number is that number which can be expressed as a sum of two 
 numbers and those two numbers must be the reverse of each other
 """"""
 
 
 function reverse(n)
     rev = 0
     while n > 0
         rev = rev * 10
         rev = rev + (n % 10);
         n = n  10
     end
     return rev
 end
 
 
 function check_mystery_num(n)
     # Let us iterate from 1 upto n/2, to check if there is any pair, such that thier
     # sum equals the given number and check if the pair are reverse of each other 
     temp = n  2
     for i in 1:(temp)
         if (reverse(i) == (n - i))
             return true
         end
     end
     return false
 end
 
 
 print(""Enter the number: "")
 num = readline()
 num = parse(Int, num)
 res = check_mystery_num(num)
 if res
     println(""The given number $num is a Mystery Number."")
 else
     println(""The given number $num is not a Mystery Number."")
 end
 
 """"""
 Time Complexity: O(n*log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 43234
 The given number 43234 is a Mystery Number.
 
 SAMPLE 2
 Enter the number: 1234
 The given number 1234 is not a Mystery Number.
 
 """"""
",Julia
"public class BubbleSort {
     static void bubbleSort(int[] arr) {  
         int n = arr.length;  
         int temp = 0;  
          for(int i=0; i < n; i++){  
             boolean sorted = true;
              for(int j=1; j < (n-i); j++){
                  if(arr[j-1] > arr[j]){
                      //swap elements
                      temp = arr[j-1];
                      arr[j-1] = arr[j];
                      arr[j] = temp;
                     sorted = false;
                  }
                           
              }
                  if(sorted) break;
          }  
   
     }  
     public static void main(String[] args) {  
         int arr[] ={3,60,35,2,45,320,5};
                  
         System.out.println(""Array Before Bubble Sort"");
         for(int i=0; i < arr.length; i++){
             System.out.print(arr[i] + "" "");
         }
         System.out.println();
                   
         bubbleSort(arr);//sorting array elements using bubble sort
                  
         System.out.println(""Array After Bubble Sort"");
         for(int i=0; i < arr.length; i++){
             System.out.print(arr[i] + "" "");
         }
    
     }
 }  ",Java
"/*
 Cyclically rotate the array by one
 
 You are given an array arr[], 
 your task is to cyclically rotate the elements clockwise
 by one and return the array.
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 
 //function to rotate the array cyclically by 1
 void rotateClockwiseby1(int arr[], int size)
 {
     int last = arr[size - 1];
     for(int pass = size - 1; pass > 0; pass--)
     {
         //making the next element equal to last element
         arr[pass] = arr[pass - 1];
     }
     //making first element equal to the last one
     arr[0] = last;
 }
 
 //driver code
 int main()
 {
     int size;
     cout << ""Enter the size of array : "";
     cin >> size;
 
     int arr[size];
     cout<< ""Enter the elements of the array: "" << endl;
     for (int i = 0; i < size; i++){
         cin >> arr[i];
     }
 
     rotateClockwiseby1(arr, size);
 
     cout<<""Rotated array is: "";
     for (int i = 0; i < size; i++){
         cout << arr[i];
     }
     cout << endl;
     return 0;
 }
 
 /*
 EXAMPLE:-
 Input--
 Enter the size of array : 5
 Enter the elements of the array: 1 3 5 9 0
 Output--
 Rotated array is: 0 1 3 5 9
 
 TIME COMPLEXITY--> O(N)
 SPACE COMPLEXITY--> O(1)
 */
",C-Plus-Plus
"// Iterative Queue based Java program to do level order traversal 
 // of Binary Tree 
 
 package practice;
 
 /* importing the inbuilt java classes required for the program */
 import java.util.LinkedList;
 import java.util.Queue;
 
 /* Class to represent Tree node */
 public class Node 
 {	
 	 int data;
 	 Node right,left;
 	 
 	 public Node(int item) 
 	 {
 		 data=item;
 		 right=left=null;
 	 }
 }
 
 /* Class to print Level Order Traversal */
 public class LevelOrderTraversalInQueue 
 {	
 	Node root;
 	
 	/* Given a binary tree. Print its nodes in level order 
     using array for implementing queue  */
 	public void printLevelOrder()
 	{  Queue<Node> q=new LinkedList<Node>();
 	   q.add(root);
        while(!q.isEmpty())
        {
     	  /* poll() removes the present head.*/ 
     	  Node temp=q.poll();
 		  System.out.print(temp.data+"" "");
 		  
 		  /*Enqueue left child */
 		  if (!((temp.left)==null))
 		     q.add(temp.left);
 		  
 		  /*Enqueue right child */
 		  if (!((temp.right)==null))
 		     q.add(temp.right);
 	   }
 	}
     
 	public static void main(String args[])  
     { 
         /* creating a binary tree and entering  
          the nodes */
         LevelOrderTraversalInQueue tree_level = new LevelOrderTraversalInQueue(); 
         tree_level.root = new Node(1); 
         tree_level.root.left = new Node(2); 
         tree_level.root.right = new Node(3); 
         tree_level.root.left.left = new Node(4); 
         tree_level.root.left.right = new Node(5); 
   
         System.out.println(""Level order traversal of binary tree is - ""); 
         tree_level.printLevelOrder(); 
     } 
 } 
 
 /*Output is
   Level order traversal of binary tree is - 
   1 2 3 4 5 
 */
",Java
"/*
 Given weights and values of n items, we need to put these items in a knapsack of capacity W to get the maximum total value in the knapsack.
 Here We are solving fractional knapsack in which we can take a fraction of item too.
 */
 
 #include <iostream>
 using namespace std;
 // A function to sort the arrays according to profit/weight
 void sort_arr(float ratio[], float profit[], float weight[], int n) 
 {
     float temp;
     for (int i = 0; i < n; i++)
         for (int j = 0; j < n - i - 1; j++)
             if (ratio[j] < ratio[j + 1])
             {
                 temp = ratio[j];
                 ratio[j] = ratio[j + 1];
                 ratio[j + 1] = temp;
 
                 temp = weight[j];
                 weight[j] = weight[j + 1];
                 weight[j + 1] = temp;
 
                 temp = profit[j];
                 profit[j] = profit[j + 1];
                 profit[j + 1] = temp;
             }
 }
 
 //function to calculate max value in knapsack.
 int knapsack_fraction(float weight[], float ratio[], float profit[], int n, int capacity) 
 {
     int final = 0;
     int i;
     //iterating over all items
     for (i = 0; i < n; i++) 
     {
         //checking if current weight is greater tahn break i.e this weight can't be put into knapsack.
         if (weight[i] > capacity) 
             break;
         //else add profir to final varibale i.e max profit and update capacity accordingly
         else 
         {
             final = final + profit[i];
             capacity = capacity - weight[i];
         }
     }
     //for fraction amount of item
     if (i < n) 
         final = final + (ratio[i] * capacity);
     return final;
 }
 
 int main()
 {
     float weight[20], profit[20], ratio[20], final, temp, capacity, amount;
     int n, i, j;
     cout << ""Enter the number of items :"";
     cin >> n;
     //accepting the profit and weight values for given value of n.
     for (i = 0; i < n; i++) 
     {
         cout << ""Enter Profit and we",C-Plus-Plus
"'''
 In rail-fence cipher, we are given a plaintext message and a
 numeric key. It is also called a zigzag cipher and is a form
 of transposition cipher. We re-arrange the order of alphabets
 in the plaintext to obtain the ciphertext. In this algorithm,
 the plaintext text is written diagonally downwards and upwards
 alternatively. The length of the diagonal is the keyword given.
 After each alphabet has been written, the individual rows are
 combined to obtain the cipher-text.
 '''
 
 import sys
 
 '''This is the encryption function, which takes plaintext
 and key as input. It then returns the ciphertext.'''
 
 def encryption(message, keyword):
 
     # This is the matrix to store the plaintext
     matrix = [[] for i in range(keyword)]
 
     i = 0
     count = 0
 
     ''' After going diagonally downwards keyword number of
         times, we need to go diangonally upwards. This rev
         list contains those values after which the plaintext
         is to be stored diagonally upwards.'''
     rev = []
     for j in range(len(message)):
         temp = keyword + j * (( 2 * keyword) - 2)
         if temp <= len(message):
             rev.append(temp)
     
     value = False
     
     while (i < keyword and count < len(message)):
         matrix[i].append(message[count])
         count = count + 1
 
         ''' As we find the reversing point, we set value to
             be true. So, that we can decrease the value of list
             index.'''
         if count in rev:
             value = True
             dec = keyword - 1
         
         ''' If value is true, we decrement the list index keyword
             number of times'''
         if value and dec > 0:
             i = i - 1
             dec = dec - 1
 
         # Else we go on storing the plaintext in downwards direction
         else:
             i = i + 1
 
     # This string stores the final ciphertext
     enc = """"
 
     # We read the value of matrix row by row to form the ciphertext
     for ",Python
"/*
 AVL tree is a self-balancing Binary Search Tree (BST) where the difference between heights of left and right subtrees cannot
 be more than one for all nodes and if at any time they differ by more than one, rebalancing is done to restore this property.
 Each node maintains extra information called a balance factor whose value is either -1, 0 or +1 where balance factor of node
 in an AVL tree is the difference between the height of the left subtree and that of the right subtree of that node.
 */
 
 import java.util.*;
 
 public class AVL_Tree {
 
     private Node root;
 
     private class Node {
         int data;
         Node left;
         Node right;
         int height;
 
         public Node(int data) {
             this.data = data;
             this.height = 1;
             left = null;
             right = null;
         }
     }
 
     // Inserting node in a tree
     public void insert(int num) {
         this.root = insert(this.root, num);
     }
 
     // Inorder Traversal
     public void inOrder(Node node) {
         if (node != null) {
             inOrder(node.left);
             System.out.print(node.data + "" "");
             inOrder(node.right);
         }
     }
 
     // Preorder traversal
     public void preOrder(Node node) {
         if (node != null) {
             System.out.print(node.data + "" "");
             preOrder(node.left);
             preOrder(node.right);
         }
     }
 
     // Postorder traversal
     public void postOrder(Node node) {
         if (node != null) {
             postOrder(node.left);
             postOrder(node.right);
             System.out.print(node.data + "" "");
         }
     }
 
     private Node insert(Node node, int num) {
 
         if (node == null) {
             Node node_new = new Node(num);
             return node_new;
         }
 
         if (num > node.data) {
             node.right = insert(node.right, num);
         } else if (num < node.data) {
             node.left = insert(node.l",Java
"import java.util.*;
 class caeserCipher
 {
     static String encrypt( String str , int n )
     {
         String s1 = """";
         for(int indexI = 0; indexI < str.length(); indexI++)
         {
             s1 = s1 + (char)((str.charAt(indexI) - 65 + n) % 26 + 65);
         }
         return s1; 
     }
     public static void main(String[] args)
     {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter a string to encrypt"");
         String str = sc.nextLine();
         System.out.println(""Enter a integer"");
         int n = sc.nextInt();
         str = str.toUpperCase();
         String encryptedString, decryptedString;
         encryptedString =  encrypt(str,n);
         decryptedString =  encrypt(encryptedString,(26-n));
         System.out.println(""Encrypted String "" + encryptedString);
         System.out.println(""Decrypted String "" + decryptedString);
     }
 }
 
 /* 
 Enter a string to encrypt
 quick
 Enter a integer
 3
 Encrypted String TXLFN
 Decrypted String QUICK
 */
",Java
"/*
 
 Given a string A. Return the string A after reversing the string word by word.
 Below is the implementation of program in 3 different ways -
 1. Iterative
 2. Built-In functions
 3. Recursive
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Iterative method
 function ReverseStringIterative(str) {
   let arrayString = str.split("""");
   let reversedArray = [];
 
   function addToArray(array) {
     if (array.length > 0) {
       reversedArray.push(array.pop()); // pop the element from array & push it in the reversedArray array
       addToArray(array);
     }
 
     return;
   }
 
   // Pass array of strings
   addToArray(arrayString);
   console.log(""Reverse String Iterative - "", reversedArray.join(""""));
   return reversedArray.join("""");
 }
 
 // Using in-built methods of JavaScript
 function ReverseString(str) {
   str = str === """" ? """" : str.split("""").reverse().join("""");
   console.log(""Reverse String - "", str);
   return str;
 }
 
 // Recursive approach
 function ReverseStringRecursive(str) {
   if (str === """") {
     return """";
   } else {
     return ReverseStringRecursive(str.substr(1)) + str.charAt(0);
   }
 }
 
 // Get the user input
 let string = prompt(""Enter String to reverse - "");
 
 // Call the algorithm
 ReverseStringIterative(string);
 ReverseString(string);
 
 // Call the recursive algorithm
 let result = ReverseStringRecursive(string);
 console.log(""Reverse String Recursive - "", result);
 
 /*
 
 > node ReverseString
 
 Enter String to reverse - node
 Reverse String Iterative -  edon
 Reverse String -  edon
 Reverse String Recursive -  edon
 
 */
 
 
",JavaScript
"// Author : @belikesayantan
 
 package main
 
 import (
 	""bufio""
 	""errors""
 	""fmt""
 	""log""
 	""os""
 	""strconv""
 	""strings""
 	""time""
 )
 
 func main() {
 	var strArray []string
 	var intArray []int
 
 	fmt.Println(""Enter an array with spaces"")
 	reader := bufio.NewReader(os.Stdin)
 	arr, err := reader.ReadString('\n')
 	if err != nil {
 		inputErr := errors.New(""something is wrong with your array input"")
 		log.Fatal(inputErr)
 	}
 	arr = strings.TrimSpace(arr)
 	strArray = strings.Split(arr, "" "")
 
 	for _, val := range strArray {
 		ele, err := strconv.Atoi(val)
 		if err != nil {
 			panic(err)
 		}
 		intArray = append(intArray, ele)
 	}
 
 	fmt.Println((""Enter the maximum element value you have in the array:""))
 	m, err := reader.ReadString('\n')
 	m = strings.TrimSpace(m)
 	max, _ := strconv.Atoi(m)
 
 	start := time.Now() // timer starts and records running time of CountingSort Algorithm
 	fmt.Println(""Sorted Array is: "", CountingSort(intArray, max))
 	end := time.Now() // timer stops and recording running time of CountingSort Algorithm is completed
 
 	fmt.Println(""\nRunning Time of CountingSort Algorithm is: "", end.Sub(start))
 }
 
 // CountingSort Algorithm Time Complexity : O(n + k) where k is the max element in the array
 func CountingSort(arr []int, max int) []int {
 	if len(arr) == 0 {
 		return nil
 	}
 
 	if len(arr) == 1 {
 		return arr
 	}
 
 	counter := make([]int, max+1)
 	sorted := make([]int, 0)
 
 	for i := 0; i < len(arr); i++ {
 		counter[arr[i]] = counter[arr[i]] + 1
 	}
 
 	for i := 0; i < len(counter); i++ {
 		count := counter[i]
 
 		for j := 0; j < count; j++ {
 			sorted = append(sorted, i)
 		}
 
 	}
 
 	return sorted
 }
 
 /*
 	I/O Sample:
 
 	Sample 1:
 	 go run countingSort.go
 	Enter an array with spaces
 	5 3 2 4 5 84 1 54
 	Enter the maximum element value you have in the array:
 	84
 	Sorted Array is:  [1 2 3 4 5 5 54 84]
 
 	Running Time of CountingSort Algorithm is:  249.246s
 
 
 	Sample 2:
 	 go run countingSort.go
 	",Go
"/*
 Bulb Swither problem
 
 There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.
 On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb.
 For the nth round, you only toggle the last bulb.
 
 Return the number of bulbs that are on after n rounds.
 
 Link to problem: https://leetcode.com/problems/bulb-switcher/
 */
 
 #include<stdio.h>
 
 int bulbSwitch(int n) {
 	int bulb = 1, ans = 0;
 	//A bulb is ON if it is toggled odd times
 	while (bulb * bulb <= n) {
 		ans++;
 		bulb++;
 	}
 	return ans;
 }
 
 int main() {
 	int n;
 	printf(""Enter the no. of bulbs: \n"");
 	scanf(""%d"", &n);
 	printf(""%d \n"", bulbSwitch(n));
 	return 0;
 }
 
 /*
  Sample Input:
  Enter the no. of bulbs:
  4
  Output:
  2
  Time complexity: O(n)
  Space complexity: O(1)
  */
",C
"/*
 Perfect number is a number which is equal to the sum of its divisors except the number itself
 For example consider 6 
 Divisors of 6 are 1, 2, 3
 Sum of divisors = 1 + 2 + 3 = 6.
 */
 
 import 'dart:io';
 
 // Check if number is perfect or no
 bool isPerfect(int number) {
   int sum = 0;
 
   for (int index = 1; index < number; index++) {
     // if number is a factor add it to sum
     if (number % index == 0) {
       sum += index;
     }
   }
 
   if (sum == number) {
     return true;
   }
   return false;
 }
 
 // Main Function, with driver code
 void main() {
   print(""Enter a number:"");
   int input = int.parse(stdin.readLineSync()!);
 
   // Call isPerfect function on input
   if (isPerfect(input)) {
     print(""$input is a perfect number"");
   } else {
     print(""$input is not a perfect number"");
   }
 }
 /**
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 Sample input/output:
 Enter a number:
 6
 6 is a perfect number
 
 Enter a number:
 12
 12 is not a perfect number
 */
 
",Dart
"// C++ Program to Merge two sorted arrays without using extra space 
 /* Given two sorted arrays, say of size m and n respectively
 The merge function will merge these sorted arrays such that the first array has m smallest elements
 and the second array has remaining n elements in a sorted manner.
 We will simultaneously iterate through both the arrays 
 and compare the first element of first array with the last element of second array,
 if element of second array is smaller than element of first array then swap it, 
 otherwise move on to the next element and repeat the previous step.
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 //Function to merge two sorted arrays
 void merge(int arr1[], int arr2[], int n, int m) {
 	//start two pointers, one from first position of arr1 and another from last position of arr2
 	int i=n-1, j=0;
 	//Iterate through every element of arr1 and arr2 and compare elements of the arrays
 	while(i>=0 && j<m){                        
 		if(arr2[j]<arr1[i]){
 	           swap(arr1[i], arr2[j]);
 	        }
 	           i--;
 	           j++;	    
 	}
 	//sort the first array
 	sort(arr1, arr1+n); 
 	//sort the second array
         sort(arr2, arr2+m);                         
 }
 int main() {
         cout<<""Enter the size of the first array : "";
         int n, m, i;
         
         cin >> n;
         cout<<""Enter the size of the second array : "";
         cin >> m;
       
         int arr1[n], arr2[m];
         cout<<""Enter the elements of the first array : "";
         for (i = 0; i < n; i++) {
             cin >> arr1[i];
         }
         cout<<""Enter the elements of the second array : "";
         for (i = 0; i < m; i++) {
             cin >> arr2[i];
         }
 	//call the merge function on both the arrays
         merge(arr1, arr2, n, m);                            
         cout<<""Sorted Array : "";
         for (i = 0; i < n; i++) {
             cout << arr1[i] << "" "";
         }
         for (i = 0; i < m; i++) {
     ",C-Plus-Plus
"/*
 String Rotation
 ---------------
 
 Problem Statement:
 Rotate a given string in specified direction by specified magnitude.
 After each rotation make a note of the first character of the rotated String, After all rotation are performed the 
 accumulated first character as noted previously will form another string, say FIRSTCHARSTRING.
 Check If FIRSTCHARSTRING is an Anagram of any substring of the Original string.
 If yes print ""YES"" otherwise ""NO"".
 Input
 The first line contains the original string s. The second line contains a single integer q. The ith of the next q 
 lines contains character d[i] denoting direction and integer r[i] denoting the magnitude.
 */
 
 #include <string.h>
 #include <iostream>
 #include <algorithm>
 #include <map>
 using namespace std;
 
 // performing left shift operation
 string shiftLeft(string s, int c) 
 {
     return s.substr(c) + s.substr(0, c);
 }
 
 // performing right shift operation
 string shiftRight(string s, int c) 
 {
     return s.substr(c + 1) + s.substr(0, c + 1);
 }
 
 // DRIVER FUNCTION
 int main()
 {
     char str[200], direction;
     int queries, amount;
     // first characters after performing each query is concatenated
     string firstchar = """"; 
     // getting the input string
     cin >> str;            
     cin >> queries;
     for (int query_num = 0; query_num < queries; query_num++)
     {
         // getting the direction and amount
         cin >> direction >> amount; 
         // if direction is left, perform left shift
         if (direction == 'L')       
         {
             firstchar += shiftLeft(str, amount)[0];
         }
         // if direction is right, perform right shift
         else if (direction == 'R') 
         {
             firstchar += shiftRight(str, amount)[0];
         }
     }
     map<char, int> mp1, mp2;
     for (auto &i : firstchar)
         // storing occurrence of characters in firstchar in map
         mp1[i]++; 
     unsigned i = 0, d = firstchar.size();
     //",C-Plus-Plus
"/* 
 Selection Sort implementation in Dart
 In this algorithm array is sorted by repeatedly finding the minimum element 
 from unsorted part of the array and putting it at the beginning. 
 */
 
 import 'dart:io';
 
 void Selection_Sort(List arr, int n) {
   for (int i = 0; i < n - 1; i++) {
     for (int j = i + 1; j < n; j++) {
       if (arr[j] < arr[i]) {
         // Swapping the elements
         int temp = arr[j];
         arr[j] = arr[i];
         arr[i] = temp;
       }
     }
   }
 }
 
 main() {
   var array = [];
 
   var n, ele;
   print('Enter the number of elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter value for element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
 
   Selection_Sort(array, n);
   print('The sorted array is $array');
 }
 
 /*
 
 TIME COMPLEXITY: O(n^2)
 
 SPACE COMPLEXITY: O(1)
 
 
 Sample Input/Output:
 
 Enter the number of elements: 
 6
 Enter value for element 1: 
 89
 Enter value for element 2: 
 45
 Enter value for element 3: 
 12
 Enter value for element 4: 
 34
 Enter value for element 5: 
 1
 Enter value for element 6: 
 9
 The sorted array is [1, 9, 12, 34, 45, 89]
 
 */
",Dart
"/* You are given a 10*10 2-D array(arr) containing only '+' and '-' characters, which represents a crossword puzzle. 
 You are also given n number of words which need to be filled into the crossword. 
 Cells containing '-' are to be filled with the given words. */
 
 import java.util.*;
 
 public class Crossword_puzzle {
     public static void main(String[] args) throws Exception {
         // User input
         Scanner scn = new Scanner(System.in);
         char[][] arr = new char[10][10];
 
         System.out.println(""\nEnter the crossword puzzle: "");
 
         // filling the crossword board array
         for (int i = 0; i < arr.length; i++) {
             String str = scn.next();
             arr[i] = str.toCharArray();
         }
 
         // total number of words
         System.out.println(""\nEnter the total words: "");
         int n = scn.nextInt();
 
         // storing words in array from input stream
         System.out.println(""\nEnter the words: "");
         String[] words = new String[n];
         for (int i = 0; i < words.length; i++) {
             words[i] = scn.next();
         }
 
         System.out.println();
 
         // invoking function to solve the crossword puzzle.
         solvePuzzle(arr, words, 0);
 
         // closing input stream
         scn.close();
     }
 
     // Global count to keep track of number of configurations
     static int count = 0;
 
     // function to display the solution on the console
     public static void display(char[][] arr) {
         // configuration number
         System.out.print(count + ""."");
 
         for (int i = 0; i < arr.length; i++) {
             if(i>0) {
                 System.out.print("" "" + ""\t"");
             }
             else {
                 System.out.print(""\t"");
             }
 
             for (int j = 0; j < arr[0].length; j++) {
                 System.out.print(arr[i][j] + "" "");
             }
             System.out.println();
         }
         System.out.println();
",Java
"/**
 Given an array of positive and negative elements.
 We have to check if there exists a subarray whose
 sum is equal to 0 or not.
  */
 
 import java.util.HashMap;
 import java.util.Scanner;
 
 public class SubarraySumZero {
 
     public static void main(String[] args) {
 		
 		Scanner sc=new Scanner(System.in);
 		
 		System.out.print (""Enter size of array - "");
 		int n=sc.nextInt();
 		
 		int[] ar=new int[n];
 		System.out.println(""Enter elements in array - "");
 		for (int i=0; i<n; i++) {
 			ar[i]=sc.nextInt();
 		}
 		
 		// the ith index of sumArray will store
 		// sum from 0th index to ith index.
 		int[] sumArray=new int[n];
 		int sum=0;
 		
 		// Map will keep track of the sums that we calculate
 		HashMap<Integer, Boolean> map=new HashMap<Integer, Boolean>();
 
 		boolean flag=false;
 		
 		for (int i=0; i<n; i++) {
 			sumArray[i]=sum + ar[i];
 			sum=sumArray[i];
 			
 			if (sum==0 || map.containsKey(sumArray[i])) {
 				flag=true;
 				break;
 			} else {
 				map.put(sumArray[i], true);
 			}
 		}
 		
 		if (flag) {
 			System.out.println(""Subarray with sum=0 is present"");
 		} else {
 			System.out.println(""Subarray with sum=0 is not present"");
 		}
 	}
 }
 
 /*
 Time Complexity : O(n)
 Space Complexity : O(n)
 
 Input 1 :
 
 Enter size of array - 9
 Enter elements in array - 
 1 3 -5 2 8 9 -11 6 4
 
 Output 1 :
 
 Subarray with sum=0 is present
 
 Input 2 :
 
 Enter size of array - 6
 Enter elements in array - 
 4 2 6 -7 5 1
 
 Output 2 :
 
 Subarray with sum=0 is not present
 */
 
",Java
"import java.util.List;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.ListIterator;
 import java.util.Scanner;
 
 /**
  * <h1>Columnar</h1>
  * <p>
  * Columnar class acts as a custom Data Structure which consits of a List of Characters.
  * </p>
  */
 class Columnar
 {
     List<Character> characterList;
 }
 
 /**
  * <h1>Simple Columnar Transposition Cipher</h1>
  * <p>
  * To Implement Simple Columnar Transposition Cipher
  * </p>
  * <b>Description</b>
  * <p>
  * class SimpleColumnarTranspositionCipher is used to encrypt plainText to cipherText using Columnar Transposition and
  * decrypt cipherText to plainText using the respective algorithm, Simple Columnar Transposition is a variation of
  * Transposition technique just like Rail Fence Cipher
  * </p>
  * <b>Requirements</b>
  * <p>
  * A string plain text and a string key are required for encryption and for decryption the cipher text which is
  * calculated from the given key and the key itself.
  * </p>
  */
 public class SimpleColumnarTranspositionCipher
 {
     /**
      * <p>
      * This is a private method used to validate the key provided by the user.
      * </p>
      * <b>Validation Scheme</b>
      * <p>
      * There must be NO occurance of repetative characters in a string, occurance of repetative characters can lead to
      * malfunctioning of the code and algorithm leading to mismatched output.
      * </p>
      * <p>
      * Thou same letters with different cases(UpperCase and LowerCase) can be accepted.
      * </p>
      * <p>
      * Example: AaZ can be a valid key, but AAZ will not be considered as a valid key.
      * </p>
      * 
      * @param key This is a String parameter to validateKey method, this signifies key which is passed to perform encryption
      *            and decryption.
      * 
      * @return Boolean Tells whether the key entred is a valid key or not
      */
     private Boolean validateKey(String key)
     {
         for (int i = 0; i ",Java
"/*Problem Statement- Cpp program to implement Two stacks using a single array. The operations push and pop is to be performed on two stacks and this should be done in one array. 
 
 Approach- Top of first stack will start from index 0 of the array and move towards right of the array as more elements are pushed into stack 1. Top of second stack will start from the end of the array(size-1) and stack 2 will grow in left direction when elements are pushed into it.
 when both the stacks meet each other(top of first stack = top of second stack-1) we cannot push any element in both stacks.
 */
 
 #include <iostream>
 #define size 20
 
 using namespace std;
 
 int array[size];
 int top1 = -1;
 int top2 = size;
 
 /*Function to push element in stack 1*/
 void push_in_stack1(int data){
 	if(top1 < top2-1){
 		array[++top1] = data;
 		cout<<data<<"" pushed onto stack 1""<<endl;
 	}
 	/*when the value of top1 = top2-1, the array is completely used up and we cannot push more elements in it.*/
 	else{
 		cout<<""Stack Overflow!""<<endl;
 	}
 }
 
 /*Function to push element in stack 2*/
 void push_in_stack2(int data){
 	if(top1 < top2-1){
   		array[--top2] = data;
   		cout<<data<<"" pushed onto stack 2""<<endl;
 	}
 	else{
 		cout<<""Stack Overflow!""<<endl;
 	}
 }
 
 /*Function to pop an element in stack 1*/
 void pop_from_stack1(){
 	if(top1 > -1){
 		int popped_data = array[top1];
 		top1--;
 		cout<<popped_data<<"" popped from stack 1""<<endl;
 	}
 	/*when the value of top is -1, there is no element present in the stack, hence pop operation cannot be performed.*/
 	else{
 		cout<<""Stack 1 is Empty!""<<endl;
 	}
 }
 
 /*Function to pop an element in stack 2*/
 void pop_from_stack2(){
 	if(top2 < size){
 		int popped_data = array[top2];
 		top2++;
 		cout<<popped_data<<"" popped from stack 2""<<endl;
 	}
 	else{
 		cout<<""Stack 2 is Empty!""<<endl;
 	}
 }
 
 /*Function to display all the elements in stack 1*/
 void display_stack1(){
 	cout<<""Displaying elements in Stack 1""<<endl;
 	for(int ",C-Plus-Plus
"/* Below code is an implementation of Vigenere Cipher in golang.
 It is a form of substitution cipher. Given a plaintext and a key.
 If the length of key is smaller than that of plaintext, then we 
 repeat the contents of the key in a circular fashion till both of
 their lengths is same. Plaintext and key are converted to number 
 [0-25] and then each character of plaintext is shifted by character
 present at the same index in the key to form the encrypted message.*/
 
 package main
 
 import (
 	""fmt""
 	""strings""
 	""unicode""
 )
 
 /*This method generates the key if the length of key
 is shorter than the length of the plaintext.*/
 func keygen(key string, length int) string {
 
 	if(len(key) < length) {
 		var pad string
 		for j := 0; j < len(key) ; j++ {
 			pad += string(key[j])
 		}
 		/*In a circular fashion, we add the contents
 		of the key from front to the end, till the
 		length of the key becomes equal to the length
 		of the plaintext.*/
 		for i := 0; i < (length - len(key)); i++ {
 			pad += string(key[i % len(key)])
 		}
 		return pad
 	}
 	// Return the final key to be used
 	return key
 }
 
 // This is the encryption function
 func encrypt(plaintext, key string) string {
 
 	/* Calling the above function to ensure that
 	the length of the key is same as length of
 	the plaintext*/
 	var pad string = keygen(key, len(plaintext))
 	var encrypted string
 
 	// Shifting the plaintext to generate the ciphertext
 	for i := 0; i < len(plaintext); i++ {
 		var temp int = (int(plaintext[i]) - 97 + int(pad[i]) - 97) % 26
 		temp = temp + 97
 		encrypted += string(temp)
 	}
 	// Returns the ciphertext
 	return encrypted
 }
 
 /* This method formats the ciphertext according to
 the plaintext. From the encrypt function above, we
 send plaintext in lowercase. So, the ciphertext we
 get is also in all lowercase. Here, we format the
 ciphertext so that wherever there is capital letter
 in the plaintext, same follows in the ciphertext.*/
 func format(plaintext, ciphe",Go
"""""""
 Purpose: To check wether it is possible for a Knight to visit each
          cell of the N*N chessboard without visiting any cell
          twice starting from (X, Y) position.
          
 Problem Link:- https://en.wikipedia.org/wiki/Knight%27s_tour
 Visualization:- https://github.com/karan236/Algorithm-Visualizer
 
 Method: Backtracking Algorithm
 Intution: To visit each and every positions which are available from
           the current position and recursively repeat this until
           all the cells are covered
 Worst-Case Time Complexity:  O(8^N)
 Space Complexity: O(N^2)
 
 Argument: Tupple (Current Position)
 Return  : 2d Matrix (Steps of the Knight)
 
 Note: Backtracking approch for Knight's Tour Problem is very slow
         hence use smaller number (<8) for fast result
 """"""
 
 from time import time
 
 
 def move_Knight(n, pos, move, ans, step):
     x, y = pos
 
     # Base Case
     if step == n * n:
         return ans
     for i in move:
         r = x + i[0]
         c = y + i[1]
         if 0 <= r < n and 0 <= c < n and not ans[r][c]:
             ans[r][c] = step + 1
             temp = move_Knight(n, (r, c), move, ans, step + 1)
             if temp is not False:
                 return temp
             ans[r][c] = 0
     return False
 
 
 def Knight_Tour(n, pos):
     x, y = pos
 
     # All valid moves that a Knight can make
     move = [[2, 1], [2, -1], [-2, 1], [-2, -1],
             [1, 2], [1, -2], [-1, 2], [-1, -2]]
 
     # To keep a track of already visited cells and
     # Answer Matrix
     answer = [[0]*n for i in range(n)]
 
     # To mark (X, Y) cell as visited
     answer[x][y] = 1
 
     return move_Knight(n, pos, move, answer, 1)
 
 
 # ------------------------DRIVER CODE ------------------------
 
 if __name__ == ""__main__"":
 
     # Input the initial Position of the Knight
     N = int(input(""Enter the size of the Chessboard: ""))
     X, Y = map(int, input(""Enter Initial Position of the Knight: "").split())
     start = tim",Python
"//Lomuto partition of quick sort 
 //This is similar to the implementation of QuickSort
 //The difference is that once we select the last element as the pivot
 //we need to keep adjusting its position by sorting and swapping the elements in memory.
 import java.util.Scanner;
 public class Main
 {
 	public static void main(String[]args)
     
 {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter size of the array:"");
         int n =sc.nextInt();
         int[] ar = new int[n];
         System.out.println(""Enter array elements:"");
         for(int i=0;i<n;i++)
         {
             ar[i] =sc.nextInt();
         }
         System.out.println(""The array before sorting is:"");
         for(int i=0;i<n;i++)
         {
             System.out.print(ar[i]+"" "");
         }
         quickSort(ar, 0, ar.length-1);
         System.out.println(""\n"");
         System.out.println(""The Sorted array is:"");
         for(int i=0;i<n;i++)
         {
             System.out.print(ar[i]+"" "");
             
         }
     }
 	
 public static void quickSort(int[] ar, int low, int high)
 {
     if(low<high)
     {
         int p =partition(ar, low, high);
         // from the above function the pivot is choosen 
         //and the quicksort function is called  as two parts
         //from 0 to p-1 and other is p+1 to the higher end
         //from 0 to p-1 and other is p+1 to the higher end limit of the array
         quickSort(ar, 0, p-1);
         quickSort(ar, p+1, high);
     }
 @@ -54,7 +54,7 @@ public static int partition(int[] ar, int l, int r)
     int i =l;
     for(int j=l;j<r;j++)
     {
         //swapping is done on comparing woth the pivot element
         //swapping is done on comparing with the pivot element
         if(ar[j] <=pivot)
             {
             int t =ar[j];
             ar[j] =ar[i];
             ar[i] =t;
             i++;
             } 
     }
     int t =ar[i];
     ar[i] =ar[r];
     ar[r] =t;
     return i;
 }
 }
 //T",Java
"""""""
 Purpose: To determine whether a given array of numbers can be divided
         into to sets of equal sum or not.
         Example: 6 3 11 2
         Output:  Yes ((6,3,2) and (11))
 
 Method: Dynamic Programing
 Intution: The problem can be solved using dynamic programming when the
         sum of the elements is not too big. We can create a 2D array part[][]
         of size (sum/2 + 1)*(n+1).And we can construct the solution in a
         bottom-up manner such that every filled entry has the following property.
 
         DP[i][j] = True if a subset of {arr[0], arr[1], ..arr[j-1]} has sum
              equal to i, otherwise false
 Reference: https://www.geeksforgeeks.org/partition-problem-dp-18/
 
 Time Complecity:  O(sum * N)
 Space Complexity: O(sum * N)
 
 Argument: List
 Return  : Boolean
 
 """"""
 
 
 def Partition_Problem(n, arr):
 
     # Calculate the sum of the each element in the array
     s = sum(arr)
 
     # Base Case: if the sum is odd, return false
     if s % 2:
         return False
 
     DP = [[True] * (n + 1) for j in range(s // 2 + 1)]
 
     # Initilize the leftmost col to False
     for i in range(1, s // 2 + 1):
         DP[i][0] = True
 
     # Construct the DP table
     for row in range(1, s // 2 + 1):
 
         for col in range(1, n + 1):
             DP[row][col] = DP[row][col - 1]
 
             if row >= arr[col - 1]:
                 DP[row][col] = DP[row][col] or DP[row - 1][col - 1]
 
     # Return the last element of the table
     return DP[-1][-1]
 
 
 # ------------------------DRIVER CODE ------------------------
 
 if __name__ == ""__main__"":
 
     # Input the array form the user
     a = list(map(int, input(""Enter the array elements: "").split()))
     n = len(a)
 
     ans = Partition_Problem(n, a)
 
     if ans:
         print(""Yes"")
     else:
         print(""No"")
 
 """"""
 
 Sample Input / Output
 
 Enter the array elements: 6 3 11 2
 Yes
 
 
 Enter the array elements: 1 3 4 14 6
 Yes
 
 
 Enter the array elements: 1 2",Python
"# Julia program to find the number of bits to be flipped to convert one number to another
 
 """"""Inorder to compare the individual bits of given the numbers, we can compute the number of
 set bits in thier XOR, as we know that XOR operation yields set bits, only when two same
 bits are XORed.""""""
 function get_num_flips(n1, n2)
     count = 0
     n = n1  n2
     while(n != 0)
         if(n & 1 == 1)
             count = count + 1
         end
         n = n >> 1
     end
     return count
 end
 
 
 print(""Enter the first number:"")
 n1 = readline()
 n1 = parse(Int32, n1)
 print(""Enter the second number:"")
 n2 = readline()
 n2 = parse(Int32, n2)
 res = get_num_flips(n1, n2)
 print(""Number of flips required to inter-convert the given numbers is: $res"")
 
 """"""
 Time Complexity: O(log(n)), where n is the greater of the input number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the first number:13
 Enter the second number:26
 Number of flips required to inter-convert the given numbers is: 4
 """"""
",Julia
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""# STARTUP PROFIT PREDICTION""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Link to the Dataset: [Startup Details](https://www.kaggle.com/sonalisingh1411/startup50)""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Importing Libraries""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""import pandas as pd\n"",
     ""import numpy as np\n"",
     ""import seaborn as sb\n"",
     ""from sklearn import preprocessing \n"",
     ""from scipy import stats\n"",
     ""from statsmodels.stats.outliers_influence import variance_inflation_factor\n"",
     ""import matplotlib.pyplot as plt\n"",
     ""from sklearn.model_selection import train_test_split\n"",
     ""from sklearn.tree import DecisionTreeRegressor""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""### Getting our Data""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {},
    ""outputs"": [
     {
      ""data"": {
       ""text/html"": [
        ""<div>\n"",
        ""<style scoped>\n"",
        ""    .dataframe tbody tr th:only-of-type {\n"",
        ""        vertical-align: middle;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe tbody tr th {\n"",
        ""        vertical-align: top;\n"",
        ""    }\n"",
        ""\n"",
        ""    .dataframe thead th {\n"",
        ""        text-align: right;\n"",
        ""    }\n"",
        ""</style>\n"",
        ""<table border=\""1\"" class=\""dataframe\"">\n"",
        ""  <thead>\n"",
        ""    <tr style=\""text-align: right;\"">\n"",
        ""      <th></th>\n"",
        ""      <th>R&amp;D Spend</th>\n"",
        ""      <th>Administration</th>\n"",
        ""      <th>Marketing Spend</th>\n"",
        ""      <th>State</th>\n"",
        ""      <th>Profit</th>\n"",
        ""    </tr",Python
"/*
 Description:
 
 Implementation of Right side view of Binary Tree
 
 The Right view contains all nodes that are last nodes in their levels. A simple solution 
 is to do level order traversal and print the last node in every level.
 */
 
 // Java Code -->
 
 import java.util.*;
 
 class Node
 {
     int key;
     Node left = null, right = null;
 
     Node(int key) {
         this.key = key;
     }
 }
 
 public class Right_Side_View_Of_BinaryTree{
 
 	public static Scanner sc=new Scanner(System.in);
 
 	public static Node BuildTree(){
 
 	//user inputs the values in preorder and enters -1 to denote a null node
 	int d=sc.nextInt();
 
 	if(d == -1)
 		return null;
 
 	//A new node created with value d
 	Node root = new Node(d);
 
 	//Recursive call to the left and right child of the root
 	root.left = BuildTree();
 	root.right = BuildTree();
 
 	return root;
 }
 
     public static void printRightView(Node root)
     {
         // return if the tree is empty
         if (root == null) {
             return;
         }
 
         // create an empty queue and enqueue the root node
         Queue<Node> queue = new ArrayDeque<>();
         queue.add(root);
 
         // to store the current node
         Node curr = null;
 
         // loop till queue is empty
         while (!queue.isEmpty())
         {
             // calculate the total number of nodes at the current level
             int size = queue.size();
             int i = 0;
 
             // process every node of the current level and enqueue their
             // non-empty right and right child
             while (i++ < size)
             {
                 curr = queue.poll();
 
                 // if this is the last node of the current level, print it
                 if (i == size) {
                     System.out.print(curr.key + "" "");
                 }
 
                 if (curr.left != null) {
                     queue.add(curr.left);
                 }
 
                 if (curr.right != null",Java
"/* Below checks checks if a number is a mystery number.
 Mystery number - A number that can be represented by sum
 of two numbers, such that the two numbers are reverse of
 each other.*/
 
 package main
 
 import (
 	""fmt""
 	""strconv""
 )
 
 /* This function takes a number as a input and returns
 a number with the digits reversed*/
 func rev(number int) int {
 
 	var reverse string
 	for number > 0 {
 		/* The number is broken into pieces by taking mod 10.
 		Each digit is converted to string and concatenated.*/
 		str := strconv.Itoa(number % 10)
 		reverse += str
 		number = number / 10
 	}
 	// Finally the reversed string is converted back to integer
 	revs, err := strconv.Atoi(reverse)
 	if(err == nil) {
 		// If there were no errors we return the number
 		return revs
 	}
 	return -1
 }
 
 // This function checks if the number is a mystery number
 func mystery(number int) int {
 
 	// We iterate till the middle of the number
 	var distance int = number / 2
 	for i:= 1; i <= distance; i++ {
 		// Check the sum of number with its reverse
 		if(i + rev(i) == number) {
 			// If its is equal to the given number we return and print
 			fmt.Print(""\nThe two digits are: "", i, "" "", rev(i))
 			return 1
 		}
 	}
 	// Else return -1
 	return -1
 }
 
 func main() {
 
 	// Taking number as input from the user
 	fmt.Print(""Enter a number to check if it's a mystery number: "")
 	var number int
 	fmt.Scan(&number)
 
 	// Calling the mystery function
 	var result int = mystery(number)
 
 	// If the result is 1, the number is a mystery number
 	if(result == 1) {
 		fmt.Print(""\nThe number "", number, "" is a mystery number.\n"")
 	} else {
 		// Else it is not a mystery number
 		fmt.Print(""\nThe number "", number, "" is not a mystery number.\n"")
 	}
 }
 
 /* Sample I/O:
 
 Enter a number to check if it's a mystery number: 33
 
 The two digits are: 12 21
 The number 33 is a mystery number.
 
 */
",Go
"/*
 Finding duplicate elements:
 
 Some integral elements are taken in input, which may occur once or twice, the repeated 
 element is considered as duplicate and this code prints the repeated elements in output.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void find_duplicate_elements(int *arr,int n)
 {
     cout<< ""Enter again the total number of integral elements:""<<endl;
     cin>>n;
     for(int i=0;i<n;i++)
     {
         for(int j=i+1;j<n;j++)
         {
             int x=arr[i]^arr[j];
             if (x==0)
             {
                 cout<< ""Repeated Element = ""<<arr[i]<<endl;
             }
         }
     }  
 }
 int main()
 {
     int n;
     cout<< ""Enter total number of integral elements:""<<endl;
     cin>>n;
     int arr[n];
     cout<<""Enter the integral elements:""<<endl;
     for(int i=0;i<n;i++)
     {
         cin>>arr[i];
     }
     find_duplicate_elements((int*)arr,n);
     
     return 0;
 }
 
 /*
 Sample Input:
 Enter total number of integral elements:
 10
 Enter the integral elements:
 1 5 6 4 5 4 1 2 3 2
 
 Sample Output:
 Repeated Element = 1
 Repeated Element = 5
 Repeated Element = 4
 Repeated Element = 2
 
 Time Complexity - O(n^2)
 Space Complexity - O(n^2)
 
 */
 
",C-Plus-Plus
"/*
 Introduction 
 Any binary tree can be represented using multiple traversal techniques.One of them is level order traversal.
 In this traversal, we print the nodes of a tree,level by level,one after another.
 This could be implemented using recursion or queue data structure.
 Here,this code is based on recursion.
 There are basically two functions in this code.One prints all nodes at a given level and the other
 prints level order traversal considering the subtrees individually.
 At the end,it prints the level order traversal of the given binary tree.
 */
 import java.util.*;
 class Node
 {
     int data;
     Node left;
     Node right;
     public Node(int item)
     {
         data = item;
         left = right = null;
     }
 }
 class BinaryTree
 {
     Node root;
     public BinaryTree()
 	{
 		root = null;
 	}
     int height(Node root)
 	{
 		if (root == null)
 		return 0;
 		else
 		{
 			/* calculate height of each subtree individually */
 			int lh = height(root.left);
 			int rh = height(root.right);
 			
 			/* the height is the maximum path,theefore,return the larger one */
 			if (lh > rh) return(lh+1);
 			else return(rh+1);
 		}
 	}
     void printLevel (Node root ,int level)
 	{
         /* if root is null,then the root is the last node,therefore,we end here */
 		if (root == null)
 			return;
 
         /* if it is the first level,then print the data */
 		if (level == 1)
 			System.out.print(root.data + "" "");
 
         /* if the level is not 1, print the left and right subtree individually */
 		else if (level > 1)
 		{
 			printLevel(root.left, level-1);
 			printLevel(root.right, level-1);
 		}
 
 	}
     void LevelOrderTraversal(Node root)
 	{
         /* calculate the height of the tree */
 		int h = height(root);
 		int i;
 
         /* traverse till the height */
 		for (i=1; i<=h; i++)
 			printLevel(root, i);
 	}
     public Node insert(Node root, int data) 
     {
         if(root == null) {
             return new Node(data);
       ",Java
"/*
 Q Kth largest element 
 
 Given an array a[] and a number K where K is smaller than size of array, 
 the task is to find the Kth largest element in the given array.
 It is given that all array elements are distinct. */
 
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //find the kth largest Element
 void kthLargestElement(int a[], int size, int k){
 
     priority_queue <int, vector<int>, greater<int>> minHeap;
     
     for(int i = 0; i < size; i++){
         minHeap.push(a[i]);
         
         if(minHeap.size() > k){
             minHeap.pop();
         }
     }
     cout<< ""Kth largest element in the array is: ""<< minHeap.top();
 }
 
 int main()
 {
     int size, k; 
     
     cout << ""Enter the size of an Array : "";
     cin >> size;
 
     cout << ""Enter the value of k : "";
     cin>> k;
 
     cout<< ""Enter the elements of the array: "" << endl;
     
     int a[size];
     
 
     for (int i = 0; i < size; i++){
         cin >> a[i];
     }
 
     kthLargestElement(a,size,k);  
     
     return 0;
 }
 
 /*
 Input 
 Enter the size of an Array : 7                                                                                                                
 Enter the value of k : 3                                                                                                                      
 Enter the elements of the array:                                                                                                              
 7 5 9 8 6 4 10      
 
 Output
 Kth largest element in the array is: 8
 
 Space complexity => O(k)
 Time complexity => O(nlogk)
 */",C-Plus-Plus
"/*
 Construct a binary tree using inorder and preorder.
 
 Given preorder and inorder traversal of a tree, construct the binary tree.
 Problem link: https://www.interviewbit.com/problems/construct-binary-tree-from-inorder-and-preorder/
 e.g.
 Input :
 Preorder : [1, 2, 3]
 Inorder : [2, 1, 3]
 
         Return :
                     1
                    / \
                   2   3
 (To verify the tree I will print its PostOrder traversal i.e [2, 3, 1].)
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 // structure to define the tree
 struct TreeRoot
 {
     // data varible of type int to store the integer data in the node.
     int data;
     // left pointer of the same type as of node to point at left subtree of the node.
     struct TreeRoot *left;
     // right pointer of the same type as of node to point at right subtree of the node.
     struct TreeRoot *right;
     // constructor to initialize/ create the node.
     TreeRoot(int x)
     {
         data = x;
         left = NULL;
         right = NULL;
     }
 };
 
 void postorder(TreeRoot *root)
 {
     if (root == NULL)
     {
         return;
     }
     postorder(root->left);
     postorder(root->right);
     cout << root->data << "" "";
 }
 
 TreeRoot *buildTree(vector<int> &preorder, vector<int> &inorder, int start, int end)
 {
     // a static variable to keep the track of preorder vector.
     static int index = 0;
     if (start > end)
         return NULL;
     // to store the value at given index in preorder vector.
     int current = preorder[index];
     // after storing the value increment the index.
     index++;
     // creating the node of the current element.
     TreeRoot *node = new TreeRoot(current);
     // a varible to find the position of the element in the inorder vector.
     if (start == end)
         return node;
     int position;
     for (int i = start; i <= end; i++)
     {
         if (inorder[i] == current)
             position = i;
     }
     // creating the left sub-t",C-Plus-Plus
"/*
 Given an array of N elements, each element's occurrence in the array can be more than once.
 Find all elements whose occurrence is more than 1.
 Formally find all duplicate elements of the array.
 */
 
 #include <stdio.h>
 #include <string.h>
 
 //From this dupicate_elements function we will print duplicate elements of the array
 void dupicate_elements(int ar[] ,int N)
 {
     /* we will insert the array elements into visited array. if current element already
     in the visited array
     then definitely that element's occurrence is more than 1.
     Hence it is duplicate and will print it*/
     printf(""Duplicate elements are : \n"");
     int i = 0;
     int visited_array[N + 1];
     memset(visited_array, 0, sizeof(visited_array));
     for(i = 0; i < N; i++)
     {
         if(visited_array[ar[i]] != 0)
         {
             // this element is duplicate
             printf(""%d "", ar[i]);
         }
         if(visited_array[ar[i]] == 0)
         {
             visited_array[ar[i]]++;
         }
     }
     return;
 }
 
 int main()
 {
     printf(""Enter the size of the array : "");
     int N;
     scanf(""%d"", &N);
     int ar[N + 1];
     printf(""Enter array elements :\n"");
     for(int i = 0; i < N; i++)
     {
         scanf(""%d"", &ar[i]);
     }
     dupicate_elements(ar , N);
 }
 
 /*
 Standard Input and Output
 
 Enter the size of the array : 7
 Enter array elements :
 1 2 4 5 5 7 8
 Duplicate elements are :
 5 8
 
 Time Complexity : O(N)
 Space Complexity : O(N)
 
 */
",C
"""""""Julia program to implement Maximum Sum Increasing Subsequence
 In this problem, given an array we have to find the maximum sum an increasing subsequence of that array can make.
 This problem is a slight modification to the Longest Increasing subsequence problem.
 The problem can be solved using Dynamic Programming
 """"""
 
 
 function maximum_sum_increasing_subsequence(arr, n)
     max_sum = 0
     dp = Int[]
 
     # Initialize the dp array with the array values, as the maximum sum 
     # at each point is atleast as the value at that point  
     for i in 1:n
         push!(dp, arr[i])
     end
 
     for i in 1:n
         for j in 1:(i-1)
             if(arr[i] > arr[j] && dp[i] < dp[j] + arr[i])
                 dp[i] = dp[j] + arr[i]
             end
         end
     end
 
     # Now Find the maximum element in the dp array 
     max_sum = findmax(dp)[1]
     return max_sum
 
 end
 
 
 print(""What is the length of the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""No numbers present in the array!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 res = maximum_sum_increasing_subsequence(arr, n)
 print(""The maximum sum of an  increasing subsequence of the given array is $res"")
 
 
 """"""
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 10
 Enter the numbers: 23 14 5 84 24 222 321 43 123 432 
 The maximum sum of an increasing subsequence of the given array is 1082
 
 SAMPLE 2
 
 What is the length of the array? 5
 Enter the numbers: 5 4 3 2 1
 The maximum sum of an increasing subsequence of the given array is 5
 
 """"""
",Julia
"'''
 Count pairs with given sum
 Given an array of integers, and a number sum find the number of pairs of integers in the array whose sum is equal to sum.
 Examples:
  Input  :  arr[] = {1, 5, 7, -1},
            k = 6
  Output :  2
  Pairs with sum 6 are (1, 5) and (7, -1)
 
 
  Input  :  arr[] = {1, 1, 1, 1}
            k = 2
  Output :  6
  There are 3! pairs with sum 2.
 
 '''
 def Count_pairs_with_given_sum(arr,k):
     import collections
     hashmap = collections.defaultdict(int) #this will help to find distinct values 
     for val in arr:
         #length of distinct values 
         hashmap[val] += 1  
     res = 0 
     for num in arr:
         num_2 = k- num
         if num_2 in hashmap: 
             res += hashmap[num_2]
         
         if num_2 == num:  
             res -= 1
      #result        
     return res//2 # for approximate value 
 
 if __name__ == ""__main__"":
     k = int(input(""Enter the  target value: ""))
     arr = list(map(int,input(""Enter the list: "").split()))
     print(""Pairs are "",Count_pairs_with_given_sum(arr,k))
     
 '''
 Time Complexity : O(n)
 Space Complexity : O(1)
 
 INPUT
 
 Enter the value: 6 
 Enter the list: 1 5 7 -1
 
 OUTPUT
 Pairs are 2 
 
 '''
",Python
"/*An integer x is said to be Noble given an array 
 if the number of integers greater than x are equal to x.
 If noble integer is not found output is -1.
 */
 #include <bits/stdc++.h>
 using namespace std;
 int nobleint(int[], int);
 int main()
 {
 	int num, i, x, arr[10000];
 	cout << ""Enter the number of elements:"";
 	cin >> num;
 	cout << ""Enter the elements:"";
 	for (int i = 0; i < num; i++)
 	{
 		cin >> x;
 		arr[i] = x;
 	}
 	cout << nobleint(arr, num);
 	return 0;
 }
 
 // To find the noble integer from the given array
 int nobleint(int arr[], int num)
 {
 	int x = 0, i;
 	sort(arr, arr + num);
 	for (i = 0; i < num - 1; i++)
 	{
 		if (arr[i] == arr[i + 1])
 		{
 			continue;
 		}
 
 		if (arr[i] == num - i - 1)
 		{
 			x = 1;
 			return (num - i - 1);
 			break;
 		}
 	}
 	if (x == 0)
 		return (-1);
 }
 
 /*
 Sample Output
 
 Enter the number of elements:4
 Enter the elements:7 3 9 81
 3
 Enter the number of elements:3
 Enter the elements:2 2 2
 -1
 
 Complexities
 Time Complexity:O(nlogn)
 Space Complexity:O(1)
 */
 
",C-Plus-Plus
"/* Find Common elements in three sorted arrays. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function to Find common elements in three sorted arrays. */
 void solve()
 {
     /* Input n1 = size of array 1
        Input n2 = size of array 2
        Input n3 = size of array 3 */
     int n1,n2,n3;
     cin >> n1 >> n2 >> n3;
 
     int a1[n1],a2[n2],a3[n3];
 
     /* Input values in a1 */
     for (int i = 0; i < n1; ++i)
     {
         cin>>a1[i];
     }
 
     /* Input values in a2 */
     for (int i = 0; i < n2; ++i)
     {
         cin>>a2[i];    }
 
     /* Input values in a1 */
     for (int i = 0; i < n3; ++i)
     {
         cin>>a3[i];
     }
 
     /* Create a unordered_map to store */
     unordered_map<int,int> m1,m2,m3;
 
     for (int i = 0; i < n1; ++i)
     {
         m1[a1[i]]++;
     }
 
     for (int i = 0; i < n2; ++i)
     {
         m2[a2[i]]++;
     }
 
     for (int i = 0; i < n3; ++i)
     {
         m3[a3[i]]++;
     }
 
     vector<int> v;
 
     for (int i = 0; i < n1; ++i)
     {
         /* Check if the element in present in all three
            hashmap so print that element */
         if(m1[a1[i]] & m2[a1[i]] & m3[a1[i]])
         {
             v.push_back(a1[i]);
         }
     }
 
     cout << ""Common element is : "";
     for (int i = 0; i < v.size(); ++i)
     {
         cout << v[i] << "" "";
     }
 }
 
 
 int main()
 {
     solve();
     return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
         
         6 5 8
         1 5 10 20 40 80 
         6 7 20 80 100 
         3 4 15 20 30 70 80 120
 
     Output 1 :
 
         Common elements are : 20 80
 
     Input 2 :
 
         3 5 4
         1 5 5 
         3 4 5 5 10
         5 5 10 20
     
     Output 2 :
     
         Common elements are : 5 5
     
     Time complexity: O(n1+n2+n3)
     Space Complexity: O(n1+n2+n3)
 */
",C-Plus-Plus
"/*
 Tower of Hanoi is a mathematical puzzle where we have three rods and n disks. 
 The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:
 1) Only one disk can be moved at a time.
 2) Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack i.e. a disk can only be moved if it is the uppermost disk on a stack.
 3) No disk may be placed on top of a smaller disk.
 */
 
 import 'dart:io';
 
 void towerOfHanoi (int num, String from,String aux, String to){
   
   // Base case
   if (num == 1){
     print(""Move Disk from Rod-$from to Rod-$to"");
   }
   // Recursive case
   else{
     towerOfHanoi(num-1, from, to, aux);
     towerOfHanoi(1, from, aux, to);
     towerOfHanoi(num-1, aux, from, to);
   }
 }
 
 // Main function with driver function
 void main(){
   // Take user input
   print(""Enter Number of disk:"");
   int num = int.parse(stdin.readLineSync()!);
 
   // Pass to Tower of Hanoi Recurrsive function
   towerOfHanoi(num, 'A','B', 'C');
 }
 
 /**
 Time Complexity: O(2^N)
 Space Complexity: O(N)
 
 Sample input/output:
 
 Enter Number of disk:
 2
 Move Disk from Rod-A -> Rod-B
 Move Disk from Rod-A -> Rod-C
 Move Disk from Rod-B -> Rod-C
 
 Enter Number of disk:
 3
 Move Disk from Rod-A to Rod-C
 Move Disk from Rod-A to Rod-B
 Move Disk from Rod-C to Rod-B
 Move Disk from Rod-A to Rod-C
 Move Disk from Rod-B to Rod-A
 Move Disk from Rod-B to Rod-C
 Move Disk from Rod-A to Rod-C
 
 */
",Dart
"/*
 
 - Phone Keypad Sequence:
     Given a keypad as shown in the diagram, and an n digit number, list all words which are possible by pressing these numbers.
 
 - Example: 
  
     Input number: 23
 
     Output: ad ae af
             bd be bf
             cd ce cf
 
 - Approach :
 
     1. As observed each digit can represent 3 to 4 different alphabets (except 0 and 1)
     2. Map each number with its keypad string equivalent.
     3. Use recrsive function to try all alphabets mapped to the current digit in alphabetic order, and again call the recursive function for the next digit and will pass on the current output string. 
 
 */
 
 import java.util.Arrays;
 import java.util.List;
  
 public class KeypadSequence
 {
     // Top-down recursive function 
     public static void findCombinations(List<List<Character>> keypad,
                                         int[] input, String result, int index)
     {
         // if we have processed every digit of the key, print the result (base case)
         if (index == -1)
         {
             System.out.print(result + "" "");
             return;
         }
  
         // stores the current digit
         int digit = input[index];
  
         // one by one, replace the digit with each character in the corresponding
         // list and recur for the next digit
         for (char c: keypad.get(digit)) {
             findCombinations(keypad, input, c + result, index - 1);
         }
     }
  
     public static void main(String[] args)
     {
         List<List<Character>> keypad = Arrays.asList(
                 // 0 and 1 digit doesn't have any characters associated
                 Arrays.asList(),
                 Arrays.asList(),
                 Arrays.asList( 'a', 'b', 'c' ),
                 Arrays.asList( 'd', 'e', 'f' ),
                 Arrays.asList( 'g', 'h', 'i' ),
                 Arrays.asList( 'j', 'k', 'l' ),
                 Arrays.asList( 'm', 'n', 'o' ),
                 Arrays.asList( 'p', 'q', 'r",Java
"/*
 Median of a stream of running integers
 ======================================
 Print the median of given numbers while keep taking in new numbers
 
 Concept:
 We maintain two heaps - a minHeap and a maxHeap. minHeap contains numbers greater than the current median and
 maxHeap contains numbers less than equal to the current median.
 Note that if the number of elements in both the heaps are equal then median will be equal to the average of the
 topmost elements of the two heaps. If any heap contains more elements than the other heap then its topmost element will
 be the current median. Also note that the maximum difference in the number of elements between the two heaps should always be
 less than equal to 1.
 
 |n(minHeap) - n(maxHeap)|<=1
 
 If we are in a situation where inserting an element causes increase in this difference, then we must transfer an element
 from one heap to other to settle this.
 
 Time Complexity: O(nlogn)
 Space Complexity: O(n)
 */
 
 #include <iostream>
 #include<queue>
 using namespace std;
 
 // Prints median in a running stream of integers
 void getMedian(int a[], int n) {
 	// Declare a maxHeap and a minHeap
 	priority_queue<int> maxHeap;
 	priority_queue<int, vector<int>, greater<int>> minHeap;
 
 	// Push in maxheap
 	maxHeap.push(a[0]);
 
 	// current median
 	// When count of numbers is 1, median is equal to the number itself
 	double curr = a[0];
 	// Print current median
 	cout << curr << "" "";
 
 	//  While numbers are being inputted
 	for (int i = 1; i < n; i++) {
 		int num = a[i];
 		// INSERTION:
 
 		// If num is greater than current median
 		if (num > curr) {
 			// Insert in minHeap
 			// If size of minHeap is more
 			if (minHeap.size() >= maxHeap.size() + 1) {
 				// shift one element from minHeap to maxHeap
 				int num = minHeap.top();
 				minHeap.pop();
 				maxHeap.push(num);
 			}
 			// Insert in minHeap
 			minHeap.push(num);
 		}
 
 		// If num is less than equal to the current median
 		else {
 			// Ins",C-Plus-Plus
"/*
     To find the total amount of water collected, we
     firstly take an input of an array of size n of 
     heights of buildings. After that we will try 
     to find out minimum heights upto which water
     could be stored at that particulat index of building.
     This process has to be done from both left and the 
     right sides. 
     The complexity of the whole process will be O(n)
     where, n stands for total number of buildings in each test-case.
 
 */
 #include<bits/stdc++.h>
 using namespace std;
 
 // Function to return amount of water trapped
 void solve()
 {
     cout<<""Enter number of Buildings: "";
     long long int no_of_buildings;
     //taking input of number of buildings
     cin>>no_of_buildings;
     // Making an array containing heights of buildings
     long long int height[no_of_buildings];
     cout<<""Height of buildings: "";
     for(long long int i=0;i<no_of_buildings;i++){
         
         //Taking input of height of ith-building
         cin>>height[i];
     }
 
     // Making a left and a right array. 
     long long int left_arr[no_of_buildings],right_arr[no_of_buildings];
     left_arr[0]=height[0];
     right_arr[no_of_buildings-1]=height[no_of_buildings-1];
     // Computing subsequent max elements from left sidewards.
     for(long long int i=1;i<no_of_buildings;i++)
     {
         left_arr[i]=max(height[i],left_arr[i-1]);
     }
     // Computing subsequent max elements from right sidewards.
     for(long long int i=no_of_buildings-2;i>=0;i--)
     {
         right_arr[i]=max(right_arr[i+1],height[i]);
     }
     long long int total_water=0;
 
     // To find the amount of water getting collected inbetween the Buildings:
     // We find minimum between the right and the left array at same indices, 
     // Then Subtract the amount of space taken by the building at that particular index.
 
     for(long long int i=0;i<no_of_buildings;i++)
     {
         //Take sum of collected water at each index.
         total_water",C-Plus-Plus
"'''
     Author: Dasu Srinivas
     Description: Calculates the height of the given tree
 '''
 # Binary node creation
 class Node:
     def __init__(self,data):
         self.data=data
         self.left=None
         self.right=None
 
 def height_of_tree(node):
     if node is None:
         return 0
     else:
         left_height = height_of_tree(node.left)
         right_height = height_of_tree(node.right)
 
         # will give the maximum height
         if left_height > right_height:
             return left_height+1
         else:
             return right_height+1
 
 
 
 root_node = Node(1) 
 root_node.left = Node(21) 
 root_node.right = Node(23) 
 root_node.left.left = Node(34) 
 root_node.left.right = Node(35)
 root_node.right.left = Node(37)
 root_node.left.right.left = Node(46)
 
 print(""Height of the given tree is:"", height_of_tree(root_node))",Python
"/*
    This is a simple program in go language to check
    if a given number is an ugly number or not.
    
    An Ugly number is a number whose only prime factors
    are 2, 3 or 5.
 
    Note : 1 is taken as base case and is considered
           as an ugly number
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 /* This function repeatedly divides a give number
     till its divisible by the second number*/
 func divisible(x,y int) int {
 
      var r int
      r = x % y
 
      for r == 0 {
 
          x = x/y
          r = x % y
 
      }
 
      return x
 }
 
 /* This is the function where we check if a given 
    number is an ugly number or not*/
 func uglynumber(n int) int{
 
     // these are the base cases
     if(n == 1 || n==2 || n==3 || n==5 ) {
 
        return 1
 
     }
 
     // checking divisibility by 2 and its multiples
     n = divisible(n,2)
     if(n == 1) {
         return 1
     }
 
     // checking divisibility by 3 and its multiples
     n = divisible(n,3)
     if(n == 1) {
         return 1
     }
 
     // checking divisibility by 5 and its multiples
     n = divisible(n,5)
     if(n == 1) {
         return 1
      }
 
     // if its not divisible by either of them
     return 0
 
 }
 
 // driver function
 func main() {
 
     var number int
     fmt.Print(""Enter the number you want to check for :"")
     // taking the number as input from user
     fmt.Scan(&number)
 
     // validating the input
     if (number <= 0){
 
         fmt.Print(""Enter a valid number!"")
 
     }else {
 
         var checker int
         checker = 0
 
         checker = uglynumber(number)
 
         // checking if the number is ugly number or not
         if( checker == 1 ){
 
              fmt.Print(""The given number is a ugly number!"")
 
         }else {
 
              fmt.Print(""The given number is not an ugly number"")
 
         }
 
     }
 
 }
 
 /*
     Sample I/O :
 
     a) Is Ugly Number :
 
     Enter the number you want to check for :300
     The ",Go
"/*
 One plus to whole
 
 For a given array arr[] of decimal digits, all of which are non-negative numbers.
 The digits are stored such that the most significant is at the head of the list, 
 and each element of the array contaians single digit only.
 It is assumed that none of the numbers have its most significant digit equal to 0.
 Your task is to increment the interger so formed by one and return it.
 */
 
 import java.util.*;
 
 public class OnePlustoWhole
 {
     //function to return the incremented integer
     public int[] onePlus(int arr[], int size)
     {
         for(int i=size-1; i>=0; i--)
         {
             //if element of the array are somethig less than 9 no carray
             if(arr[i]<9)
             {
                 arr[i]++;
                 return arr;
             }
             //else if array element is 9 then we crearw new array
             //with one extra digit to keep carry
             arr[i]=0;
         }
 
         int[] num=new int[size+1];
         num[0]=1;
         
         return num;
     }
 
     //DRIVER METHOD
     public static void main(String[] args)
     {
         Scanner sc = new Scanner(System.in);
 
         //size of array
         System.out.println(""Enter the number of elements of array: "");
         int size = sc.nextInt();
 
         int []arr = new int[size];
         //array elements
         System.out.println(""Enter the elements for array: "");
         for (int i = 0; i < size; i++) {
             arr[i] = sc.nextInt();
         }
 
         System.out.println(""The incremented number is: "");
         int[] res=new OnePlustoWhole().onePlus(arr, size);
         for(int i=0; i<res.length; i++)
         {
             System.out.print(res[i]+"" "");
         }
     }
 }
 
 /*
 EXAMPLE:-
 
 Input--
 Enter the number of elements of array: 5
 Enter the elements for array: [1, 2, 2, 5, 6]
 Output--
 The incremented number is: [1, 2, 2, 5, 7]
 
 TIME COMPLEXCITY --> O(N)
 SPACE COMPLEXITY --> O(N)
 */
",Java
"// C++ program to implement Matrix Addition
 #include <bits/stdc++.h>
 using namespace std;
 void matrix_add(int [][10],int [][10],int [][10],int,int,int,int);
 int main()
 {
     int r1, c1, r2, c2;
     cout << ""Enter the number of rows and columns of the first matrix:  "";
     cin >> r1 >> c1;
     cout << ""Enter the number of rows and columns of the second matrix: "";
     cin >> r2 >> c2;
 
     //If the given matrices differ in thier number of rows and columns, they cannot be added
     if ((r1 != r2) || (c1 != c2))
     {
         cout << ""Given Matrices cannot be added!!!"";
         return 0;
     }
     int A[10][10], B[10][10], C[10][10];
 
     // Input the values of the matrices
     cout << ""Enter the values of the first matrix\n"";
     for (int i = 0; i < r1; i++)
     {
         for (int j = 0; j < c1; j++)
             cin >> A[i][j];
     }
     cout << ""Enter the values of the second matrix\n"";
     for (int i = 0; i < r2; i++)
     {
         for (int j = 0; j < c2; j++)
             cin >> B[i][j];
     }
     matrix_add(C,A,B,r1,r2,c1,c2);
     cout << ""The resultant matrix is:\n"";
     for (int i = 0; i < r2; i++)
     {
         for (int j = 0; j < c2; j++)
             cout << C[i][j] << "" "";
         cout << endl;
     }
     return 0;
 }
 void matrix_add(int C[][10],int A[][10],int B[][10],int r1,int r2,int c1,int c2)
 {
     for (int i = 0; i < r1; i++)
     {
         for (int j = 0; j < c2; j++)
         {
             // Add the corresponding values of both the matrices
             C[i][j] = A[i][j] + B[i][j];
         }
     }
 
 }
 
 /*
 Time Complexity: O(r * c), where 'r' is the number of rows and 'c' is the number of columns 
 Space Complexity: O(r * c)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number of rows and columns of the first matrix:  2 2
 Enter the number of rows and columns of the second matrix:  2 2
 Enter the values of the first matrix
 2 2
 2 2
 Enter the values of the second matrix
 2 2
 2 2
 The resultant matrix is:
 4",C-Plus-Plus
"/* C Program to Remove Duplicates from a Unsorted Linked List
 Without using any Extra Space i.e while finding Duplicates we can't use any Data
 Structure to store values. Then we can use two pointers approach :current and
 runner ,current iterates through the linked list and runner check all subsequent
 nodes for every current and try to find duplicates in the list.
 
 */
 
 #include <malloc.h>
 #include <stdio.h>
 
 // structure of a node in a linked list
 struct Node {
   int value;
   struct Node *next;
 };
 
 struct Node *head = NULL;
 
 // Dynamically generate the node
 struct Node *gen_node(int val) {
   struct Node *newnode;
   newnode = (struct Node *)malloc(sizeof(struct Node));
   if (newnode == NULL) {
     printf(""\nMemory was not allocated"");
     return 0;
   } else {
     newnode->value = val;
     newnode->next = NULL;
     return newnode;
   }
 }
 
 // Insert node at the beginning of the linked list
 void insert_node_first() {
   int val;
   struct Node *newNode, *temp;
   printf(""\nEnter the value for the node:"");
   scanf(""%d"", &val);
   newNode = gen_node(val);
   if (head == NULL) {
     head = newNode;
     head->next = NULL;
   } else {
     temp = head;
     head = newNode;
     head->next = temp;
   }
 }
 
 /*
   Two pointers current and runner is used
   current will iterate through the linked list and runner will
   check all the subsequent nodes for duplicates
 */
 void removeDup() {
   struct Node *cur = head;
   while (cur != NULL) {
     struct Node *runner = cur;
     // Remove all future nodes that have the same value
     while (runner->next != NULL) {
       if (runner->next->value == cur->value) {
         runner->next = runner->next->next;
       } else {
         runner = runner->next;
       }
     }
     cur = cur->next;
   }
 }
 
 // Display the entered list
 void display() {
   struct Node *temp;
   temp = head;
   while (temp != NULL) {
     printf(""%d "", temp->value);
     temp = temp->next;
   }
 }
 
 int main() {
   int",C
"/*
 The Tower of Hanoi is a very famous mathematical problem. You have three rods and n disks. Initially all the n disks are stacked on one rod.
 The task is to take all those disks from one rod to some other rod following these rules:
 1) Only one disk can be moved among the towers at any given time.
 2) There can be no disk mounted on top of a smaller disk.
 3) Only the ""top"" disk can be removed.
 4) A disk can be moved only if it is the stack's uppermost disk.
     
 Program will print the source and destination to transfer each disks for all the steps in chronological order.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void tower_of_hanoi(int n, char from_rod, char aux_rod, char to_rod)
 {
 	/*
 		This function takes the number of disks and the names of the rods.
 		The Idea is to shift one disk from the source to the destination.
 		BUT,if there is already mutiple disk on the source then call the same function to put the extra disk on an auxiliary rod.
 		AND,if there is already mutiple disk on the destination then call the same function to put the extra disk on an auxiliary rod.
 	*/
 
 	if (n == 1)
 		cout << ""Move a rod from the top of "" << from_rod << "" to the top of "" << to_rod << '\n';
 	else
 	{
 		tower_of_hanoi(n - 1, from_rod, to_rod, aux_rod);
 		tower_of_hanoi(1, from_rod, aux_rod, to_rod);
 		tower_of_hanoi(n - 1, aux_rod, from_rod, to_rod);
 	}
 }
 
 int main()
 {
 
 	int n;
 	cin >> n;	// Number of disks			
 	tower_of_hanoi(n, 'A', 'B', 'C');
 
 	return 0;
 }
 
 /* 
  Test Case :
  ******************************************************************
  Input : 2
 
  Output :
     Move a rod from the top of A to the top of B
     Move a rod from the top of A to the top of C
     Move a rod from the top of B to the top of C
 *******************************************************************
  Input : 3
  
  Output : 
 	Move a rod from the top of A to the top of C
 	Move a rod from the top of A to the top of B
 	Move a rod from the top of ",C-Plus-Plus
"import java.util.*;
 public class DutchFlag {
     private static void dutchNationalFlag(int[] array, int size){
         int start = 0 , mid = 0;
         int end = size-1;
 
         while(mid < end){
             switch(array[mid]){
                 case 0:
                     swap(array,start,mid);
                     start++;
                     mid++;
                     break;
                 case 1:
                     mid++;
                     break;
                 case 2:
                     swap(array,mid,end);
                     end--;
                     break;
             }
         }
     }
     private static void swap(int[] array, int i, int j){
         int temp = array[i];
         array[i] = array[j];
         array[j] = temp;
     }
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         int size = sc.nextInt();
         int[] array = new int[size];
         //Input Array:
 
         for(int i = 0; i < size; i++){
             array[i] = sc.nextInt();
         }
 
         dutchNationalFlag(array,size);
         //Output
         System.out.println(""Sorted Array : "");
 
         for(int i = 0; i < size; i++){
             System.out.print(array[i]+"" "");
         }
     }
 }
 //Sample output : 
 // 8 ->size
 // 0 1 2 2 1 1 0 0 -> input array
 //Output : s
 // Sorted Array : 
 // 0 0 0 1 1 1 2 2",Java
"#include <stdio.h>
 
 int painters(int * arr, int maxtime, int len, int num) {
     int time = 0, count = 1;
     for (int i = 0; i < len; i++) {
         time += arr[i];
         if (time > maxtime) {
             time = arr[i];
             count++;
             if (count > num) {
                 return 0;
             }
         }
     }
     return 1;
 }
 
 int get_max(int arr[], int len) {
     int max = arr[0];
     for (int i = 1; i < len; i++) {
 
         if (max < arr[i]) max = arr[i];
     }
     return max;
 }
 
 int main() {
     int len, num, time;
     int sum = 0;
     printf(""Enter the length of array, num of painters and time: "");
     scanf(""%d%d%d"", & len, & num, & time);
 
     int arr[len];
 
     printf(""Enter the array: "");
     for (int i = 0; i < len; i++) {
         scanf(""%d"", & arr[i]);
         sum += arr[i];
     }
 
     // Finding the max of array
     int start = get_max(arr, len);
     int end = sum, ans;
     while (start <= end) {
         int mid = (start + end) / 2;
         if (painters(arr, mid, len, num)) {
             ans = mid;
             end = mid - 1;
         } else {
             start = mid + 1;
         }
     }
     ans = ans * time;
     printf(""Total time taken: %d"", ans);
 
     return 0;
 }
 /*
 Output:
 
 Enter the length of array,num of painters and time: 2 2 5
 Enter the array: 1 10
 Total time taken: 50
 Time complexity : O(n*log(N)) (where N is sum of array elements)
 space complexity : O(n) (n is size of array)
 */
",C
"/*
 Given a string,
 sort it in decreasing order based on the occurrence of each characters.
 then return new string.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // this get_string_sort_characters_by_their_occurrence will give us the new string
 string get_string_sort_characters_by_their_occurrence(string s)
 {
     // we will insert characters into the map
     map < char, int > occur_char;
     for(int i = 0; i < (int)s.size(); i++)
     {
         occur_char[s[i]]++;
     }
     /* multimap can contain duplicate keys. that's why we will use it.
     here multimap's key is the occurrence of each character
     and multimap's value is that particular character.
     greater < int > will store them in descending order.
     */
     multimap < int , char, greater < int > > occur_char_2;
     for(auto i : occur_char)
     {
         occur_char_2.insert( { i.second , i.first } );
     }
 
     string new_string = """";
 
     for(auto i : occur_char_2)
     {
         int freq = i.first;
         while(freq--)
         {
             /* for each occurrence
             we will add particular character to
             our new string
             */
             new_string += i.second;
         }
 
     }
     return new_string;
 }
 
 int main()
 {
     cout << ""Enter the string : "";
     string s;
     cin >> s;
     string new_string = get_string_sort_characters_by_their_occurrence(s);
     cout << ""The New String based on the occurrence of each characters is : \n"";
     cout << new_string << endl;
 }
 
 /*
 Standard Input and Output
 
 Enter the string :
 GMAFGGGMMAF
 
 The New String based on the occurrence of each characters is :
 GGGGMMMAAFF
 
 Time Complexity : O( log N )
 Space Complexity : O( N )
 
 */
",C-Plus-Plus
"/*
 Given a string , remove spaces from it and then return new string. We can solve it By using getline function in C++ and then get a new string.
 */
 #include <bits/stdc++.h>
 using namespace std;
 string new_string(string s)
 {
 
     stringstream s2(s);
     string tem;
 
     // Making the string empty
     s = """";
 
     // Running loop till end of stream
     // and getting every word
     while (getline(s2, tem, ' ')) {
        s += tem;
     }
     return s;
 }
 
 int main()
 {
     cout << ""Enter the string\n"";
     string s;
     getline(cin , s);
     cout << ""After Removing Spaces the New String is : "";
     cout << new_string(s) << endl;
 }
 /*
 
 Standard Input and Output
 
 Input : I am a Open Source Contributor in GSSoC'21
 Output : IamaOpenSourceContributorinGSSoC'21
 
 Time Complexity : O(N) // String size
 Space Complexity : O(N) // an intermediate string
 
 */
",C-Plus-Plus
"/*Implementation of Segment Tree for a problem where
 	we have to find the sum of element from a given range(l,r) 
 and also perform the update operation at particular index/*
 */
 
 public class SegmentTree{
 	
 //	A function for returning the size of the segment Tree
 	public static int sizeOfSegmentTree(int n) {
 		 
 		 int y = (int) (Math.ceil(Math.log(n) / Math.log(2))); 
 		 int size = 2 * (int) Math.pow(2, y) - 1; 
 	  
 	  return size;
 	}
 	
 	
 //	A recursive function for creating a segment tree from a given array	
 	public static void buildTree(int start,int end,int treeIndex,int arr[],int tree[]) {
 
 		if(start==end) {
 			tree[treeIndex]=arr[start];
 			return;
 		}
 		
 		int mid=(start+end)/2;
 		buildTree(start, mid, 2*treeIndex, arr, tree);
 		buildTree(mid+1, end, 2*treeIndex+1, arr, tree);
 		
 		tree[treeIndex]=tree[2*treeIndex]+tree[2*treeIndex+1];
 	}
 	
 	
 //	Function for updating a value at particular index	
 	public static void update(int start,int end,int index,int value,int treeIndex,int arr[],int tree[]) {
 		
 		if(start==end) {
 			arr[start]=value;
 			tree[treeIndex]=value;
 			return;
 		}
 		
 		int mid=(start+end)/2;
 		if(index>mid) {
 //			right side tree
 			update(mid+1, end, index, value, 2*treeIndex+1, arr, tree);
 		}else {
 //			left side tree
 			update(start, mid, index, value, 2*treeIndex, arr, tree);
 		}
 		
 		tree[treeIndex]=tree[2*treeIndex]+tree[2*treeIndex+1];
 	}
 	
 //	Function which return the sum of elements from left index to right index	
 	public static int query(int start,int end,int left,int right,int treeIndex,int tree[]) {
 		
 //		Completely outside
 		if(start>right||end<left) {
 			return 0;
 		}
 //		Completely inside
 		if(start>=left&&end<=right) {
 			return tree[treeIndex];
 		}
 //		Partial 
 		int mid=(start+end)/2;
 		
 		int leftSum=query(start, mid, left, right, 2*treeIndex, tree);
 		int rightSum=query(mid+1, end, left, right, 2*treeIndex+1, tree);
 		
 		return (leftSum+rightSum);
 	}
 ",Java
"# Arctan Algorithm
 # Written by XZANATOL
 
 """"""
 Algorithm that demonstrates how to calculate Arctan and obtain angle in the \
 desired mode. (degrees/radians)
 """"""
 pi = 3.141592653589793238462643383279502884197169399375105  # Constant
 
 
 def conv_to_deg(angle):
     """"""Converts radian angles to degrees""""""
     return angle*180 / pi
 
 
 def conv_if_neg(x):
     """"""Returns abs of an angle if it's negative""""""
     if x < 0:
         return abs(x), True
     return x, False
 
 
 def arctan(val):
     """"""Arctan power series that obtains the angle in radians""""""
     val = val - (val**3)/3 + (val**5)/5 - (val**7)/7 + (val**9/9) - \
         (val**11/11)
     return val
 
 
 # Start Checkpoint
 if __name__ == ""__main__"":
     # Get Inputs
     val = float(input(""Enter value to obtain its angle > ""))
     mode = input(""Enter display mode (deg/rad) > "")
 
     val, neg_flag = conv_if_neg(val)  # Step 1 - Check if negative
     comp_flag = False  # Step 2 - Complementary angles
     identity_flag = False  # Step 3 - Identity angle
     if val > 1:
         comp_flag = True
         val = val**-1
     elif val > (2-3**0.5):
         identity_flag = True
         val = ((3**0.5 * val) - 1) / (3 ** 0.5 + val)
 
     angle = arctan(val)  # Step 4 - Substitute in the power series
 
     # Validate flags
     if comp_flag:
         angle = pi/2 - angle
     if identity_flag:
         angle = pi/6 + angle
     if neg_flag:
         angle *= -1
 
     # Validate display mode
     if mode == ""deg"":
         angle = conv_to_deg(angle)
 
     print(""Angle > {}"".format(angle))
 
 """"""
 The approach to calculate the Arctan is using a power series. \
 but the value must be validated before substituting it into the power series.
 Steps:
 =======
     1) Check if value is negative and use the fact that tan(-x) = -tan(x)
     2) If the value > 1: use complementary angles => arctan(x) = pi/2 - arctan(x**-1)
     3) else if value > 2-3**0.5: use identity equation => arctan(x) = pi/6 + arcta",Python
"/* Below is an implementation of Burrows Wheeler Transform in Go. It restructures
 the given plaintext to forms the ciphertext. It first forms all possible cyclic
 rotations of the plaintext, and then sorts the rotations lexicographically. Then,
 ciphertext is formed by taking the last character of each rotation sorted in
 lexicographical order. This code is implemented keeping in mind that characters
 in the plaintext are all unique.*/
 
 package main
 
 import (
 	""fmt""
 	""os""
 )
 
 // Define the size of the n (Globally)
 var n int = 4
 
 // This function generates all cyclic rotations of given plaintext
 func gen_rotations(plaintext string, combinations [][]string) {
 
 	var indx int = 0
 	for i := 0; i < n; i++ {
 		for j := 0; j < n; j++ {
 			combinations[i][j] = string(plaintext[(indx + j) % n])
 		}
 		indx += 1;
 	}
 }
 
 // This function sorts the above rotations lexicographically.
 func sort(plaintext string, combinations [][]string, arr []int) {
 
 	// Calling the generate function to generate all rotations
 	gen_rotations(plaintext, combinations)
 
 	var count int = 0
 
 	for k := 0; k < n; k++ {
 
 		// Iterate through the first column
 		for i := 0; i < 1; i++ {
 			/* Character { is lexicograqphically greater than
 			[A-Z] and [a-z]. So, we use it here as a maximum.*/
 			var min string = ""{""
 			var indx int
 
 			// Iterate though first element of each row
 			for j := 0; j < n; j++ {
 				if(combinations[j][i] < min) {
 					// Find the minimum
 					min = combinations[j][i]
 					// Store its index
 					indx = j
 				}
 			}
 			// Add the index to the array
 			arr[count] = indx
 			count += 1
 			// Replace the minimum with {
 			combinations[indx][i] = ""{""
 		}
 	}
 }
 
 // This is the encrpytion function
 func encrypt(plaintext string, combinations [][]string) string {
 
 	var arr = make([]int, n)
 
 	// Calling the sort function to get the sorted order
 	sort(plaintext, combinations, arr)
 
 	var encrypted string
 
 	// Adding last element",Go
"/*
 Introduction 
 Given a Binary Tree , Find its k th smallest element
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 Function to find and return kth smallest element
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Traverse all nodes of a tree in level order fashion 
 // and maintain k smallest elements
 int kthSmallest(struct Node* root,int k)
 {
     // If root is NULL , return -1
     if (root == NULL)
         return -1;
     //Store and maintain k smallest elements of tree
",C-Plus-Plus
"import java.util.Scanner;
 
 public class SwapNibbles {
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter a number:"");
         int num = sc.nextInt();
 
         int result = swapNibbles(num);
 
         System.out.println(""Number after swapping nibbles:"" + result);
         sc.close();
     }
 
     private static int swapNibbles(int x) {
         /* (x & 0x0F) << 4 gives us the last 4 bits of the number and
         shifts it by 4 bits to the left.
         (x & 0xF0) >> 4 gives us the last 4 bits of the number and
         shifts it to right by 4 bits. */
         return ((x & 0x0F) << 4 | (x & 0xF0) >> 4);
     }
 }
 /*
 * Sample input/output
 * Enter a number:
 * 100
 * Number after swapping nibbles:70
 *
 * Space and Time complexity = O(1)
 */
",Java
"/*
 in this problem we will have to merge two sorted linked list and will have to make a single list.
 the list will be made by joining together the nodes of first two lists
 */
 #include <iostream>
 using namespace std;
 
 //structure
 class node{
     public:
         int data;
         node* next;
 
     //constructor
     node(int data){
         this->data = data;
         this->next = NULL;
     }    
 };
 
 // this function is for inserting nodes in each list
 void insertAtTail(node* &head,int data)
 {
     node* n = new node(data);
 	if (head==NULL){
 		head = n;
 		return;
 	}
 
 	node* temp = head;
 	while(temp->next != NULL) {
 	    temp = temp->next;
 	}
 	temp->next = n;
 }
 
 // this function is the main function for merging two sorted linked list
 node* merge(node* a, node* b)
 {
     if(a == NULL){
         return b;
     }
     else if(b == NULL){
         return a;
     }
     node* c;
     //Compare a and b for smaller element
     if(a->data < b->data){
         c = a;
         c->next = merge(a->next, b);
     }  
     else{
         c = b;
         c->next = merge(a, b->next);        
     }  
     return c;
 }
 
 // Print function
 void print(node* head)
 {
     node* temp = head;
     while(temp != NULL)
     {
         cout<<temp->data<<"" "";
         temp = temp->next;
     }
     cout<<endl;
 }
 
 // driver code
 int main() {
     
         node* head1 = NULL;
         node* head2 = NULL;
         long long int n1,n2;
         // size of first list
         cin>>n1;
         // input nodes of first list
         while(n1--){
             int no;
             cin>>no;
             insertAtTail(head1,no);
         }
         // size of second list
         cin>>n2;
         // input nodes of second list
         while(n2--){
             int no;
             cin>>no;
             insertAtTail(head2,no);
         }  
 
         // head of new list that will be created
         node* head3 = merge(head1,head2);
 
         //printing new list
  ",C-Plus-Plus
"'''
 Tiling problem 2xN
 Problem Statement:
 Given a 2 x n board and tiles of dimension 2 x 1,
 count the number of ways to tile the given board using the 2 x 1 tiles.
 A tile can either be placed horizontally, as a 1 x 2 tile or vertically, as 2 x 1 tile.
 '''
 
 
 def numberOfWays(num):
     # base cases
     if num < 1:
         return 0
     if num < 2:
         return 1
 # temporary list to stores the number of ways to fill 2xi grid
     ways = [None] * (num + 1)
     ways[1] = ways[2] = 1
 # storing the ways in the temporary list using dynamic programming
     for i in range(3, num+1):
         ways[i] = ways[i-1] + ways[i-2]
     return ways[num]
 
 if __name__ == '__main__':
     n = int(input())  # taking input from the user
     # calling the function to calculate number of ways and printing it
     print(""Number of ways is:"", numberOfWays(n))
 
 
 '''
 Test Case 1:
 Input: 4
 Output: Number of ways is: 3
 
 Test Case 2:
 Input: 10
 Output: Number of ways is: 55
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 '''
",Python
"/*
 Introduction 
 Given a Binary Search Tree ,Print all the node values
 which lies in the range of given low and high values inclusive
 
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to insert a node with given value to the root
 struct Node* insert(struct Node* root,int element) 
 {
     //If the root is NULL , create a node with given element and assign it to root
     //else if the root itself is the node with given data , return 
     //else recursively insert it in one of the subtrees accordingly
     if(root==NULL)
         root = newNode(element);
     else if(root->key < element)
         root->right = insert(root->right,element);
     else if(root->key > element)
         root->left = insert(root->left,element);
     
     return root;
 }
 
 //Function to print all the node values of the BST within the given branch
 void RangePrinter(struct Node* root,int low,int high)
 {
     //if root is a NULL node , return
     if(root==NULL)
       return;
     
     //Traverse all required parts of the Tree , in Inorder Fashion
     //And Print the nodes if they satisfy the condition
     
     //If root key is greater than lower limit
     //recursively call the function for left subtree
     if(root->key > low)
       RangePrinter(root->left,low,high);
     
     //If root lies in the given range
     //Print its value
     if(root->key >= low && root->key <= high)
       cout<<root->key<<"" "";
 
     //If root key is lesser than higher limit
     //recursively call ",C-Plus-Plus
"/*Triplet Sum in an array
 
 Given an array arr of size n and an integer X.
 Find if there's a triplet in the array 
 which sums up to the given integer X.
 
 */
 #include<bits/stdc++.h>
 
 using namespace std;
 int tripletSum() {
   int size_of_array, sum, array[size_of_array], cnt = 0;
   cout << ""Enter size of array: "";
   cin >> size_of_array;
   cout << ""Enter the sum: "";
   cin >> sum;
   cout << ""Enter array elements: "";
   for (int i = 0; i < size_of_array; i++) {
     cin >> array[i];
   }
   int first_number, second_number, third_number;
   for (first_number = 0; first_number < size_of_array - 2; first_number++) {
     for (second_number = first_number + 1; second_number < size_of_array - 1; second_number++) {
       for (third_number = second_number + 1; third_number < size_of_array; third_number++) {
         if (array[first_number] + array[second_number] + array[third_number] == sum) {
           cnt++;
         }
 
       }
     }
   }
   if (cnt >= 1) {
     cout << ""1"" << endl;
   } else {
     cout << ""0"" << endl;
   }
 }
 
 int main() {
   tripletSum();
   return 0;
 }
 /*
 Input:
 Enter size of array: 5
 Enter the sum: 10
 Enter array elements: 1 2 4 3 6
 Output:
 1
 
 Space Complexity-O(1)
 Time Complexity-0(N^2)
 */
",C-Plus-Plus
"""""""
 ___Paint Fence Algorithm___
 
 Problem:
 Given a fence with n posts and k colors
 Find out the number of ways of painting the fence
 such that at most 2 adjacent posts have the same color.
 
 Input:
 n : number of posts
 k : number of colors
 
 Output:
 result: number of ways of painting
         considering the condition above
 
 """"""
 
 
 def paint_fence(n, k):
     if n < 2 or k < (n/2) :
         return -1       # n is not enough or k is not enough to obey the condition
     total = [0]*(n-1)
     same = [0]*(n-1)
     diff = [0]*(n-1)
 
     same[0] = k           # We start from the case 2  (0 as i) till n (n-2 as i)
     diff[0] = k*(k-1)
     total[0] = k*k
     for i in range(1, n-1):
         same[i] = diff[i-1]
         diff[i] = total[i-1]*(k-1)
         total[i] = same[i]+diff[i]
     return total[n-2]
 
 
 if __name__ == ""__main__"":
     post = int(input(""Enter n, Number of Posts\n""))
     color = int(input(""Enter k, Number of Colors\n""))
     result = paint_fence(post, color)
     if result == -1 :
         print(""Painting is not possible following the condition"")
     else:
         print(""Number of Possiblities:"", result)
 
 # Sample Input/Output
 
 # Enter n,Number of Posts
 # 3
 # Enter k,Number of Colors
 # 5
 # Number of Possiblities: 120
 
 # Enter n,Number of Posts
 # 10
 # Enter k,Number of Colors
 # 4
 # Painting is not possible following the condition
 
 # Enter n,Number of Posts
 # 5
 # Enter k,Number of Colors
 # 3
 # Number of Possiblities: 180
 
 # Time Complexity  O(n)
 # Space Complexity O(n)
 
",Python
"/**
  * Maximum of All Subarrays of Size k
  * Java program to find the maximum integer in each subarray of 
  * fixed size k, given an array of integers, using the 'Sliding 
  * Window Technique'. 
  */
 
 import java.io.*;
 import java.util.*; 
 public class MaximumEachSubarray {
 
     private static String findMaxEachSubarray(int[] numArray, int k) {
         String result = """"; 
 
         //ArrayDeque stores indices of useful elements for each window.
         //These indices are sorted in decreasing order, so that for each
         //window, index of maximum element is at the front. 
         ArrayDeque<Integer> indices = new ArrayDeque<>();
         
         //For first window 
         for(int i=0; i<k; i++){
 
             //For any element, all elements smaller than it and to its left in 
             //the window are useless as they cannot be the maximum for that 
             //window. Hence, we remove them from rear of deque. 
             while(!indices.isEmpty() && (numArray[i] >= numArray[indices.peekLast()]))
                 indices.removeLast(); 
 
             //Adding newest element to rear of deque
             indices.addLast(i); 
         }
         
         //For first window
         result += (numArray[indices.peek()] + "" ""); 
         
         //The same process is repeated over all windows of length k.
         for(int i=k; i<numArray.length; i++) {
 
             //If window has crossed the index at front of deque
             if(indices.peek() <= (i-k)) 
                 indices.removeFirst(); 
 
             while(!indices.isEmpty() && (numArray[indices.peekLast()] <= numArray[i]))
                 indices.removeLast(); 
             indices.addLast(i); 
             result += (numArray[indices.peek()] + "" ""); 
         }
 
         return result;
     }
 
     public static void main(String[] args) throws IOException {
         InputStreamReader read = new InputStreamReader(System.in);
 	    BufferedReader buf = new BufferedReade",Java
"// C program to implement recursive Binary Search 
 #include <stdio.h> 
 
 // A recursive binary search function. It returns 
 // location of x in given array arr[l..r] is present,
 //(l is leftmost element , r the rightmost and x is the element we are searching for)
 // otherwise -1  
 int binarySearch(int arr[], int l, int r, int x) 
 { 
 	if (r >= l) { 
 		int mid = l + (r - l) / 2; 
 
 		// If the element is present at the middle 
 		// itself 
 		if (arr[mid] == x) 
 			return mid; 
 
 		// If element is smaller than mid, then 
 		// it can only be present in left subarray 
         //so discarding the right array
 		if (arr[mid] > x) 
 			return binarySearch(arr, l, mid - 1, x); 
 
 		// Else the element can only be present 
 		// in right subarray 
 		return binarySearch(arr, mid + 1, r, x); 
 	} 
 
 	// We reach here when element is not 
 	// present in array 
 	return -1; 
 } 
 
 //intializing a sorted array
 int main(void) 
 { 
 	int arr[] = { 2, 3, 4, 10, 40 }; 
 	int n = sizeof(arr) / sizeof(arr[0]); 
 	int x = 10; 
 	int result = binarySearch(arr, 0, n - 1, x); 
 	(result == -1) ? printf(""Element is not present in array"") 
 				: printf(""Element is present at index %d"", 
 							result); 
 	return 0; 
 } 
",C
"'''
 Problem statement- given a maze of 1s with obstacles (represented by 0).
 We have to print all the possible paths to the end.
 Logical intuition- We have to explore all the possible paths hence our mouse
 will move in all four directions untill it reaches the end
 '''
 
 
 def printPathHelper(i, j, maze, n, solution):
     '''
     Summary Line:
     This funcion helps us to print the path followed by the rat in the maze.
     It puts 1s at places that the mouse can go and 0s
     at places where the mouse doesn't go.
 
     Args:
     i- current position on the maze horizontally
     j- current position on the maze vertically
     maze- The 2D matrix that was inputted through which the Rat has to pass
     n- side of the 2D matrix
     solution- solution matrix to be returned
     '''
     if i == n-1 and j == n-1:
         print()
         solution[i][j] = 1
         for i in range(n):
             for j in range(n):
                 print(solution[i][j], end="" "")
             print()
         solution[i][j] = 0
         return
     if i < 0 or j < 0 or i >= n or j >= n or\
             maze[i][j] == 0 or solution[i][j] == 1:
         return
     solution[i][j] = 1
     printPathHelper(i+1, j, maze, n, solution)
     printPathHelper(i, j+1, maze, n, solution)
     printPathHelper(i-1, j, maze, n, solution)
     printPathHelper(i, j-1, maze, n, solution)
     solution[i][j] = 0
     return
 
 
 def printPath(maze):
     '''
     Summary Line:
     This function helps us to take form a solution matrix and calls
     another method printPathHelper() on the solution matrix
     to print all possible paths for the mouse.
 
     Args:
     maze- The 2D matrix that was inputted through which the Rat has to pass
     '''
     n = len(maze)
     solution = [[0 for j in range(n)]for i in range(n)]
     printPathHelper(0, 0, maze, n, solution)
 
 if __name__ == '__main__':
     n = int(input())
     maze = []
     for j in range(n):
         arr = [int(i) for i in input",Python
"/*
 Reverse an array in groups of given size by using DART.
 
 Given an array, reverse every subarray formed by 
 consecutive k elements.
 */
 
 import 'dart:io';
 
 void reverse_array_groups(var array, int n, int k) {
   // going group by group using forloop.
   for (int i = 0; i < n; i += k) {
     int left = i;
     int right;
     if (i + k - 1 > n - 1)
       right = n - 1;
     else
       right = i + k - 1;
 
     // reversing the subarray.
     while (left < right) {
       int temp = array[left];
       array[left] = array[right];
       array[right] = temp;
       left++;
       right--;
     }
   }
 }
 
 void main() {
   var data = [];
 
   // taking input from user and storing it in data array
   var n, ele, k;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   print('Enter group size: ');
   k = stdin.readLineSync();
   k = int.parse(k);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     data.add(ele);
   }
 
   print(""Entered List is: "");
   print(data);
 
   print(""\nList after reversing in group is: "");
 
   reverse_array_groups(data, n - 1, k);
   print(data);
 }
 
 /*
 TIME COMPLEXITY: O(n)
 SPACE COMPLEXITY: O(1)
 
 SAMPLE INPUT/OUTPUT:
 Enter the number of Elements: 
 7
 Enter group size: 
 3
 Enter Element 1: 
 10
 Enter Element 2: 
 20
 Enter Element 3: 
 30
 Enter Element 4: 
 40
 Enter Element 5: 
 50
 Enter Element 6: 
 60
 Enter Element 7: 
 70
 Entered List is: 
 [10, 20, 30, 40, 50, 60, 70]
 
 List after reversing in group is:
 [30, 20, 10, 60, 50, 40, 70]
 */
",Dart
"/*
 Description : 
     An array of even size, task is to find minimum value that can be 
     added to an element so that array become balanced. An array is 
     balanced if the sum of the left half of the array elements is 
     equal to the sum of right half.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Solution
 {
 public:
     int minValueToBalance(int a[], int n)
     {
         //first half sum
         int f_sum = 0;
         //second half sum
         int s_sum = 0;
         int mid = n / 2;
         int result = 0;
 
         //for first half of an array
         for (int i = 0; i < mid; i++)
         {
             f_sum += a[i];
         }
         //for second half of an array
         for (int j = mid; j < n; j++)
         {
             s_sum += a[j];
         }
 
         if (f_sum > s_sum)
         {
             result = f_sum - s_sum;
         }
         else
         {
             result = s_sum - f_sum;
         }
         return result;
     }
 };
 
 int main()
 {
     int size;
     cout << ""Enter the lenght of an array : "" << endl;
     cin >> size;
     int a[size];
     cout << ""Enter "" << size << "" number of elements in array :"" << endl;
     for (auto i = 0; i < size; i++)
     {
         cin >> a[i];
     }
     Solution obj;
     cout << ""To make the array balanced you can add : "" << endl;
     cout << obj.minValueToBalance(a, size);
 
     return 0;
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Cases:
 Test Case 1 :
     Input :
     Enter the lenght of an array : 
     4
     Enter 4 number of elements in array :
     1 5 3 2
 
     Output:
     To make the array balanced you can add :
     1
 
 Test case 2:
     Input :
     Enter the lenght of an array : 
     6
     Enter 6 number of elements in array :
     1 2 1 2 1 3
 
     Output :
     To make the array balanced you can add :
     2
 */
 
",C-Plus-Plus
"/*
 Problem statement : 
 There is a fence with n posts, you are given k colors to paint the fence. 
 Each post can be painted with one of the k colors. You have to paint all the posts 
 with the k colors such that atmost two adjacent posts have the same color. 
 You have to find the total number of ways to paint the fence.
 */
 
 function painting_fence(n, k) {
     let same = k;
     let diff = k * (k - 1);
     let total = k * k;
     for (let i = 0; i < n - 2; i++) {
         same = diff;
         diff = total * (k - 1);
         total = same + diff;
     }
     return total;
 }
 
 //For reading input 
 const readline = require('readline');
 
 const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
 
 const getLine = (function () {
     const getLineGen = (async function* () {
         for await (const line of rl) {
             yield line;
         }
     })();
     return async () => ((await getLineGen.next()).value);
 })();
 
 const main = async () => {
     console.log(""Enter n, the number of posts"");
     let n = Number(await getLine());
     console.log(""Enter k, the number of colors"");
     let k = Number(await getLine());
     console.log(""Number of possiblilities for painting the fence is : "" + painting_fence(n, k));
     process.exit(0);
 };
 
 main();
 
 /*
 Sample I/O:
 
 Enter n, the number of posts
 3
 Enter k, the number of colors
 2
 Number of possiblilities for painting the fence is : 6
 
 Time complexity : O(n)
 Space complexity : O(1)
 */
",JavaScript
"/*
 A happy number is a number which eventually reaches 1 when replaced by the sum of the square of each digit 
 until the sum becomes a single digit number.
 */
 
 import 'dart:io';
 
 // Function to check if number is a Happy Number
 bool isHappyNumber(int num) {
   int sum = num;
 
   // do while loop used as square of digits need to be taken a minimum of one time
   do{
     int copy = sum;
     sum = 0;
 
     // calculating sum of square of individual digits
     while(copy > 0){
       int digit = copy % 10;
       sum += (digit*digit);
       copy ~/= 10;
     }
   }
   while(sum > 9);
 
   if(sum == 1){
     return true;
   }
   return false;
 }
 
 void main() {
   print(""Enter a number :"");
   int num = int.parse(stdin.readLineSync()!);
 
   // Call function to check if number is a Happy number
   if (isHappyNumber(num)) {
     print(""$num is a Happy Number"");
   } else {
     print(""$num is not a Happy Number"");
   }
 }
 
 /**
 Space Complexity O(1)
 Time Complexity  O(nlog(n))
 
 Sample input/output:
 Enter a number :
 19
 19 is a Happy Number
 
 Enter a number :
 20
 20 is not a Happy Number
 */
",Dart
"
 '''
 Description :
     Given a 9*9 sudoku board, in which some entries are filled and others are 0 
     (0 indicates that the cell is empty), you need to find out whether the Sudoku 
     puzzle can be solved or not i.e. return true or false.
 '''
 
 
 def isSafeToPut(i,j,option,board,n):
     for k in range(n):
         if board[k][j]==option or board[i][k]==option:
             return False
         
     # finding the dimensions of the 3 X 3 box 
     starti=(i//3)*3
     startj=(j//3)*3
 
     for p in range(starti,starti+3):
         for q in range(startj,startj+3):
             if board[p][q]==option:
                 return False
     
     return True
 
 
 def sudokuSolver(i,j,board,n):
     if i==n:
         return True
     
     if j==n:
         return sudokuSolver(i+1,0,board,n)
 
     if board[i][j]!=0:
         return sudokuSolver(i,j+1,board,n)
     
     for option in range(1,10):
         if isSafeToPut(i,j,option,board,n):
             board[i][j]=option
             canWeMoveFwd=sudokuSolver(i,j+1,board,n)
             if canWeMoveFwd is True:
                 return True
             board[i][j]=0
 
     return False
 
 
 board = [[ int(ele) for ele in input().split() ]for i in range(9)]
 ans = sudokuSolver(0,0,board,9)
 if ans is True:
     print('true')
 else:
     print('false')
 
 '''
 Test case :
  sample input 
  9 0 0 0 2 0 7 5 0 
  6 0 0 0 5 0 0 4 0 
  0 2 0 4 0 0 0 1 0 
  2 0 8 0 0 0 0 0 0 
  0 7 0 5 0 9 0 6 0 
  0 0 0 0 0 0 4 0 1 
  0 1 0 0 0 5 0 8 0 
  0 9 0 0 7 0 0 0 4 
  0 8 2 0 4 0 0 0 6
  
  Output :
  true
 
 '''
 '''
  Time complexity = O(9^(n*n)), here 9 because 9 options for each cell and `n` is the no. of rows or columns
  Space complexity = O(n)
 
 ''' 
 
",Python
"def numSquareSum(num): 
     squareSum = 0; 
     while(num): 
         squareSum += (num % 10) * (num % 10); 
         num = int(num / 10); 
     return squareSum; 
   
 def isHappynumber(num): 
 
     slow = num 
     fast = num
     while(True): 
 
         slow = numSquareSum(slow)
         fast = numSquareSum(numSquareSum(fast)); 
         if(slow != fast): 
             continue
         else: 
             break 
     return (slow == 1) 
   
 # Driver Code 
 num = int(input(""Enter a number: ""))
 if (isHappynumber(num)): 
     print(num , ""is a Happy number"") 
 else: 
     print(num , ""is not a Happy number"") 
  
 """"""
 Time Complexity: O(logN)
 Space Complexity: O(logN)
 
 Sample Input:
 Enter a number: 13
 Sample Output:
 13 is a Happy number
 """"""
",Python
"def linearSearch(arr, x):
     pos = -1
     for i in range(len(arr)):
         if arr[i] == x:
             pos = i
             print(""Found at {}"".format(pos))
             
     if pos == -1:
         print(""Not Found"")",Python
"def removeOuterParentheses(S):
     res, opened = [], 0
     for c in S:
         if c == '(' and opened > 0:
             res.append(c)
         if c == ')' and opened > 1:
             res.append(c)
         opened += 1 if c == '(' else -1
     return """".join(res)
 
 str = input(""Enter string: "")
 result = removeOuterParentheses(str)
 print(result)
 
 
 """"""
 Time complexity: O(n)
 Space complexity: O(n)
 Sample Input 1:
 Enter string: (()())(())
 Output: ()()()
 
 Sample Input 2:
 Enter string: ()()
 Output: """"
 
 """"""
",Python
"""""""
     Introduction:
         Two pointer technique is an optimization technique which is a really clever way of using
         brute-force to search for a particular pattern in a sorted list.
 
     Purpose:
         The code segment below solves the Three Sum Problem. We have to find a triplet out of the
         given list of numbers such that the sum of that triplet equals to another given value.
         The Naive Approach is to calculate the sum of all possible triplets and return the one with
         the required sum or None. This approach takes O(N^3) time to run. However, by using Two pointer
         search technique we can reduce the time complexity to O(N^2).
 
     Method:
         Three Sum Problem using Two Pointer Technique
 """"""
 
 def three_sum_problem(numbers, sum_val):
     """"""
         Returns a triplet (x1,x2, x3) in list of numbers if found, whose sum equals sum_val, or None
     """"""
 
     # Sort the given list of numbers
     # Time complexity: O(N.logN)
     numbers.sort()
     size = len(numbers)
 
     # Two nested loops
     # Time complexity: O(N^2)
     for i in range(size-3+1):
         # Reduce the problem to two sum problem
         two_sum = sum_val - numbers[i]
         
         # Initialize the two pointers
         left = i+1
         right = size-1
         
         # Search in the array until the two pointers overlap
         while left < right:
             curr_sum = numbers[left] + numbers[right]
 
             # Update the pointers
             if curr_sum < two_sum:
                 left += 1
             elif curr_sum > two_sum:
                 right -= 1
             else:
                 # Return the numbers that form the desired triplet
                 return ""({},{},{})"".format(numbers[i], numbers[left], numbers[right])
     
     # No triplet found
     return None
 
 
 
 def main():
     """"""
         Takes user input and calls the necessary function
     """"""
 
     # Take user input
     numbers = list(map(i",Python
"/*
 Bucket sort is a sorting algorithm that works by distributing the elements of an array into a number of buckets.
 Each bucket is then sorted individually, either using a different sorting algorithm,
 or by recursively applying the bucket sorting algorithm.Bucket sort is mainly useful when input is uniformly distributed
 over a range. Bucket sort can be implemented with comparisons and therefore can also be considered a comparison sort algorithm.
 */
 
 // Header file to include STL library
 #include<bits/stdc++.h>
  //For cin and cout
 using namespace std;
 
 //to sort the individual bucket
 void Insertion_Sort(float arr[10][10], int n, int idx) {
   for (int i = 0; i < n; i++) {
     int k = i;
     float temp = arr[idx][i];
     while (k - 1 >= 0 && arr[idx][k] < arr[idx][k - 1]) {
       arr[idx][k] = arr[idx][k - 1];
       k = k - 1;
     }
 
     arr[idx][k] = temp;
   }
 }
 
 void Bucket_Sort(float arr[20], int n) {
   // Declare a 2D array of float numbers
   float temp[10][10];
   //count array stores the length of elements in the respective buckets
   int count[10] = {
     0
   };
   for (int i = 0; i < n; i++) {
     int idx = arr[i] * 10;
     temp[idx][count[idx]] = arr[i];
     count[idx]++;
   }
 
   for (int i = 0; i < 10; i++) {
     if (count[i] > 0)
       Insertion_Sort(temp, count[i], i);
   }
 
   //to rewrite the values in array in sorted order
   int i = 0;
   for (int j = 0; j < 10 && i < n; j++) {
     if (count[j] > 0) {
       for (int k = 0; k < count[j]; k++) {
         arr[i] = temp[j][k];
         i++;
       }
     }
   }
 }
 
 int main() {
   // Declare a variable to store no. of elements
   int n;
   // Declare an array of float numbers
   float arr[20];
   cout << ""Enter number of elements :\n"";
   cin >> n;
   for (int i = 0; i < n; i++) {
     cout << ""Enter the elements:\n"";
     cin >> arr[i];
   }
   //loop to print original array
   cout << ""\n"";
   for (int i = 0; i < n; i++) {
     cout << ""\t"" << arr[i];
   }
   Buck",C-Plus-Plus
"'''
 ~~~ RABIN KARP ALGORITHM: ~~~
 This algorthm is used to search a pattern
 in the given text.
 Time complexity of the algorithm:
     best case: O(n+m)
     worst case: O(nm)
     where n and m are lengths of text and pattern
 '''
 
 def hash(text, pattern, d, q):
     '''
     function to calculate hash values of text
     and pattern
     parameters: text, pattern, base value,
         large enough prime number
     returns: a tuple containing hash of text
        and pattern
     '''
     p = 0
     t = 0
     m = len(pattern)
     # calculate hash for each window of size m
     # from both text and pattern
     for i in range(m):
         p = (d*p + ord(pattern[i])) % q
         t = (d*t + ord(text[i])) % q
     return (p,t)
 
 def rabinKarp(pattern, text):
     '''
     function to perform search using rabin karp
     algorithm
     parameters: pattern and text
     returns: a list containing positions of matching
         sequences
         (or) -1 if not found
     '''
     m = len(pattern)    #length of pattern
     n = len(text)       #length of text
     # base of the numerical system
     d = 10
     # large enough prime number
     q = 101
     # list to store search results
     arr = []
 
     p = 0
     t = 0
     h = 1
     i = 0
     j = 0
     flag = False
 
     # check if length of pattern is greater than text
     # if yes then return
     if(m > n):
         arr.append(-1)
         return arr
 
     for i in range(m-1):
         h = (h*d) % q
 
     # calculate hash value for pattern and text
     (p, t) = hash(text, pattern, d, q)
     
     # find the match
     for i in range(n-m+1):
         if p == t:
             for j in range(m):
                 if text[i+j] != pattern[j]:
                     break
 
             j += 1
             if j == m:
                 # pattern found at index i
                 # change flag status and append to list
                 flag = True
                 arr.append(i+1)
 
         if i < n-m:
    ",Python
"package main
 
 import (
 	""fmt""
 	""bufio""
 	""os""
 )
 
 // This function checks if string is a palindrome
 func palindrome_check(str string) int {
 	// Iterate till the middle of the string
 	for i:=0; i < len(str) / 2; i++ {
 		/* Check if character at beginning index of the
 		string matches the end of the string at same index*/
 		if(string(str[i]) != string(str[len(str) - 1 - i])) {
 			// If it does not then return -1
 			return -1
 		}
 	}
 	// If everything matches then return 1
 	return 1
 }
 
 func main() {
 
 	// Take string as input from the user
 	fmt.Print(""Enter a string to check if it is a palindrome: "")
 
 	scanner := bufio.NewScanner(os.Stdin)
 	scanner.Scan()
 	line := scanner.Text()
 
 	// Calling the function to check
 	var result int = palindrome_check(line)
 
 	/* If the string is a palindrome.
 	Else the string is not a palindrome*/
 	if(result == 1) {
 		fmt.Print(""\nThe entered string is a palindrome.\n"")
 	} else {
 		fmt.Print(""\nThe entered string is not a palindrome.\n"")
 	}
 }
 
 /* Sample I/O:
 
 Enter a string to check if it is a palindrome: check kcehc
 
 The entered string is a palindrome.
 
 Time Complexity - O(n)
 Space Complexity - O(1)
 */
 
",Go
"/*
  Program to find the maximum and minimum value in a Binary search Tree.
  The maximum value in the BST will be the right most node of the right sub-tree
  The minimum value in the BST will be the left most node of the left sub-tree
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 struct Node
 {
     int data;
     struct Node * left;
     struct Node * right;
 };
 Node* root = NULL;
 
 // Utility function to create a new Tree Node
 Node* newNode(int val)
 {
     Node *temp = new Node;
     temp->data = val;
     temp->left = NULL;
     temp->right = NULL;
 
     return temp;
 }
 
 // Function to insert item in a tree
 void insertItem(int item)
 {
     Node *newnode = newNode(item);
     if(!root) {
         root = newnode;
         return;
     }
     Node *cur, *prev;
     cur = root;
     while(cur!= NULL) {
         prev = cur;
         if(cur->data > item)
             cur = cur->left;
         else
             cur = cur->right;
     }
     if(prev->data > item)
         prev->left = newnode;
     else
         prev->right = newnode;
 }
 
 // Function to find the minimum value in a BST
 int minValue()
 {
     Node *temp = root;
     while (temp->left != NULL)
     {
         temp = temp->left;
     }
 
     return temp->data;
 }
 
 // Function to find the maximum value in a BST
 int maxValue()
 {
     Node *temp = root;
     while (temp->right != NULL)
     {
         temp = temp->right;
     }
 
     return temp->data;
 }
 
 int main()
 {
     int n;
     cin>>n;
     int arr[n];
     for(int i = 0; i < n; i++) {
         cin>>arr[i];
         insertItem(arr[i]);
     }
     cout<<maxValue()<<minValue();
     return 0;
 }
 
 /*
  Sample I/O
  Input format: The first line contains n - number of nodes in the tree
                The next line contains n spaced integers
  Output format: Two spaced integers denoting max and min value respectively.
  Example:
  5
  30 60 10 63 25
 
  Output - 63 10
 
  Explanation:
     30
    /  \
   10  60
     \   \
",C-Plus-Plus
"# Python program to find the subsequences Recursion
 
 
 def Subsequence_recursion(string, index, current):
     if index == len(string):  # count the size
         print(current)  # print values one by one
         return
 # calling function to update the values
     Subsequence_recursion(string, index + 1, current + string[index])
     Subsequence_recursion(string, index + 1, current)
 
 string = input()
 Subsequence_recursion(string, 0,  '')
 
 '''
 Sample I/O:
 Input:
 abc
 
 Output:
 abc
 ab
 ac
 a
 bc
 b
 c
 
 Time Complexity:O(N) (where N =index)
 Space Complexity:O(1)
 '''
",Python
"/*
 Given a series of AP with one element missing, find the missing number.
 
 In the given solution we use the approach of binary search, to find the missing
 element.
 */
 
 import 'dart:io';
 import 'dart:math';
 
 findMissingAp(List arr, int n) {
   // Calculating the common difference in AP
   int diff = ((arr[n - 1] - arr[0]) / n).floor();
 
   int low = 0;
   int high = n - 1;
 
   int flag = 0;
   int result = 0;
 
   // Performing Binary Search
   while (low <= high) {
     int mid = ((high - low) / 2).floor();
 
     // If the element before mid is missing
     if (mid > 0 && arr[mid] - arr[mid - 1] != diff) {
       result = arr[mid - 1] + diff;
       flag = 1;
       break;
     }
 
     // If the element after mid is missing
     if (arr[mid + 1] - arr[mid] != diff) {
       result = arr[mid] + diff;
       flag = 1;
       break;
     }
 
     // Continuing the search with elements after mid
     if (arr[mid] == arr[0] + (diff * mid)) {
       low = mid + 1;
       continue;
     }
 
     // Continuing the search with elements before mid
     high = mid - 1;
   }
 
   if (flag == 1) {
     print('The missing element is: $result');
     return;
   }
 }
 
 main() {
   // Driver code to take user input
   var array = [];
 
   var n, ele;
   print('Enter the number of elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter value for element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
 
   findMissingAp(array, n);
 }
 
 /*
 TIME COMPLEXITY: O(log N)
 SPACE COMPLEXITY: O(1)
 
 SAMPLE I/O:
 Enter the number of elements: 
 6
 Enter value for element 1: 
 1
 Enter value for element 2: 
 6
 Enter value for element 3: 
 11
 Enter value for element 4: 
 21
 Enter value for element 5: 
 26
 Enter value for element 6: 
 31
 The missing element is: 16
 */
",Dart
"/*
 Introduction 
 Given a Binary Search Tree ,Find the Floor value of the given number in the BST
 Floor value of a given number is the element existing in BST with value less than or equal to the given number
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 //Define a Global variable and keep updating it
 int Floor;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to insert a node with given value to the root
 struct Node* insert(struct Node* root,int element) 
 {
     //If the root is NULL , create a node with given element and assign it to root
     //else if the root itself is the node with given data , return 
     //else recursively insert it in one of the subtrees accordingly
     if(root==NULL)
         root = newNode(element);
     else if(root->key < element)
         root->right = insert(root->right,element);
     else if(root->key > element)
         root->left = insert(root->left,element);
     
     return root;
 }
 
 //Function to update Floor value of the given number
 void UpdateFloor(struct Node* root,int value)
 {
    //If root is a NULL node , return
    if(root==NULL)
      return ;
  
    if(root->key > value)
     {
       //if root key > given value , 
       // recursively search for a floor value in left subtree
        UpdateFloor(root->left,value);
     }
    else if(root->key < value)
    {
        //if root key < given value , 
        //update the floor value and 
        //search for a greater value in right subtree recursively
        Floor=max(Floor,root->key);
        UpdateFloor(ro",C-Plus-Plus
"/**
  * @author omkarlanghe
  * @file
  * Given an unsorted array A of size N of non-negative integers, find a continuous sub-array which adds to a given number S, If not found print -1.
  *
  *  Input :
  *  Testcase1:
     5 12                    =>  where 5 is the size of an array and 12 is the original sum to check.
     1 2 3 7 5               =>  space seperated integers representing elements in an array.
 
 *   Testcase2:
     5 123                   =>  where 5 is the size of an array and 123 is the original sum to check.
     1 2 3 7 5               =>  space seperated integers representing elements in an array.
 
 *   Testcase3:
     10 15                   =>  where 10 is the size of an array and 15 is the original sum to check.
     1 2 3 4 5 6 7 8 9 10    =>  space seperated integers representing elements in an array.
 * Output :
     2 4
 
     -1
 
     1 5
 * Explanation :
     Testcase1: sum of elements from 2nd position to 4th position is 12. (consider 1 based indexing)
     Testcase2: no subarray found whose sum equals to the given sum, hence print -1.
     Testcase3: sum of elements from 1st position to 5th position is 15. (consider 1 based indexing)
 */
 
 #include <iostream>
 /**
  * Function to print the index range of subarray equal to the given sum. If no such subarray found, print -1.
  * @param arr array to check
  * @param size size of an array
  * @param original_sum sum to match with the sum of all elements of a sub array.
  * @return void and prints index ranges if sum of sub array equal to the given
  * sum, else prints -1.
  */
 void contiguous_sub_array(int *arr, int size, int orignal_sum) {
     int current_sum = 0, match = 0;
 
     for (int i = 0; i < size; i++) {
         current_sum = 0;
         for (int j = i; j < size; j++) {
             current_sum += arr[j];
             if (current_sum == orignal_sum) {
                 match = 1;
                 std::cout << (i + 1) << "" "" << (j + 1) << "" "";
                 break;
   ",C-Plus-Plus
"/*
 	Only one odd ocurring number
 	Using Xor Operation as Xor of two numbers gives zero
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 //to find missing number xor the array elements
 // xor all elements from 1 to N
 // Xor both the above two steps
 int main()
 {
 	int n;
 	cout<<""Enter number of elements \n"";
 	cin>>n;
     vector<int>arr;
     int a;
     for(int i=0;i<n;i++)
     {
     	cin>>a;
     	arr.push_back(a);
 	}
 	int res=0;
 	for(int i=0;i<n;i++)
 	{
 		res= res ^ arr[i];
 	}
 	cout<<res<<endl;  
 	  
 }
 
 
 /*
 Time Complexity: O(n) 
 Space Complexity: O(1)
 */
 
 /*
 Sample Input:
 Example 1:- 
 Enter number of elements
 5
 1 1 2 3 3
 Example 2:-
 Enter number of elements
 7
 71 4 9 71 9 7 7
 Sample Output:
 Example 1:- 2
 Example 2:- 4
 */
 
",C-Plus-Plus
"/*The program is to check whether a given number is a special number or not.
  A special number is a number whose all digits are 1
  Example-11
  */
 
 #include <stdio.h>
 
 void special(int);
 
 int main() {
     int num;
     printf(""Enter a number\n"");
     scanf(""%d"",&num);
 	/*Calling of function*/
     special(num);
 	
 	return 0;
 }
 
 void special(int n)
 {
     int b,s=0,c=0;
     while(n!=0)
     {
         b=n%10;
 		/*Sum of digits*/
         s=s+b;
 		/*Count of digits*/
         c++;
         n=n/10;
     }
 	/*if sum and count are equal
 	then special number*/
     if(s==c)
     printf(""The given number is special"");
     else
     printf(""The given number is not special"");
 }
 
 /*
 Time Complexity:O(n)
 Space Complexity:O(1)
 Input/Output:
 Enter a number
 123
 The given number is not special
 */
",C
"/*
 Cloning stack without extra space:
 
 This Function takes takes two stakes as input and copy data of first stack to the second stack.
 It is a recursive code in which we store the top element of the stack in a temporary variable
 and call the function which clones rest of the stack and push the stored to the top of
 the stack.
 
 */
 #include<bits/stdc++.h>
 using namespace std;
 void clonestack(stack<int> st, stack<int> &cloned)
 {
 	if (st.size() > 0)
 	{
 		int x = st.top();
 		st.pop();
 		clonestack(st, cloned);
 		cloned.push(x);
 	}
 }
 
 int main()
 {
 	stack<int> source, dest;
 	cout << ""Enter the no. of elements\n"";
 	int n, element;
 	cin >> n;
 	cout << ""Enter the elements of stack\n"";
 	for (int i = 0; i < n; i++) {
 		cin >> element;
 		source.push(element);
 	}
 	clonestack(source, dest);
 	cout << ""Source Stack : "";
 	while (!source.empty()) {
 		cout << source.top() << "" "";
 		source.pop();
 	}
 	cout << endl;
 	cout << ""Cloned Stack : "";
 	while (!dest.empty()) {
 		cout << dest.top() << "" "";
 		dest.pop();
 	}
 	return 0;
 }
 /*
 Sample Input/Output:
 INPUT:  Enter the no. of elements
 	5
 	Enter the elements of stack
 	3 5 1 2 4
 
 OUTPUT: Source Stack : 3 5 1 2 4
 	Cloned Stack : 3 5 1 2 4
 
 Time and space complexity for this approach:
   Time Complexity: O(N)
   Auxiliary Space: O(1)
 */
",C-Plus-Plus
"#include <bits/stdc++.h>
 using namespace std;
 
 int b;
 
 struct Problem
 {
     int Left, Right;
 };
 
 void probRes(int a[], int n, Problem p[], int m)
 {
     
     b = (int)sqrt(n);
 
     
     sort(p, p+m , check);
 
     int currLeft = 0, currRight = 0;
     int currSum = 0;
 
     
     for (int i=0; i<m; i++)
     {
         
         int Left = p[i].Left, Right = p[i].Right;
         while (currLeft < Left)
         {
             currSum -= a[currLeft];
             currLeft++;
         }
         while (currLeft > Left)
         {
             currSum += a[currLeft-1];
             currLeft--;
         }
         while (currRight <= Right)
         {
             currSum += a[currRight];
             currRight++;
         }
 
         while (currRight > Right+1)
         {
             currSum -= a[currRight-1];
             currRight--;
         }
 
         cout << ""Sum of ["" << Left << "", "" << Right
             << ""] is "" << currSum << endl;
     }
 }
 
 bool check(Problem x, Problem y)
 {
     
     if (x.Left/b != y.Left/b)
         return x.Left/b < y.Left/b;
 
     
     return x.Right < y.Right;
 }
 
 int main()
 {
     int a[] = {1, 1, 2, 1, 3};
     int n = sizeof(a)/sizeof(a[0]);
 
     Problem p[] = {{1, 5}, {2, 4}};
     int m = sizeof(p)/sizeof(p[0]);
     
     probRes(a, n, p, m);
     return 0;
 } 
 
 // O(m * n)
 
 // O/P : Sum of [1, 5] is 6
 // Sum of [2, 4] is 6
 
 
 
 // Some other examples:
 // I/P:
 // Arr = [0, 1, 1, 0, 2, 3, 4, 1, 3, 5, 1, 5, 3, 5, 4, 0, 2, 2] of 18 elements
 // Queries (0-indexed): [0, 8], [2, 5], [2, 11], [16, 17], [13, 14], [1, 17], [17, 17]
 
 
 // O/P:
 // 27
 // 6
 // 47
 // 8
 // 9
 // 122
 // 2
",C-Plus-Plus
"/*Problem Statement:
 Given an integer, the task is to convert it to a roman numeral.
 Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
 Symbol Value
 I 1
 V 5
 X 10
 L 50
 C 100
 D 500
 M 1000 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 string IntegerToRoman(int num) {
     string ans = """";
     vector<pair<int, string>> values = {{1000, ""M""}, {900, ""CM""}, {500, ""D""}, 
                                        {400, ""CD""}, {100, ""C""}, {90, ""XC""}, 
                                        {50, ""L""}, {40, ""XL""}, {10, ""X""}, 
                                        {9, ""IX""}, {5, ""V""}, {4, ""IV""}, {1, ""I""}};
     vector<pair<int, string>>::iterator it; 
     it = values.begin(); //to iterate over the values
     while(num > 0 && it != values.end()) { 
         if(it -> first <= num){
             ans += it -> second;
             num -= it -> first;
         }
         else{
             it++;
         }
     }
     return ans;
 }
 
 int main() {
     int num;
     cin >> num;
     cout << IntegerToRoman(num);
     return 0;
 }
 
 /* Examples:
 1. Input: num = 3
    Output: ""III""
 2. Input: num = 1994
    Output: ""MCMXCIV"" */
 
",C-Plus-Plus
"package main
 
 import ""fmt""
 
 type solver interface {
 	play(int)
 }
 
 type towers struct{}
 
 func (t *towers) play(n int) {
 	t.shiftN(n, 1, 2, 3)
 }
 
 func (t *towers) shiftN(n, from, to, via int) {
 	if n > 0 {
 		t.shiftN(n-1, from, via, to)
 		t.shiftM(from, to)
 		t.shiftN(n-1, via, to, from)
 	}
 }
 
 func (t *towers) shiftM(from, to int) {
 	fmt.Println(""Shifting disk from rod"", from, ""to rod"", to)
 }
 
 func main() {
 	var t solver
 	t = new(towers)
 	t.play(4)
 }
 
 /*
 Tower of Hanoi is a mathematical puzzle where we have three rods and n disks. The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:
 1) Only one disk can be moved at a time.
 2) Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack i.e. a disk can only be moved if it is the uppermost disk on a stack.
 3) No disk may be placed on top of a smaller disk.
 In this code, we use the recursive definition of Tower of Hanoi.
 Time Complexity: O(2^N)
 Space Complexity: O(N)
 
 INPUT: 4
 
 OUTPUT:
 Shifting disk from rod 1 to rod 3
 Shifting disk from rod 1 to rod 2
 Shifting disk from rod 3 to rod 2
 Shifting disk from rod 1 to rod 3
 Shifting disk from rod 2 to rod 1
 Shifting disk from rod 2 to rod 3
 Shifting disk from rod 1 to rod 3
 Shifting disk from rod 1 to rod 2
 Shifting disk from rod 3 to rod 2
 Shifting disk from rod 3 to rod 1
 Shifting disk from rod 2 to rod 1
 Shifting disk from rod 3 to rod 2
 Shifting disk from rod 1 to rod 3
 Shifting disk from rod 1 to rod 2
 Shifting disk from rod 3 to rod 2
 
 */
",Go
"/* Problem statement: 
 You are given a string, you have to replace all the occurrences of ""pi"" int the string into 3.14. */
 #include <bits/stdc++.h>
 using namespace std;
 void replacepi(char a[], int i)
 {
     if (a[i] == '\0' or a[i + 1] == '\0')
     {
         return;
     }
     //checks if the current and the next part of the string is ""pi""
     if (a[i] == 'p' and a[i + 1] == 'i')
     {
         //Shifting the replacement of 3.14
         int j = i + 2;
         //taking j to the end of the string
         while (a[j] != '\0')
         {
             j++;
         }
 
         while (j >= i + 2)
         {
             a[j + 2] = a[j];
             j--;
         }
 
         //replacing ""pi"" with 3.14
         a[i] = '3';
         a[i + 1] = '.';
         a[i + 2] = '1';
         a[i + 3] = '4';
         replacepi(a, i + 4);
     }
     //Go to the next position
     else
     {
         replacepi(a, i + 1);
     }
 }
 
 //Time Complexity :O(n)
 int main()
 {
     char a[1000];
     cin >> a;
     replacepi(a, 0);
     cout << a << endl;
     return 0;
 }
 /* 
 Example 1:
 Input : xpighpilmpipi
 Output: x3.14gh3.14lm3.143.14
 
 Example 2:
 Input : abcpipikjpilk
 Output: abc3.143.14kj3.14lk
 
 Time Complexity :O(n) */",C-Plus-Plus
"
 /*Input:
 First line contains two space separated integers,(N,M) 
 N- no of vertices, M- no of edges.
 Then M lines follow, each line has 3 space separated integers ui ,vi ,wi which denotes edge from vertex ui to vi with weight wi.
 In the given graph, detect wheather any negative cycle is present or not.
 
 
 TEST CASE
 4 4
 1 2 1
 2 3 -1
 3 4 -1
 4 1 -1
 
 OUTPUT
 Negative Cycle Present */
 
 
 #include<bits/stdc++.h>
 using namespace std;
 
 struct Edge { 
   int src, dest, weight; 
 }; 
 
 struct Graph { 
   int V, E; 
   struct Edge* edge; 
 }; 
   
 struct Graph* createGraph(int V, int E) 
 { 
   struct Graph* graph = new Graph; 
   graph->V = V; 
   graph->E = E; 
   graph->edge = new Edge[E]; 
   return graph; 
 } 
 
 bool containNegativeCycle(struct Graph* graph, int src){
   int V = graph->V; 
   int E = graph->E; 
   int dist[V];
 
   for (int i = 0; i < V; i++) 
     dist[i] = INT_MAX; 
   dist[src] = 0;
 
   for(int i=0;i<V-1;i++){
     for (int j = 0; j < E; j++){
       int u = graph->edge[j].src; 
       int v = graph->edge[j].dest; 
       int w = graph->edge[j].weight; 
       if (dist[u] != INT_MAX && dist[u] + w < dist[v]) 
         dist[v] = dist[u] + w;
     }
   }
 
   for (int i = 0; i < E; i++) { 
     int u = graph->edge[i].src; 
     int v = graph->edge[i].dest; 
     int weight = graph->edge[i].weight; 
     if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {  
       return true; 
     } 
   } 
   return false;
 }
 
 int main(){
   int n,m;
   cin>>n>>m;
   struct Graph* graph = createGraph(n, m);
     
   for(int i=0;i<m;i++){
     int u,v,w;
     cin>>u>>v>>w;
     graph->edge[i].src = u-1; 
     graph->edge[i].dest = v-1; 
     graph->edge[i].weight = w;
   }
 
   bool negativeCycle=containNegativeCycle(graph,0);
   if(negativeCycle){
   	cout<<""Negative Cycle is Present""<<endl;
   }
   else{
   	cout<<""No negative cycle present""<<endl;
   }
   return 0;
 }
 
 /*
 Time- complexity
     O(VE)
     If there are 'n' vertices, then ",C-Plus-Plus
"/*Prim's algorithm is a minimum spanning tree algorithm that takes a graph as input and finds 
 the subset of the edges of that graph which. form a tree that includes every vertex. 
 has the minimum sum of weights among all the trees that can be formed from the graph.
 (issue-3304)*/
 #include<bits/stdc++.h> 
 /*This includes functions like strlen and strcpy,It's the C++ version of header from C*/
 using namespace std;
 int operation(int array[] , int row, int coloumn, int graph[4][4]); 
 #define number 4
 /* separate function is declared to form process and output
 which takes 2 for loops with min val of vertex displays output 
 in 2 columns where Weight of ele and Edge of graph*/
 int operation(int array[], int row, int coloumn, int graph[4][4]) {
         int least_val = 100;
         for (int index_x = 0 ; index_x < number; index_x ++) {
       if (array[index_x]) {
         for (int index_y = 0 ; index_y < number; index_y++) {
           if (!array[index_y] && graph[index_x][index_y])  {  
             if (least_val> graph[index_x][index_y] ){
              least_val = graph[index_x][index_y];
              row= index_x , coloumn= index_y;
             } } } } }
     cout << graph[row][coloumn]<<""  ""<<row<< "" - "" << coloumn << endl;
     array[coloumn] = true;
     }
 /* in main we give inputs to graph array and calls operation function */ 
 int main() {
   int all_edges;
    int array[number];
 /*memset Sets the first num bytes of the block of memory 
 pointed by ptr to the specified value faster than loop*/
   memset(array, false, sizeof(array));
   all_edges = 0;
   array[0] = true;
  cout<<""enter the elements into graph array ""<< endl ;
  /* taking the inputs for graph in form of loop
  which is of having number(of rows and coloumns) */
   int row , coloumn; 
 int graph[number][number];
         for (int i =0; i< number ; i++){
     for(int j=0 ; j< number ; j++){
         cin>>graph[i][j];
     } }
 cout <<""Weight of ele,""<< "" ""<<""Edge of graph"" <<""\n"";
 /",C-Plus-Plus
"//Strong number is a special number whose sum of factorial of digits is equal to the original number.
 //For example: 145 is strong number. Since, 1! + 4! + 5! = 145
 
 #include <bits/stdc++.h>
 using namespace std;
 int main()
 {
     long long int num, n, factorial=1, sum=0;
     int i, digit;
     cout<<""Enter a number to check whether it is a strong number or not: "";
     cin>>num;
     n=num;
     for(n=num; n>0; n=n/10)
     {
         digit=n%10;     //digit of the number
         if(digit!=0)
         {
             factorial=1;
             for(i=1; i<=digit; i++)
                 factorial*=i;    //code for calculating factorial of digits
         }
         else
             digit=1;
         sum+=factorial;     //sum of factorial of digits
     }
     if(sum==num)
         cout<<sum<<"" is a strong number.""<<endl;
     else
         cout<<num<<"" is not a strong number.""<<endl;
     return 0;
 }
 
 /*
 Time Complexity: O(n*9)
 Space Complexity: O(1)
 
 sample 1:
 Input: Enter a number to check whether it is a strong number or not:  145
 Output: 145 is a strong number.
 sample 2:
 Input: Enter a number to check whether it is a strong number or not: 2
 output: 2 is not a strong number.
 */ 
",C-Plus-Plus
"""""""
 Author: Akash Kumar Bhagat (akay_99)
 Dice Throw Problem : Given n dice each with m faces, numbered
         from 1 to m, find the number of ways to get sum X.
         X is the summation of values on each face when all
         the dice are thrown.
 
 Purpose: Return the number of ways you can get a sum equal to K
         by throwing a M faced dice for N times.
 
 Method: Dynamic Programing
 Intution:The Naive approach is to find all possible combinations from N dice
         and keep counting the if the desired sum is achieved
          Sum(m, n, X)=Finding Sum (X - 1) from (n - 1) dice plus 1 from nth dice
                + Finding Sum (X - 2) from (n - 1) dice plus 2 from nth dice
                + Finding Sum (X - 3) from (n - 1) dice plus 3 from nth dice
                   ...................................................
                   ...................................................
                   ...................................................
               + Finding Sum (X - m) from (n - 1) dice plus m from nth dice
 
         We can use Dynamic Programing to solve this problem efficiently because
         this problem contains many overlaping Sub-problems which need to be
         calculated again and again. We can use Dynamic Programing to store the
         result of the previous sub-problems.
 
 Time Complexity: O(N*K)
 Space Complexity: O(N*K)
 
 Argument: 3 Integers (M, N and K)
 Return  : Integer    (Number of ways)
 
 Reference: https://www.geeksforgeeks.org/dice-throw-dp-30/
 
 """"""
 
 
 def Dice_Throw(n, m, k):
 
     # DP table to store the results of all possible sub-problems in a matrix
     # Here DP[i][j] denoted the Number of ways to get the sum j with i throws
     DP = [[0] * (k + 1) for i in range(n + 1)]
 
     # By convention, the 0th index of the matrix will not be used and
     # the value at DP[0][0] must be 1
     DP[0][0] = 1
 
     # Iterate through 1 to n dice trows
     for i in range(1, n + 1):
 
       ",Python
"#include<iostream>
 using namespace std;
 
 //creating structure for node
 struct Node {
     char data;
     struct Node *left;
     struct Node *right;
 };
 
 // Insert Function
 Node* Insert(Node *root, char data) {
     //if root have no value
     //then create a node and insert values
     if (root == NULL) {
         root = new Node();
         root->data = data;
         root->left = root->right = NULL;
     }
     //check if data is less than root value
     //then insert into left subtree
     else if (data <= root->data)
         root->left = Insert(root->left, data);
     //check if data is less than root value
     //then insert into right subtree
     else
         root->right = Insert(root->right, data);
     return root;
 }
 
 //Preorder Function
 void Preorder(struct Node *root) {
     // if tree is empty then return
     if (root == NULL) return;
     //otherwise print data
     printf(""%c "", root->data);
     //visit left and right subtree
     Preorder(root->left);
     Preorder(root->right);
 }
 
 //Main Function began
 int main() {
     Node* root = NULL;
     //input values
     root = Insert(root, 'M');
     root = Insert(root, 'B');
     root = Insert(root, 'Q');
     root = Insert(root, 'Z');
     root = Insert(root, 'A');
     root = Insert(root, 'C');
     //Print Nodes in Preorder.
     cout << ""\tOUTPUT\n"";
     cout << ""Preorder traversal : "";
     Preorder(root);
     cout << ""\n"";
 }
 //Main Ends
 
 /*
 Sample Input Output:
 
 Input -> M B Q Z A C
 
 OUTPUT:
 Preorder traversal : M B A C Q Z
 
 Time Complexity: O(n)
 */
",C-Plus-Plus
"'''
 INTRO SORT
 Introsort sort is a sorting algorithm that initially uses quicksort, 
 but switches to heap sort if the depth of the recursion is too deep,
 and uses insertion sort for small cases.
 
 Time Complexity:
 Worst-case performance: O(nlogn)
 Average-case performance: O(nlogn)
 '''
 
 #A function that takes a list as argument.
 def introsort(alist): 
     
     #maxdepth is chosen equal to 2 times floor of log base 2 of the length of the list.
     maxdepth = (len(alist).bit_length() - 1 ) * 2
     # Call introsort_helper with start = 0 and end = len(blist).
     introsort_helper(alist, 0, len(alist), maxdepth)
  
 #The function sorts the list from indexes start to end. 
 def introsort_helper(alist, start, end, maxdepth):
     if end - start <= 1:
         return
     elif maxdepth == 0:
         heapsort(blist, start, end)
     else:
         p = partition(alist, start, end)
         introsort_helper(alist, start, p + 1, maxdepth - 1)
         introsort_helper(alist, p + 1, end, maxdepth - 1)
  
 #Partition function uses Hoare partition scheme to partition the list. 
 def partition(alist, start, end):
     pivot = alist[start]
     i = start - 1
     j = end
  
     while True:
         i = i + 1
         while alist[i] < pivot:
             i = i + 1
         j = j - 1
         while alist[j] > pivot:
             j = j - 1
  
         if i >= j:
             return j
  
         swap(alist, i, j)
 
 #Function for swapping particular elements of a list
 def swap(alist, i, j):
     alist[i], alist[j] = alist[j], alist[i]
 
 #Heapsort from indexes start to end - 1 
 def heapsort(blist, start, end):
     build_max_heap(alist, start, end)
     for i in range(end - 1, start, -1):
         swap(blist, start, i)
         max_heapify(alist, index = 0, start = start, end = i)
  
 #Rearrange the list into a list representation of a heap. 
 def build_max_heap(alist, start, end):
     def parent(i):
         return (i - 1) // 2
     length = end - start
     index ",Python
"/*
  * AFFINE CIPHER :-
  * 		It is one of the methods from cryptography.
  * 
  * 		Algorithm :- 
  * 			1) Input text
  * 			2) Find numeric value associated with each letter in the text as ""A as 0"", ""B as 1"",...""a as 26"", ... etc.
  * 			3) Apply the encryption or decryption formula according to the given instructions.
  * 			4) Now you will get a numeric value, find its equivalent letter (described in step 2).
  * 			5) Collect all the letters and form the cipher text.
  * 			6) Display Cipher text.
  * 
  * 		The Encryption and Decryption formula's followed by the Affine Cipher are as follows :
  *
  * 			Encryption :-
  *				cipherCode = ((multiplicationFactor * inputCode) + additionFactor) % lengthOfAlphabets
  *
  *			Decrytion :-
  * 				decipherCode = ((inverse_multiplicationFactor) * (inputCode - additionFactor)) % lengthOfAlphabets
  * 
  * 			Symbols :-
  * 			1) Length of the alphabet list => 
  * 					It is the total no. of alphabets used as a dictionary to encrypt or decrypt the text.
  * 					In this case, we are considering english language so the dictionary has ""A to Z"" and ""a to z""
  * 
  * 			2) Multiplication Factor => 
  * 					It is a multiplication factor to the input code. It should be coprime with z to work this algorithm.
  * 					In this case, we will be randomly choosing 'multiplication factor' from the set of coprime no.s to length of alphabets.
  * 
  * 			3) Inverse of Multiplication Factor => 	
  * 					This is the a-inverse i.e. the multiplicative inverse of a with respect to length of alphabets. 
  * 					Means (Multiplication Factor x Inverse Multiplication Factor) mod length of alphabets = 1.
  * 
  * 			4) Addition Factor => 
  * 					It is a addition factor. There are no specific constraints other than 0 <= Addition Factor <= Length of alphabets.
  */
 
 import java.util.*;
 
 public class AffineCipher {
 	//Creating objects that will be used throughout the code. 
 	List<Character> alphabets = new ArrayList<Character>();
 	Ran",Java
"/**
 The Sieve of Eratosthenes is one of the most 
 efficient ways to find all primes smaller than n.
 */ 
 
 import java.util.Arrays;
 import java.util.Scanner;
 
 public class Sieve_of_Eratosthenes {
 
     public static void main(String[] args) {
         
 		Scanner sc=new Scanner(System.in);
 	        System.out.print (""Enter value of n - "");
 		int n=sc.nextInt();
 		
 		boolean[] prime=new boolean[n+1];
 	    
 		for (int i=2; i<=n; i++) {
 			prime[i]=true;
 		}
 		
 		for (int i=2; i<=Math.sqrt(n); i++) {
 			int x = i;
 
 			if (prime[i]) {
 
 				for (int j=2; j*x<=n; j++) {
 					prime[j*x]=false;
 				}
 			}
 		}
 		
               System.out.print (""Prime numbers upto ""+n+"" - "");
 
 		for (int i=2; i<=n; i++) {
 
                        if (prime[i]) {
                                System.out.print (i+"", "");
                        }
               }
 
               System.out.println (""End."");
 	}
 }
 
 /**
 
 Time Complexity : O(N(log(log(N))))
 Space Complexity : O(N)
 
 Sample Test case 1 :
 
 Enter value of n - 13
 
 Output :
 
 Prime numbers upto 13 - 2, 3, 5, 7, 11, 13, End.
 
 */
",Java
"# Given a string s, and assuming that a=1, b=2, c=3, d=4, .... z=26
 # Python recursive function to print all the possible codes for the strings.
 
 
 def output(original, previous):
 
     if len(original) == 0:  # if length is zero print 0th value i.e., '`'
         print(previous)
         return
     if len(original) == 1:
         print(previous + chr(96 + int(original)))  # checking range
         return
 
     if int(original[0:2]) < 27:
         new_character = chr(96 + int(original[0:2]))  # getting  new character
         output(original[2:], previous + new_character)
     new_character = chr(96 + int(original[0:1]))
     output(original[1:], previous + new_character)
 
 
 # driver code
 if __name__ == '__main__':
     string = input()
     output(string, '')
 
 '''
 Sample I/O:
     Input:
     1123
     Output:
     kw
     kbc
     alc
     aaw
     aabc
 
 Time Complexity: O(N), where N =String
 Space Complexity: O(1)
 '''
",Python
"/* 
 Quick Sort in Dart
 
 Quicksort algorithm is based on the divide and conquer approach where
   1. An array is divided into subarrays by selecting a pivot element.
   2. The left and right subarrays are also divided using the same approach. 
     This process continues until each subarray contains a single element.
   3. At this point, elements are already sorted. Finally, elements are 
     combined to form a sorted array.
 */
 
 import 'dart:io';
 
 // function to find the partition position
 int partition(var array, int low, int high) {
   // choosing rightmost element as pivot
   int pivot = array[high];
   // pointer for greater element
   int i = low - 1;
 
   for (int j = low; j < high; j++) {
     // compare each element with pivot
     if (array[j] <= pivot) {
       i = i + 1;
       // if element smaller than pivot is found swap it i
       int temp = array[j];
       array[j] = array[i];
       array[i] = temp;
     }
   }
   // swapping pivot with greater element
   int temp = array[i + 1];
   array[i + 1] = array[high];
   array[high] = temp;
 
   // return the position from where partition is done
   return i + 1;
 }
 
 // function to perform quicksort
 void quickSort(array, low, high) {
   if (low < high) {
     // find pivot element such that
     // element smaller than pivot are on left and greater than are at right
     int pi = partition(array, low, high);
     quickSort(array, low, pi - 1);
     quickSort(array, pi + 1, high);
   }
 }
 
 // main function
 void main() {
   var data = [];
 
   // taking input from user and storing it in data array
   var n, ele;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     data.add(ele);
   }
 
   // Implementing quick sort
   quickSort(data, 0, n - 1);
 
   // displaying sorted array
   print(data);
 }
 
 /*
 
 Time Complexitie",Dart
"/*Vigenere Cipher Algorithm is a famous cryptographic algorithm.
 Vigenre cipher is a method of encrypting alphabetic text by using a series of interwoven Caesar ciphers*/
 
 #include <stdio.h>
 #include <string.h>
 
 char key[100];
 int x;
 
 void encryption(char message[]) {
 	for (int i = 0; i < strlen(message); ++i) {
 		int t=(message[i] + key[i%x])%26;
     	message[i]=('A'+t);
 	}
 }
 
 void decryption(char message[]) {
 	for (int i = 0; i < strlen(message); ++i) {
 	    int t=(message[i] - key[i%x] +26)%26;
 	    message[i]=('A'+t);
 	}
 }
 
 int main() {
 	char message[100];
 	printf(""Enter Message To Encode: "");
 	scanf(""%s"", message);
 	//use only uppercase characters (you can modify the code for lowercase characters)
 	printf(""\nEnter Key:"");
 	scanf(""%s"", key);
 	x=strlen(key);
 
 	printf(""Generated Key: %s\n"", key);
 	encryption(message);
 	printf(""Encrypted Message: %s\n"",message);
 
 	decryption(message);
 	printf(""Decrypted Message: %s"",message);
 	return 0;
 }
 
 /*
 OUTPUT
 Generated Key: NEOALGO
 Encrypted Message: GIGSPXOPXQOOOBTRSOLRUB
 Decrypted Message: TESSERACTCODINGNEOALGO
 */
",C
"/**
  * Maximum of Minimum for Every Window Size in an Array
  * Find the maximum of the minimum of every window size in a given 
  * positive integer array of size len. The size of windows in an array 
  * vary from 1 to len. 
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void printMaxOfMin(int arr[], int len)
 { // Used to find previous and next smaller
     stack<int> s;
 
     // Arrays to store previous and next smaller
     int left[len + 1];
     int right[len + 1];
 
     // Initialize elements of left[] and right[]
     for (int i = 0; i < len; i++) {
         left[i] = -1;
         right[i] = len;
     }
 
     // Fill elements of left[]
     /* If stack is not empty, then pop an element from stack. 
        If the popped element is smaller than next, then 
     a) store it in left[]
     b) keep popping while elements are 
     smaller and stack is not empty */
     for (int i = 0; i < len; i++) {
         while (!s.empty() && arr[s.top()] >= arr[i])
             s.pop();
 
         if (!s.empty())
             left[i] = s.top();
         /* push next to stack so that we can find next greater for it */
         s.push(i);
     }
 
     // Empty the stack as stack is going to be used for right[]
     while (!s.empty())
         s.pop();
 
     // Fill elements of right[] using same logic as left
     for (int i = len - 1; i >= 0; i--) {
         while (!s.empty() && arr[s.top()] >= arr[i])
             s.pop();
 
         if (!s.empty())
             right[i] = s.top();
 
         s.push(i);
     }
 
     // Create and initialize answer array
     int ans[len + 1];
     for (int i = 0; i <= len; i++)
         ans[i] = 0;
 
     // Fill answer array by comparing minimums of all
     // lengths computed using left[] and right[]
     for (int i = 0; i < len; i++) {
         // length of the interval
         int len = right[i] - left[i] - 1;
 
         // arr[i] is a possible answer for this length
         // 'len' interval, check if arr[i] is mo",C-Plus-Plus
"/*
 Approach :First sort the array then, swap pairs of elements
 except the first element. Example - keep a[0], swap a[1] with a[2], swap a[3] with a[4], and so on.
 So, we will take array and its size as parameters, run a loop from i to size of the array 
 and swap every pair of element using swap function. At the end of loop, we will print the array.
 */
 #include <bits/stdc++.h>
 using namespace std;
 /*helper function that converts given array in zig-zag form*/
 void zigzag(int a[] , int n)
 {
     for(int i=1; i<n; i+=2)
     {
         if(i+1<n)
             swap(a[i],a[i+1]);
     }
     cout<<""\nZig-Zag array is : "";
     for(int i=0 ; i<n ; i++)
         cout<<a[i]<<""  "";
 }
 /*Driver Program*/
 int main()
 {
     int n;
     cout<<""Enter size of array : "";
     cin>>n;
     int a[n];
     cout<<""Enter array : ""<<endl;
     for(int i=0; i<n; i++)
         cin>>a[i];
     sort(a,a+n);
     zigzag(a,n);
     return 0;
 }
 
 /*
 
 Sample Input/Output:
 
 Input: Enter size of array : 7
        Enter array :
        4
        3
        7
        8
        6
        2
        1
 
 Output:Zig-Zag array is : 1  3  2  6  4  8  7
 
 Time Complexity : O(n log n); because we are using sorting.
 Space Complexity : O(1)
 
 */
 
",C-Plus-Plus
"'''
 
 The program helps to count the number of
 vowels and consants in a string.
 
 '''
 
 def Count(word):
     vc, cc = 0, 0
 
     for s in word:
         if (s.isalpha()):
             if (s == 'a' or s == 'e' or s == 'i' or s == 'o' or s == 'u'):
                 vc = vc + 1
             else:
                 cc = cc + 1
     return vc, cc
 
 if __name__ == ""__main__"":
     TheWord = input(""Enter a string: "").lower()
     vc, cc = Count(TheWord)
     print(""Vowel count = "", vc, "" Consonant count = "", cc)
 
 else:
         print(""File one executed when imported"")
 
 
 """"""
 Time Complexity: O(n)
 
 Sample Input:
 Enter a string: Hello World
 
 Sample Output:
 Vowel count =  3  Consonant count =  7
 """"""
",Python
"/* This program calculates nth Catalan number using Dynamic programming.
 The solutions to the nth Catalan number is calculated in bottom-up manner.
 There by reducing the time complexity.*/
 
 #include <iostream>
 using namespace std;
 
 // This function returns nth catalan number
 long long int n_catalan(long int number) {
 
 	// Makes an array to store the catalan numbers
 	long long int array[number + 1];
 
 	// Base cases
 	array[0] = 1;
 	array[1] = 1;
 
 	// Initializing the array to all zeroes.
 	for(int i = 2; i < number + 1; i++) {
 		array[i] = 0;
 	}
 
 	// Using DP recursive solution to get nth catalan number
 	for(int i = 2; i < number + 1; i++) {
 		for(int j = 0; j < i; j++) {
 			array[i] += array[j] * array[i - j - 1];
 		}
 	}
 
 	// Return the nth catalan number
 	return array[number];
 }
 
 int main() {
 
 	// Take number as input from the user
 	long int number;
 	cout << ""Enter a number: "";
 	cin >> number;
 
 	if(number < 0) {
 		cout << ""\nPlease enter a non-negative number."" << endl;
 		exit(0);
 	}
 
 	// Print the nth catalan number
 	cout << ""\nCatalan number at index "" << number << "" is "" << n_catalan(number) << endl;
 	return 0;
 }
 
 /*
 Sample I/O:
 
 1)
 Enter a number: 10
 
 Catalan number at index 10 is 16796
 
 2)
 Enter a number: -23
 
 Please enter a non-negative number.
 
 */
",C-Plus-Plus
"/*
 Check wether the array is Palindrome by using DART.
 
 Given an array of integers, check wether the array is Palindrome or not.
 */
 
 import 'dart:io';
 
 int palindrome_array(var array, int len) {
   int flag = 0;
   for (int i = 0; i <= len ~/ 2; i++) {
     if (array[i] != array[len - i - 1]) {
       flag = 1;
       break;
     }
   }
   return flag;
 }
 
 void main() {
   var data = [];
 
   // taking input from user and storing it in data array
   var n, ele;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     data.add(ele);
   }
 
   print(""\nInputted array is $data"");
   int ans = palindrome_array(data, n);
   if (ans == 1)
     print(""Array is not a Palindrome"");
   else
     print(""Array is a Palindrome"");
 }
 
 /*
 TIME COMPLEXITY: O(n)
 SPACE COMPLEXITY: O(1)
 
 Example 1:
 
 Enter the number of Elements: 
 3
 Enter Element 1: 
 1
 Enter Element 2:
 2
 Enter Element 3:
 3
 
 Inputted array is [1, 2, 3]
 Array is not a Palindrome
 
 Example 2:
 
 Enter the number of Elements: 
 5
 Enter Element 1: 
 1
 Enter Element 2: 
 2
 Enter Element 3: 
 3
 Enter Element 4: 
 2
 Enter Element 5: 
 1
 
 Inputted array is [1, 2, 3, 2, 1]
 Array is a Palindrome
 */
",Dart
"/*
 Prefix expression:- An expression is called the prefix expression if the operator appears in the expression before the operands
 Example: operator operand1 operand2
 This program is for evaluating prefix expression.
 In this we evaluate the given prefix expression using stack
 */
 
 // creating stackarr 
 var stackarr=[];
 
 // Initialize topp variable with -1
 var topp=-1;
 
 // creating evalstack
 var evalstack=[];
 
 // function for evaluating prefix expression
 function prefixevaluator(evalst)
 {
     eval=evalst.split("" "");
    for(var i=eval.length-1;i>=0;i--)
    {
        if(!operator(eval[i]))
        {
            push(eval[i]);
        }
        else
        {
            var op1=parseInt(pop());
            var op2=parseInt(pop());
            
            if(eval[i]==""+"")
            {
                push(op1+op2);
            }
            else if(eval[i]==""-"")
            {
                push(op1-op2);
            }
            else if(eval[i]==""*"")
            {
                push(op1*op2);
            }
            else
            {
                push(op1/op2);
            }
        }
    }
    console.log(pop());
 }
 
 // function for push 
 function push(e)
 {
    topp++;
    stackarr[topp]=e;
 }
 
 // function for pop out
 function pop()
 {
     if(topp==-1)
     return 0;
     else
     {
         var popped_ele=stackarr[topp];
         topp--;
         return popped_ele;
     }
 }
 
 // function for checking whether operator or not 
 function operator(op)
 {
     if(op=='+' || op=='-' || op=='^' || op=='*' || op=='/' || op=='(' || op==')')
     {
         return true;
     }
     else
     return false;
 }
 
 // function for checking precedency
 function precedency(pre)
 {
     if(pre=='@' || pre=='(' || pre==')')
     {
         return 1;
     }
     else if(pre=='+' || pre=='-')
     {
         return 2;
     }
     else if (pre=='/' || pre=='*')
     {
         return 3;
     }
     else if(pre=='^')
     {
         return 4;
   ",JavaScript
"/*Problem Statement: 
 The member states of the UN are planning to send  people to the moon.
 They want them to be from different countries. You will be given a list of pairs of astronaut ID's. 
 Each pair is made of astronauts from the same country. 
 Determine how many pairs of astronauts from different countries they can choose from. */
 
 #include<bits/stdc++.h>
 using namespace std;
     
 list<int> *ad;
 int *visited;
 int vertices;
     
 void DFS(int u)
 {
     visited[u] = 1;
     vertices++;
     list<int>::iterator it;
     for(it=ad[u].begin();it!=ad[u].end();it++)
     {
         //If the node is not visited
         if(visited[*it] == 0)
         {
             visited[*it] = 1;
             DFS(*it);
         }
     }
 }
     
 int main()
 {
     int no_astronauts,pairs,u,v,numComponents=0,all_vertices=0,temp=2,count=0;
     int eachC[1000];
     cout << ""Enter total number of astronauts and the total no of pairs: ""<<endl;
     cin >> no_astronauts >> pairs;
     if(no_astronauts == 1)
     {
         cout <<""0""<<endl;
         return 0;
     }
     ad = new list<int>[no_astronauts];
     list<int>::iterator it;
     cout<<""Enter id and nationality: ""<<endl;
     for(int i=0;i<pairs;i++)
     {
         cin >> u >> v;
         ad[u].push_back(v);
         ad[v].push_back(u);    
     }
     visited = new int[no_astronauts];
     for(int i=0;i<no_astronauts;i++)
     {
         visited[i] = 0;
     }
     for(int i=0;i<no_astronauts;i++)
     {
         if(visited[i] == 0)
         {
             vertices = 0;
             DFS(i);
             eachC[numComponents] = vertices;
             numComponents++;
         }
     }
     int totalWays = no_astronauts*(no_astronauts-1) / 2;
     int sameWays = 0;
     for(int i=0;i<numComponents;i++)
     {    
         sameWays = sameWays + (eachC[i]*(eachC[i]-1) / 2);
     }
     cout << ""Total chosen pairs: "" << (totalWays - sameWays) << endl;
     return 0;
 }
 /*Example:-
 
 Input:-
 Enter total number of as",C-Plus-Plus
"/*
 
 In a circular Singly linked list, the last node of the list contains a pointer to the first node of the list.
 We can have circular singly linked list as well as circular doubly linked list.
 We traverse a circular singly linked list until we reach the same node where we started. 
 The circular singly liked list has no beginning and no ending. There is no null value present in the next part of any of the nodes.
 
 In this program, user can provide a choice to perform operations on a Circular Singly Linked List. It is created using a ES6 class syntax. 
 prompt & colors are node packages for taking user input and displaying text in different colors respectively. 
 
 */
 
 const prompt = require(""prompt-sync"")({ sigint: true });
 const colors = require(""colors"");
 
 // Setting the color schema
 colors.setTheme({
   display: ""green"",
   insert: ""white"",
   delete: ""red"",
   leave: ""yellow"",
   end: ""rainbow"",
   wrong: ""america"",
 });
 
 // Creating the node class to create nodes
 class Node {
   constructor(value, next = null) {
     this.value = value;
     this.next = next;
   }
 }
 
 // Creating Circular Singly Linked List class to perform operations
 class CircularLinkedList {
   constructor(value) {
     this.head = null;
     this.tail = this.head;
     this.length = 0;
   }
 
   // Looping to a given index in Linked List
   traverseToIndex(index) {
     let counter = 1;
     let currentNode = this.head;
 
     while (counter !== index) {
       currentNode = currentNode.next;
       counter++;
     }
 
     return currentNode;
   }
 
   // Handling the very first node of Linked List
   firstNode(value) {
     let newNode = new Node(value);
 
     this.head = newNode;
     this.head.next = this.head;
     this.tail = this.head;
 
     this.length++;
     return this;
   }
 
   // Appending ( at the end ) node in Linked List
   append(value) {
     if (!this.head) return this.firstNode(value);
     let newNode = new Node(value);
 
     this.tail.next = newNo",JavaScript
"/*Unique_Number_III
 Given an array that contains all elements occurring 3 times, but one occurs only once. Find that unique element.*/
 #include <iostream>
 using namespace std;
 int main()
 {
 	int cnt[64] = {0};
 	int n, no;
 	cin >> n;
 	for (int i = 0; i < n; i++)
 	{
 		cin >> no;
 
 		int j = 0;
 		while (no > 0)
 		{
 			int last_bit = (no & 1);
 			cnt[j] += last_bit;
 			j++;
 			no = no >> 1;
 		}
 	}
 	int p = 1;
 	int ans = 0;
 	for (int i = 0; i < 64; i++)
 	{
 		cnt[i] %= 3;
 		ans += (cnt[i] * p);
 		p = p << 1;
 	}
 	cout << ans << endl;
 	return 0;
 }
 /*
 Input : arr[] = {6, 2, 5, 2, 2, 6, 6}
 Output : 5	
 Time Complexity:O(n)
 */
",C-Plus-Plus
"/**
  * XOR Cipher method is used for data encryption. It works upon a property of XOR operation according to which a ^ b = c, then c ^ b = a.
  * This encryption is done by taking a specific key which can be any character of your choosing.
  * Then XOR operation is performed on every character of the string with the key chosen which ends in the formation of encoded string.
  * The encoded string is decoded again by passing the encoded string again to the function which gives us back the original string.
  * 
  */
 
 import java.util.*;
 
 public class XORCipher{
     //this function is used for decoding as well as encoding of data
     static String process(String s){
         char[] charArray = s.toCharArray();
         char key = 'M'; //any key can be choosen
         String output = """"; //used to store output of function
 
         for(int i = 0; i < charArray.length; i++)
             output += (char)(charArray[i] ^ key); //XOR operation on character of string with key
         return output; 
     }
 
     public static void main(String[] args){
         Scanner sc = new Scanner(System.in);
 
         System.out.print(""Enter the string to be encrypted : "");
         String s = sc.next();
 
         String encoded = process(s); //storing the encoded data
         System.out.println(""Data after encoding : ""+ encoded);
         String decoded = process(encoded); //decoding the encoded data
         System.out.println(""Data after decoding : ""+ decoded);
         sc.close();
     }
 }
 /**
  * Complexity :
  * Time Complexity : O(N)
  * Space Complexity : O(N)
  *
  * Sample Output :
  * Enter the string to be encrypted : XORCipher
  * Data after encoding : $=%(?
  * Data after decoding : XORCipher
  */
",Java
"// C program to illustrate Affine Substitution Cipher
 
 /*
 The Affine Substitution cipher is a type of monoalphabetic substitution cipher wherein each letter in an alphabet
 is mapped to its numeric equivalent encrypted using a simple mathematical function and converted back to a letter.
 */
 
 #include <stdio.h>
 #include <string.h>
 #include <ctype.h>
 #include <stdlib.h>
 // function declaration
 int CalculateGCD(int);
 int CalculateMultiplicativeInverse(int);
 
 int main()
 {
     int size = 0;
     int index, indx, k, gcd, alpha, beta, num_msg[size], numcipher[size], numdecipher[size], decipher[size], alphaInverse;
     char *msg, *cipher;
     printf(""Input:\n"");
     printf(""Enter the size of the array: "");
     scanf(""%d"", &size);
     // allocating memory dynamically
     msg = (char *)malloc(size * sizeof(char));
     if (msg == NULL)
     {
         printf(""memory cannot be allocated\n"");
     }
     else
     {
         printf(""Enter the Cipher message: "");
         scanf(""%s"", &*(msg));
     }
 
     //converting entered string to Capital letters
     for (index = 0, indx = 0; index < strlen(msg); index++)
     {
         if (msg[index] != ' ')
         {
             msg[indx] = toupper(msg[index]);
             indx++;
         }
         else
         {
             msg[indx] = ' ';
             indx++;
         }
     }
     //adding '\0' at end of string
     msg[indx] = '\0';
     printf(""Enter the value of the key alpha: "");
     scanf(""%d"", &alpha);
     //Checking whether key alpha is in range of(1-25)
     if (alpha < 1 || alpha > 25)
     {
         printf(""Alpha should lie in between 1 and 25\nTry again !\n"");
         exit(0);
     }
 
     //  calling CalculateGCD function
     gcd = CalculateGCD(alpha);
     if (gcd != 1)
     {
         printf(""Mandatory condition : gcd(alpha,26)=1 but \n gcd(%d,26)=%d\n Try again !\n"", alpha, gcd);
         exit(0);
     }
 
     printf(""Enter the value of the key beta: "");
     scanf(""%d"", &beta);
  ",C
"#= Finding the Nth number in the Fibonacci Sequence using Dynamic Programming
 =#
 
 ## Function 
 
 function fibonacci(n)
     f = Int64[]
     push!(f, 0)
     push!(f, 1)
     for i = 3:n
         temp = f[i-1] + f[i-2]
         push!(f, temp)
     end
     return f[n]
 end
 
 ## Input 
 
 print(""Enter the number: "")
 n = readline()
 n = parse(Int64, n)
 println(""The $(n)th fibonacci number is "")
 
 ## Calling the function 
 
 fibonacci(n)
 
 #=
 Sample Test Case:
 Input: 
     Enter the number: 5
 Output:
     The 5th fibonacci number is 3
 
 Time Complexity: O ( N )
 =#
",Julia
"/*
 A Dynamic Programming based C program to find minimum 
 number operations to convert string1 to string2
 */
 
 #include <stdio.h>
 #include <string.h>
 	// Utility function to find the minimum of three numbers 
 int mincount(int count1, int count2, int count3)
 {
 	if (count1 <= count2 && count1 <= count3)
 		return count1;
 	else if (count2 <= count1 && count2 <= count3)
 		return count2;
 	else
 		return count3;
 }
 int editDistDP(char str1[], char str2[], int str1Len, int str2Len)
 {
 	// Create a table to store results of subproblems 
 	int dp[str1Len + 1][str2Len + 1];
 	// Fill d[][] in bottom up manner 
 	for (int indexstr1 = 0; indexstr1 <= str1Len; indexstr1++)
 	{
 		for (int indexstr2 = 0; indexstr2 <= str2Len; indexstr2++)
 		{ /*If first string is empty, only option is to 
 			   insert all characters of second string */
 			if (indexstr1 == 0)
 				// Min. operations = indexstr2
 				dp[indexstr1][indexstr2] = indexstr2;
 			/* If second string is empty, only option is to 
 			    remove all characters of second string */
 			else if (indexstr2 == 0)
 				dp[indexstr1][indexstr2] = indexstr1;	// Min. operations = loop
 			/*If last characters are same, ignore last char 
 			   and recur for remaining string */
 			else if (str1[indexstr1 - 1] == str2[indexstr2 - 1])
 				dp[indexstr1][indexstr2] = dp[indexstr1 - 1][indexstr2 - 1];
 			/*If the last character is different, consider all 
 			  possibilities and find the minimum */
 			else
 				dp[indexstr1][indexstr2] = 1 + mincount(dp[indexstr1][indexstr2 - 1],	// Insert 
 					dp[indexstr1 - 1][indexstr2],	// Remove 
 					dp[indexstr1 - 1][indexstr2 - 1]);	// Replace 
 		}
 	}
 	return dp[str1Len][str2Len];
 }
 // Driver program 
 int main()
 {
 	char string1[20];
 	char string2[20];
 	int n;
 	printf(""\n Input: "");
 	printf(""\n Enter the first string:"");
 	gets(string1);
 	printf(""\n Enter the second string:"");
 	gets(string2);
 	n = editDistDP(string1, string2, strlen(string1), strlen(string2))",C
"# Take input for class TestCase
 print(""Enter Number of TestCase :"")
 testcase = int(input())
 # Iterate till TestCase
 for item in range(testcase):
     # Take input for str1 and str2
     print(""\nEnter value for str1 and str2 :"")
     str1, str2 = input().split()
     # Base Cases
     index1 = 0
     index2 = 0
     len1 = len(str1)
     len2 = len(str2)
     # Iterate till index1 and index2
     # Is less than len1 and len2
     while index1 < len1 and index2 < len2:
         if str1[index1] == str2[index2]:
             index1 += 1
             index2 += 1
         else:
             index2 += 1
     print(""\tOUTPUT\n"")
     # print yes if A is a subsequence of B.
     if index1 == len1:
         print (""YES! String1 is subsequence of String2"")
     # else print No
     else:
         print (""NO! String1 is not subsequence of String2"")
 
 # Sample Input output:
 # Enter Number of TestCase : 2
 # Enter value for str1 and str2 :AXY YADXCP
 #    OUTPUT
 # NO! String1 is not subsequence of String2
 # Enter value for str1 and str2 :AXY ADXCPY
 #   OUTPUT
 # YES! String1 is subsequence of String2
 # Time Complexity:O(n)
",Python
"/*
 Convert Sorted Array to Binary Search Tree
 
 You are given an array of integers arr[], where 
 the elements of the array are sorted in ascending order, 
 your task is to convert it to a height balenced binary 
 search tree which is a binary tree in which the depth of 
 the two subtrees of every node never differs by more than one.
 */
 
 import java.io.*;
 import java.util.Scanner;
 import java.util.*;
 
 //defining a class for storing nodes of tree
 class BTNode 
 {
     int value;
     BTNode left;
     BTNode right;
     BTNode() 
     {}
     BTNode(int value) 
     {
         this.value = value; 
     }
     BTNode(int value, BTNode left, BTNode right) 
     {
         this.value = value;
         this.left = left;
         this.right = right;
     }
 }
 
 public class SortedArrayToBST
 {
     //function to convert the sorted array to BST
     public BTNode sortedArrtoBST(int[] arr)
     {
         //if the array is empty then simply return zero
         if(arr == null || arr.length == 0)
         {
             return null;
         }
 
         //otherwise recursively call the array and then construct the BST
         return constructBST(arr, 0, arr.length - 1);
     }
 
     //function to construct the BST
     public BTNode constructBST(int[] arr, int left, int right)
     {
         int lftprt = left;
         int rtprt = right;
         //if the left pointer is greater than right pointer 
         //then then simply return
         //this is a kind of check for sorted array
         if(lftprt > rtprt)
         {
             return null;
         }
 
         //otherwise we go for recursive call
         int mid = lftprt + (rtprt - lftprt) / 2;
         BTNode curr = new BTNode(arr[mid]);
         curr.lftprt = constructBST(arr, lftprt, mid - 1);
         curr.rtprt = constructBST(arr, mid + 1, rtprt);
 
         //returning the node generated
         return curr;
     }
 
     //drivers code 
     public static void main (String[] args) throws IOEx",Java
"/*
 The traversal operation is a frequently used operation on a binary tree. This operation is used to visit each node in the tree exactly once
 A full traversal on a binary tree gives a linear ordering of data in the tree .  This is the iterative inorder tree traversal algorithms
 */
 #include <stdio.h>
 #include <stdlib.h>
 //structure for the binary tree node
 typedef struct Tree
 {
     char data;
     struct Tree *left;
     struct Tree *right;
 } TreeNode;
 //structure for stack which is used for the iterative traversal algorithms
 //stack is implemented using linked list
 typedef struct Stack
 {
     TreeNode *node;
     struct Stack *next;
 } Stack;
 //push operation for the stack
 void push(Stack **s, TreeNode *node)
 {
     Stack *New = (Stack *)malloc(sizeof(Stack));
     New->node = node;
     New->next = (*s);
     (*s) = New;
 }
 // pop operation for the stack
 TreeNode *pop(Stack **s)
 {
     if ((*s) != NULL)
     {
         TreeNode *ptr = (*s)->node;
         (*s) = (*s)->next;
         return ptr;
     }
 }
 //checks whether the stack is empty or not
 int isEmpty(Stack **s)
 {
     if ((*s) == NULL)
     {
         return 1;
     }
     return 0;
 }
 //iterative inorder traversal
 void inorder(TreeNode *root)
 {
     TreeNode *ptr = root;
     Stack *s = NULL;
     while (!isEmpty(&s) || ptr != NULL)
     {
         if (ptr != NULL)
         {
             push(&s, ptr);
             ptr = ptr->left;
         }
         else
         {
             ptr = pop(&s);
             printf(""%c "", ptr->data);
             ptr = ptr->right;
         }
     }
 }
 //Search_Link returns the pointer to the node which contains the value key , it is used in the insertion operation
 TreeNode *Search_Link(TreeNode *root, char key)
 {
     TreeNode *ptr = root;
     if (ptr->data != key)
     {
         if (ptr->left != NULL)
         {
             Search_Link(ptr->left, key);
         }
         if (ptr->right != NULL)
         {
             Search_Link(ptr->rig",C
"/* There is an array of n integers. There are also 2 disjoint sets, A and B, each containing m integers.
 You like all the integers in set A and dislike all the integers in set B. Your initial happiness is 0. 
 For each i integer in the array, if i e A , you add 1 to your happiness. If i e B, you add -1 to your happiness.
 Otherwise, your happiness does not change. Output your final happiness at the end.
 
 	Input Format
 	
 	The first line contains integers n and m separated by a space.
 	The second line contains n integers, the elements of the array.
 	The third and fourth lines contain m integers, A and B, respectively.
 	
 	Output Format
 	
 	Output a single integer, your total happiness.
 	
 Problem Link: https://www.hackerrank.com/challenges/no-idea/problem
 */
 
 #include<stdio.h>
 
 int countHappiness(int arr[], int n, int m, int A[], int B[]) {
   int happiness = 0, i, j;
 
   for (i = 0; i < n; i++) {
     for (j = 0; j < m; j++) {
 
       if (A[j] == arr[i]) {
         happiness += 1;
         break;
       }
 
       if (B[j] == arr[i]) {
         happiness -= 1;
         break;
       }
     }
   }
   return happiness;
 }
 
 int main() {
   int i, n, m, arr[100000], A[100000], B[100000], totalHappy;
 
   printf(""Enter the value of n and m: "");
   scanf(""%d%d"", & n, & m);
 
   printf(""Enter the elements of array: "");
   for (i = 0; i < n; i++)
     scanf(""%d"", & arr[i]);
 
   printf(""Enter the elements of set A: "");
   for (i = 0; i < m; i++)
     scanf(""%d"", & A[i]);
 
   printf(""Enter the elements of set B: "");
   for (i = 0; i < m; i++)
     scanf(""%d"", & B[i]);
 
   totalHappy = countHappiness(arr, n, m, A, B);
   printf(""Total happiness= %d"", totalHappy);
 
   return 0;
 }
 
 /*
 	Sample input/output
 	Enter the value of n and m: 3 2
 	Enter the elements of array: 1 5 3
 	Enter the elements of set A: 3 1
 	Enter the elements of set B: 5 7
 	Total happiness= 1
 	
 	Time Complexity= O(n^2) 
 	Space Complexity= O(1)
 */
",C
"# breadth first search.
 
 #a key-value pair represent a vertex and all it's outward edges.
 adjacent = {}
 #stores the list of vertex.
 Vertex = []
 # a key-value pair represents a vertex and its level.
 # level of the root node is zero.
 level = {}
 # a key-value pair represents a vertex and its parent.
 parent = {}
 
 def initalizeVertex():
     n = int(input('Enter the no. of vertices.\n'))
     print(""Enter the vertexes."")
     for i in range(n):
         vertex = input()
         Vertex.append(vertex)
         adjacent[vertex] = []
 
 def initalizeUndirectedEdges():
     n = int(input(""Enter the no. of edges.\n""))
     print(""Enter the space seperated edges."")
     for i in range(n):
         a,b = input().split()
         adjacent[a].append(b)
         adjacent[b].append(a)
 
 def initalizeDirectedEdges():
     n = int(input(""Enter the no. of edges.\n""))
     print(""Enter the space seperated edges."")
     for i in range(n):
         a,b = input().split()
         adjacent[a].append(b)    
 
 def showVertex():
     print('The vertexes are: ')
     print(Vertex)
     print('\n')
 
 def showEdges():
     print('The dictionary of edges are: ')
     print(adjacent)
     print('\n')
 
 def bfs():
     frontier = []
     neighbour = []
     start = input('Enter the first node.\n')    
     level[start] = 0
     parent[start] = None
     level_no = 1
     frontier.append(start)
 
     while len(frontier):
         neighbour = []
         for u in frontier:
             for v in adjacent[u]:
                 if v not in level.keys():
                     level[v] = level_no
                     parent[v] = u
                     neighbour.append(v)
         frontier = neighbour.copy()
         level_no +=1    
 
 # program starts here.
 
 initalizeVertex()
 initalizeUndirectedEdges()  
 #showVertex()
 #showEdges()
 print('Implementing BFS.')
 bfs()
 print(level)
",Python
"/*Code to find the first index in which 1 appears in an array of 0 and 1
 APPROACH USED -Binary Search
 */
 #include<bits/stdc++.h>
 using namespace std;
 int binSearch(int a[],int n)
 {
     int l=0,r=n-1,mid=0;
     while(l<=r)
     {
         mid=(l+r)/2;
         if(a[mid]==1 && (mid==0 || a[mid-1]==0))
         return mid+1;
         else if(a[mid]==1)
         r=mid-1;
         else l=mid+1;
     }
     return -1;
 }
 int main()
 {
     int n;
     cin>>n;
     int a[n];
     cout<<""Enter only 1 and 0 in sorted order\n"";
     for(int i=0;i<n;i++)
     cin>>a[i];
     sort(a,a+n);
     cout<<binSearch(a,n);
 }
 /*
 TIME COMPLEXITY: O(nlogn)
 INPUT:
 5
 Enter only 1 and 0 in sorted order
 1 1 1 1 1
 OUTPUT:1
 
 INPUT:
 5
 Enter only 1 and 0 in sorted order
 0 0 0 0 0
 OUTPUT:-1
 */
",C-Plus-Plus
"package main
 
 import (
 	""fmt""
 	""math""
 )
 
 // Area of a Rectangle
 
 func rectangle(l, b float64) float64 {
 	return l * b
 }
 
 // Area of a Square
 
 func square(l float64) float64 {
 	return l * l
 }
 
 // Area of a Triangle
 
 func triangle(b, h float64) float64 {
 	return (b * h) / 2.0
 }
 
 // Area of a Circle
 
 func circle(r float64) float64 {
 	return math.Pi * math.Pow(r, 2)
 }
 
 // Area of a Parallelogram
 
 func parallelogram(b, h float64) float64 {
 	return b * h
 }
 
 // Area of a Trapezium
 
 func trapezium(a, b, h float64) float64 {
 	return (a + b) * h / 2.0
 }
 
 func main() {
 	fmt.Println(rectangle(3.0, 5.0))
 	fmt.Println(square(4.0))
 	fmt.Println(triangle(4.0, 6.0))
 	fmt.Println(circle(3.5))
 	fmt.Println(parallelogram(4.0, 7.0))
 	fmt.Println(trapezium(4.0, 3.5, 6.5))
 }
 
 // Time Complexity - O(1)
 // Space Complexity - O(1)
",Go
"#include <stdio.h>
 #include <stdlib.h>
 #define MAX(a,b) (((a)>(b))?(a):(b))
 
 int main(void) {
     
 	// Accepting an array 
 	int size;
 	printf(""Enter the size of the array "");
 	scanf (""%d"", &size);
 	
 	printf(""Enter elements of array \n"");
 	int arr[size];
 	for (int index = 0; index < size; index++ ){
 	    scanf(""%d"", &arr[index]);
 	}
 	
 	//KADANE'S ALGORITHM
 	int max_sum  = arr[0];
 	int curr_max = arr[0];
 	for (int index = 1; index < size; index++ ){
 	    curr_max = MAX(arr[index], arr[index] + curr_max);
 	    max_sum = MAX(curr_max, max_sum);
 	}
 	
 	printf(""Maximum sum of subarray is %d \n"", max_sum);
 	
 	return 0;
 }
 
 /*
 TIME COMPLEXITY : O(n) where n is number of elements in array
 SPACE COMPLEXITY : O(1) as no new space is allocated
 TEST CASE 
 
 INPUT
 Enter number of elemets in array 4
 Enter elemets of array  2 -3 4 6 
 
 OUTPUT
 Maximum sum of subarray is 10 
 
 
 INPUT
 Enter number of elemets in array 4
 Enter elemets of array  2 3 4 6 
 
 OUTPUT
 Maximum sum of subarray is 15 
 */
 
",C
"/**
 Topological sort is linear ordering of vertices
 in a directed acyclic graph (DAG). This algorithm is useful in 
 solving many other applications on DAG
 **/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void dfs_visit(vector<vector<int>>& Graph, int src, stack<int>& s, vector<bool>& visit) {
 	visit[src] = 1;
 	for(int i = 0; i < Graph[src].size(); i++)
 		if(visit[Graph[src][i]] == 0)
 		    dfs_visit(Graph, Graph[src][i], s, visit);
     s.push(src);
 }
 
 void dfs(vector<vector<int>>& Graph, int v, stack<int>& s) {
 	vector<bool> visit(v);
 	for(int i = 0; i < v; i++)
 		if(visit[i] == 0)
 			dfs_visit(Graph, i, s, visit);
 }
 
 void topological_sort(vector<vector<int>>& Graph, int v) {
 	stack<int> s;
 	dfs(Graph, v, s);
 	while(!s.empty()) {
 		cout << s.top() << ' ';
 		s.pop();
 	}
 	cout << '\n';
 }
 
 int main() {
 	int v, e, a, b;
 	// all vertices are labelled from 0 to v-1
 	cin >> v >> e;
 	vector<vector<int>> Graph(v);
 	// all directed edges
 	for(int i = 0; i < e; i++) {
 		cin >> a >> b;
 		// edge a -> b
 		Graph[a].push_back(b);
 	} 
 	topological_sort(Graph, v);
 	return 0;
 }
 
 /**
 Input :
 6 8
 0 3
 0 4
 0 5
 1 5
 1 0
 2 1
 3 4
 4 5
 Output :
 2 1 0 3 4 5
 
 Time Complexity : O(v+e)
 Space Complexity : O(v)
 **/
",C-Plus-Plus
"// Program to Implement a Queue
 #include <stdio.h>
 #include <stdlib.h>
 #define MAX 50
 void insert();
 void delete();
 void display();
 int queue_array[MAX];
 int rear = -1;
 int front = -1;
 int main()
 {
 	int choice;
 	while (1)
 	{
 		printf(""1.Insert element to queue \n"");
 		printf(""2.Delete element from queue \n"");
 		printf(""3.Display all elements of queue \n"");
 		printf(""4.Quit \n"");
 		printf(""Enter your choice : "");
 		scanf(""%d"", &choice);
 		switch (choice)
 		{
 			case 1:
 				insert();
 				break;
 			case 2:
 				delete();
 				break;
 			case 3:
 				display();
 				break;
 			case 4:
 				exit(1);
 			default:
 				printf(""Wrong choice \n"");
 		}
 	}
 }
 // Inserting an element
 void insert()
 {
 	int item;
 	if (rear == MAX - 1)
 		printf(""Queue Overflow \n"");
 	else
 	{
 		if (front == -1)
 			front = 0;
 		printf(""Inset the element in queue : "");
 		scanf(""%d"", &item);
 		rear = rear + 1;
 		queue_array[rear] = item;
 	}
 }
 // Deleting an element
 void delete()
 {
 	if (front == -1 || front > rear)
 	{
 		printf(""Queue Underflow \n"");
 		return;
 	}
 	else
 	{
 		printf(""Element deleted from queue is : %d\n"", queue_array[front]);
 		front = front + 1;
 	}
 }
 // Displaying the elements in the queue
 void display()
 {
 	int i;
 	if (front == -1)
 		printf(""Queue is empty \n"");
 	else
 	{
 		printf(""Queue is : \n"");
 		for (i = front; i <= rear; i++)
 			printf(""%d "", queue_array[i]);
 		printf(""\n"");
 	}
 }
 
 /*
 Sample Output
 1.Insert element to queue 
 2.Delete element from queue 
 3.Display all elements of queue 
 4.Quit 
 Enter your choice : 1
 Insert the element in queue : 2
 1.Insert element to queue 
 2.Delete element from queue 
 3.Display all elements of queue 
 4.Quit 
 Enter your choice : 1
 Insert the element in queue : 1
 .Insert element to queue 
 2.Delete element from queue 
 3.Display all elements of queue 
 4.Quit 
 Enter your choice : 3
 Queue is : 
 2 1 
 1.Insert element to queue 
 2.Delete element from queue 
 3.Displ",C
"/*
 Description : 
         Given an integer N, the task is to find the number of groups having the largest size.
         Each number from 1 to N is grouped according to the sum of its digits.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //for finding the sum of number
 int sum_of_digi(int n)
 {
     //initial sum is zero
     int sum = 0;
     while (n)
     {
         //taking out the sum
         sum += n % 10;
         n /= 10;
     }
     return sum;
 }
 
 //map for holding the unqiue sum of number
 map<int, int> mp(int n)
 {
     //for returning answer
     map<int, int> sum_mp;
 
     for (int i = 1; i < n + 1; ++i)
     {
         int sum1 = sum_of_digi(i);
         //if number found
         if (sum_mp.find(sum1) == sum_mp.end())
         {
             sum_mp[sum1] = 1;
         }
         else
         {
             sum_mp[sum1] = sum_mp[sum1] + 1;
         }
     }
 
     return sum_mp;
 }
 //for finding the biggest group in mp
 int largest_grp(int n)
 {
     int size = 0;
     int counter = 0;
     map<int, int> d = mp(n);
     //iterating in mp
     for (auto it = d.begin(); it != d.end(); ++it)
     {
         int x = it->first;
         int y = it->second;
 
         if (y > size)
         {
             size = y;
             counter = 1;
         }
         else if (y == size)
         {
             counter += 1;
         }
     }
 
     return counter;
 }
 
 int main()
 {
     //input number
     int num;
     cout << ""Enter the number : "" << endl;
     cin >> num;
 
     int g_num = largest_grp(num);
     cout << ""The largest group : "" << endl;
     cout << g_num << endl;
 
     return 0;
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Case :
  Input :
  Enter the number : 
  15
 
  Output :
  6
 */
 
",C-Plus-Plus
"/*
 A mystery number is that number which can be expressed as a sum of two 
 numbers and those two numbers must be the reverse of each other
 */
 
 import 'dart:io';
 
 // Function to check if number is a Magic Number
 bool isMysteryNumber(int number) {
   for (int count = 1; count < number / 2; count++) {
     if (count + rev(count) == number) {
       return true;
     }
   }
   return false;
 }
 
 // Function to reverse of a number
 int rev(int number) {
   int temp = number;
   int reverse = 0;
   // Iterate through the number to reverse it
   while (temp != 0) {
     int rem = temp % 10;
     reverse = reverse * 10 + rem;
     temp = (temp / 10).floor();
   }
   return reverse;
 }
 
 // Main function with driver code
 void main() {
   print(""Enter a number :"");
   int num = int.parse(stdin.readLineSync()!);
 
   // Call function to check if number is a Mystery number
   if (isMysteryNumber(num)) {
     print(""$num is a Mystery Number"");
   } else {
     print(""$num is not a Mystery Number"");
   }
 }
 
 /**
 Space Complexity O(1)
 Time Complexity  O(nlog(n))
 
 Sample input/output:
 
 Enter a number :
 121
 121 is a Mystery Number
 
 Enter a number :
 1234
 1234 is not a Mystery Number
 */
 
",Dart
"/*
 Town planner Harry  is assigned to build new houses in the ninja town for its citizens. 
 The town is in the form of a rectangular grid TOWN[][] of (M * N) dimensions where 'M' 
 is the number of rows and 'N' is the number of columns. Each cell of the grid can be an 'empty location' 
 (that can be used for house) denoted by '.' or 'Tree' denoted by 'T'.
 Following Are The Conditions Asked By Citizens For Their House Locations :
 House should not have a house on its left cell
 House should not have a house on its right cell
 House should not have a house on its upper-left cell
 House should not have a house on its upper-right cell
 Return The Maximum Number Of Houses That Can Be Built While Meeting 
 The Citizens' Demands And Not Cutting Any Of The Trees.
 */
 
 #include<bits/stdc++.h>
 #include <vector>
 #include <unordered_set>
 #include <unordered_map>
 using namespace std;
 
 int countSetBits(int mask)
 {
     int count = 0;
     for (int i = 0; i < sizeof(int) * 8; i++)
     {
         if (mask & (1 << i))
         {
             count++;
         }
     }
     return count;
 }
 
 // This bit is on.
 bool on(int bit, int mask)
 {
     return (1 << bit) & mask;
 }
 
 bool checkRowValid(vector<vector<char>> &town, int row, int mask, int n)
 {
     for (int i = 0; i < n; i++)
     {
         // If a house is placed on a tree.
         if (on(i, mask) && town[row][i] == 'T'){
             return false;
         }
         // If there is a house on the left of this house.
         if (i > 0 && on(i - 1, mask) && on(i, mask)){
             return false;
         }
         // If there is a house on the right of this house.
         if (i < n - 1 && on(i + 1, mask) && on(i, mask)){
             return false;
         }
     }
     return true;
 }
 
 bool checkTwoRowCollision(int mask, int nmask, int n)
 {
     for (int i = 0; i < n; i++)
     {
         // If there is a house on the upper left.
         if (i > 0 && on(i, nmask) && on(i - 1, mask)",C-Plus-Plus
"/* Bead sort, also called as gravity sort, is a natural sorting algorithm since this algorithm was inspired
 from natural phenomenons and was designed keeping in mind objects(or beads) falling under the influence of gravity.
 The bead sort operation can be compared to the manner in which beads slide on parallel poles, such as on an abacus.
 However, each pole may have a distinct number of beads. */
 
 // Header file to include STL library
 #include <bits/stdc++.h>
 //For cin and cout
 using namespace std;
 
 void beadSort(vector<int>& nums)
 {
     // find maximum element in vector
     auto max = *max_element(nums.begin(), nums.end());
 
     // declare beads vector for sorting
     vector<unsigned char> beads(max * nums.size(), 0);
 
     // initialize the beads accordingly
     for(auto i = 0; i < nums.size(); i++)
         for(auto j = 0; j < nums[i]; j++)
             beads[i * max + j] = 1;
 
     // Use gravity to let beads fall
     for(auto j = 0; j < max; j++)
     {
         int sum = 0;
         // assign beads for each post
         for(auto i = 0; i < nums.size(); i++)
         {
             sum += beads[i * max + j];
             beads[i * max + j] = 0;
         }
         // Use gravity to bring beads down
         for(auto i = nums.size() - sum; i < nums.size(); i++)
             beads[i * max + j] = 1;
     }
     // put sorted beads back into vector
     for(auto i = 0; i < nums.size(); i++)
     {
         for(auto j = 0; j < max && beads[i * max + j]; ++j)
             nums[i] = j+1;
     }
 
 }
 
 int main()
 {
     // initialize a vector of integers
     vector<int> nums;
     // Declaration of required variables
     int a,n;
     cout<<""Enter the number of elements :"";
     cin>>n;
     cout<<""Enter the elements to be sorted : "";
     //For loop for taking elements from the user, can be space-separated as well
     for(int i=0;i<n;i++){
         cin>>a;
         nums.push_back(a);
     }
 
     // reserve static vector for optimal performan",C-Plus-Plus
"""""""
 Rapidly-exploring Random Trees
 
 Purpose: A robot is attempting to navigate its path from the start point to a specified goal region, 
         while avoiding the set of all obstacles.Will be  Using tree structure
 """"""
 
 import matplotlib.pyplot as plt
 import math
 import random
 from shapely.geometry import Point
 from shapely.geometry import Polygon, MultiPolygon, LineString
 
 
 # tree structure definition
 class Tree():
 
     def __init__(self, data=Point(0,0), children=None, par=None):
         self.data = data
         self.children = []
         if children is not None:
             for child in children:
                 self.add_child(child)
         self.par = par
 
     def add_child(self, node):
         self.children.append(node)
         node.par = self
                 
     def __str__(self, level=0):
         ret = ""\t""*level+repr(self.data.x)+"" ""+repr(self.data.y)+""\n""
         for child in self.children:
             ret += child.__str__(level+1)
         return ret
 
     def __repr__(self):
         return '<tree node representation>'
 
     # to trace final path
     def tb(self,n):
         ax = []
         ay = []
         ax.append(n.data.x)
         ay.append(n.data.y)
         while n.data != self.data:
             n = n.par
             ax.append(n.data.x)
             ay.append(n.data.y)
         return ax,ay
 
 
 # defining obstacles as a set of polygons
 def obst(arr):
     ans = []
     for coord in arr:
         m = Polygon(coord)
         ans.append(m)
     t = MultiPolygon(ans)
     return t
 
 # defining goal region as polygon
 def dgoal(coord):
     m = Polygon(coord)
     t = MultiPolygon([m])
     return t
 
 # distance between two points
 def distance(pt1,pt2):
     ans = math.sqrt((pt1.x - pt2.x) ** 2 + (pt1.y-pt2.y) ** 2)
     return ans
 
 # finding nearest neighbour
 def nearestNode(pt,root,mind):
     if distance(root.data,pt) < mind:
         mind = distance(root.data,pt)
     ans = root
     for i in root.chil",Python
"'''
 8 PUZZLE PROBLEM SOLVING USING A* ALGORITHM
 
 An instance of the n-puzzle game consists of a board holding n^{2}-1 
 distinct movable tiles, plus an empty space. The tiles are numbers from 
 the set 1,..,n^{2}-1. For any such board, the empty space may be legally 
 swapped with any tile horizontally or vertically adjacent to it. In this 
 assignment, the blank space is going to be represented with the number 0. 
 Given an initial state of the board, the combinatorial search problem is 
 to find a sequence of moves that transitions this state to the goal state; 
 that is, the configuration with all tiles arranged in ascending order 
 0,1,..,n^{2}-1.
 
 So, this is the goal state that we want to reach:
 [1, 2, 3]
 [8, 0, 4]
 [7, 6, 5] 
 
 The search space is the set of all possible states reachable from the 
 initial state. The blank space may be swapped with a component in one of 
 the four directions {Up, Down, Left, Right}, one move at a time.
 
 A* algorithm has 3 parameters:
 g: the cost of moving from the initial cell to the current cell.
 h: also known as the heuristic value, it is the estimated cost of moving from 
    the current cell to the final cell. The actual cost cannot be calculated until 
    the final cell is reached. Hence, h is the estimated cost. We must make sure 
    that there is never an over estimation of the cost.
 f: it is the sum of g and h. So, f = g + h
 We always go to the state that has minimum 'f' value.
 
 '''
 
 # importing the necessary libraries
 from time import time
 from queue import PriorityQueue
 
 # creating a class Puzzle
 class Puzzle:
     # setting the goal state of 8-puzzle
     goal_state=[1,2,3,8,0,4,7,6,5]
     # setting up the members of a class
     heuristic=None
     evaluation_function=None
     needs_hueristic=False
     num_of_instances=0
     
     # constructor to initialize the class members
     def __init__(self,state,parent,action,path_cost,needs_hueristic=False):
         s",Python
"/*
 Description :  We have to divide a array into two sub array (left and right)
                containing n/2 elements each and do the sum of the subarrays 
                and then multiply both the subarrays.
 */
 
 #include <bitset/stdc++.h>
 using namespace std;
 
 int multiply(int arr[], int n)
 {
     int sum_1 = 0;
     int sum_2 = 0;
     int result;
     int len = n / 2;
     for (int i = 0; i < len; i++)
     {
         sum_1 += arr[i];
     }
     for (int j = len; j < n; j++)
     {
         sum_2 += arr[j];
     }
     result = sum_1 * sum_2;
     return result;
 }
 
 int main()
 {
     // n =  size of an array
     int n;
     cout << ""Enter the size of the array : "" << endl;
     cin >> n;
     //array of n size
     int a[n];
     cout << ""Enter "" << n << "" number of elements : "" << endl;
     for (int i = 0; i < n; i++)
     {
         cin >> a[i];
     }
     cout << ""Multiplication of left and right sub-array : "" << endl;
     cout << multiply(a, n) << endl;
     return 0;
 }
 
 /*
 Time Complexity : O(n)
 space Complexity : O(n)
 */
 
 /*
  Test Cases : 
  Test Case 1 :
     Input : 
     Enter the size of the array : 
     4
     Enter 4 number of elements : 
     1 2 3 4
 
     Output :
     Multiplication of left and right sub-array : 
     21
  Test case 2 :
     Input : 
     Enter the size of the array : 
     2
     Enter 2 number of elements : 
     1 2
 
     Output : 
     Multiplication of left and right sub-array : 
     2
  */
 
",C-Plus-Plus
"/*In Columnar Cipher, we are given a plaintext and a key. The plaintext is written out in rows and the ciphertext
  * is formed by reading out columns one by one according to the order of the key given. Key is converted to its 
  * corresponding numerical(Ex A-0, B-1, C-2, ...... , Z-25). Cipher text is formed by reading the columns corresponding
  * to the lowest numerical value in the key to highest numerical value.
  */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <limits.h>
 
 //Defining maximum length of plaintext and key
 #define MAXLENGTH 100
 
 //Sort function, returns sorted integer array
 int* sort(int arr[], int len) {
 
 	//Bubble sort is used here
 	for(int i = 0; i < len - 1; i++) {
 		for(int j = 0; j < len - 1 - i; j++) {
 			if(arr[j] > arr[j + 1]) {
 				int temp = arr[j];
 				arr[j] = arr[j + 1];
 				arr[j + 1] = temp;
 			}
 		}
 	}
 	return arr;
 }
 
 /*This function returns the corresponding numerical value 
   of the key in the form of an array
 */
 int* order(char* key) {
 
 	int length = strlen(key);
 
 	static int order_key[MAXLENGTH];
 	
 	/*We find the numerical value of each alphabet
 	  corresponding to the key*/
 	for(int i = 0; i < length; i++) {
 		order_key[i] = key[i] - 0;
 		order_key[i] -= 65;
 	}
 
 	static int temp[MAXLENGTH];
 
 	//Storing the numerical value temporarily
 	for(int i = 0; i < length; i++) {
 		temp[i] = order_key[i];
 	}
 
 	/*Finding the relative numbering of
 	  each alphaet in the key*/
 	int* sorted;
 	sorted = sort(order_key, length);
 
 	static int index[MAXLENGTH];
 
 	for(int i = 0; i < length; i++) {
 		for(int j = 0; j < length; j++) {
 			if(temp[i] == sorted[j]) {
 				index[i] = j+1;
 			}
 		}
 	}
 	/*Returning the array containing the numerical
 	  value of key in relative order*/
 	return index;
 }
 
 /*This is the encrypt function that takes
   plaintext and key as input*/
 char* encrypt(char* message, char* key) {
 
 	//varible to store the correspoding cipher te",C
"  /*This is a java code of finding two substring. One will be shortest substring
   as the substring will start from smallest(initial charater of alphabets) charater from string,
   similarly for largest substring, the substring will start from largest(end
   most charater of alphabets) charater from string.
   For example, AwesomeJAVAcode for length 3 will return Aco as smallest and wes as largest.
   */
   import java.util.Scanner;
   import java.lang.String;
   public class smallest_and_longest_SubString
   {
         public static String getSmallestAndLargest(String string, int length)
         {
             String largest = """";
             String smallest = """";
             int string_length = string.length();
             String store[] = new String[20];
             char last_char = 'z';
             int start = 0;
             /*
              the idea here is to store the occurrence count against the ASCII
              value of that character. For example, the occurrence of A would
              be stored in counter[65] because ASCII value of A is 65.
             */
             for (int i = 57; i >= 0; i--)
             {
                 for (int j = 0; j <= string_length - length; j++)
                 {
                     char current_char = string.charAt(j);
                     if (current_char == last_char)
                     {
                         store[start] = string.substring(j, j + length);
                         smallest = store[start];
                         largest = store[0];
                         start++;
                     }
                 }
                 last_char--;
             }
             return ""Smallest substring  ""+smallest + ""\n"" +""largest String  ""+ largest;
         }
     public static void main(String[] args)
     {
         Scanner scan = new Scanner(System.in);
         System.out.println(""Enter your String..."");
         String string = scan.next();
         System.out.println(""Please enter",Java
"#= Print all the subsequences of the string.
 =#
 
 ## Function 
 
 function subsequence(s, ans)
     if (length(s) == 0)
         if (length(ans) >= 1)
             println(ans)
         end
         return
     end
     ch = s[1]
     rest_of_string = SubString(s, 2)
     subsequence(rest_of_string, ans)
     subsequence(rest_of_string, ans * ch)
 end
 
 ## Input
 
 println(""Enter the string: "")
 s = readline()
 
 ## Calling the Function 
 
 println(""The subsequences are :"")
 subsequence(s, """")
 
 #=
 Sample Test Case: 
 Input: 
     Enter the string: abc
 Output:
     The subsequences are :
     c
     b
     bc
     a
     ac
     ab
     abc
 Time complexity: O ( 2^N * l) (where l is the length of string)
 =#
",Julia
"{
   ""nbformat"": 4,
   ""nbformat_minor"": 0,
   ""metadata"": {
     ""colab"": {
       ""name"": ""Iris_Classifier_using_Keras.ipynb"",
       ""provenance"": [],
       ""collapsed_sections"": []
     },
     ""kernelspec"": {
       ""name"": ""python3"",
       ""display_name"": ""Python 3""
     }
   },
   ""cells"": [
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""i5uTf_ntVg1v"",
         ""colab_type"": ""text""
       },
       ""source"": [
         ""### Step 1: Importing important libraries. *Numpy:* Linear Algebra and manipulation of data. *Keras:* High-level API built on top of Tensorflow. *SKLearn:* Machine Learning libraries that holds datasets, models and other useful functions.""
       ]
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""GoxnaUatRkao"",
         ""colab_type"": ""code"",
         ""colab"": {
           ""base_uri"": ""https://localhost:8080/"",
           ""height"": 83
         },
         ""outputId"": ""8e85f91c-cb96-4f60-805f-97078555675a""
       },
       ""source"": [
         ""import numpy as np\n"",
         ""import keras\n"",
         ""from keras.models import Sequential\n"",
         ""from keras.layers import Dense\n"",
         ""from keras.optimizers import Adam\n"",
         ""from sklearn.datasets import load_iris\n"",
         ""from sklearn.preprocessing import OneHotEncoder\n"",
         ""from sklearn.model_selection import train_test_split""
       ],
       ""execution_count"": null,
       ""outputs"": [
         {
           ""output_type"": ""stream"",
           ""text"": [
             ""Using TensorFlow backend.\n""
           ],
           ""name"": ""stderr""
         },
         {
           ""output_type"": ""display_data"",
           ""data"": {
             ""text/html"": [
               ""<p style=\""color: red;\"">\n"",
               ""The default version of TensorFlow in Colab will soon switch to TensorFlow 2.x.<br>\n"",
               ""We recommend you <a href=\""https://www.tensorflow.org/guide/migrate\"" target=\""_blank\"">upgr",Python
"import java.util.*;
 import java.lang.*;
 import java.io.*;
 
 class String_to_int {
     public int myAtoi(String str) {
         if (str.length() == 0) return 0;
         
         String ans = """";
         if (str.length() > 2 ){     // for TESTCASE ""+-6""
             if (str.charAt(0) == '-' && str.charAt(1) == '+') return 0;
             if (str.charAt(1) == '-' && str.charAt(0) == '+') return 0;
         }
         
         for (int i = 0 ; i < str.length(); i++){
 	    
 	    // ith Character of String str 
             char c = str.charAt(i);
             if (ans.length() > 0 && !(c >= '0' && c <= '9')) break;
             else if (str.charAt(i) == ' ') continue;
             else if (str.charAt(i) == '-') ans += str.charAt(i);
             else if (str.charAt(i) == '+') ans += str.charAt(i);
             
             else if (c >= '0' && c <= '9') ans += c;
             else if (ans.length() == 0 && !(c >= '0' && c <= '9')) break;
            
         }
         
         if (ans.length() == 0) return 0;
         if (ans.equals(""-"") || ans.equals(""+"")) return 0;
         // if (ans.length() > 9) 
         
         int max = Integer.MAX_VALUE;
         int digits_max = (int)Math.floor(Math.log10(max) + 1);  // hete it is 9 always 
         
         int min = Integer.MIN_VALUE;
         
         long count_0 = 0;
         for (int  i= 0 ; i < ans.length(); i++){
             if (ans.charAt(i) == '-' || ans.charAt(i) == '+') {
                 count_0 ++;
                 continue;
             }
             if (ans.charAt(i) != '0') break;
             count_0 ++;
             
         }
         
         if (ans.length() - count_0 > digits_max){
             if (ans.charAt(0) == '-') return min;
             return max;
         }
         
         long temp = Long.parseLong(ans) ;
         if (temp > Integer.MAX_VALUE) return Integer.MAX_VALUE;
         else if (temp < Integer.MIN_VALUE) return Integer.MIN_VALUE;
         
          return Integer",Java
"/*
 Link of the problem:-  https://practice.geeksforgeeks.org/problems/rat-in-a-maze-problem/1
 There is a rat who is at the starting point of a matrix and wants to reach
  to the ending point i.e at the last coordinate of the matrix.
  1 denotes the point where it is possible for the mouse to go and
  0 denotes the dead end 
  */
 #include <iostream>
 #include<bits/stdc++.h>
 using namespace std;
  /*
  *checking whether safe to move 
  */
 bool issafetomove(int** arr, int x, int y, int row, int col)    
 {
     if(x<row && y<col && arr[x][y]==1)
     {
         return true;
     }
     return false;
 }
 bool ratInMaze(int** arr, int x,int y,int row, int col, int** solution)
 {
 /* base condition  */
     if(x==row-1 && y==col-1)
     {
         solution[x][y]=1;
         return true;
     }
 
     if(issafetomove(arr,x,y,row,col))
     {
         solution[x][y]=1;
 
 /*moving in right direction */
     if(ratInMaze(arr,x+1,y,row,col,solution))
     {
         return true;
     }
 
 /*moving in down direction*/
     if(ratInMaze(arr,x,y+1,row,col,solution))
     {
         return true;
     }
 
 /*backtracking  */
     solution[x][y]=0;
     return false;
     }
     return false;
 }
 int main()
 {
     int row, col;
     cout<<""enter the rows and columns of the  matrix\n"";
     cin>>row>>col;
 
     int** arr=new int*[row];
     for(int x=0;x<row;x++)
     {
         arr[x]=new int[col];
     }
 
     cout<<""enter the elements of the array\n"";
     for(int i=0;i<row;i++)
     {
         for(int j=0;j<col;j++)
         {
             cin>>arr[i][j];
         }
     }
 
     int** solution=new int*[row];
      for(int i=0;i<row;i++)
     {
         solution[i]=new int[col];
         for(int j=0;j<col;j++)
         {
             solution[i][j]=0;
 
         }
     }
     if(ratInMaze(arr,0,0,row,col,solution))
     {
         cout<<""The path obtained is as follows\n"";
 
     for(int i=0;i<row;i++)
     {
         for(int j=0;j<col;j++)
         {
             cout<<",C-Plus-Plus
"/*
 Given an array of N elements , find it's prefix sum array. In Competitive Programming, many times we need to calculate prefix sum array to solve our problem.
 */
 
 #include <stdio.h>
 
 void prefix_sum_array(int ar[] ,int N)
 {
     int pref_ar[N + 1];
     pref_ar[0] = ar[0];
     int i = 0;
     /* we will add the current element of ar[] array
     and previous element of pref_ar [] array */
     for(i = 1; i < N; i++)
     {
         pref_ar[i] = ar[i] + pref_ar[i - 1];
     }
     printf(""The New Prefix sum array is \n"");
     for(int i = 0; i < N; i++)
     {
         printf(""%d "",pref_ar[i] );
     }
     printf(""\n"");
     return;
 }
 
 int main()
 {
     printf(""Enter the size of array \n"");
     int N;
     scanf(""%d"", &N);
     int ar[N + 1];
     printf(""Enter array elements \n"");
     for(int i = 0; i < N; i++)
     {
         scanf(""%d"", &ar[i]);
     }
     prefix_sum_array(ar , N);
 }
 /*
 Standard Input and Output
 
 Enter the size of array 
 7
 Enter array elements
 10 4 16 34 23 5 90
 
 The New Prefix sum array is
 10 14 30 64 87 92 182
 
 Time Complexity : O(N)
 Space Complexity : O(N)
 
 */
",C
"/*
 A pair of two consecutive members u and v on a line is considered average integer pair 
 if their average is an integer,
 i.e. (u+v)/2 is an integer. 
 Given an array, arrange the elements, 
 such that number of consecutive average integer pairs is maximised.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 //Function to reorder elements such that number of consecutive average integer pairs is maximised.
 void Maximum_consecutive_avgint_pair(int n, int arr[]) {
     
     int odd=0, even=0;
     //Count the no of even and odd nos in the array
     for( int i=0; i<n ; i++){
 	    if( arr[i] % 2 != 0){
 	        odd++;
 	    }
 	    else{
 	        even++;
 	    }
     }
    /*If the no of odd is greater than no of even print 
    the odd nos first followed by the even nos*/
 	if( odd > even){
     	for( int i=0; i<n ; i++){
     	     if( arr[i] % 2 != 0){
     	         cout << arr[i] << "" "";
     	     }
     	 }
     	for( int i=0; i<n ; i++){
     	     if( arr[i] % 2 == 0){
     	         cout << arr[i] << "" "";
     	     }
     	 }	 
 	}
    /*If the no of even is greater than no of odd print 
    the even nos first followed by the odd nos*/
 	else{
 	    for( int i=0; i<n ;i++){
     	     if( arr[i] % 2 == 0){
     	         cout << arr[i] << "" "";
     	     }
     	 }
     	for( int i=0; i<n ;i++){
     	     if( arr[i] % 2 != 0){
     	         cout << arr[i] << "" "";
     	     }
     	 }	 
 	}
 
 }
 
 int main() {
 	int  n;
 	cout << ""Enter the no of elements in array:"" <<endl;
 	cin >> n;
 	int arr[n];
 	cout << ""Enter the elements in array:"" <<endl;
 	for( int i=0; i<n ;i++){
 	    cin >> arr[i];
 	}
 	cout << ""The reordered array is: ""<<endl;
 	Maximum_consecutive_avgint_pair(n, arr);
 	return 0;
 }
 
 /*
 Sample Input/Output:
 
 Input:
 Enter the no of elements in array:
 8
 Enter the elements in array:
 10 9 13 15 3 16 9 13
 Output:
 The reordered array is: 
 9 13 15 3 9 13 10 16 
 
 Time complexity:-O(n) to compute odd and even numbers
 Sp",C-Plus-Plus
"//the following program finds length of longest increasing subsequence in the given array using dynamic programming
 //the subsequence is a part of given parent array that has same order of elements as of parent array.
 #include<iostream>
 using namespace std;
 
 int
 main ()
 {
   
 int arr[8] = { 10, 22, 9, 33, 21, 50, 41, 6 };
   
 cout << ""The elements of array are:"";
   
 for (int i = 0; i < 8; i++)
     {
       
 cout << arr[i] << "" "";
     
 } 
 int n = 8;		//number of elements in array
   int count[n];
   
 for (int i = 0; i < n; i++)
     {
       
 count[i] = 1;		//initially assign every element as 1 because every element is longest increasing subsequence in itself
   } 
 for (int i = 1; i < n; i++)
     {				//loop starts from index 1
       for (int j = 0; j < i; j++)
 	{			//next loop runs till one index less than i
 	  if (arr[i] > arr[j] && count[j] + 1 > count[i])
 	    {			// if it finds number smaller than current ith index and it's next element in count array is greater than ith index by one 
 	      count[i] = count[j] + 1;	//then increment the count of ith element in count array by 1
 	    }
 	
 }
     
 }
   
 int max = 0;			//initially assign max variable as 0
   for (int i = 0; i < n; i++)
     {
       
 if (count[i] > max)
 	{			//if current element is larger than max
 	  max = count[i];	//assign maximum value in max variable
 	}
     
 }
   
 cout << ""\n"" << ""The length of longest increasing subsequence is "" << max;
 
 }
",C-Plus-Plus
"// Red Black Tree implementation in C++ (creation,insertion,traversal)
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // structure of a node
 struct Node {
 	int data; 
 	Node *parent; // pointer to the parent
 	Node *left; // pointer to left child
 	Node *right; // pointer to right child
 	int color; // 1 -> Red, 0 -> Black
 };
 
 typedef Node *NodePtr;
 
 // class RBTree implements the operations in Red Black Tree
 class RBTree {
 	NodePtr root;
 	NodePtr TNULL;
 
 	// initializes the nodes with appropirate values
 	// all the pointers are pointing to the null pointer
 	void initializeNULLNode(NodePtr node, NodePtr parent) {
 		node->data = 0;
 		node->parent = parent;
 		node->left = nullptr;
 		node->right = nullptr;
 		node->color = 0;
 	}
 
 	void pre_Order(NodePtr node) {
 		if (node != TNULL) {
 			
  		string sColor = node->color?""RED"":""BLACK"";
 		   cout<<node->data<<""(""<<sColor<<"")  "";
 			pre_Order(node->left);
 			pre_Order(node->right);
 		} 
 	}
 
 	void in_Order(NodePtr node) {
 		if (node != TNULL) {
 			in_Order(node->left);
 			string sColor = node->color?""RED"":""BLACK"";
 		   cout<<node->data<<""(""<<sColor<<"")  "";
 			in_Order(node->right);
 		} 
 	}
 
 	void post_Order(NodePtr node) {
 		if (node != TNULL) {
 			post_Order(node->left);
 			post_Order(node->right);
 			string sColor = node->color?""RED"":""BLACK"";
 		   cout<<node->data<<""(""<<sColor<<"")  "";
 		} 
 	}
 
 	// fix the red-black tree
 	void fixInsert(NodePtr k){
 		NodePtr u;
 		// when parent is red
 		while (k->parent->color == 1) {
 			if (k->parent == k->parent->parent->right) {
 				u = k->parent->parent->left; // uncle
 				if (u->color == 1) {
 					// when uncle is also red
 					u->color = 0;
 					k->parent->color = 0;
 					k->parent->parent->color = 1;
 					k = k->parent->parent;
 				} else {  
 					if (k == k->parent->left) {
 						k = k->parent;
 						rightRotate(k);
 					}
 					
 					k->parent->color = 0;
 					k->parent->parent->color = 1;
 					leftRotate(k-",C-Plus-Plus
"/*
 Introduction 
 Given a roman numeral, convert it to an integer.
 
 Argument/Return Type
 Given a string which represents a roman numeral ,
 return its corresponding decimal integer value
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Function to convert the given roman numeral to its corresponding integer value
 int romanToInt(string roman) 
 { 
     //Define a map     
     map<string,int>value;
     
     //Store the integer values of all valid roman symbols
     value[""I""]  = 1;
     value[""IV""] = 4;
     value[""V""]  = 5;
     value[""IX""] = 9;
     value[""X""]  = 10;
     value[""XL""] = 40;
     value[""L""]  = 50;
     value[""XC""] = 90;
     value[""C""]  = 100;
     value[""CD""] = 400;
     value[""D""]  = 500;
     value[""CM""] = 900;
     value[""M""]  = 1000;
     
     //Now traverse over all characters of string
     int index=0;
     //Initiate the decimal value with 0
     int decimalValue=0;
 
     while(index<roman.length())
     {
         //If there is one more char after the current position
         if(index<roman.length()-1)
         {
             /* check if the substring corresponding to two chars 
             is a valid roman symbol */
             string sub=roman.substr(index,2);
             if(value[sub])
             {
                 /* If substring is a valid roman symbol 
                  add it to decimal value and move the index forward two times */
                 decimalValue=decimalValue+value[sub];
                 index=index+2;
             }
             else
             {
                 // else add the decimal value the char at this position 
                 sub=roman.substr(index,1);
                 decimalValue=decimalValue+value[sub];
                 index=index+1;
             }
         }
         else
         {
             /* If current position is end of the string
              add the decimala value of this char and continue */
             string sub=roman.substr(index,1);
             decimalValue=",C-Plus-Plus
"
 class IntersectionPointOfLL {
     static class Node {
 
         int data;
         Node next;
     };
 
     static int intesection(Node head1, Node head2) {
         Node curr1 = head1;
         Node curr2 = head2;
 
         if (curr1 == null || curr2 == null)
             return -1;
 
         while (curr1 != null && curr2 != null && curr1 != curr2) {
             curr1 = curr1.next;
             curr2 = curr2.next;
 
             if (curr1 == curr2)
                 return curr1.data;
             if (curr1 == null)
                 curr1 = head2;
             if (curr2 == null)
                 curr2 = head1;
         }
 
         return curr1.data;
     }
 
     public static void main(String[] args) {
 
         Node newNode;
 
         Node head1 = new Node();
         head1.data = 10;
 
         Node head2 = new Node();
         head2.data = 3;
 
         newNode = new Node();
         newNode.data = 6;
         head2.next = newNode;
 
         newNode = new Node();
         newNode.data = 9;
         head2.next.next = newNode;
 
         newNode = new Node();
         newNode.data = 15;
         head1.next = newNode;
         head2.next.next.next = newNode;
 
         newNode = new Node();
         newNode.data = 30;
         head1.next.next = newNode;
 
         head1.next.next.next = null;
 
         System.out.print(intesection(head1, head2));
     }
 
 }
 // O/P: 15
 
 // Other examples
 
 // if we put the values of 1st and 2nd Linked List as :
 // 1st : 1->2->3->4->5->6
 // 2nd : 7->4->9->3
 
 // 4 is the intersection point
 
 // if we put the values of 1st and 2nd Linked List as :
 // 1st 3->8->9->12->10
 // 2nd 10->12->80
 
 // 12 is the intersection point
",Java
"/*Problem Statement:
 Given N,friends who want to go to a party on bikes.
 Each guy can go as single, or as a couple.
 Find the number of ways in which N friends can go to the party. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int friendsPairing(int n)
 {
     if(n==0 or n==1)
     {
         return 1;
     }
     if(n==2)
     {
         return 2;
     }
     int ans1=friendsPairing(1)*friendsPairing(n-1);
     int ans2=friendsPairing(2)*friendsPairing(n-2);
 
     return ans1+ans2;
 }
 int main()
 {
     int n;
     cout<<""Enter total number of friends: ""<<endl;
     cin>>n;
     cout<<""Total ways: ""<<friendsPairing(n)<<endl;
     return 0;
 }
 /*Example:
 Input: 
 Enter total number of friends: 4
 Output:
 Total ways: 3
 Time Complexity: O(nlogn)
 Space Complexity: O(nlogn)
 */
 
",C-Plus-Plus
"#include<iostream>
 #include<bits/stdc++.h>
 
 using namespace std;
 
 //triplets printing function
 void printtriplets(int* arr,int n,int sum)
 {
 	//sorting array initially
 	sort(arr,arr+n);
 	cout<<""The triplet sets are:""<<endl; 
 	for(int i =0;i<n-1;i++)
 	{
 		int left=i+1;
 		int right=n-1;
 		int current=arr[i];
 		while (left < right) 
 		{ 
                     if (current + arr[left] + arr[right] == sum) 
 	            { 
 			    // Print elements if it's sum is given sum.
 				//printing elements in ascending order 
                             cout<<current<<"", ""<<arr[left]<<"" and ""<<arr[right]<<endl;
                             left++; 
                             right--; 
                     } 
   
                     // If current sum is less than 'sum' then increment the left index
                     else if (current + arr[left] + arr[right] < sum) 
                     left++; 
   
                     // if current sum is greater than  'sum', then decrement the right index 
                     else
                     right--; 
                 } 
 	 }
 }
 
 //Main function
 int main() 
 {
 	int end,target;
 	cout<<""Enter the no. of elements in array you want to enter""<<endl; 
 	cin >> end;
 	
 	int* input = new int[end];
 	cout<<""Enter elements""<<endl;
 	for(int ind=0;ind<end;ind++)
 		cin >> input[ind];
 	
 	cout<<""Enter target""<<endl;	
 	cin>>target;
 	printtriplets(input,end,target);
 	delete[] input;
 	return 0;
 }
",C-Plus-Plus
"#include <bits/stdc++.h>
 using namespace std;
 class Node
 {
 public:
     int data;
     Node* next;
     Node(int data)
     {
         this -> data = data;
         this -> next = NULL;
     }
 };
 /* 
 The helper class for the basic utility 
 functions used in Linked List algorithms
 
 1 - length - to return length of the Linked List
 2 - print_ll - print the linked list to the output console
 3 - take_input - take input from the user, terminated by -1
 4 - Node* copy=NULL;
 */
 class helper
 {
 public:
     int length(Node* head)
     {
         Node* temp = head;
         int count = 0;
         while(temp != NULL)
         {
             temp = temp -> next;
             count++;
         }
         return count;
     }
     void print_ll(Node* head)
     {
         Node *temp=head;
         while(temp != NULL)
         {
             cout << temp -> data <<""--> "";
             temp= temp -> next;
         }
         cout<<""NULL""<<endl;
     }
     Node* take_input()
     {
         cout<<""Enter data to enter into the linked list and add -1 at the end of link list : "";
         int data;
         cin >> data;
         Node* head = NULL;
         Node* tail = NULL;
         if(data==-1)
             cout<<""Link List is Empty please try again."";
         while(data != -1)
         {
             Node* n = new Node(data);
             if(head==NULL)
             {
                 head = n;
                 tail = n;            
             }
             else
             {
                 tail -> next = n;
                 tail = tail -> next;
             }
             cin >> data;
         }
         return head;
     }
     Node *copy(Node *ref)
     {
         if(ref==NULL) return ref;
         Node *temp=(Node *)malloc(sizeof(Node));
         temp->data=ref->data;
         temp->next=copy(ref->next);
         return temp;
     }
 };
 
 /// The main algorithmic solution class
 class solution
 {
 public:    
      /// Recursive approach
      Node* reve",C-Plus-Plus
"/*
 
 Introduction 
 Given a Binary Tree , invert it and print its Levelorder
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 Level Order of inverted tree is printed as output
 
 */
 
 //  Code / Solution
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 //Function to create a node with 'value' as the data stored in it. 
 //Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 //Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Function to print Level order traversal of given tree
 void levelOrder(struct Node* root)
 {
     //If root is NULL , return it
     if (root == NULL)
         return;
     //Create a queue
     queue<Node*> q;
     //Push the root to the ",C-Plus-Plus
"#include <stdio.h>
 #include <string.h>
 
 void getZ(char s[], int z[])
 {
 	int n = strlen(s);
 	int left = 0, right = 0;
 	for (int i = 1; i < n; ++i)
 	{
 		if (i > right)
 		{
 			left = right = i;
 			while (right < n && s[right - left] == s[right])
 				right++;
 			z[i] = right - left;
 			right--;
 		}
 		else
 		{
 			int k = i - left;
 			if (z[k] < right - i + 1)
 			{
 				z[i] = z[k];
 			}
 			else
 			{
 				left = i;
 				while (right < n && s[right - left] == s[right])
 					right++;
 				z[i] = right - left;
 				right--;
 			}
 		}
 	}
 }
 
 int main()
 {
 	char text[100], pattern[100];
 	printf(""Enter the text: "");
 	scanf(""%s"", text);
 	printf(""\nEnter the pattern: "");
 	scanf(""%s"", pattern);
 	int m = strlen(pattern);
 	strcat(pattern, ""$"");
 	strcat(pattern, text);
 	int n = strlen(pattern);
 	int z[n];
 	getZ(pattern, z);
 	for (int i = 0; i < n; ++i)
 	{
 		if (z[i] == m)
 		{
 			printf(""\nPattern found at index %d"", i - m - 1);
 		}
 	}
 
 	return 0;
 }
 
 /*
 Time Complexity: O(length of text + length of pattern)
 
 Input
 Enter the text: AABACAAFGAABAABA
 Enter the pattern: AABA
 
 Output
 Pattern found at index 0
 Pattern found at index 9
 Pattern found at index 12
 */
",C
"# Python program for all basic functionalities of Singly Linked List
 
 class Node:
     # Constructor to initialize the node object
     def __init__(self, data):
         self.data = data
         self.next = None
 
 class LinkedList:
     # Constructor to initialize head 
     def __init__(self):
         self.head = None
 
     def insertNodeAtFront(self, ndata):
         nnode = Node(ndata)
         nnode.next = self.head
         self.head = nnode
 
     def insertNodeAtEnd(self, ndata):
         nnode = Node(ndata)
         if self.head == None:
             self.head = nnode
         else:
             last = self.head
             while last.next != None:
                 last = last.next
             last.next = nnode
     
     def insertNodeAtPosition(self, index, ndata):
         if index == 1:
             insertNodeAtFront(self, ndata)
         else:
             cur = 1
             pos = self.head
             while cur < index-1 and pos != None:
                 pos = pos.next
                 cur += 1
             if pos == None:
                 insertNodeAtEnd(self, ndata)
             else:
                 nnode = Node(ndata)
                 nnode.next = pos.next
                 pos.next = nnode
 
     def deleteNodeAtFront(self):
         if self.head == None:
             print(""Empty list, nothing to delete!"")
         else:
             self.head = self.head.next
 
     def deleteNodeAtEnd(self):
         if self.head == None:
             print(""Empty list, nothing to delete!"")
         elif self.head.next == None:
             self.head=None
         else:
             pos = self.head
             while pos.next.next != None:
                 pos = pos.next
             pos.next = None
 
     def deleteNodeAtPosition(self, index):
         if self.head == None:
             print(""Empty list, nothing to delete!"")
             return
         pos = self.head
         if index == 1:
             self.head = pos.next
             temp = N",Python
"/* This Program is to check the Orientation of three given points on a 2-D plane
      i.e, a) Counter-Clockwise
           b) Clockwise
           c) Collinear
  Based on the slope, we can categorize the orientation of the three points.
  If the slope of line segment (a,b)> slope of line segment (b,c), then the orientation is clockwise or right turn
  and vice versa for counter - clockwise or left turn.
  When the three points are collinear, the slope of both the lines are equal
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 /*returns 1 if  rotation is counter - clockwise
  returns 0 if  rotation is collinear
  returns -1 if rotation is clockwise*/
 int CheckOrientation(int x1, int y1, int x2, int y2, int x3, int y3)
 {
     int slope = (y2 - y1) * (x3 - x2) - (y3 - y2) * (x2 - x1);
     if (slope > 1e-10)
     {
         return -1;
     }
     if (slope == 0)
     {
         return 0;
     }
 
     if (slope < -1e-10)
     {
         return 1;
     }
     else
         return 0;
 }
 
 int main()
 {
     int x1, y1, x2, y2, x3, y3;
     //To input the desired values.
     cout << ""Input the desired values for point a, point b, point c to check their Orientation \n"";
     cout << ""Input x and y values for point a"" << endl;
     cin >> x1 >> y1;
     cout << ""Input x and y values for point b"" << endl;
     cin >> x2 >> y2;
     cout << ""Input x and y values for point c."" << endl;
     cin >> x3 >> y3;
 
     //calling the function for checking the Orientation.
     int result = CheckOrientation(x1, y1, x2, y2, x3, y3);
     if (result > 0)
     {
         cout << ""Orientation : Counter-Clockwise."" << endl;
     }
 
     if (result == 0)
     {
         cout << ""Orientation :  Collinear."" << endl;
     }
     if (result < 0)
     {
         cout << ""Orientation : Clockwise."" << endl;
     }
 
     return 0;
 }
 
 /* Time Complexity : O(1)
    Since there are no loops , time complexity is constant 
 */
 
 /* Test Case 1:
 Sample Input :Input the desired valu",C-Plus-Plus
"/* This is a simple program in go language to search 
    linearly in a recursive manner given an array.
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 // global variables
 var array[100] int
 var number int
 var element int
 
 // this function prints the result
 func printfunction(res int) {
 
     if(res == -1) {
        fmt.Print(""Element not found!"")
     }else {
        fmt.Print(""The entered element is at the index position : "",res)
     }
 
 }
 
 // This function searches linearly in recursive manner
 func linearsearch(first,last int) int {
 
     if(array[first] == element){
 
          return first
 
     }else if(array[last] == element) {
 
          return last
 
     }else if(last<first) {
 
          return -1
 
     }else {
 
          last = last -1
          first = first+1
          return linearsearch(first,last)
     }
 }
 
 // driver function
 func main() {
 
    // Taking inputs from user here
    fmt.Print(""The number of elements :"")
    fmt.Scan(&number)
 
    var n int
    fmt.Print(""Enter the elements of the array :"")
    for i:=0;i<number;i++ {
         fmt.Scan(&n)
         array[i] = n
    }
 
    fmt.Print(""Enter the element you want to search for : "")
    fmt.Scan(&element)
 
    first := 0
    last := number-1
 
    // result after linear search
    result := linearsearch(first,last)
 
    // calling the print function
    printfunction(result)
 
 }
 
 /*
    Sample I/O :
 
    a) Element found :
 
    The number of elements :5
    Enter the elements of the array :1 2 3 4 5
    Enter the element you want to search for : 5
    The entered element is at the index position : 4 
   
    b) Element not found :
 
    The number of elements :4
    Enter the elements of the array :1 2 3 6 
    Enter the element you want to search for : 90
    Element not found! 
 
 */
 
",Go
"import java.util.Scanner;
 
 public class LetterCodeRecursion {
 
     public static void main(String[] args) {
 
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Codes will be decoded according to positions of letters, for example: 1=A, 2=B, ..., 26=Z"");
         System.out.println(""Enter the length of given code:"");
         int size = scanner.nextInt();
         int[] arr = new int[size];
         System.out.println(""Enter the numbers of the given code (with spaces):"");
         for (int i = 0; i < size; i++) {
             arr[i] = scanner.nextInt();
         }
         scanner.close();
 
         int result = countCodes(arr, size);
 
         System.out.println(""Number of codes:"" + result);
     }
 
     private static int countCodes(int[] arr, int size) {
 
         // basic situation
         if (size == 1 || size == 0) {
             return 1;
         }
 
         // for a situation for example 0543
         if (arr[0] == 0) {
             return 0;
         }
 
         int count = 0; // initialize count
 
         if (arr[size-1] > 0) {
             // only if the digit under counting is greater than 0
             count = countCodes(arr, size - 1);
         } else {
             // cannot find codes if a digit is 0
             return 0;
         }
 
         if (arr[size - 2] == 1 || (arr[size - 2] == 2 && arr[size - 1] < 7) ) {
             count += countCodes(arr, size - 2);
         }
 
         return count;
     }
 }
 
 /*
 * Sample input/output:
 * Codes will be decoded according to positions of letters, for example: 1=A, 2=B, ..., 26=Z
 * Enter the length of given code:
 * 4
 * Enter the numbers of the given code (with spaces):
 * 1 2 3 4
 * Number of codes:3
 *
 * (ABCD, LCD, AWD)
 *
 * Time complexity = O(2^n)
 */
",Java
"#include<stdio.h>
 
 int max(int a,int b) {
     return (a >= b) ? a : b;
 }
 
 int max_sum_crossing(int arr[], int lo, int mid, int hi) {
     int cur = 0, presum = -1e9;
     for (int i = mid; i >= lo; --i) {
         cur += arr[i];
         presum = max(presum, cur);
     }
     cur = 0;
     int postsum = -1e9;
     for (int i = mid + 1; i <= hi; ++i) {
         cur += arr[i];
         postsum = max(postsum, cur);
     }
 
     return max(max(presum, postsum), presum + postsum);
 
 }
 
 int max_sum_subarray(int arr[], int lo, int hi) {
     if(lo == hi) {
         return arr[lo];
     }
     int mid = lo + (hi - lo) / 2;
     return max(max(max_sum_subarray(arr, lo, mid), max_sum_subarray(arr, mid+1, hi)), max_sum_crossing(arr, lo, mid, hi));
 }
 
 int main() {
     int n;
     scanf(""%d"", &n);
     int arr[n];
     for (int i = 0; i < n; ++i) {
         scanf(""%d"", &arr[i]);
     }
     int ans = max_sum_subarray(arr, 0, n-1);
     printf(""The maximum sum subarray is: %d"", ans);
     return 0;
 }
 
 /*
 Time Complexity: O(N logN)
 
 INPUT 1:
 5
 1 3 2 4 7
 OUTPUT 1:
 The maximum sum subarray is: 17
 
 INPUT 2:
 5
 1 -1 2 3 -2
 OUTPUT 2:
 The maximum sum subarray is: 5
 
 */
",C
"#include <iostream>
 using namespace std;
 
 int main() {
 	int t;
 	cin >> t;
 	while (t--) {
 		int i = 0, j = 0;                                  //i will point str1 and j will point str2
 		string str1, str2;                                 //str1 is substring
 		cin >> str1 >> str2;                               //str2 is full string
 		while (i < str1.length() && j < str2.length()) {
 			if (str1[i] == str2[j]) {
 				i++;
 			}
 			j++;
 		}
 		if (i == str1.length()) {
 			cout << ""Yes, str1 is substring of str2"";
 		}
 		else {
 			cout << ""No, str1 is not substring of str2"";
 		}
 		cout << endl;
 	}
 	return 0;
 }
 
 /*Time Complexity: O(n)
 Input:
 2
 WGA AWRGNA
 QBR EQVBA
 Output:
 Yes, str1 is substring of str2
 No, str1 is not substring of str2
 */
",C-Plus-Plus
"/*  HASH TABLE USING LINEAR PROBING
     * Hash table is a type of access table which contains key-value pairs
     * Each value is placed into a location in the hash table
     * This location will be calculated from the value itself
     * The mapping between a value and an index in the hash table is known as hashing
     * Allotment of more than one key value in one location in hash table is called collision
     * Linear Probing / Closed Hashing is a collision resolution technique
 
     Closed hashing works as follows:
         1. Start with the index where collision has occured, say i
         2. Continue the sequential search in the following locations:
             i, i+1, i+2,...., h,1,2,...i-1
         3. Here the table is considered circular, ie,when the last location is reached,
            search proceeds to first location of table
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 //Declare a hash table of preferred size
 #define SIZE 10
 typedef int* HashTable;
 
 //Hashing function to get index for a given value
 int hash(int val)
 {
     return val % SIZE;
 }
 
 //to insert into hash table
 void insert(HashTable ht, int val)
 {
     /*Compute the index and search for an empty location
       from key in a circular manner*/
     int key = hash(val);
     int i = key;
     do
     {
         if (ht[i] == 0)
         {
             ht[i] = val;
             return;
         }
         i = (i + 1) % SIZE;
     } while (i != key);
 }
 
 //to check if a value exists in the hash table
 int doesExist(HashTable ht, int val)
 {
     //return 1 if exists and 0 if not
     int k = hash(val), i = k;
     do
     {
         if (ht[i] == val)
             return 1;
         i = (i + 1) % SIZE;
     } while (i != k);
     return 0;
 }
 
 //to print hash table as key-value pairs
 void print(HashTable ht)
 {
     for (int i = 0; i < SIZE; i++)
         printf(""%d -> %d\n"", i, ht[i]);
 }
 
 // driver code
 int main()
 {
     HashTable ht = (int*)malloc(sizeof(int) * SI",C
"/* Write a Python program to count the number of articles in a given text. */
 
 CODE:
 
 s=input(""ENTER TEXT HERE"")
 y=s.split()
 a=0
 an=0
 the=0
 for i in range(len(y)):
 if (y[i]==""a"" or y[i]==""A""):
 a=a+1
 if (y[i]==""an"" or y[i]==""An""):
 an=an+1
 if (y[i]==""the"" or y[i]==""The""):
 the=the+1
 print(""a:"",a)
 print(""an:"",an)
 print(""the:"",the)
 print(""Total Articles:"",a+an+the)
 
 ---------------------------------------------------------------------------------------------
 TIME COMPLEXITY: O(N) (Where N is length)
 SPACE COMPLEXITY: O(N)
 ------------------------------------------------------------------------------------------
 OUTPUT:
 
 ENTER TEXT HERE A was the an I am a the she was this that the an a the
 a: 3
 an: 2
 the: 4
 Total Articles: 9
",Python
"/*Problem Statement: 
 There's a scientist is interested in budding of cells. He has one container which initially contains only a single cell. 
 Now he wants n number of cells in his container. 
 So he can change the number of cells in container in 3 different ways -:
 
 1.Double the number of cells present in the container.
 
 2.Increase the number of cells in the container by 1.
 
 3.Decrease the number of cells in the container by 1.
 
 Now, all the above operations have different costs associated with them x,y,z respectively for above operations. 
 Help him in finding the minimum cost to generate n cells in the container starting from one cell. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int costToGenerate(int n, int x, int y, int z)
 {
     int dp[100];
     dp[0] = 0;
     dp[1] = 0;
 
     for (int i = 2; i <= n; i++)
     {
         if (i % 2 == 0)
         {
             dp[i] = min(dp[i / 2] + x, dp[i - 1] + y);
         }
         else
         {
             /*Here, an odd number cannot be reached by doubling an odd number,
             therefore, we increase it by 1  and then use case 1*/
             dp[i] = min(dp[i - 1] + y, dp[i + 1 / 2] + x + z);
         }
     }
 
     return dp[n];
 }
 
 int main()
 {
     int x, n, y, z;
     cin >> n >> x >> y >> z;
     int dp[100];
     cout << costToGenerate(n, x, y, z) << endl;
     return 0;
 }
 
 /*Example: 
 1)Input: 5 2 1 3
 Output: 4
 2)Input: 7 4 2 3
 Output: 10
 Time Complexity: O(n)
 Space Complexity: O(n) */
",C-Plus-Plus
"/*Given a string s containing round, curly, and square open and closing brackets,
  return whether the brackets are balanced. The aim of the program is to make use of stacks.*/
 
 import java.util.*;
 
 public class balancedBrackets {
     /* This method checks if the input string is balanced or not */
     public static boolean isBalanced(String s) {
         java.util.Stack<Character> stack = new java.util.Stack<>();
         if (s.length() == 1)
             return false;
         for (int i = 0; i < s.length(); i++) {
             char c = s.charAt(i);
 
             /* If the present character is an opening bracket, we push it into the stack */
             if (c == '(' || c == '[' || c == '{')
                 stack.add(c);
 
             /*
              * If it is a closing bracket, we check if the last character pushed into the
              * stack is the corresponding opening bracket or not and we pop it
              */
             else {
                 if (c == ')') {
                     if (stack.isEmpty())
                         return false;
                     char c2 = stack.pop();
                     if (c2 != '(')
                         return false;
                 } else if (c == ']') {
                     if (stack.isEmpty())
                         return false;
                     char c2 = stack.pop();
                     if (c2 != '[')
                         return false;
                 } else if (c == '}') {
                     if (stack.isEmpty())
                         return false;
                     char c2 = stack.pop();
                     if (c2 != '{')
                         return false;
                 }
             }
         }
 
         /*
          * At the end of all operations, if it turns out that the stack is not empty
          * i.e, the brackets are not balanced, we return false.
          */
         if (!stack.isEmpty())
             return false;
         return true;
     }
 
     publ",Java
"// This Program takes vertices and edges from the user, generates graph(adjacency list representation) and performs DFS on it.
 
 using System;
 using System.Linq;
 using System.Collections.Generic;
 
 namespace NeoAlgo
 {
     class DFS
     {
         static void Main()
         {
             bool isGraphGenerated = GenerateGraph(out Dictionary<string, Vertex> graph);
             if (!isGraphGenerated)
             {
                 Console.WriteLine(""Some Error Occurred Creating Graph"");
                 return;
             }
 
             GraphTraversal(graph);
             ResetGraph(graph);
 
             Console.ReadLine();
         }
 
 
         /// <summary>
         /// Given the vertices and edges input by user this function generates a graph and 
         /// </summary>
         /// <param name=""graph"">Dictionary representing the graph</param>
         /// <returns>true if graph is generated, false otherwise. Along with this it returns dictionary object representing graph</returns>
         
         static bool GenerateGraph(out Dictionary<string, Vertex> graph)
         {
             graph = new Dictionary<string, Vertex>();
 
             Console.Write(""Supply Vertices of Graph Seperated by Space : "");
             HashSet<string> vertices = Console.ReadLine().Trim().Split(' ').ToHashSet();
 
             foreach (string vertex in vertices)
             {
                 graph.Add(vertex, new Vertex(vertex));
             }
 
             Console.Write(""Supply Number of Edges : "");
 
             bool canParse = int.TryParse(Console.ReadLine().Trim(), out int graphSize);
 
             if (!canParse)
             {
                 Console.WriteLine(""Size of graph must be an integer. Please try again"");
                 return false;
             }
 
             for (int edge = 1; edge <= graphSize; edge++)
             {
                 Console.Write($""Supply Space Seperated Start and End Vertex of Edge {edge}: "");
                 strin",C-Sharp
"""""""
 Linear Probing is a technique for resolving hash collisions of calues of hash function.It is a form of open addressing.
 In this scheme, each cell of a hash table stores a single keyvalue pair. 
 When the hash function causes a collision by mapping a new key to a cell of the hash table that is already occupied by another key, 
 linear probing searches the table for the closest following free location and inserts the new key there.
 """"""
 
 #Function for Linear Probing
 def linearProbing( hash, hashSize, arr, sizeOfArray):
     for i in arr:
         keySpace = i % hashSize 
         if hash[keySpace] == -1:
             hash[keySpace] = i
         else:
             for j in range((keySpace+1), (keySpace+hashSize)):
                 j = j%hashSize
                 if hash[j] == -1:
                     hash[j] = i
                     break                   
 #  Driver Code Starts
 def main():
     t=int(input())  
     while(t>0):       
         hashSize=int(input())
         sizeOfArray=int(input())
         arr=[int(x) for x in input().strip().split()]
         hash=[-1]*hashSize      
         linearProbing( hash, hashSize, arr, sizeOfArray)       
         for i in hash:
             print(i,end="" "")
         print()
         t-=1
 if __name__==""__main__"":
     main()
 #Driver Code Ends
 
 """"""
 Sample Input
 hashSize=10
 sizeOfArray = 3
 Array[] = {3,13,23,33}
 Sample Output
 -1 -1 -1 3 13 23 33 -1 -1 -1
 
 Time Complexity:- Best case: O(1), Worst case: O(n)
 Space Complexity:- O(n)""""""
 
",Python
"class node:
     def __init__(self, val):
         self.val = val
         self.left = None
         self.right = None
 
 
 class Tree:
     def __init__(self):
         self.root = None
 
     def createTree(self, treeNodesArray):
         queue = []
         self.root = node(int(treeNodesArray.pop(0)))
         queue.append(self.root)
         size = len(queue)
         while treeNodesArray:
             while size:
                 root = queue.pop(0)
                 if root:
                     val = treeNodesArray.pop(0)
                     if val == 'null':
                         root.left = None
                     else:
                         root.left = node(int(val))
                         queue.append(root.left)
                     val = treeNodesArray.pop(0)
                     if val == 'null':
                         root.right = None
                     else:
                         root.right = node(int(val))
                         queue.append(root.right)
                 size -= 1
             size = len(queue)
 
     def recursive_preorder_traversal(self, root, path):
         if root:
             path.append(root.val)
             self.recursive_preorder_traversal(root.left, path)
             self.recursive_preorder_traversal(root.right, path)
         return path
 
     def iterative_preorder_traversal(self, root):
         self.path = []
         stack = []
         while stack or root:
             while root:
                 self.path.append(root.val)
                 stack.append(root)
                 root = root.left
             root = stack.pop()
             root = root.right
         return self.path
 
 treeNodesArray = list(input().split(','))
 preOrdertree = Tree()
 preOrdertree.createTree(treeNodesArray)
 
 # Pre-Order Traversal :- root.val -> root.left -> root.right
 
 print(preOrdertree.recursive_preorder_traversal(preOrdertree.root, []))
 print(preOrdertree.iterative_preorder_traversal(preOrdertree.root))
 
 '",Python
"//C Program to sort an array using Shell Sort technique
 #include <stdio.h>
 //ShellSort Function
 void ShellSort(int arr[], int num)
 {
     int gap, i, j, tmp;
     //this for loop of gap is the heart of Shell sort
     //In each pass w check the valu of gap
     //if gap=1 then we stop this loop
     for (gap = num / 2; gap > 0; gap = gap / 2)
     {
         for (i = gap; i < num; i++)
         {
         	//loop continue for index lesser then gap
             for(j = i - gap; j >= 0; j = j - gap)
             {
             	//if lesser index value is small
             	//compared to bigger index
             	//then continue
                 if (arr[j+gap] >= arr[j])
                     break;
                 //else    
                 // Swap values of bigger index with smaller one   
                 else
                 {
                     tmp = arr[j];
                     arr[j] = arr[j+gap];
                     arr[j+gap] = tmp;
                 }
             }
         }
     }
 }
 //Display function to print the result
 void display(int arr[],int n)
 {
 	int i;
 printf(""\n\nSorted Array in ascending order is : \n"");
 for(i=0; i < n; ++i)
 printf(""%5d"",arr[i]);
 }
 //Main Function
 int main()
 {
     int i,k, num;
     //Enter the number of element array have
     printf(""Enter total number of elements :: "");
     scanf(""%d"",&num);
     //store the element of array
     int arr[num];
     //Input values of array
     printf(""Enter elements :: "");
     for(i = 0; i < num; i++)
     {
         scanf(""%d"",&arr[i]);
     }
     //Call shell sort function
     ShellSort(arr,num);
     //call display function
     display(arr,num);
     return 0;
 }
 //end of Main function
 
 /*Sample Input Output
 Enter total number of elements :: 10
 Enter elements : 36 432 43 44 57 63  94 3 5 6
 
 Sorted Array in ascending order is :
     3    5    6    36     43     44     57     63     94     432
 */
 
 /*Complexity
 
 Worst case time complexity is O(n2) 
 Best",C
"/*
 Next Greatest Element to the left using stacks in C++ 
 ALGORITHM:
  *Declare an array and a stack
  *If the stack is empty, then no element to the left is greater than the present element
  *If the stack is not empty but the element present at the top of the stack is not greater than the current element then-
  *pop the stack till  the stack is not empty or the top element of stack is greater than the current element
  *If the stack is not empty and the element at the top of the stack is greater than the current element then-
   push the topmost element to the stack
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void nextGreatestToLeft(int a[],int n)
 {
     stack <int> s;
     vector <int> v;
     for(int i = 0; i < n; i++)
     {
         if(s.empty() == true)
         v.push_back(-1);
         else if(s.empty() != true && s.top() > a[i])
         v.push_back(s.top());
         else if(s.empty() != true && s.top() <= a[i])
         {
             while(s.empty() != true && s.top() <= a[i])
             {
                 s.pop();
             }
             if(s.empty() == true)
             v.push_back(-1);
             else if(s.top() > a[i])
             v.push_back(s.top());
         }
         s.push(a[i]);
     }
     for(int i = 0; i < n; i++)
     cout << v[i] << "" "";
 }
 
 //Driver Function
 int main()
 {
     int n;
     cout << ""Enter the number of elements: "";
     cin >> n;
     int a[n];
     cout << ""Enter the elements: "";
     for(int i = 0; i < n; i++)
     cin >> a[i];
     cout << ""The next greatest element to the left of each element: \n"";
     nextGreatestToLeft(a,n);
 }
 
 /*
 INPUT:
 Enter the number of elements: 4
 Enter the elements: 5 2 4 6
 
 OUTPUT:
 The next greatest element to the left of each element: 
 -1 5 5 -1 
 
 Time Complexity: O(n^2)
 Space complexity: O(n)
 */
",C-Plus-Plus
"/*
 Sum up left leaves of the tree 
 
 You are given root of the binary tree,
 your task is to find the sum of all the leaves
 present on the left.
 */
 
 import java.io.*;
 import java.until.*;
 
 //defining a class for storing nodes of tree
 class BTNode 
 {
     int value;
     BTNode left;
     BTNode right;
     BTNode() 
     {}
     BTNode(int value) 
     {
         this.value = value; 
     }
     BTNode(int value, BTNode left, BTNode right) 
     {
         this.value = value;
         this.left = left;
         this.right = right;
     }
 }
 
 public class SumOfLeftLeaves
 {
     //function to find the sum of left leaves
     public int sumLeftLeaves(BTNode root)
     {
         //if the root is null then simply return 0
         if(root == null)
         {
             return 0;
         }
         //else if the left node does not have any 
         //child then we add that node to the sum 
         //derived from right side
         else if(root.left != null && root.left.left == null && root.left.right == null)
         {
             return root.left.val + sumLeftLeaves(root.right);
         }
         //else we recursivily call the function for both the sides
         else
         {
             return sumLeftLeaves(root.left) + sumLeftLeaves(root.right);
         }
     }
 
     //driver code
     public static void main()
     {
         // Taking input
 	    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
         System.out.println(""Enter the values of nodes for tree : "");
 	    String str = br.readLine();
 
         String ip[] = str.split("" "");
         // Here we start creating the root of the tree
         Node root = new Node(Integer.parseInt(ip[0]));
         // Pushing the roots to the queue
         Queue<Node> Treequeue = new LinkedList<>(); 
         Treequeue.add(root);
 
         //for output
         System.out.println(""Sum of left leaves is : "");
         System.out.print(sumLeftLeaves(root));
         Syst",Java
"#include <stdio.h>
 
 int iterative_doublefactorial(int n) {
   int res = 1;
   for (int i = n; i > 0; i -= 2) {
     if (n == 0 || n == 1)
       return res;
     else
       res = res * i;
   }
 
 }
 
 int recursive_doublefactorial(int n) {
   if (n == 0 || n == 1)
     return 1;
   else
     return n * recursive_doublefactorial(n - 2);
 }
 
 int main() {
   int n;
   printf(""Enter the number :"");
   scanf(""%d"", & n);
   int k;
   do {
     printf(""Enter the choice below :\n1.Iterative solution \n2.Recursive Solution \n3.Exit \n"");
     scanf(""%d"", & k);
     switch (k) {
     case 1:
       printf(""The Double Factorial is : %d\n"", iterative_doublefactorial(n));
       break;
     case 2:
       printf(""The Double Factorial is : %d\n"", recursive_doublefactorial(n));
       break;
     }
   } while (k != 3);
 
   return 0;
 }
 
 /*
 Enter the number :7
 Enter the choice below :
 1.Iterative solution 
 2.Recursive Solution 
 3.Exit 
 1
 The Double Factorial is : 105
 Enter the choice below :
 1.Iterative solution 
 2.Recursive Solution 
 3.Exit 
 2
 The Double Factorial is : 105
 Enter the choice below :
 1.Iterative solution 
 2.Recursive Solution 
 3.Exit 
 3
 */
",C
"'''
 Problem - 
 	To find the time taken for all oranges to get rotten.
 
 Algorithm - 
     We follow by DFS search starting from those points that have rotten oranges and finding thoses fresh oranges in adjacent to them.
     We keep a queue and as we get a new rotten orange we push it into the queue and do this until all possible oranges are rotten.
     The time taken is then returned.
 	
 '''
 
 from queue import Queue
 import copy
 
 class rotten_Oranges():
     def __init__(self, arr):
         self.arr = copy.deepcopy(arr)
         self.R = len(arr)
         self.C = len(arr[0])
         self.time = -1
     
     # Checks if the index in consideration is valid or not
     def isValid(self, x, y):
         return (x >= 0 and x < self.R and y >= 0 and y < self.C)
     
     # Checks if there are still some fresh oranges left
     def checkall(self):
     	for i in range(self.R):
     		for j in range(self.C):
     			if (self.arr[i][j] == 1):
     				return True;
     	return False;
     
     # A checker to take care of all corner case. In case the matrix is all zero then this checker takes care of such cases
     def checkzero(self):
     	for i in range(self.R):
     		for j in range(self.C):
     			if (self.arr[i][j] != 0):
     				return False;
     	return True;
 
     # The main function where the calculation for time taken takes place
     def timeTaken(self):
         q = Queue(0)
         xindex = [1, -1, 0, 0]
         yindex = [0, 0, 1, -1]
         
         for i in range(self.R):
             for j in range(self.C):
                 if (self.arr[i][j] == 2):
                     q.put([i, j])
         
         while (not q.empty()):
             self.time += 1
             lsize = q.qsize()
             
             for i in range(lsize):
                 curr_x, curr_y = q.get()
                 
                 for j in range(4):
                     x = curr_x + xindex[j]
                     y = curr_y + yindex[j]
                 
   ",Python
"/* 
   Given an array containing only 0s and 1s,
   find the largest subarray which contains equal no of 0s and 1s.
   This problem is going to reduce into the problem
   of finding length of longest subarray with 0 sum. 
   The concept of taking cumulative sum,
   taking 0s as -1 will help us in optimizing the approach. 
   This is a very important question from interciew point of
   view as it is a combination of trick,prefix sum and hashing.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 #define ll long long 
 
 /* maxLen function returns the largest subarray with equal
    number of 0 and 1 */
 
 void maxLen(int a[],int n){
 	
 /* create an empty map to store the ending index of the first subarray
    having some sum */
     unordered_map<int, int>ump;
 /* to handle the case when a
    subarray with zero-sum starts from index 0*/
     ump[0] = -1;
      
 // preSum stores the prefix sum ,ans stores the maximum length
 	int preSum=0,ans=0;
 	
 // stores ending index of the maximum length subarray having zero-sum
     int ending_index = -1;
 	
 	for(int i=0;i<n;i++){
 		
 		// sum of elements so far (replace 0 with -1)
         preSum += (a[i] == 0)? -1 : 1;
         
 		// if the sum is seen before
         if (ump.find(preSum) != ump.end())
         {
             /* update length and ending index of maximum length
                 subarray having zero-sum */
             if (ans < i - ump[preSum])
             {
                 ans = i - ump[preSum];
                 ending_index = i;
             }
         }
         /* if the sum is seen for the first time, insert the sum with its
            index into the map */
         else {
             ump[preSum] = i;
         }
 	}
 	//Print the subarray
 	if(ending_index!=-1)
 	cout<<""largest subarray with equal number of 0 and 1 :"" <<""["" << ending_index - ans + 1 << "", "" << ending_index << ""]"";
     else
     cout<<""No subarray of equal number of 1's and 0's present""<<endl;
 }
 int main(){
    int n;
    ",C-Plus-Plus
"/*
 Description :
    Given an array of set , you have to find subset of that set using bitwise operators
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 // function to find the subset
 void find_subset(int arr[] , int len)
 {
     for(int i=0;i<(1<<len);i++)
     {
         for(int j=0;j<len;j++){
             if(i & (1<<j)){
                 cout<<arr[j]<<"" "";
             }
         }
         cout<<""\n"";
     }
 }
 
 int main()
 {
     int len;
     cout<<""Enter the size of array ""<<endl;
     cin>>len;
     int arr[len];
     cout<<""Enter ""<<len<<"" in array :""<<endl;
     for(int i=0;i<len;i++){
         cin>>arr[i];
     }
     cout<<""The subset are : ""<<endl;
     find_subset(arr,len);
     return 0;
 }
 
 /*
 Time complexity : O(2^n)
 Space complexity :O(1)
 */
 
 /*
 Input :
 Enter the size of array 
 4
 Enter 4 in array :
 1 2 3 4
 
 Output :
 The subset are : 
 1
 2
 1 2
 3
 1 3
 2 3
 1 2 3
 4
 1 4
 2 4
 1 2 4
 3 4
 1 3 4
 2 3 4
 1 2 3 4
 */",C-Plus-Plus
"/*
 Keys and rooms for entry
 
 You are given n rooms and you are asked to start from room 0.
 Each room is given a distinct number in 0, 1, 2, ..., N-1,
 and each room may have some keys to access the next room. 
 Formally, each room i has a list of keys room[i], 
 and each key room[i][j] is an integer in [0, 1, ..., N-1],
 where n is room length. Any key rooms[i][j] = v opens only for number v.
 Initially, all the rooms starts locked except for room 0. 
 It is given that you can walk back and forth between rooms freely.
 Your task is to return true if and only if you can enter every room.
 */
 
 import java.util.*;
 import java.io.*;
 
 class Key_n_room
 {
     //function to check if rooms is visited and return true accordingly
     public boolean didVisitRooms(List<List<Integer>> room)
     {
         //visited reperesents true if at some time the room has been visited
         boolean[] visited = new boolean[room.size()];
         //it is given that we start we room 0 so it is automatically visited
         visited[0] = true;
         //keeping track of all the keys
         //keys represent the index of the next room that we can visit
         Stack<Integer> keys = new Stack();
         //since we are starting from room 0 it is also added in the keys stack 
         keys.add(0);
 
         while(!keys.isEmpty())
         {
             int current_key = keys.pop();
             //now we are going to access each key and check if 
             //any room unlocks with that key it means 
             //we haven't visited it yet so we unlock that room
             for (int new_key: room.get(current_key)) 
             {
                 if (!visited[new_key])
                 { 
                     //checking ..which hasn't been used for unlock yet
                     visited[new_key] = true; 
                     //if any key has not been used to unlocked then we add it to keys stack
                     keys.add(new_key); 
                 }
             }    
 ",Java
"def radix_sort(arr):
     max_number = max(arr) #finding the number with the maximum number of digits
     arr_copy = arr[:] #making a copy of the original list
     
     for digit in range(len(str(max_number))): #iterating over the length of the number with the maximum digits
         place = digit + 1 #denotes the place value we are currently sorting according to; we do a +1 because the indices start from 0 but the place values start from 1
         digits = [[] for _ in range(10)] #initializing buckets for each base, i.e 10 (0 to 9) in this case
         for number in arr_copy: #iterating over the list that contains the unsorted list
             try: #this handles the case when the numbers with less digits than the maximum one is out of digits to be placed in a corresponding bucket
                 digits[int(str(number)[-place])].append(number) #adding values to the corresponding buckets
             except IndexError: #handles the case when some smaller number(compared to the one with the maximum digits) is out of digits and places in it the 0 bucket
                 digits[0].append(number) #adding the numbers to the 0 bucket
         arr_copy = [] #intializing an the empty array after placing all numbers into respective buckets for a single digit(LSD to MSD)
         for base in digits: #iterating over the buckets to collect back the numbers from the buckets
             arr_copy.extend(base) #collecting back the numbers from their respective buckets in a sorted manner as per a particular digit     
     return arr_copy #returning the sorted list
  
 def main():
     unsorted_list = list(map(int, input(""Enter space separated numbers for the list\n"").split()))
     print(""Unsorted List:"", unsorted_list)
     print(""Sorted List:"", radix_sort(unsorted_list))
 main() 
",Python
"def sieve_of_Eratosthenes(num):
 
     not_prime_num = set()
     prime_nums = []
 
     for i in range(2, num+1):
         # checks if the number is in the not_prime_num list
         if i in not_prime_num:
             continue
 
         # if number absent in not_prime_num then add that number to prime_num list
         # and every multiple of that number to the not_prime_num list
         for f in range(i*2, num+1, i):
             not_prime_num.add(f)
 
         prime_nums.append(i)
 
     # returns a list of prime numbers less then the given number
     return prime_nums
 
 
 if __name__ == ""__main__"":
     user_input = int(input(""Enter a sequence of comma seprated numbers: ""))
 
     # calling the sieve_of_Eratosthenes function
     prime_numbers = sieve_of_Eratosthenes(user_input)
     print(prime_numbers)
",Python
"""""""
 Python program to get count of divisors.
 Count of divisors refers to the count of numbers in the range [1 to n] which perfectly divides n.
 """"""
 
 import math
 # Function to calculate the count of divisors
 
 def count_of_divisors(num):
     i = 1
     # Initializing cnt by 0
 
     cnt = 0
     while True:
         if i > math.sqrt(num):
             break
         # Increasing cnt by 1 for i
 
         if num % i == 0 and i == math.sqrt(num):
             cnt += 1
         # Increasing cnt by 2 for i and n/i
 
         elif num % i == 0:
             cnt += 2
         i += 1
     return cnt
 
 if __name__ == '__main__':
     # Taking Input 
 
     n = int(input('Enter the number: '))
     # Printing Output
 
     print(""The count of the divisors is: {} "".format(count_of_divisors(n)))
 
 """"""
 Time Complexity - O(sqrt(n)), where 'n' is the number
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 SAMPLE I
 
 INPUT
 Enter the number: 36
 
 OUTPUT
 The count of the divisors is: 9
 
 """"""
 
",Python
"// C code for Maximum size square sub-matrix with all 1's 
 #include<stdio.h>
 
 int main() {
 
   int r_size, c_size, mat[r_size][c_size], MaxSub[r_size][c_size];
   printf(""Input --> \n"");
   printf(""Enter the row-size :\n"");
   scanf(""%d"", & r_size);
   printf(""Enter the column-size :\n"");
   scanf(""%d"", & c_size);
   printf(""Enter the elements of matrix  :\n"");
   for (int i = 0; i < r_size; i++) {
     for (int j = 0; j < c_size; j++) {
       scanf(""%d"", & mat[i][j]);
     }
   }
   /* Set first column of MaxSub[][]*/
   for (int i = 0; i < r_size; i++)
     MaxSub[i][0] = mat[i][0];
   /* Set first row of MaxSub[][]*/
   for (int j = 0; j < c_size; j++)
     MaxSub[0][j] = mat[0][j];
 
   /* Construct other entries of MaxSub[][]*/
   for (int i = 1; i < r_size; i++) {
     for (int j = 1; j < c_size; j++) {
       if (mat[i][j] == 1) {
         int m;
         /* To get minimum of three values */
         m = MaxSub[i][j - 1];
         if (m > MaxSub[i - 1][j])
           m = MaxSub[i - 1][j];
         if (m > MaxSub[i - 1][j - 1])
           m = MaxSub[i - 1][j - 1];
 
         MaxSub[i][j] = m + 1;
       } else
         MaxSub[i][j] = 0;
     }
   }
   /* Find the maximum entry, and indexes of maximum entry  
       in MaxSub[][] */
   int max_of_subMat = MaxSub[0][0], max_i = 0, max_j = 0;
   for (int i = 0; i < r_size; i++) {
     for (int j = 0; j < c_size; j++) {
       if (max_of_subMat < MaxSub[i][j]) {
         max_of_subMat = MaxSub[i][j];
         max_i = i;
         max_j = j;
       }
     }
   }
   printf(""Output -->\n"");
   printf(""Maximum square sub-matrix is: \n"");
   int size = 0;
   for (int i = max_i; i > max_i - max_of_subMat; i--) {
     for (int j = max_j; j > max_j - max_of_subMat; j--) {
       printf(""%d "", mat[i][j]);
 
     }
     printf(""\n"");
     size++;
   }
   printf(""Size of max SubSquareMatrix : "");
   printf(""%d"", size);
   return 0;
 }
 
 /*
  Input -->
 
  Enter the row-size : 3
  Enter the column-size : 4
  Enter the el",C
"/*
 Given a number , check whether the number is power of 2 or not.
 We can check this by doing some bitwise operation.
 Bitwise operations are best because they perform the operation in least possible time.
 */
 
 #include <stdio.h>
 #include <math.h>
 
 // this number_is_power_of_2 will tell us whether a number is power of 2
 int number_is_power_of_2(int number)
 {
     /* if bitwise and of number and number - 1 is zero
     then we can say that number is power of 2
     otherwise it is not.
     */
     if((number & (number - 1)) == 0)
     {
         return 1;
     }
     return 0;
 }
 int main()
 {
     printf(""Enter the number \n"");
     int number;
     scanf(""%d"", &number);
     int solve = number_is_power_of_2(number);
     if(solve)
     {
         printf(""The Number is power of 2\n"");
     }
     else
     {
         printf(""No. the number is not power of 2\n"");
     }
 }
 
 /*
 Standard Input and Output
 Enter the number
 64
 
 The Number is power of 2
 
 Enter the number
 34
 
 No. the number is not power of 2
 
 Time Complexity : O(1)
 Space Complexity : O(1)
 
 */
",C
"// Program to implement QuickSort Algorithm in Java
 
 
 import java.util.*;
 class Sorting
 {
 	// function to print the final sorted array in ASCending order
 	static void printArray(int arr[])
     	{
         	int n = arr.length;
         	for (int i=0; i<n; ++i)
             		System.out.print(arr[i]+"" "");
         	System.out.println();
     	}
 	
    	/* 
 		This is the calling function that implements QuickSort algorithm, where:
 		arr = input array given by user;
 		low = starting index;
 		high = ending index
 	*/
     	static void quickSort(int arr[], int low, int high)
     	{
         	if (low < high)
         	{
             		// pi is partitioning index, arr[pi] is now at right place 
             		int pi = new QuickSort().partition(arr, low, high);
 			
             		// Recursively sort elements before partition and after partition
             		quickSort(arr, low, pi-1);
             		quickSort(arr, pi+1, high);
         	}
     	}
 	
     	// main() 
     	public static void main(String args[])
     	{
 		Scanner sc = new Scanner(System.in);
 		int n = sc.nextInt();
 		
 		int arr[] = new int[n];
 		for(int i = 0; i < n; i++)
 			arr[i] = sc.nextInt();
 			
 		quickSort(arr, 0, n-1);
 		printArray(arr);
 	} 
 }
 
 class QuickSort
 {
    	/* 
 		This function takes last element as pivot, places  the pivot element at its correct position in sorted  array, 
 		and places all smaller (smaller than pivot) to left of pivot and all greater elements to right  of pivot 
     	*/
     	static int partition(int arr[], int low, int high)
     	{
        		/*
 			The value of i is initialized to (low-1) since initially first element is swapped by itself 
 			Reason: no greater element has been encountered apart from itself
 		*/ 
 		int i = (low - 1), j;
         	int pivotElement = arr[high];
         
         	for(j = low; j <= (high - 1); j++){
             		if(arr[j] < pivotElement){
                 		i++;
                 
                 		// swap",Java
"/*
 Given a sequence of brackets as a string, find maximum possible length of balanced bracket sequence.
 string consists only two characters , one is '(' another is ')'
 can be solved this with the help of stack data structure.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int balanced_bracket_sequence(string s, int string_size)
 {
     int max_possible_balanced_bracket_sequence = 0;
     stack < char > st;
     for(int i = 0 ; i < string_size; i++)
     {
         /* Here if the current character of string is ' ( ' we will push it to stack
           and if the current character of string is ' ) ' and
           stack is not empty we will pop from the top of the stack
           increment the max_possible_balanced_bracket_sequence by 2
           every time.
         */
         if(s[i] == '(' )
         {
             st.push(s[i]);
         }
         else if(s[i]==')')
         {
             if(!st.empty())
             {
                 if(st.top()=='(')
                 {
                     st.pop();
                     max_possible_balanced_bracket_sequence += 2;
                 }
             }
         }
     }
     return max_possible_balanced_bracket_sequence;
 }
 
 int main()
 {
     cout << ""Enter the string : \n"";
     string s;
     cin >> s;
     int string_size = (int)s.size();
     int max_balanced_bracket_sequence = balanced_bracket_sequence(s, string_size);
     cout << ""Maximum possible length of balanced bracket sequence is : \n"";
     cout << max_balanced_bracket_sequence << endl;
 }
 
 /*
 Standard Input and Output
 
 Enter the string :
 ((()())
 
 Maximum possible length of balanced bracket sequence is :
 6
 
 Time Complexity : O(N)
 Space Complexity : O(N)
 
 */
",C-Plus-Plus
"/* 
 A special number is a number in which the sum of factorial of 
 digits is equal to the number itself.
 Example-145 as 145=1!+4!+5!
 */
 
 
 #include <iostream>
 using namespace std;
 
 int special(int x)
 {
     int t=x,b=0,f,sum=0,i;
     while(x!=0)
     {
         b=x%10;
         f=1;
 		/*To calculate factorial of each digit*/
         for(i=1;i<=b;i++)
         f=f*i;
 		/* To store the sum of factorial of digits*/
         sum=sum+f;
         x=x/10;
     }
     if(sum==t)
     return 1;
     else
     return 0;
 }
 /*Main function*/
 int main() {
 	// your code goes here
 	int n;
 	cout<<""Enter a number to check special or not\n"";
 	cin>>n;
 	int a;
 	/*Calling the function special*/
 	a=special(n);
 	if(a==0)
 	cout<<""It is not a special number.\n"";
 	else
 	cout<<""It is a special  number.\n"";
 	return 0;
 }
 
 /*
 Time Complexity:O(n)
 Space Complexity:O(1)
 
 Input/Output:
 Enter a number to check special or not 150
 It is not a special number.
 */
",C-Plus-Plus
"#include <stdio.h>
 #include <stdlib.h>
 #include<strings.h>
 
 //Definition of node
 struct Node{
     char data;
     struct Node *next;
 }*top=NULL;
 
 //function for 'Push(Adding to Queue)'
 void push(char x){
     struct Node *t;
     t=(struct Node*)malloc(sizeof(struct Node));
 
     if(t==NULL)
         printf(""stack is full\n"");
     else{
         t->data=x;
         t->next=top;
         top=t;
     }
 }
 
 //Function for 'Pop(Removing from Queue)'
 char pop(){
     struct Node *t;
     char x=-1;
 
     if(top==NULL)
         printf(""Stack is Empty\n"");
     else{
         t=top;
         top=top->next;
         x=t->data;
         free(t);
     }
     return x;
 }
 
 //Function to Display
 void Display(){
     struct Node *p;
     p=top;
     while(p!=NULL){
         printf(""%d "",p->data);
         p=p->next;
     }
     printf(""\n"");
 }
 
 //function to check Precedence of signs
 int pre(char x){
     if(x=='+' || x=='-')
         return 1;
     else if(x=='*' || x=='/')
         return 2;
     return 0;
 }
 
 //function to check if character is operand or not
 int isOperand(char x){
     if(x=='+' || x=='-' || x=='*' || x=='/')
         return 0;
     else
         return 1;
 
 }
 
 //function to convert infix to postfix
 char * InToPost(char *infix){
     int i=0,j=0;
     char *postfix;
     int len=strlen(infix);
     postfix=(char *)malloc((len+2)*sizeof(char));
 
     while(infix[i]!='\0')
     {
         if(isOperand(infix[i]))
             postfix[j++]=infix[i++];
         else{
             if(pre(infix[i])>pre(top->data))
                 push(infix[i++]);
             else
                 postfix[j++]=pop();
         }
     }
     while(top!=NULL)
         postfix[j++]=pop();
     postfix[j]='\0';
     return postfix;
 }
 
 int main()
 {
     char *infix=""a+b*c-d/e"";
     push('#');
     char *postfix=InToPost(infix);
     printf(""%s "",postfix);
     return 0;
 }
 
 /*
 Input is given as : 'a+b*c-d/e'
 
 Output is : 'abc*+de/-'
 
 */
 /*
 S",C
"/*
   Following is the code to find the Kth smallest element in an array
   Approach:
       1.  Maintain a max heap of size k.
       2.  Traverse the array and remove the top element if it becomes
           greater than the current element of the array.
       3.  The top element of the heap after the traversal of the array
           is the Kth smallest element of the array.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int findkthsmallest(int arr[],int n,int k)
 {
     //creating a max heap pf size k
     priority_queue<int>pq;
 
     //iterating through the elements and storing them in the max heap
     for(int i=0;i<n;i++)
     {
 
       //maintaing size of heap as k
       if(i<k)pq.push(arr[i]);
       else
       {
           if(pq.top()>arr[i])
           {
             pq.pop();
             pq.push(arr[i]);
           }
        }
     }
     return pq.top();
 }
 
 int main()
 {
     cout<<""Enter the size of the array: "";
     int n,k;
     cin>>n;
     cout<<""Enter k: "";
     cin>>k;
     int arr[n];
     cout<<""Enter array elements: "";
     for(int i=0;i<n;i++)
     {
         cin>>arr[i];
     }
     cout<<""The Kth Smallest Element: ""<<findkthsmallest(arr,n,k)<<endl;
     return 0;
 }
 
 /*
 Sample Input:
 
 Enter the size of the array: 8
 Enter k: 4
 Enter array elements: 7 8 9 5 7 2 4 10
 
 Sample Output:
 The Kth Smallest Element: 7
 
 Time Complexity: O(nlogk)
 Space Complexity: O(k)
 */
",C-Plus-Plus
"#include <iostream>
 #include <stack>
 #include <vector>
 using namespace std;
 
 // every node of the binary tree is represented by a 'node' data type
 struct node{
     int key_value;  // value the node holds
     node* left;     // address of its left child
     node* right;    // address of its right child
 };
 
 class binaryTree{
     private:
         node* root;
         void insertKey(int key, node* leaf);
         void preOrderTraversal_recursive(node* leaf);
     public:
         binaryTree();
         void insertKeys(vector<int> keys);
         void insertKey(int key);
         void preOrderTraversal_recursive();
         void preOrderTraversal_iterative();
 };
 
 // constructor. initializes root to NULL
 binaryTree::binaryTree(){
     root = NULL;
 }
 
 // accepts a vector and calls insertKey(int) iteratively.
 void binaryTree::insertKeys(vector<int> keys){
     int len = keys.size();
     for(int i=0;i<len;i++){
         insertKey(keys[i]);
     }
 }
 
 // When called for the first time(when root IS initialized as NULL), insertKey(int)
 // initializes root to point to a node data type. This node data type gets it key_value
 // as key(argument) and child nodes as NULL.
 // For all calls other than the first time, it further calls insertKey(int, node*)
 void binaryTree::insertKey(int key){
     if(root!=NULL){
         insertKey(key, root);
     }
     else{
         root = new node;
         root->key_value = key;
         root->left = NULL;
         root->right = NULL;
     }
 }
 
 // inserts the key, such that the Tree follows the definition of a binary tree.
 // the function travels down the tree starting from the root to find a suitable position.
 // if key is less than the key_value at a node, function calls itself with its left subtree.
 // if key is greater than the key_value at a node, function calls itself with its right subtree.
 // When it reaches a suitable place, it creates a new node. This node gets key_value as key and child nodes as NULL
",C-Plus-Plus
"/* C program to check if a number is a Krishnamurthy number or not.
 Krishnamurthy Number is a number whose sum of the factorial of digits
 is equal to the number itself. The Number is named after Jiddu Krishnamurti */
 
 #include <stdio.h>
 #include <stdbool.h>
 
 
 // Helper function to return the factorial of a number
 long int factorial(int num)
 {
     if (num == 1 || num == 0)
         return 1;
     return num * factorial(num - 1);
 }
 
 bool check_krishnamurthy_number(int num)
 {
     // Store the given number in a temporary variable.
     int temp = num;
     long int sum = 0;
     // Find the sum of the factorial of the individual digits.
     while (temp > 0)
     {
         int rem = temp % 10;
         sum = sum + factorial(rem);
         temp = temp / 10;
     }
     if (sum == num)
         return true;
     else
         return false;
 }
 
 int main()
 {
     int num;
     printf(""Enter the number: "");
     scanf(""%d"", &num);
     bool res = check_krishnamurthy_number(num);
     if (res)
     {
         printf(""The given number %d is a Krishnamurthy Number. "", num);
     }
     else
     {
         printf(""The given number %d is not a Krishnamurthy Number."", num);
     }
 }
 
 /*
 Time Complexity - O(n * log(n)), where 'n' is the given number
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 Enter the number: 145
 The given number 145 is a Krishnamurthy Number. 
 
 SAMPLE II
 
 Enter the number: 1234
 The given number 1234 is not a Krishnamurthy Number.
 */
",C
"/*
 
 Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai).
 n vertical lines are drawn such that the two endpoints of the line i is at (i, ai) and (i, 0).
 Find two lines, which, together with the x-axis forms a container, such that the container contains the most water.
 
 input: heights = [1,8,6,2,5,4,8,3,7]
 Output: 49
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 /* Brute Force Solution */
 const getMaxWaterContainerBrute = function (heights) {
   let maxArea = 0;
 
   // Loop through the each points
   for (let a1 = 0; a1 < heights.length; a1++) {
     for (let a2 = a1 + 1; a2 < heights.length; a2++) {
       const height = Math.min(heights[a1], heights[a2]);
       const width = a2 - a1;
       const area = height * width;
       maxArea = Math.max(maxArea, area); // get the max area
     }
   }
 
   console.log(""Max water container can contain (Brute) - "", maxArea);
   return maxArea;
 };
 
 /* Optimal Solution */
 const getMaxWaterContainerOptimal = function (heights) {
   let a1 = 0,
     a2 = heights.length - 1,
     maxArea = 0;
 
   while (a1 < a2) {
     const height = Math.min(heights[a1], heights[a2]);
     const width = a2 - a1;
     const area = height * width;
     maxArea = Math.max(maxArea, area);
 
     if (heights[a1] <= heights[a2]) {
       a1++;
     } else {
       a2--;
     }
   }
 
   console.log(""Max water container can contain (optimal) - "", maxArea);
   return maxArea;
 };
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered value is number or not
   if (array.includes(N",JavaScript
"// C Program to implement Tim Sort
 /*  
 Tim Sort is a stable sorting algorithm that combines the capabilities of  Merge sort and Insertion sort.
 It first splits the array into  small segments and sort them using Insertion Sort, and then merges the small segments using merge operation.
 It is used in Javas Arrays.sort() as well as Pythons sorted() and sort()
 */
 #include <stdio.h>
 const int SIZE = 16;
 
 //Helper function to find the minimum of two variables
 int min(int a, int b)
 {
     if (a < b)
         return a;
     return b;
 }
 
 // Perform insertion sort
 void insertion_sort(int arr[], int start, int end)
 {
     for (int i = start + 1; i <= end; i++)
     {
         int temp = arr[i], j = i - 1;
 
         /* Shift elements of arr[0..i-1], that are 
         greater than temp, to one position ahead 
         of their current position */
         while (j >= start && arr[j] > temp)
         {
             arr[j + 1] = arr[j];
             j--;
         }
         arr[j + 1] = temp;
     }
 }
 
 // Merge operation to merge two sorted segments
 void merge(int arr[], int start, int mid, int end)
 {
     int n = mid - start + 1, m = end - mid;
     int arr1[n], arr2[m];
 
     for (int i = 0; i < n; i++)
         arr1[i] = arr[start + i];
     for (int i = 0; i < m; i++)
         arr2[i] = arr[mid + 1 + i];
 
     int i = 0, j = 0, k = start;
 
     while (i < n && j < m)
     {
         if (arr1[i] <= arr2[j])
         {
             arr[k] = arr1[i];
             i++;
         }
         else
         {
             arr[k] = arr2[j];
             j++;
         }
         k++;
     }
     while (i < n)
     {
         arr[k] = arr1[i];
         k++;
         i++;
     }
     while (j < m)
     {
         arr[k] = arr2[j];
         k++;
         j++;
     }
 }
 
 // Sort the array using Tim Sort
 void tim_sort(int arr[], int n)
 {
     // Sort individual subarrays of size SIZE
     for (int i = 0; i < n; i += SIZE)
         insertion_sort(arr, i, min",C
"/*
 	==============================================================
 		 Implementing Singly Linked List  data structure
 	==============================================================
 */
 
 package main
 
 import (
 	""fmt""
 )
 
 // Node it is user-defined data type used to store data and the address of next node
 type Node struct {
 	next *Node
 	data int
 }
 
 // List it is user-defined data type used to represent the linked list
 type List struct {
 	head *Node
 	tail *Node
 	size int
 }
 
 // initList(): it will initalize the List's fields for first time
 func (list *List) initList() {
 	list.head = nil
 	list.tail = nil
 	list.size = 0
 }
 
 // isEmpty(): if the head of list is not poiting any node then it will return true otherwise false
 func (list *List) isEmpty() bool {
 	return list.head == nil
 }
 
 // insertAtFront(): if the list is empty then it will assign the same value to head and tail of linked list
 // otherwise it will insert node before the head in linked list
 func (list *List) insertAtFront() {
 	var value int
 	fmt.Println(""enter the value of element to be inserted at front:"")
 	fmt.Scanf(""%d"", &value)
 	var node Node
 	node.data = value
 	if list.isEmpty() {
 		list.head = &node
 		list.tail = &node
 		list.size = 1
 	} else {
 		node.next = list.head
 		list.head = &node
 		list.size++
 	}
 	fmt.Println(""value added successfully at the front of the linked list"")
 }
 
 // insertAtEnd(): if the list is empty then it will assign the same value to head and tail of linked list
 // otherwise it will insert node after the tail in linked list
 func (list *List) insertAtEnd() {
 	var value int
 	fmt.Println(""enter the value of element to be inserted at the end:"")
 	fmt.Scanf(""%d"", &value)
 	var node Node
 	node.data = value
 	if list.isEmpty() {
 		list.head = &node
 		list.tail = &node
 		list.size = 1
 	} else {
 		list.tail.next = &node
 		list.tail = &node
 		list.size++
 	}
 	fmt.Println(""value added successfully at the end of the linked list"")",Go
"#include <stdio.h>
 #include <stdlib.h>
 
 struct pair
 {
     int first;
     int second;
 };
 
 int find_char_index(char *str)
 {
     struct pair p[256] = {0};
     for (int i = 0; str[i]; i++)
     {
         (p[str[i]].first)++;
         p[str[i]].second = i;
     }
     int index = 10001;
     for (int i = 0; i < 256; i++)
     {
         if (p[i].first == 1)
             index = index > p[i].second ? p[i].second : index;
     }
     return index;
 }
 
 int main()
 {
     char str[10000];
     printf(""Enter a string: "");
     scanf(""%s"", str);
     int index = find_char_index(str);
     if (index == 10001)
         printf(""%d"", -1);
     else
         printf(""%d"", index);
     return 0;
 }
 
 /*
 Given a string, find the index of the leftmost non repeating character in it.
 Example: s = ""hello"", output should be: 0 (index of h)
 s = ""aabcdb"", output should be: 3 (index of c)
 s = ""xxyyzz"", output should be -1 (since there is no non repeating character in this string)
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
",C
"/*
 Infix to Postfix conversion using stacks in C++
 ALGORITHM:
 *Scan the element from left to right
 *If the scanned element is a '(' push to stack
 *If scanned element is a '), pop and output contents of stack till empty or '(' is encountered
 *If scanned element is an operand output it
 *If scanned element is an operator, then check for precedence
 *If the precedence of scanned elements is less than the precedence of the operators in the stack then pop and output
 *If the precedence of scanned elements is greater than the precedence of the operators in the stack then push into stack
 */
 #include <bits/stdc++.h>
 using namespace std;
 int prec(char x)
 {
     if (x == '+' || x == '-')
         return 1;
     else if (x == '*' || x == '/')
         return 2;
 }
 void infixToPostfix(string s)
 {
     int l = s.length();
     stack<char> st;
     string new_string = """";
     st.push('X');
     for (int i = 0; i < l; i++)
     {
         if (s[i] == '(')
             st.push(s[i]);
         else if (s[i] == ')')
         {
             while (st.top() != 'X' && st.top() != '(')
             {
                 char x = st.top();
                 new_string += x;
                 st.pop();
             }
             if (st.top() != 'X' && st.top() == '(')
             {
                 st.pop();
             }
         }
         else if (s[i] == '+' || s[i] == '*' || s[i] == '/' || s[i] == '-')
         {
             while (st.top() != 'X' && prec(st.top()) >= prec(s[i]) && st.top() != '(')
             {
                 new_string += st.top();
                 st.pop();
             }
             st.push(s[i]);
         }
         else
         {
             new_string += s[i];
         }
     }
     while (st.top() != 'X')
     {
         new_string += st.top();
         st.pop();
     }
     cout << new_string << ""\n"";
 }
 int main()
 {
     string s;
     cin >> s;
     infixToPostfix(s);
 }
 /*
 Time Complexity: O(n^2)
 INPUT:
 a+b+(c*d)
 OUTPUT:
 ab+cd*+
",C-Plus-Plus
"/*
 Problem : 
 	Given an array of size N. Find the total sum of all the subarrays in the array.
 
 -->Efficient Method : (USING REVERSE LOOKUP)
 	-> Find the count of subarrays where a particular element is included.
 	-> Once we have the repetition number, we can multiply it with the value of element to get its contribution.
 	-> For an element with value 'X' at i-th position :-
 	    -- the number of subarrays starting from index 0 to i = i + 1 
 	    -- the number of subarrays ending on indices from i to N-1 = N - i
     -> The total contribution by X = X * repetitions  = X * ((i + 1) * (N - i)).
     -> Total time complexity => O(N).
 
 Note :- 
 Modular arithmethic to avoid overflows:
 -> (a + b) % M = ((a % M) + (b % M)) % M
 -> (a * b) % M = ((a % M) * (b % M)) % M
 where, M = 10^9 + 7
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 const long long M = 1e9 + 7;
 
 /* function subset_sums() calculates the total sum of all subsets. 
    contribution variable denotes the contribution given by each element in the array.    
 */
 long long subset_sums(vector<int>& array, int n){
     long long sum = 0, contribution;
     for (int i = 0; i < n; i++) {
         contribution = (((i+1) % M * (n-i) % M) % M * array[i] % M) % M;
         sum = ((sum % M) + (contribution % M)) % M;
     }
     return sum;
 }
 
 int main()
 {
     int n, value;
     long long total_sum;
     vector<int> array;
     cin >> n; 
 
     for (int i = 0; i < n; i++) {
         cin >> value;
         array.push_back(value);
     }
 
     // calculating subset sums
     total_sum = subset_sums(array, n);
     cout << total_sum << endl;
 
     return 0;
 }
 
 
 /*
 Input : 
 6
 2 3 4 7 8 9
 
 Output:
 308
 
 Time Complexity : O(n)
 Space Complexity : O(1)
 */
",C-Plus-Plus
"/*
 DOUBLY LINKED LIST TO CHECK IF A STRING IS PALINDROME
 A string is accepted as input from the user.
 The characters in the string are inserted as nodes
 into the doubly linked list.
 Two pointers lptr and rptr are used to point to the
 beginning and end of the string respectively.
 The list is traversed from left to right using lptr
 and right to left using rptr.
 If the characters match until they reach the same node
 the string is palindrome
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //structure for doubly linked list
 typedef struct node
 {
     char data;
     struct node *rlink;
     struct node *llink;
 } node;
 
 //to insert into doubly linked list
 void insert(node *head, char a)
 {
     node *n = new node;
     n->data = a;
     n->rlink = NULL;
     node *ptr = head;
     while (ptr->rlink)
         ptr = ptr->rlink;
     ptr->rlink = n;
     n->llink = ptr;
 }
 
 //to check if the string is palindrome
 int palindrome(node *head)
 {
     if (head->rlink == NULL)
         return 1;
     node *rptr = head;
     while (rptr->rlink)
         rptr = rptr->rlink;
     node *lptr = head->rlink;
     while (lptr != rptr)
     {
         if (lptr->data != rptr->data)
             return 0;
         lptr = lptr->rlink;
         rptr = rptr->llink;
     }
     return 1;
 }
 
 //driver code
 int main()
 {
     node *head = new node;
     char str[30];
     printf(""Enter a string : "");
     scanf(""%s"", str);
     for (int i = 0; str[i] != '\0'; i++)
         insert(head, str[i]);
     if (palindrome(head) == 1)
         printf(""%s is a palindrome\n"", str);
     else
         printf(""%s is not a palindrome\n"", str);
 }
 
 /*
 SAMPLE I/O:
 Enter a string : refer
 refer is a palindrome
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
",C-Plus-Plus
"import sys
 """""" 
 In this problem given set is partitioned into two subsets
 such that the difference between the sum of elements
 of 1st set and the sum of elements of 2nd set is minimized.
 """"""
 """"""
 This problem has an optimal structure i.e. problem can be broken into 
 number of smaller subproblems,further divided into yet smaller and 
 simpler subproblems until the solution becomes trivial. 
 """"""
 """"""
 Using Dynamic Programming Approach
 Partition the set S into two subsets S1,S2 such that the
 difference between the sum of elements is S1 and the sum of
 elements in S2 is minimized
 """"""
 
 
 def MinimumSumPartition(arr):
     # Taking Sum of all elements
     summ = sum(arr)
     
     # Creating a matrix to store values(True,False) 
     # for results of subproblems
     mat = []
     for i in range(len(arr) + 1):
         row = []
         for j in range(summ + 1):
             row.append(0)
         mat.append(row)
     # Now sum 0 can be possible with any number of elements of array 
     # so taking all elements to be True in first column
     for j in range(summ + 1):
         mat[0][j] = True
     # Now with zero elements only sum 0 is possible so initialising all
     # other elements in first row to be False 
     for i in range(len(arr) + 1):
         mat[i][0] = False
     # Filling the Partition Matrix 
     for i in range(1,len(arr) + 1):
         for j in range(1,summ + 1):        
             # If ith element is excluded
             mat[i][j] = mat[i - 1][j]
             # If ith element is included
             if arr[i - 1] <= j:
                 mat[i][j] |= mat[i - 1][j - arr[i - 1]]
     # Intialising the Variable for difference
     minn = sys.maxsize
     # Find largest j in which mat[n][j] is true       
     # Taking the last row with True values till half of range            
     for j in range(summ // 2,-1,-1):
         if mat[len(arr) - 1][j]:
             minn = summ - (2 * j) # break the loop after first value of j 
             ",Python
"/* This program prints lucky numbers till a given number n. Lucky
 number - It is a set of numbers which is formed by eliminating
 numbers based on their position based on the remaining set.*/
 
 package main
 
 import (
 	""fmt""
 )
 
 func lucky_number(number int) {
 
 	// This array stores the lucky numbers
 	array := make([]int, number)
 
 	// This array is used for eliminating
 	count := make([]int, number)
 
 	// This array is used for terminating
 	check := make([]int, number)
 	check[0] = 0
 
 	// Fill the array with numbers from 1 to n
 	for i := 0; i < number; i++ {
 		array[i] = i + 1
 		count[i] = i + 1
 	}
 
 	// First case where every second number is eliminated
 	var counter int = 1
 	for i := counter; i < number; i += 2 {
 		array[i] = -1
 		count[i] = -1
 	}
 
 	// Updating the count array for further eliminations
 	var cnt int = 0
 	for i := 0; i < number; i++ {
 		if(count[i] != -1) {
 			count[i] = cnt + 1
 			cnt++
 		}
 	}
 
 	counter = 3
 	var same int = 0
 	var value int = 1
 
 	// For further forming the series of lucky numbers
 	for {
 		same = 0
 		/* Updating the value of array of lucky number
 		 according to the count array.*/
 		 for i := 0; i < number; i++ {
 			if(count[i] % counter == 0) {
 				array[i] = -1
 			}
 		}
 
 		// Setting the count array to initial state
 		for i := 0; i < number; i++ {
 			count[i] = -1
 		}
 
 		// Forming the count array for next set of eliminations
 		cnt = 0
 		for i := 0; i < number; i++ {
 			if(array[i] != -1) {
 				count[i] = cnt + 1
 				cnt++
 			} else {
 				// Keeping a track of number of -1's in array
 				same += 1
 			}
 		}
 
 		// Filling number of -1's at each iteration
 		check[value] = same
 
 		// Finding the next index to eliminate from
 		for i := counter; i < number; i++ {
 			if(array[i] != -1) {
 				counter = array[i]
 				break
 			}
 		}
 
 		// Terminating step
 		if(check[value] == check[value - 1]) {
 			/* If the number of -1's don't change in
 			two successive operati",Go
"// MERGE SORT IN C
 #include<stdio.h>
 void main()
 {
     int arraySize ,  index;
     printf(""Please enter the size of the array\n"");
     scanf(""%d"",&arraySize);
     int arr[arraySize];
     printf(""Please enter the elements to sort\n"");
     for(index=0 ; index<arraySize ; index++)
     {
         scanf(""%d"",&arr[index]);// You would now fill the array with the numbers you want to sort
     }
 
     // Now the lower bound and upper bound values would be defined
 
 int lower_bound =0;
 int upper_bound = arraySize-1;
 
 // we pass three parameters to the mergeSort function
 
 mergeSort(arr,lower_bound, upper_bound);
 
 printf(""SORTED ARRAY\n"");
 
 for(index=0 ; index<arraySize ; index++)
     {
         printf(""%d\t"",arr[index]);
     }
 
 }
 int mergeSort(int arr[],int lower_bound, int upper_bound)
 {
     // We use recursion to divide the array
 
     if(lower_bound<upper_bound)
     {
         int mid = (lower_bound+upper_bound)/2;
         mergeSort(arr,lower_bound,mid);
         mergeSort(arr,mid+1,upper_bound);
 
         // Now we use merge function to join the array in a sorted manner
         merge(arr , lower_bound , mid , upper_bound );
     }
 }
 int merge(int arr[],int lower_bound , int mid , int upper_bound )
 {
     int variable_a = lower_bound ;
    int variable_b = mid+1;
     int variable_c = lower_bound;
     int size = upper_bound+1 ;
     int arr_new[size]; // we create a new array by arr_new
     while(variable_a<=mid && variable_b<=upper_bound )
     {
         if(arr[variable_a]<=arr[variable_b])
 {
     arr_new[variable_c] = arr[variable_a];
     variable_a++;
 
 }
 else
 {
     arr_new[variable_c] = arr[variable_b];
     variable_b++ ;
 
 }
 variable_c++;
     }
 
     if(variable_a>mid)
     {
         while(variable_b<=upper_bound)
         {
             arr_new[variable_c] = arr[variable_b];
             variable_b++ ;
             variable_c++;
 
         }
     }
 else
 {
     while(variable_a<= mid )
     {
         arr_new[variab",C
"
 /*
 It is a monte carlo version of code with a depth,it give you the optimal or sub optimal result
 */
 
 #include<stdio.h>
 #include<stdlib.h>
 #include<time.h>
 
 int pick_random(int *a,int n){
     int i;
     time_t t;
 
     srand((unsigned)time(&t));
 
     return a[rand()%n];
 }
 
 int* create(int n){
     int* a = (int*)malloc(n*sizeof(n));
 
     for (int i = 0; i < n; i++)
     {
         /* code */
         scanf(""%d"",(a+i));
     }
 
     return a;
     
 }
 
 void display(int *a,int n){
     for (int i = 0; i < n; i++)
     {
         /* print the array */
         printf(""%d "",*(a+i));
     }
     
 }
 
 int random_search(int element,int *a,int n){
     int set_depth = 1000;
      while (1 || set_depth<1000)
      {
          /* infinite loop untill get the element */
          int temp = pick_random(a,n);
 
          if (temp == element)
          {
              return 1;
              break;
          }
 
          set_depth++;
          
      }
 
      return 0;
      
 }
 
 int main(int argc, char const *argv[])
 {
     int n;
 
     printf(""enter the size of the array:"");
     scanf(""%d"",&n);
 
 
     int *a = create(n);
 
     display(a,n);
     
     int element;
 
     printf(""enter the element to search:"");
     scanf(""%d"",&element);
 
     if(random_search(element,a,n)==1){
        printf(""element found"");
     }
     else
     {
         printf(""element not found"");
     }
     
     return 0;
 }
",C
"/*
 
 Stooge sort is a recursive sorting algorithm.
 It is notable for its exceptionally bad time complexity which is slower compared to reasonable sorting algorithms.
 
 Algorithm - 1) If value of the start is larger than the value at the end, swap them
             2) If there are 3 or more elements in the list, then -
                 a] Stooge sort the initial 2/3 of the list
                 b] Stooge sort the final 2/3 of the list
                 c] Stooge sort the initial 2/3 of the list again
 
 Time Complexity - O(n(log3/log1.5)) ( Slower than bubble sort )
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 function stoogeSort(array, start, end) {
   let pivot;
 
   // Checking condition - whehther there are at least 2 elements or not
   if (end - start + 1 > 2) {
     pivot = Math.floor((end - start + 1) / 3);
     stoogeSort(array, start, end - pivot); // sort the first 2/3
     stoogeSort(array, start + pivot, end); // sort the last 2/3
     stoogeSort(array, start, end - pivot); // sort the first 2/3 again
   }
 
   // Swap if the leftmost element is larget than rightmost
   if (array[start] > array[end]) {
     [array[start], array[end]] = [array[end], array[start]];
   }
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered value is number or not
   if (array.includes(NaN)) return console.log(""Only numbers are allowed"");
 }
 
 console.log(""Your array - "", array);
 
 // Call the algorithm
 stoogeSort(array, 0, arrayLength - 1);
 console.log(""Sorted Array - "", array);
 
 // Sample I/O
 
 /*
 
 > node Stooge",JavaScript
"""""""
 
 Input:
 
     Enter the number of rows: 3
 
     Enter the number of columns: 3
 
     Enter the entries row wise:
     1
     1
     0
     0
     0
     0
     0
     2
     0
 
 Output:
 
     Given matrix is a sparse matrix
     [0, 0, 2]
     [0, 1, 1]
     [1, 1, 2]
 
 
 Time Complexity:O(noOfRows*noOfcolumns)
 Space Complexity:O(1)
 
 """"""
 
 
 # for row and column input
 
 
 ROW = int(input(""Enter the number of rows:""))
 COLUMN = int(input(""Enter the number of columns:""))
 
 
 # Initialize matrix
 
 
 matrix = []
 
 print(""Enter the entries row wise:"")
 
 # For user input
 
 
 for i in range(ROW):          # A for loop for row entries
     a = []
     for j in range(COLUMN):      # A for loop for column entries
         a.append(int(input()))
     matrix.append(a)        # taking input of arrays
 
 # Initializing count = 0 to count the number of zeros.
 
 count = 0
 
 # Calculates number of rows and columns present in given matrix
 
 
 matrix_rows = len(matrix)
 matrix_cols = len(matrix[0])
 
 # Calculates the size of the array
 
 
 size = matrix_rows * matrix_cols
 
 
 # Count all zero element present in matrix
 
 for i in range(0, matrix_rows):
     for j in range(0, matrix_cols):
         if(matrix[i][j] == 0):
             count = count + 1
 
 
 # Sparse Matrix definition
 
 def sparse_matrix():
     size = 0
     for i in range(ROW):
         for j in range(COLUMN):
             if (matrix[i][j] != 0):
                 size += 1
 
     matrix_rows, matrix_cols = (3, size)
     Print_Matrix = [[0 for i in range(matrix_cols)]
                     for j in range(matrix_rows)]
 
     k = 0
     for i in range(ROW):
         for j in range(COLUMN):
             if (matrix[i][j] != 0):
                 Print_Matrix[0][k] = i
                 Print_Matrix[1][k] = j
                 Print_Matrix[2][k] = matrix[i][j]
                 k += 1
 
     for i in Print_Matrix:
         print(i)
 
 
 if(count == size):
     print(""Null Mtrix"")
 
 elif(count > (siz",Python
"/* C Program to implement a Stack using Queue.Here we will try to realise STACK
     using the properties OR functions of QUEUE and by making pop operation
    costly*/
 
 #include <malloc.h>
 #include <stdio.h>
 
 struct Node {
   int data;
   struct Node *next;
 };
 
 /*Maintaining a front,rear pointer
  where insertion takes place at rear end and deletion at front
  and O(1) time is taken  for insertion by maintaining a rear pointer
 */
 struct Node *front = NULL, *rear = NULL;
 // Store size of queue
 int qsize = 0;
 
 // check whether queue is empty or not
 int isEmpty(struct Node *q) {
   if (q == NULL) {
     // return true i.e Queue is empty
     return 1;
   }
   return 0;
 }
 
 // Enqueue i.e insert at the REAR end
 int enQueue(int item) {
   struct Node *q;
   // creation of new node
   q = (struct Node *)malloc(sizeof(struct Node));
   q->data = item;
   q->next = NULL;
 
   /* If queue is empty
   i.e front is pointing to NULL update front*/
   if (front == NULL) {
     front = q;
   } else {
     (rear)->next = q;
   }
 
   rear = q;
   // increase current queue size
   qsize++;
   return 0;
 }
 
 // Dequeue i.e delete at the FRONT end
 int deQueue() {
   int delElement;
   /*Queue is empty
   dequeue not possible*/
   if (isEmpty(front)) {
     return -1;
   } else {
     // store the dequeued element
     delElement = front->data;
     (front) = (front)->next;
 
     if ((front) == NULL) {
       (rear) == NULL;
     }
     // reduce the current queue size
     qsize--;
   }
   return delElement;
 }
 
 void push(int data) { enQueue(data); }
 
 int pop() {
   int i, element;
   /* dequeue upto n-1 elements in the queue
      and enqueue the respective dequeued element
          at the REAR end of the queue*/
   for (i = 0; i < qsize - 1; i++) {
     element = deQueue();
     enQueue(element);
   }
   /* dequeue the element which will be first value of the STACK
    and return the element*/
   element = deQueue();
   if (element == -1) {
     printf(""\",C
"""""""
 Algorithm to find the first non-repeating character in a string
 Input the string from the user.
 Start traversing the string using two loops.
 Use the first loop to scan the characters of the string one by one.
 Use the second loop to find if the current character is occurring
 in the latter part of the string or not.
 If it is not occurring, print that character.
 Else, continue traversing.
 """"""
 
 
 def firstNotRepeatingCharacter(string):
     for i in range(len(string)):
         flag = False
         for j in range(len(string)):
             if string[i] == string[j] and i != j:
                 flag = True
         if not flag:
             return string[i]
     return ""_""
 
 string = input(""Enter a string: "")
 index = firstNotRepeatingCharacter(string)
 if index is None:
     print('No non repeating character found.
           All the characters are repeating.')
 else:
     ind = string.find(index)
     print(""Non Repeating character "" +
           str(string[ind]) + "" found at index "" + str(ind))
 
 """"""
 Sample input 1:
 Input: Enter a string : abaacd
 Output: Non Repeating character b found at index 1
 Sample input 2:
 Input: Enter a string : aabbccdd
 Output: No non repeating character found. All the characters are repeating.
 Time Complexity: O(n*2) - n being the length of string
 Space Complexity: O(n)
 """"""
",Python
"""""""
 The worst fit strategy is a reverse of the best-fit strategy. It allocates the largest block available in the storage list.
 The idea behind worst-fit is to reduce the rate of production of small blocks. The below program is an implementation of
 the worst fit algorithm using array data structure.
 """"""
 
 # Block class is used as the fixed memory blocks for allocation
 class Block:
     def __init__(self):
         self.size = 0
         self.ID = 0
         self.fragment = 0
 
 
 # process class is used for allocating memory for the requesting processes
 class process:
     def __init__(self):
         self.Num = 0
         self.size = 0
         self.block = None
 
 
 # initialiseBlocks function initializes all the blocks with sizes and id
 def initialiseBlocks(arr, sizes, n):
     for i in range(n):
         arr[i].size = sizes[i]
         arr[i].fragment = sizes[i]
         arr[i].ID = i + 1
 
 
 # printResult function prints the result of the memory allocation strategy
 def printResult(arr2, numOfProcess):
     print(
         ""Process No            Process Size          Block ID          Block Size         Block Fragment""
     )
     for i in range(numOfProcess):
         print(
             str(arr2[i].Num)
             + ""                     ""
             + str(arr2[i].size)
             + ""                     ""
             + str(arr2[i].block.ID)
             + ""                     ""
             + str(arr2[i].block.size)
             + ""                     ""
             + str(arr2[i].block.fragment)
         )
 
 
 # worstfit function allocates memory to processes using worstfit allocation algorithm
 def worstfit(arr, sizes, n, arr2, numOfProcess):
     maxBlock = Block()
     for i in range(numOfProcess):
         max = 0
         for j in range(n):
             if arr2[i].size <= arr[j].fragment and arr[j].fragment > max:
                 max = arr[j].fragment
                 maxBlock = arr[j]
         maxBlock.fragment = maxBlock.fragment -",Python
"/*
 Given a number. find it's smallest prime factor.
 we have to get the smallest factor of that number and
 the smallest factor has to be a prime number.
 */
 
 import java.util.Scanner;
 import java.lang.*;
 import java.math.*;
 
 public class SmallestPrimeFactor
 {
     //this function checks whether a number is prime or not
     static int check_prime(int number)
     {
        for(int i = 3; i * i <= number; i += 2)
        {
           if(number % i == 0)
           {
               return 0;
           }
        }
        return 1;
     }
 
     //this function gives us the smallest prime factor of a number
     static int get_smallest_prime_factor(int number)
     {
         int get_factor = 0;
         /* loop runs till sqrt( number ) for not any getting precision errors
          use i * i <= number */
          for(int i = 3 ; i * i <= number; i += 2)
          {
              if(number % i == 0)
              {
                 get_factor = 1;
                 int prime = check_prime(i);
                 if(prime == 1)
                 {
                   // that means the number is smallest prime factor 
                    get_factor = i;
                    break;
                  }
              }
         }
         if(get_factor == 0)
         {
         /*
         that means the number itself it's smallest prime factor.
         Ex : 17 so we can return the number. */
           return number;
         }
         return get_factor;
     }
     
     public static void main(String args[])  
     {
         Scanner scan = new Scanner(System.in);
 	System.out.print(""Enter the number : \n"");
 	int number = scan.nextInt();
 	    
         /* if the number is even, we can say that the smallest prime factor
         is 2 for any even number. because 2 is prime and it's a factor of
         every even number. */
         if(number % 2 == 0)
         {
             System.out.println(""Smallest prime factor for this number is : 2"");
         }
         e",Java
"import java.util.*;
 
 class MergeSortedArrays
 {
 	private static void merge(int arr1[], int arr2[])
 	{
         if (arr1 == null || arr2 == null) {
             return;
         }
 
 		// Iterate through all elements of arr2[] in reverse 
 		for (int i = (arr2.length - 1); i >= 0; i--)
 		{
             // In here we compare the different terms of
             // both arrays and place them in respective positions
 			int j, last = arr1[arr1.length - 1];
 			for (j = arr1.length - 2; j >= 0 && arr1[j] > arr2[i]; j--) {
                 arr1[j+1] = arr1[j];
             }
 			// If there was a greater element
 			if (j != arr1.length - 2 || last > arr2[i])
 			{
 				arr1[j+1] = arr2[i];
 				arr2[i] = last;
 			}
 		}
 	}
 
 	public static void main(String[] args)
 	{
         Scanner sc = new Scanner(System.in);
 
         // taking input array 1
         System.out.println(""Enter size of first array:"");
         int size1 = sc.nextInt();
         int arr1[] = new int[size1];
         System.out.println(""Enter array elements:"");
         for (int i=0; i<size1; i++) {
             arr1[i] = sc.nextInt();
         }
         // taking input array 2
         System.out.println(""Enter size of second array:"");
         int size2 = sc.nextInt();
         int arr2[] = new int[size2];
         System.out.println(""Enter array elements:"");
         for (int i=0; i<size2; i++) {
             arr2[i] = sc.nextInt();
         }
         sc.close();
         
         merge(arr1, arr2);
 
         System.out.println(""Sorted arrays are:"");
         for (int i = 0; i < size1; i++) {
             System.out.print(arr1[i] + "" "");
         }
         System.out.println();
         for (int i = 0; i < size2; i++) {
             System.out.print(arr2[i] + "" "");
         }
 	}
 }
 /**
  * Sample input/output
  * Enter size of first array:
  * 6
  * Enter array elements:
  * 1 8 9 15 16 18
  * Enter size of second array:
  * 4
  * Enter array elements:
  * 2 4 7 10
  * Sorted arrays ar",Java
"package main
 
 import (
 	""fmt""
 	""math""
 )
 
 // Find takes a slice and looks for an element in it. If found it will
 // return true otherwise it will return false.
 func Find(slice []string, val string) (int, bool) {
 	for i := 0; i < len(slice); i++ {
 		if string(slice[i]) == val {
 			return i, true
 		}
 	}
 	return -1, false
 }
 
 func longestSubstring(value string) {
 	if len(value) == 0 {
 		fmt.Println(""String is empty"")
 	} else {
 		left := 0
 		right := 0
 		maxLength := 0 // max lenght of substring
 
 		var uniqueChars []string // to store the visited chars.
 
 		var start int // starting index for longest substring with non repeating char.
 		var end int   // ending index for longest substring with non repeating char.
 
 		for right < len(value) && left < len(value) {
 			index, isThere := Find(uniqueChars, string(value[right]))
 			if !isThere {
 				uniqueChars = append(uniqueChars, string(value[right]))
 				maxLength = int(math.Max(float64(maxLength), float64(len(uniqueChars))))
 				if maxLength == len(uniqueChars) {
 					// if the maxLenght == lenght of uniqeChars it might be the longest substring
 					// with non repeating char.
 					// si it's stroing the starting and ending index of that substring
 					start = left
 					end = right
 
 				}
 				right++
 			} else {
 
 				char := string(value[left])
 				// finding the index of char that is repeatating in substring
 				index, isThere = Find(uniqueChars, char)
 				if isThere {
 					// this simple removes the that char from this slice
 					uniqueChars = append(uniqueChars[:index], uniqueChars[index+1:]...)
 					left++
 				}
 
 			}
 		}
 
 		fmt.Print(""Longest Substring Without Repeating Characters: "")
 		fmt.Println(value[start : end+1])
 
 	}
 }
 
 func main() {
 	var input string
 	fmt.Println(""enter the string without space"")
 	fmt.Scanf(""%s"", &input)
 	longestSubstring(input)
 }
 
 /*
 
 	input/output sample
 
 	enter the string without space
 	pwwkew
 	Longest Substring Witho",Go
"""""""Julia program to check if a number is a Neon Number or not
 A neon number is a number where the sum of digits of square of the number is equal to the number.
 """"""
 
 function check_neon_num(n)
     sum = 0
     temp = n ^ 2
     while(temp != 0)
         sum = sum + (temp % 10)
         temp = temp   10
     end
     if(sum == n)
         return true
     else
         return false
     end
 end
 
 
 print(""Enter the number: "")
 n = readline()
 n = parse(Int, n)
 res = check_neon_num(n)
 if res
     println(""The given number $n is a Neon Number."")
 else
     println(""The given number $n is not a Neon Number."")
 end
 
 
 """"""
 Time Complexity: O(log(num)), where 'num' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 0
 The given number 0 is a Neon Number..
 
 SAMPLE 2
 Enter the number: 14
 The given number 14 is not a Neon Number.
 
 """"""
",Julia
"/*
 
 Shaker Sort aka Cocktail aka bidirectional sort aka ripple sort is an extension of bubble sort.
 Cocktail extends bubble sort by operating in two directions
 Algortihm - 1. Loop through array from left to right -> compare adjacent values & swap accordingly
             2. Loop through array in opposite direction i.e from end to start of array
 Time Complexity - 1. Best Case : O(n)
                   2. Worst/Average Case : O(n*n)
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Perform shaker sort
 function ShakerSort(array) {
   let start = 1; // start index
   let end = array.length - 1; // end index
 
   while (start <= array.length / 2) {
     // Loop from left to right
     for (let i = start - 1; i < end; i++) {
       if (array[i] > array[i + 1]) {
         [array[i], array[i + 1]] = [array[i + 1], array[i]];
       }
     }
 
     end = end - 1;
 
     // Loop from right to left
     for (let i = end; i >= start; i--) {
       if (array[i] < array[i - 1]) {
         [array[i], array[i - 1]] = [array[i - 1], array[i]];
       }
     }
 
     start = start + 1;
   }
 
   console.log(""Sorted Array - "", array);
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered value is number or not
   if (array.includes(NaN)) return console.log(""Only numbers are allowed"");
 }
 
 console.log(""Your array - "", array);
 
 // Call the algorithm
 ShakerSort(array);
 
 /*
 
 > node ShakerSort 
 
 Enter array length - 7
 Enter 1 element - 21
 Enter 2 element - 87
 Enter 3 element - 65
 Enter 4 element - 45
 Enter 5 element - ",JavaScript
"/* Problem statement :
 Given an unsorted array. Sort the array in such a way that the array looks like a wave array.
 For example, if the given sequence arr has n elements then the sorted wave array looks like -
 arr[0] >= arr[1] and arr[1] <= arr[2]
 arr[2] >= arr[3] and arr[3] <= arr[4]
 arr[4] >= arr[5] and arr[5] <= arr[6] And so on
 For example, the given array : arr = { 4, 3, 5, 2, 3, 1, 2 } 
 The above figure is a visual representation of the given arr and you can see we can express arr in a waveform array because 
 4>3 and 3<5 
 5>2 and 2<3
 3>1 and 1<2
 And it follows the condition of wave array */
 
 #include <bits/stdc++.h>
 using namespace std;
 vector<int> wave_sort(vector<int> &v, int n)
 {
 	for (int i = 0; i < n; i += 2)
 	{
 		/*If the current element is lesser in value than the previous and is not the first.
 		then the values are swapped */
 		if (v[i] < v[i - 1] and i != 0)
 		{
 			swap(v[i], v[i - 1]);
 		}
 
 		/*If the current element is lesser in value than the next and is not the last.
 		then the values are swapped */
 		if (v[i] < v[i + 1] and i != n - 1)
 		{
 			swap(v[i], v[i + 1]);
 		}
 	}
 
 	return v;
 }
 
 int main()
 {
 	int n;
 	vector<int> v;
 	cin >> n;
 
 	for (int i = 0; i < n; i++)
 	{
 		int temp;
 		cin >> temp;
 		v.push_back(temp);
 	}
 	wave_sort(v, n);
 	
 	//Printing the final vector
 	for (int i = 0; i < n; i++)
 	{
 		cout << v[i] << "" "";
 	}
 
 	return 0;
 }
 
 /* Example 1:
 Input[] : {20 80 40 35 10 15 70}
 Output[] : {80 20 40 10 35 15 70}
 
 Example 2:
 Input[] = {12 20 45 60 5}
 Output[] : {20 12 60 5 45}
 
 Time Complexity: O(n) */
",C-Plus-Plus
"""""""
 Python program to find the n'th number in the tribonacci series
 Tribonacci series is a generalization of the Fibonacci sequence, in which the current term
 is the sum of the previous three terms.
 """"""
 
 def find_tribonacci(n):
     dp = [0] * n
     dp[0] = 0
     dp[1] = 0
     dp[2] = 1
 
     # Compute the sum of the previous three terms
     for i in range(3,n):
         dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
 
     return dp[n-1]
 
 if __name__ == '__main__':
     print(""Enter the value of n?, where you need the n'th number in the tribonacci sequence. "", end="""")
     n = int(input())
     if (n <= 0):
         print(""The given value of n is invalid."", end="""")
         exit()
 res = find_tribonacci(n)
 print(""The {}'th term in the tribonacci series is {}."".format(n, res))
 
 
 """"""
 Time Complexity - O(n)
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 Enter the value of n?, where you need the n'th number in the tribonacci sequence. 12
 The 12'th term in the tribonacci series is 149.
 
 SAMPLE II
 Enter the value of n?, where you need the n'th number in the tribonacci sequence. 1254
 The 1254'th term in the tribonacci series is 4020147461713125140.
 """"""
",Python
"''' K-TH LARGEST NUMBER 
     To find the k-th largest number from an array of distinct numbers
     * The array is sorted in descending order
     * arr[k-1] gives the k-th largest number
 '''
 
 # to sort the array- Bubble Sort
 def sort_arr(arr):
     n = len(arr)
     for i in range(0, n-1):
         for j in range(0, n-i-1):
             if(arr[j] < arr[j+1]):
                 temp = arr[j]
                 arr[j] = arr[j+1]
                 arr[j+1] = temp
     return arr
 
 #to find k-th largest element
 def k_largest(arr, k):
     return arr[k-1]
 
 #driver code
 def main():
     #accept array and k as user inputs
     arr = list(map(int, input(""Enter the array: "").split()))
     k = int(input(""Enter the value of k: ""))
     print(k_largest(sort_arr(arr), k))
 
 if __name__ == '__main__':
     main()
 
 '''
     Sample Input:
     Enter the array: 1 5 3 6 2 7
     Enter the value of k: 3
 
     Sample Output:
     5
 
     Time Complexity: O(n^2)
     Space complexity: O(n)
 '''
",Python
"/*
 Given an array of numbers find the next smallest element to the left of each element.
 ALGORITHM:
 *We use the concept of Last In First Out of stacks
 *Here we use the Stack class
 */ 
 
 import java.util.Stack;
 import java.util.Scanner;
 
 public class NextSmallestToLeft
 {
     public static void nextSmallestToLeft(int a[],int n)
     {
         //Initializing in-built stack
         Stack<Integer> st=new Stack<>();
         int v[]=new int[n];
         for(int i=0;i<n;i++)
         {
             if(st.empty())
             v[i]=-1;
             else if(st.empty()!=true && st.top()<a[i])
             v[i]=st.top();
             else if(st.empty()!=true && st.top()>=a[i])
             {
                 while(st.empty()!=true && st.top()>=a[i])
                 st.pop();
 
                 if(st.empty())
                 v[i]=-1;
                 else if(st.top()<a[i])
                 v[i]=st.top();
             }
             st.push(a[i]);
         }
         for(int i=0;i<n;i++)
         System.out.print(v[i]+"" "");
     }
     public static void main(String args[])
     {
         Scanner s=new Scanner(System.in);
         int n;
         System.out.println(""Enter the size of the array: "");
         n=s.nextInt();
         int a[]=new int[n];
         System.out.println(""Enter the elements: "");
         for(int i=0;i<n;i++)
         a[i]=s.nextInt();
         nextSmallestToRight(a,n);
         s.close();        
     }
 }
 
 /*
 Time Complexity: O(n)
 
 Space Complexity: O(n)
 
 Input:
 
 Enter the size of the array: 
 5
 Enter the elements:
 4 6 2 9 0
 
 Output:
 
 -1 4 -1 2 -1
 */
",Java
"/*
 Queue is a linear data structure which follows FIFO
 (First In First Out) Rule. It can be implemented using array/
 linked list/ stacks.
 */
 
 #include<stdio.h>
 #include<stdlib.h>
 /*We are creating a structure for Queue.*/
 struct node
 {
     int front,rear;
     int capacity;
     int *ptr;
 };
 /*Creating an empty node of the queue*/
 struct node* createqueue(int cap)
 {
     struct node *queue;
     queue=(struct node*)malloc(sizeof(struct node));
     queue->front=0;
     queue->rear=0;
     queue->capacity=cap;
     queue->ptr=malloc(sizeof(int)*queue->capacity);
     return(queue);
 }
 /*Checking if the Queue is empty or not*/
 int isEmpty(struct node *queue)
 {
     if(queue->rear==queue->front)
         return 1;
     return 0;
 }
 /*Checking if the Queue is full or not*/
 int isFull(struct node *queue)
 {
     if((queue->rear+1)%queue->capacity==queue->front)
         return 1;
     return 0;
 }
 /*Inserting data into the queue*/
 void enQueue(struct node *queue)
 {
     if(isFull(queue))
         printf(""\nQueue is full.\n"");
     else
     {
         int data;
         printf(""\nEnter data t be inserted : "");
         scanf(""%d"",&data);
         queue->rear=(queue->rear+1)%queue->capacity;
         queue->ptr[queue->rear]=data;
     }
 }
 /*Deleting data from the queue*/
 void deQueue(struct node *queue)
 {
     if(isEmpty(queue))
         printf(""\nQueue is empty.\n"");
     else
     {
         int data;
         queue->front=(queue->front+1)%queue->capacity;
         data=queue->ptr[queue->front];
         printf(""\n%d is deleted from queue.\n"",data);
     }
 }
 /*Traversing queue and printing data*/
 void display(struct node *queue)
 {
     int i;
     if(isEmpty(queue))
         printf(""\nQueue is empty.\n"");
     else
     {
         printf(""\nElements in Circular Queue are: \n"");
         for(i=queue->front+1 ; i != queue->rear ; i = (i+1) % queue->capacity)
             printf(""Data = %d\n"",queue->ptr[i]);
         printf(""Data = %d\n"",queu",C
"/*
 C# Program to Perform a Heap Sort
 Heap Sort is a popular and efficient sorting algorithm.Heap sort is a comparison
 based sorting technique based on Binary Heap data structure. It is similar to 
 selection sort where we first find the minimum element and place the minimum 
 element at the beginning. We repeat the same process for the remaining elements.
 */
 
 using System;
 public class HeapSort
 {
     static void Sort(int[] array, int length)
     {
         //Build max heap
         for (int i = length / 2 - 1; i >= 0; i--)
         {
             Heapify(array, length, i);
         }
         for (int i = length - 1; i >= 0; i--)
         {
             //Swap
             int temp = array[0];
             array[0] = array[i];
             array[i] = temp;
             //Heapify root element
             Heapify(array, i, 0);
         }
     }
 
     //Rebuilds the heap
     static void Heapify(int[] array, int length, int i)
     {
         //Find largest among root and children
         int max = i;
         int left = 2 * i + 1;
         int right = 2 * i + 2;
         
         if (left < length && array[left] > array[max])
         {
             max = left;
         }
         
         if (right < length && array[right] > array[max])
         {
             max = right;
         }
         
         //If root is not largest, swap with largest and continue heapifying
         if (max != i)
         {
             int swap = array[i];
             array[i] = array[max];
             array[max] = swap;
             Heapify(array, length, max);
         }
     }
 
     public static void Main()
     {
         //Take array size input
         Console.Write(""Enter array size: "");
         int length = Convert.ToInt32(Console.ReadLine());
         
         int[] array = new int[length]; 
         
         //Take array elements input
         for(int i=0; i<length; i++){
             Console.Write(""Element {0} : "", i);
             array[i] = Convert.ToI",C-Sharp
"//Using GCD, find LCM of two number.
 
 #include <iostream>
 using namespace std;
 
 // Gcd recursive Function
 long long gcd(long long int x, long long int y)
 {
   if (y == 0)
     return x;
     //Rcursive function
   return gcd(y, x % y);
 }
 
 // Lcm Function
 long long lcm(int a, int b)
 {
 	//return Lcm of two number
     return (a / gcd(a, b)) * b;
 }
 
 //main function
 int main()
 {
 	//Input 2 numbers for Lcm
     int n1, n2;
     cout << ""Enter two numbers: "";
     cin >> n1 >> n2;
     //Print output
     cout<<""\tOUTPUT\n"";
     //calling Lcm Funtion
     cout << lcm(n1, n2); 
  
     return 0;
 }
 /*Sample Input Output
 
 Sample 1.
 Enter two numbers : 761457 614573
 
 	OUTPUT
 LCM of 761457 and 614573 --> 467970912861
 
 Sample 2.
 Enter two numbers : 6 8
 
 	OUTPUT
 LCM of 6 and 8 --> 24
 
 Time Complexity :O(logn)
 Space Complexity:O(1)
 
 */
 
",C-Plus-Plus
"/*
  - Meetings :
       We will give the input as our available time and if our available time is in between
       meeting_hour1 to meeting_hour2 then we are able to attend the meeting otherwise not
       time is a string in the format ""HH:MM AM"" or ""HH:MM PM"" (without quotes)
 
  - Example : Let the available time be 01:04 AM and scheduled meeting time be 12:00 AM to 03:00 PM
              now, 01:04 AM lies between 12:00 AM to 03:00 PM hence, we can attend the meeting
 
  - Approach :
    1. As the time is in the form of String so we have to convert it to the integer and we will use
       time conversion method
 
    2. If time is in AM then just multiply hour by 100 and add minutes to it
       for example - time is 01:04 AM
                     multiply hour by 100(1*100 = 100) and then add minutes(100 + 04 = 104)
 
    3. If time is in PM then multiply hour by 100 and add 1200 + minutes to it
       for example - time is 01:04 PM
                     multiply hour by 100(1*100 = 100) and then add 1200 + minutes(100 + 1200 + 04 = 1304)
 
    4. After converting String to integer check the condition (available_time >= meeting_hour1 && available_time <= meeting_hour2)
       if it is true then you can attend the meeting otherwise not
  */
 
 import java.util.Scanner;
 
 public class Meetings {
 
 	//method to convert String to an integer
 	public static int timeConversion(String s) {
 
         //taking first 2 characters of String
 		int hour = Integer.parseInt(s.substring(0, 2)) % 12;
 		hour = hour*100;
 
         //If String ends with PM then add 1200 to hour
 		if (s.endsWith(""PM"")) {
 			hour += 1200;
 		}
 		//adding minutes to hour
 		int minute = Integer.parseInt(s.substring(3, 5));
 		hour = hour + minute;
 
 		return hour;
 	}
 
 	//main method
 	public static void main(String[] args){
 
 		Scanner sc = new Scanner(System.in);
 
 		//Enter the time when you are available
 		System.out.print(""Enter Time : "");
 		String date1=sc.nextLine();
 
 		int a",Java
"/*
  Fibonacci Search
 Search for an element in a Sorted Array
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 int fibonacciSearch(int arr[], int n, int element) {
    // Initializing fibonacci no 
    //(m-2)th fibonacci no
    int fibM2 = 0; 
    //(m-1)th fibonacci no. 
    int fibM1 = 1; 
    //mth fibonacci no.
    int fibM = fibM1 + fibM2; 
 
    /*finding smallest fibonacci no. greater than or equal to 
      n in Fibonacci sereies and storing it in fibM */
 
    while (fibM < n) {
       fibM2 = fibM1;
       fibM1 = fibM;
       fibM = fibM1 + fibM2;
    }
 
    // to mark range elminated from front 
    int offset = -1;
 
    /* until there are elements to be inspected 
       we compare arr[fibM2] with element when fibM becomes 1 
       then fibM1 becomes 1 and fibM2 becomes 0 */
 
    while (fibM > 1) {
 
       // Check if fibM2 is valid location
       int i = min(offset + fibM2, n - 1);
 
       /*
         when element is greater than value at index fibM2 ,
         we move 3 fibonacci variable ,1 fibonacci down reset offset to i.
         we drop approx front 1/3 of remaining array 
       */
       if (arr[i] < element) {
          fibM = fibM1;
          fibM1 = fibM2;
          fibM2 = fibM - fibM1;
          offset = i;
       }
       /*
         when element is less than value at index fibM2 ,
         we move 3 fibonacci variable ,2 fibonacci down
         we drop approx rear 2/3 of remaining array 
       */
       else if (arr[i] > element) {
          fibM = fibM2;
          fibM1 = fibM1 - fibM2;
          fibM2 = fibM - fibM1;
       }
       // if found return index 
       else return i;
    }
    // check for last array element 
    if (fibM1 && arr[offset + 1] == element)
       return offset + 1;
 
    // element not found return -1
    return -1;
 }
 
 int main() {
    int n; 
    cout << ""Enter Size Of Arrary:"" << ""\n"";
    cin >> n;
 
    int arr[n]; 
    cout << ""Enter Elements In Array"" << ""\n"";
 
    for (int i = 0; i",C-Plus-Plus
"/*
 Is Symmetric Tree
 
 For a given a Binary Tree,
 your task is to check whether it is Symmetric or not,
 i.e. whether that binary tree is a Mirror image of itself or not.
 Like--
     5 
    / \
   2   2
  /     \
 3       3
 This is a symmetric tree.
 */
 
 import java.util.LinkedList; 
 import java.util.Queue; 
 import java.io.*;
 import java.util.*;
 
 //defining a class for storing nodes of tree
 class Node
 {
     int value;
     Node left;
     Node right;
     Node(int value)
     {
         this.value = value;
         left=null;
         right=null;
     }
 }
 
 class Checksymmetric
 {
     // function to return true/false accordingly if the tree is Symmetric or if not
     public static boolean isSymmetric(Node root)
     {
         // If the tree is empty then obviously it is symmtric
         if(root == null)
         {
             return true;
         }
         // Otherwise
         return util(root.left, root.right);
     }
 
     public static boolean util(Node n1,Node n2)
     {
         // If the trees are empty then they are symmetric
         if(n1 == null && n2 == null)
         {
             return true;
         }
         // If any one is empty then obviously is not equal to that tree
         // and hence not symmetric
         if(n1 == null || n2 == null)
         {
             return false;
         }
         // Otherwise
         return n1.value == n2.value && util(n1.left, n2.right) && util(n1.right, n2.left);
     }
 }
 
 //driver code
 class Is_symmetric_tree
 {
     // Function to build the tree
     static Node buildTree(String str)
     {    
         if(str.length() == 0 || str.charAt(0) == 'N')
         {
             return null;
         }
 
         String ip[] = str.split("" "");
         // Here we start creating the root of the tree
         Node root = new Node(Integer.parseInt(ip[0]));
         // Pushing the roots to the queue
         Queue<Node> Treequeue = new LinkedList<>(); 
         Treequeue.add(root);
 
    ",Java
"/* This is a use of Sieve of Eratosthenes algorithm.
 In this We can find all unique prime factor of any number n.For example if n is 12 then output will be 2,3
 In this first we store all prime factor of numbers till n and then print prime factors of n. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void unique_prime(int n){
   int arr[n+1];
   memset(arr , 1 , n+1);
   //first find all prime factors till n by sieves method 
   for(int i = 2 ; i <= sqrt(n) ; i++) {
     if(arr[i]==0){
       continue;
     } 
       for(int j = i*i ; j <=n ; j += i){
         arr[j] = 0;
       
     }
   }
   //now check which prime number are factor of n
   cout<<""All unique prime factors of ""<<n<<"" are: "";
   for(int i=2; i<=n; i++){  
     if(arr[i] == 0 && n%i == 0 ) {
       cout << i <<""  "";
     }
   }
 }
 
 int main() {
   int num;
   cout<<""Enter the number: "";
   cin >> num;
   unique_prime(num);
 }
 
 /* Sample Input
    Enter the number: 5446
    Sample output
    All Unique prime factors of 5446 are: 2  7  389 
 */
 /* Time complaxity : O(n + n(log(logn)))
    Space Complaxity : O(n)
 */
",C-Plus-Plus
"'''
 Jack and Harry are playing a new game today. They form a tower of N coins 
 and make a move in alternate turns. harry plays first. In one step, the player 
 can remove either 1, X, or Y coins from the tower. The person to make the last 
 move wins the game. Find who wins the game for different number of coins.
 '''
 
 def findWinner(totalcoins ,coinsThatCanBeRemoved1, coinsThatCanBeRemoved2) :
     #We are assuming that y is greater than or equal to x
     if coinsThatCanBeRemoved1>coinsThatCanBeRemoved2 :
         coinsThatCanBeRemoved1, coinsThatCanBeRemoved2 = coinsThatCanBeRemoved2, coinsThatCanBeRemoved1
         
     '''
         dp[i] represents whether Harry will win provided that ""i"" coins
         are remaining and it is Harry's turn.
         If Harry will win in that scenario, dp[i] will be true otherwise
         it'll be false.
 
     '''
    
     dp = [False] * (totalcoins+1)
     #i represents number of remaining coins
    
     for i in range(1, (totalcoins+1)) :
         if (i == 1) or (i == coinsThatCanBeRemoved1) or (i == coinsThatCanBeRemoved2) :
             '''
             Trivial case : if 1, coinsThatCanBeRemoved1 or coinsThatCanBeRemoved2 coins are remaining and it's Harry's turn,
             he will simply pick up all coins and win the game.
             '''
            
             dp[i] = True
            
         elif i < coinsThatCanBeRemoved1 :
             '''
             If less than coinsThatCanBeRemoved1 coins remain, each player can only pick up one coin per turn.
             so the result of the game when i coins are remaining will be the reverse
             of the result when there were i - 1 coins.
             '''
             dp[i] = not(dp[i-1])
        
         elif i < coinsThatCanBeRemoved2 :
             '''
             If the number of coins is between coinsThatCanBeRemoved1 and coinsThatCanBeRemoved2, each player can pick up either 1 or coinsThatCanBeRemoved1 coins
             per turn. Now, each play",Python
"/* Bucket Sort in C - Bucket Sort is a sorting algorithm, which is commonly used in 
 computer science. Bucket Sort works by distributing the elements of an array into 
 a number of buckets. Each bucket is then sorted individually, either using a 
 different sorting algorithm, or by recursively applying the bucket 
 sorting algorithm. 
 # The average time complexity for Bucket Sort is O(n + k). 
   The worst time complexity is O(n).
 # The space complexity for Bucket Sort is O(n+k). */
 
 /* C Program to sort Elements Using Bucket Sort */
 #include <stdio.h>
 
 // bucket sort function
 void Bucket_Sort(int array[], int n, int max, int min)
 {
     int i, j = 0;
     int cpos[max+1], cneg[-(min-1)];
     for (i = 0; i <= max; i++)
         cpos[i] = 0;
     for (i = 0; i <= -(min-1); i++)
         cneg[i] = 0;
 
     for (i = 0; i < n; i++)
     {
         if (array[i] >= 0)
             (cpos[array[i]])++;
         else
             (cneg[-array[i]])++;
     }
 
     for (i = -min; i > 0; i--)
         for (; cneg[i] > 0; (cneg[i])--)
             array[j++] = -i;
 
     for (i = 0; i <= max; i++)
         for (; cpos[i] > 0; (cpos[i])--)
             array[j++] = i;
 }
 
 //main fucntion
 int main()
 {
     int array[100], i, num, max = 0, min = 0;
     printf(""Enter the size of array : "");
     scanf(""%d"", &num);
     printf(""Enter the %d elements to be sorted:\n"",num);
     for (i = 0; i < num; i++)
         scanf(""%d"", &array[i]);
     for (i = 0; i < num; i++)
     {
         if (array[i] > max)
             max = array[i];
         if (array[i] < min)
             min = array[i];
     }
     if (min >= 0)min = 0;
     printf(""\nThe array of elements before sorting : \n"");
     for (i = 0; i < num; i++)
         printf(""%d "", array[i]);
     printf(""\nThe array of elements after sorting : \n"");
     Bucket_Sort(array, num, max, min);
     for (i = 0; i < num; i++)
     {
         printf(""%d "", array[i]);
     }
 
     return 0;
 }
 
 /* 
 Output:
 Enter the s",C
"'''
 bubble_sort() function uses an iterative approach sort the array in increasing
 order passed as an argument. It compares adjacent elements and swappes them if
 there is any larger element before the smaller element. After the first pass,
 the most heaviest element shifts to the last position.
 The flag is used to check if any swapping is performed or not. If no swapping is
 done, the loop breaks as the array is already sorted.
 Return Type: No return type as lists are mutable
 '''
 def bubble_sort(Array):
 
     n = len(Array)
     for i in range(n-1):
         flag = True
         for j in range(n-i-1):
             if Array[j] > Array[j+1]:
                 flag = False
                 Array[j], Array[j+1] = Array[j+1], Array[j]
         if flag:
             break
 
 
 if __name__ == ""__main__"":
     
     print(""Enter the elements of the list to be sorted: "")
     Array = [int(x) for x in input().split("" "")]
     bubble_sort(Array)
     print(""List after sorting: "")
     for i in Array:
         print(i, end="" "")
 
 
 '''
 Sample Input:
 Enter the elements of the list to be sorted:
 2 5 1 6 3 9 10 8
 
 Sample Output:
 List after sorting:
 1 2 3 5 6 8 9 10
 
 Time Complexity: O(n^2)
 Space Complexity: O(1)
 '''
",Python
"/* This code is an implementation of Hill Cipher in Java.
    It is a polygraphic substitution cipher. It forms a nxn
    matrix of key and nx1 matrix(s) of the plaintext and then
    multiplies the two matrices to obtains the matrix of ciphertext.*/
 
 import java.util.*;
 import java.lang.*;
 
 public class HillCipher {
 
 	// This global variable defines the size of n
 	public static int size = 3;
 
 	/* This method forms the nxn matrix of keyword. The value of
 	   n can be changed by setting the global vaiable size.*/
 	static void generateKeyMatrix(String key, int[][] keymatrix) {
 
 		int count = 0;
 		for(int i = 0; i < size; i++) {
 			for(int j = 0; j < size; j++) {
 				// Stores decimal value of ASCII
 				keymatrix[i][j] = key.charAt(count);
 				/* Here, a = 97, b = 98 and so on.
 			   	We want a = 0, b = 1 and so on. So,
 				we subtract 97.*/
 				keymatrix[i][j] -= 97;
 				count = count + 1;
 			}
 		}
 	}
 
 	/* This method forms the nx1 matrix of the plaintext. The value of n can be
 	   changed by setting the global variable size.*/
 	static void generatePlaintextMatrix(String plaintext, int[][] plaintextmatrix) {
 
 		int count = 0;
 		for(int i = 0; i < size; i++) {
 			for(int j = 0; j < 1; j++) {
 				// Stores decimal value of ASCII
 				plaintextmatrix[i][j] = plaintext.charAt(count);
 				/* As we did above, we subtract 97 from the
 				decimal value to start indexing from 0.*/
 				plaintextmatrix[i][j] -= 97;
 				count = count + 1;
 			}
 		}
 	}
 
 	/* This function forms the nx1 ciphertext matrix. The matrix of decimal is then converted
 	to ascii value and combined and then returned.*/
 	static String generateCiphertextMatrix(String plaintext, String key, int[][] ciphertextmatrix) {
 
 		// Forming the keyword matrix
 		int[][] keymatrix = new int[size][size];
 		// Calling the keyord matrix function
 		generateKeyMatrix(key, keymatrix);
 
 		// Forming the plaintext matrix
 		int[][] plaintextmatrix = new int[size][1];
 		// Calli",Java
"/*
     Author: Davide Pollicino (@omonimus1)
     Date: 07/07/2020
     Summary: Implement Level Traverse of a tree, applying the Breath First Search Algorithm (BFS)
              algorithm
 */
 
 void level_order(Node *root)
 {
     if(root == NULL)
         return; 
     
     // Create queue and push in the root node
     queue<Node *>q;
     q.push(root);
 
     // Create a temporary node
     Node *temp;
     // Until the queue is not empty
     while(!q.empty())
     {
         // Fetch the front Node of the queue and store it in temp;
         temp = q.front();
         // Remove the front element from the queue
         q.pop();
         // Print the data stored in the temporary value
         cout << temp-data << "" "";
         // If the temporary node has a left-child, push it in the queue
         if(temp->left != NULL) q.push(temp->left);
         // If the temporary node has a right-child, push it in the queue
         if(temp->right != NULL) q.push(temp->right);
     }
 }
",C-Plus-Plus
"/*
 Given an integer array A of N integers, find the pair of integers 
 in the array which have minimum XOR value. Report the minimum XOR value. 
 
 Explanation: According to the problem, we are given the size of the array 
 and the numbers present in it. So we have to find two such numbers that are 
 the elements of the array and their xor is the minimum in value in comparison 
 to all the possible pairs of the array.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void Min_xor(int*A,int n)
 {
     //ele1 and ele2 will store the value of the elements that gives minimum xor value
     int ele1,ele2;
     //ans will store the minimum xor value
     int ans=INT_MAX;
     for(int i=0;i<n-1;i++)
     {
         //x will store xor value for each possible pair of elements of array
         int x=A[i]^A[i+1];
         if(x<ans)
         {
             ans=x;
             ele1=A[i];
             ele2=A[i+1];
         } 
     }
     //printing the output
     cout<<""The Minimum xor value is : ""<<ans<<endl;
     cout<<""The corresponding elements are : ""<<ele1<<"" and ""<<ele2;
 }
 
 int main() {
     //n will store the size of the array
     int n;
     cout<<""Enter the size of array : "";
     cin>>n;
     cout<<""Enter the array : "";
     int A[n];
     for(int i=0;i<n;i++)
     cin>>A[i];
     //sort() will sort the array in increasing order
     sort(A,A+n);
     //calling the function
     Min_xor(A,n);
     return 0;
 }
 
 /*
 Sample Input :
 Example 1:
 Enter the size of array : 4
 Enter the array : [0, 2, 5, 7]
 Output 1:
 The Minimum xor value is : 2
 The corresponding elements are : 0 and 2
 */
 
 /*
 Time Complexity : O(nlogn)
 Space Complexity : O(1)
 */
",C-Plus-Plus
"""""""
 Problem Statement : To find Hamming Distance between two numbers.
                     Hamming distance? The hamming distance is the value differ in two binary 
                     representations as a 32-bit integer.
 
 Intution: If num1 = 7(0111) and num2 = 8(1000), the bit differance between 
           these two numbers will be 4.
 
 """"""
 
 def hamming_distance(num1, num2):
 
     #To store value of the differnce
     bitdiff = 0
     
     for i in range(31, -1, -1):
         
         #right shift for both the numbers for i AND 1 times
         binary_num1 = num1>>i&1
         binary_num2 = num2>>i&1
 
         #checking if binary of both are not equal
         if binary_num1 != binary_num2:
             bitdiff += 1
         #i it is equal bitdiff will be same and loop will continue
 
     return bitdiff
 
 def main():
 
     #User input for a both numbers
     num1 = int(input(""Enter 1st number: ""))
     num2 = int(input(""Enter 2nd number: ""))
 
     #function call for getting hamming distance for the given two numbers.
     print(""Hamming distance between these two numbers is: "", hamming_distance(num1, num2))
 
 main()
 
 '''
 Time complexity :O(n)
 Space complexity :O(1)
 '''
 
 """"""
 Sample Input / Output:
 
 Enter 1st number: 7
 Enter 2nd number: 8
 Hamming distance between these two numbers is:  4
 
 Enter 1st number: 1
 Enter 2nd number: 6
 Hamming distance between these two numbers is:  3
 
 """"""
",Python
"{
   ""nbformat"": 4,
   ""nbformat_minor"": 0,
   ""metadata"": {
     ""colab"": {
       ""name"": ""SVM_ON_IRIS_DATASET.ipynb"",
       ""provenance"": []
     },
     ""kernelspec"": {
       ""name"": ""python3"",
       ""display_name"": ""Python 3""
     }
   },
   ""cells"": [
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""ggkm7kfA7sgB""
       },
       ""source"": [
         ""#Support Vector Machine on IRIS dataset""
       ]
     },
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""hB586ryH8srI""
       },
       ""source"": [
         ""####What are Support Vector Machines?\r\n"",
         ""\r\n"",
         ""Support-vector machine constructs a hyperplane or set of hyperplanes in a high- or infinite-dimensional space, which can be used for classification, regression, or other tasks like outliers detection. Intuitively, a good separation is achieved by the hyperplane that has the largest distance to the nearest training-data point of any class (so-called functional margin), since in general the larger the margin, the lower the generalization error of the classifier. SVMs belong to a family of generalized linear classifiers and can be interpreted as an extension of the perceptron.""
       ]
     },
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""ClcNN-0q7-66""
       },
       ""source"": [
         ""###Objective \r\n"",
         ""\r\n"",
         ""* We Compare different SVM models accuraccy on the IRIS dataset\r\n"",
         ""* We are using the first two features present in the dataset\r\n"",
         ""* Classify into different classes with max accuracy""
       ]
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""vgoRPV6KuyJw""
       },
       ""source"": [
         ""import numpy as np\r\n"",
         ""import matplotlib.pyplot as plt\r\n"",
         ""\r\n"",
         ""from sklearn import svm, datasets\r\n"",
         ""from sklearn.model_selection import train_test_split""
       ],
       ""exe",Python
"// C++ program to Check if a number is a Mystery Number or Not.
 /*
 A mystery number is that number which can be expressed as a sum of two 
 numbers and those two numbers must be the reverse of each other
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 // Helper function to reverse a number.
 int reverse(int n)
 {
     int rev = 0;
     for (; n > 0; n /= 10)
     {
         rev = rev * 10;
         rev = rev + (n % 10);
     }
     return rev;
 }
 
 bool check_mystery_num(int n)
 {
     /* Let us iterate from 1 upto n/2, to check if there is any pair, such that thier
        sum equals the given number and check if the pair are reverse of each other  */
     for (int i = 1; i <= n / 2; i++)
     {
         if (reverse(i) == n - i)
         {
             return true;
         }
     }
     return false;
 }
 
 int main()
 {
     int n;
     cout << ""Enter the number: "";
     cin >> n;
     bool res = check_mystery_num(n);
     if (res)
     {
         cout << ""The given number "" << n << "" is a Mystery Number."";
     }
     else
     {
         cout << ""The given number "" << n << "" is not a Mystery Number."";
     }
     return 0;
 }
 
 /*
 Time Complexity: O(n*log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 43234
 The given number 43234 is a Mystery Number.
 
 SAMPLE 2
 Enter the number: 1234
 The given number 1234 is not a Mystery Number.
 */
",C-Plus-Plus
"/**
  * Finding the maximum value of the items that can be popacked into the knapsack if it is possible to take one item multiple times
  * DYNAMIC PROGRAMMING
  * Time Complexity O(n^2) 
  **/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int unboundedKnap(int w[], int v[], int W, int n)
 {
     //table
     int t[n + 1][W + 1];
 
     /*Base conditions
     If the number of items in the knapsack is zero, then the value of the items taht can be packed is zero
     If the weight of the knapsack is zero, then the value of the items taht can be packed into the knapsack will be zero too*/
     for (int i = 0; i < n + 1; i++)
     {
         for (int j = 0; j < W + 1; j++)
         {
             if (i == 0 || j == 0)
                 t[i][j] = 0;
         }
     }
 
     /*-->If the weight of the ith item is less than the weight of the knapsack, then we can either include the item or exclude it depending upon which will maximise the value
       -->If included then we can include it again
       -->If not included once then it is not included again
       -->If the weight is greater than the weight of the knapsack then we cannot include it into the knapsack at any time
     */
 
     for (int i = 1; i < n + 1; i++)
     {
         for (int j = 1; j < W + 1; j++)
         {
             if (w[i - 1] <= j)
                 t[i][j] = max(v[i - 1] + t[i][j - w[i - 1]], t[i - 1][j]);
             if (w[i - 1] > j)
                 t[i][j] = t[i - 1][j];
         }
     }
     return t[n][W];
 }
 
 //Driver code
 int main()
 {
     int W;
     cin >> W;
     int n;
     cin >> n;
     int v[n], w[n];
     for (int i = 0; i < n; i++)
         cin >> w[i] >> v[i];
     cout << unboundedKnap(w, v, W, n) << ""\n"";
 }
 
 /*
  * EXAMPLE
  * INPUT 
  * W=10
  * n=5
  * w[n] = 2 4 6 7 8
  * v[n] = 10 20 30 40 100
  * OUTPUT- 100
  */
 
",C-Plus-Plus
"// C program to Count of distinct elements in every window.
 
 #include<stdio.h>
 void distCount(int a[], int n, int k) {
     int count[100000] = {0};
     int i, d = 0;
     printf(""Count of distinct elements in every window: "");
     for (i = 0; i < k; i++) {
         count[a[i]] += 1;
         if (count[a[i]] == 1)
             d++;
     }
 
     printf(""%d "", d);
     for (i = k; i < n; i++) {
         count[a[i - k]] -= 1;
         if (count[a[i - k]] == 0)
             d--;
         if (count[a[i]] == 0)
             d++;
         count[a[i]] += 1;
         printf(""%d "", d);
     }
 }
 
 int main() {
     int i, n, k, a[100000];
     printf(""Enter the size of array: "");
     scanf(""%d"", &n);
     printf(""Enter the elements of array: "");
     for (i = 0; i < n; i++)
         scanf(""%d"", &a[i]);
     printf(""Enter the size of window: "");
     scanf(""%d"", &k);
     distCount(a, n, k);
     return 0;
 }
 
 /*
     Sample input/output:
     Enter the size of array: 10
     Enter the elements of array: 10 9 8 9 7 8 5 6 6 5
     Enter the size of window: 4
     Count of distinct elements in every window: 3 3 3 4 4 3 2
 
     Time Complexity= O(n)
     Space Complexity= O(n)
 */
",C
"/******************************************************************************
 Author - @Suvraneel 
         Suvraneel Bhuin
 
 * Implementation of a dynamic, menu-driven Priority Queue using arrays in C++ *
 ******************************************************************************/
 
 #include <iostream>
 using namespace std;
 
 //define queue's max capacity here 
 #define capacity 1000
 //global variable
 int size = -1; 
 
 // defines a structure for each element entered
 struct item { 
     int priority;
 	int data;
 }priorityQ[capacity];
 
 //function to check if queue is empty
 bool isEmpty(){
     return (size == -1);
 }
 
 //function to check if queue is at capacity
 bool isFull(){
     return (size == capacity-1);
 }
 
 //function to insert an element into queue
 void push(int data, int priority) 
 { 
     // Increment in size
 	size += 1; 
 	// Insert the element 
     priorityQ[size].priority = priority;
 	priorityQ[size].data = data;
     cout << ""("" << priorityQ[size].data << "") "" << ""with priority: "" << priorityQ[size].priority << "" was enqueued""  << endl;
 }
 
 //function to print the entire queue in order of input entered by user
 void printQ(){
     cout << ""Priority\t"" << ""Data"" << endl;
     for (int i = 0; i <= size; i++)
         cout << priorityQ[i].priority << ""\t---->\t"" << ""("" << priorityQ[i].data << "")"" << endl;    
 }
 
 // returns highest priority element without deleting it from queue
 int peek() 
 {
     //Initialising j (index for priority-Q)
     //objective of j is to keep track of the top priority element as of yet
     int j = -1;
     /*
     Set an element with minimum possible priority (i.e, INT_MIN) so that any value will replace the elephant
     *reference to ""Elephants in Cairo"" problem : 
     A piece of data that matches the search criteria purposefully inserted at the end of a search space, in order to make sure the search algorithm terminates; it is a humorous example of a sentinel value.
     */
 	int elephant = I",C-Plus-Plus
"/*Problem statement :
 Print the first non repeating character in a running stream of characters, 
 that is the characters will input continuously until a '.'
 is encountered you need to keep printing the first non repeating character. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void first_non_repeating(queue<char> q, int frequency[])
 {
         while (!q.empty())
         {
             int index = q.front() - 'a';
             //If character already exists more than once, then pop
             if (frequency[index] > 1)
             {
                 q.pop();
             }
             else
             {
                 cout << q.front() << endl;
                 break;
             }
         }
 
         if (q.empty())
         {
             cout << ""-1"" << endl;
         }
 }
 
 int main()
 {
     queue<char> q;
     int frequency[27] = { 0 };
 
     char ch;
     cin >> ch;
     while (ch != '.')
     {
         q.push(ch);
         frequency[ch - 'a']++;
         first_non_repeating(q,frequency);
         cin >> ch;
     }
 
     return 0;
 }
 /*
 Example :
 1)Input = a a b c c .
 Output = a -1 b b b
 2)Input: s d d g .
 Output: s s s s 
 Time Complexity : O(n) 
 Space Complexity : O(1) */
 
",C-Plus-Plus
"/*
  * Implementation of heap.
  * A Heap is a special Tree-based data structure in which the tree is a complete binary tree. 
  * A tree is said to be complete if all its levels, except possibly the deepest, are complete. 
  * A heap has many applications, including the most efficient implementation of priority queues, which are useful in many applications. 
  * In the worst case, the time complexity of inserting a node in a heap would be O(logN).
  * The delete operation has a time complexity relative to the height of the tree, or O(log n).
  * Heapsort is a comparison-based sorting algorithm. Heaps are often implemented in an array rather than a linked list. 
    Overall time complexity of Heap Sort is O(nLogn).
  */
 
 import java.util.Arrays;
 import java.util.NoSuchElementException;
 import java.util.Scanner;
 
 class heap //max-heap
 {
 	private static final int d = 2;
 	private int[] arr1;
 	private int heapSize;
     //This will initialize our heap with default size.
 	 
 	public heap(int capacity) {
 		heapSize = 0;
 		arr1 = new int[capacity + 1];
 		Arrays.fill(arr1, -1);
 
 	}
 
 	//This will check if the heap is empty or not 
 	public boolean isEmpty() {
 		return heapSize == 0;
 	}
 
 	//to check if heap is full or not
 	public boolean isFull() {
 		return heapSize == arr1.length;
 	}
 
 	private int parent(int i) {
 		return (i - 1) / d;
 	}
 
 	private int kthChild(int i, int k) {
 		return d * i + k;
 	}
 
 	//This will insert new element in to heap Complexity: O(log N) As worst case scenario, we need to traverse till the root
 	public void insert(int x) {
 		if (isFull())
 			throw new NoSuchElementException(""Heap is full, No space to insert new element"");
 		arr1[heapSize++] = x;
 		heapifyUp(heapSize - 1);
 	}
 
 //This will delete element at index x 
 	public int delete(int x) 
 {
 		if (isEmpty())
 			throw new NoSuchElementException(""Heap is empty, No element to delete"");
 		int key = arr1[x];
 		arr1[x] = arr1[heapSize - 1];
 		heapSize--;
 ",Java
"/* Row with max 1s = Here given a boolean 2D array where each row is sorted, so here find which first row contain maximum number of 1's.
 
   ALGORITHM:
 * 1st take value row and col by user input where row = No of row, col = No of column and then we create a 2D vector (matrix)
 * Then we created a function find_Max1s
   * find_Max1s = 1. 1st initialize i, j=col-1, index = -1
                  2. for i=0 to row
                         while j>=0 
                            if a[i][j]==1
                               index=i
                               j--
                            else
                               break
                  3. return index
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // finding row with max 1s
 int find_Max1s(vector<vector<int>> a, int row, int col)
 {
     int i, j = col - 1, index = -1;
     for (i = 0; i < row; i++)
     {
         while (j >= 0)
         {
             //when a[i][j]==1 then j decrement
             if (a[i][j] == 1)
             {
                 //here store the row index i
                 index = i;
                 j--;
             }
             else
                 break;
         }
     }
     return index;
 }
 
 int main()
 {
     int row, col;
     cout << ""No of row : "";
     cin >> row;
     cout << ""No of column : "";
     cin >> col;
     vector<vector<int>> a(row, vector<int>(col));
     cout << ""Taking the matrix : "" << endl;
     for (int i = 0; i < row; i++)
     {
         for (int j = 0; j < col; j++)
         {
             cin >> a[i][j];
         }
     }
     int ans = find_Max1s(a, row, col);
     cout << ""Output : "";
     cout << ans << endl;
     return 0;
 }
 
 /*
 
 INPUT:
 No of row : 5
 No of column : 5
 Taking the matrix : 
 0 0 0 1 1
 1 1 1 0 1
 1 1 0 0 0
 0 0 0 0 0
 1 1 1 0 0
 Output : 1
 
 Time Complexity : O(row x col) 
 Space Complexity : O(1)
 
 */
 
 
 
 
 
 
",C-Plus-Plus
"// Given a sorted array A, size of N ( N elements) and a target value X, find if there exists any pair of elements in the Array such that their total sum is equal to X.
 
 /*
 we can solve this by using Two pointers Method and thus time complexity will be O(N).
 Two pointers Method is a method where one pointer starts from beginning and other from the end and they proceed towards each other simultaneously
 
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 int ar[100009];
 
 bool Pair_exist_by_Two_Pointer_Method(int ar[], int N, int X)
 {
     int i = 0, j = N - 1, cur_sum = 0;
     while(i < j)
     {
         cur_sum = ar[i] + ar[j];
         if(cur_sum == X)
         {
             return true;
         }
         else if(cur_sum < X)
         {
             i++;
         }
         else if (cur_sum > X )
         {
             j--;
         }
     }
     return false;
 }
 
 
 int main()
 {
 	int N, X;
 	cout << ""Input array size and target value\n"";
 	cin >> N >> X;
 	for(int i = 0; i < N; i++)
     {
         cin >> ar[i];
     }
     bool solve = Pair_exist_by_Two_Pointer_Method(ar , N , X);
     if(solve)
         cout << ""Pair found and their total sum is equal to target value\n"";
     else
         cout << ""Pair doesn't exist in the array\n"";
 }
 /*
 
 Standard Input and Output
 
 Input array size and target value
 6 70
 10 20 35 50 75 80
 Pair found and their total sum is equal to target value
 
 Time Complexity : O(N)
 Space Complexity : O(1)
 
 */
",C-Plus-Plus
"import java.util.InputMismatchException;
 import java.util.Scanner;
 
 /**
  * <h1>Binary Tress with N nodes</h1> <b>Purpose</b>
  * <p>
  * Total Number of Binary Tress we can create with N number of nodes
  * </p>
  * <b>Description</b>
  * <p>
  * class BinarySearchTreeCount program is used to implement a program to find a
  * count of the total number of different binary search trees that we can make
  * with N nodes.
  * </p>
  * <p>
  * There are four approaches used to implement the given problem:
  * </p>
  * <ul>
  * <li>Using Dynamic Programming</li>
  * <li>Using Recursion</li>
  * <li>Using the Binomial Coefficient</li>
  * <li>Using a Custom made Formulae</li>
  * </ul>
  */
 public class BinarySearchTreeCount {
 
     /**
      * This is a private method used to calculate the Binomial Coefficient
      * 
      * @param numberOne This is a first Integer parameter to
      *                  calculateBinomialCoefficient method.
      * @param numberTwo This is a second Integer paramter to
      *                  calculateBinomialCoefficient method.
      * @return Long This returns Binomial Coefficient of numberOne and numberTwo.
      */
     private Long calculateBinomialCoefficient(Integer numberOne, Integer numberTwo) {
 
         // Initialized coefficient to 1
         Long coefficient = 1L;
 
         /*
          * If substraction of numberOne and numberTwo is smaller than numberTwo then
          * numberTwo is assigned a new value which is the substraction of numberOne and
          * numberTwo.
          */
         if (numberTwo > (numberOne - numberTwo)) {
             numberTwo = numberOne - numberTwo;
         }
 
         /*
          * Calculating value of coefficient iteratively
          */
         for (int i = 0; i < numberTwo; i++) {
             coefficient *= (numberOne - i);
             coefficient /= (i + 1);
         }
         return coefficient;
     }
 
     /**
      * This is a public method used to calculate the total ",Java
"# Depth First Search Traversal in Graphs
 
 # Graph class created
 class Graph:
 
     def __init__(self):
         # graph declared to a dictionary
         self.graph = {}
         # visited nodes are maintained in this set
         self.visited = set()
 
     def add_vertex(self, vertex):
         # vertex is added to the graph dictionary and it's adjacency list is declared
         self.graph[vertex] = []
     
     def add_edge(self, source, destination):
         # directional edges are added in this function
         # the edge is directional, i.e., going from source to destination
 
         # conditional statements in case the vertex aren't present in the graph
         if destination not in self.graph or source not in self.graph:
             if source not in self.graph:
                 print(str(source)+' is not a vertex')    
                 # 1 is returned to avoid stopping the running of the program allows the user to re-enter values
                 return 1 
             if destination not in self.graph:
                 print('\n'+str(destination)+' is not a vertex.')
                 # 1 is returned to avoid stopping the running of the program allows the user to re-enter values
                 return 1     
 
         # edge is added to the graph, from source to destination
         self.graph[source].append(destination)
 
     def add_edge_bidirected(self, vertex1, vertex2):
         # bidirectional graph edges are added in this function
         # the edge is bidirectional, i.e., the edge goes both ways
 
         # conditional statements to check if the vertices are present
         if vertex2 not in self.graph or vertex1 not in self.graph:
             if vertex1 not in self.graph:
                 print('\n'+str(vertex1)+' is not a vertex'+'\n')
                 return 1    # 1 is returned to avoid stopping the running of the program allows the user to re-enter values
             if destination not in self.graph:
                 print('\n",Python
"/*   C Program to Implement Oddeven Sort */
 
 #include <stdio.h>
 #define MAX 7
  
 void swap(int *,int *);
 void oddeven_sort(int *);
  
 void main()
 {
     int a[MAX], i;
  
     printf(""enter the elements into the matrix :"");
     for (i = 0;i < MAX;i++)
     {
         scanf(""%d"", &a[i]);
     }
     printf(""sorted elements are :\n"");
     oddeven_sort(a);
     for (i = 0;i < MAX;i++)
     {
         printf("" %d"", a[i]);
     }
 }
  
 /* swaps the elements */
 void swap(int * x, int * y)
 {
     int temp;
  
     temp = *x;
     *x = *y;
     *y = temp; 
 }
  
 /* sorts the array using oddeven algorithm */
 void oddeven_sort(int * x)
 {
     int sort = 0, i;
  
     while (!sort)
     {
         sort = 1;
         for (i = 1;i < MAX;i += 2)
         {
             if (x[i] > x[i+1])
             {
                 swap(&x[i], &x[i+1]);
                 sort = 0;
             }
         }
         for (i = 0;i < MAX - 1;i += 2)
         {
             if (x[i] > x[i + 1])
             {
                 swap(&x[i], &x[i + 1]);
                 sort = 0;
             }
         }
     }
 }
",C
"/*
 Banker's Algorithm
 
 Banker's Algorithm is a technique used for deadlock avoidance when there are multiple instances of a resource.
 The banker's algorithm for deadlock-free resource allocation is one of the basic algorithms in concurrent and distributed systems.
 User process may only request one resource at a time. System grants request only if the request will result in a safe state.
 A state is considered to be safe if it is possible for all the processes to complete its execution without causing any deadlocks.
 An unsafe state is the one in which the processes cannot complete its execution.
 
 The time complexity for n processes and m resources is o(n*n*m).
 The space complexity for n processes and m resources is o(n*m).
 */
 
 import java.util.Scanner;
 
 class algorithm {
 
     void display(int r, int p, int[] avail, int max[][], int need[][], int allocation[][], int res[]) {
         
         //Checking for available resources inline.
         System.out.println(""THE MAXIMUM RESOURCES MATRIX IS AS FOLLOWS :"");
         System.out.print(""   "");
         for (int i = 0; i < r; i++) {
             System.out.print("" "" + (i + 1));
         }
         System.out.println("" "");
         System.out.println(""_______________________"");
         for (int i = 0; i < p; i++) {
             System.out.print(""P"" + i + ""|"");
             for (int j = 0; j < r; j++) {
                 System.out.print("" "" + max[i][j]);
             }
             System.out.println("" "");
         }
 
         System.out.println("" "");
 
         System.out.println(""THE ALLOCATION MATRIX IS AS FOLLOWS :"");
         System.out.print(""   "");
         for (int i = 0; i < r; i++) {
             System.out.print("" "" + (i + 1));
         }
         System.out.println("" "");
         System.out.println(""_______________________"");
         for (int i = 0; i < p; i++) {
             System.out.print(""P"" + i + ""|"");
             for (int j = 0; j < r; j++) {
                 System.out.print("" "" +",Java
"""""""
 Edit Distance using dynamic programming
 Problem on Leetcode: https://leetcode.com/problems/edit-distance/
 
 Given two strings, return the minimum number of operations required to convert one word to other.
 You can apply the following operatiions:
 1. Insert a character
 2. Delete a character
 3. Replace a character
 
 m: length of first string
 n: length of second string
 Time Complexity : O(m*n) (Looping through both strings)
 Space Complexity : O(m*n) (Matrix distance)
 """"""
 
 
 def editDist(first_string, second_string):
     # Length of both strings
     first_length = len(first_string)
     second_length = len(second_string)
 
     # Distance table for computing edit distance
     # Initializing edit distances as 0
     distance = [[0 for x in range(second_length + 1)]
                 for x in range(first_length + 1)]
 
     # Looping and comparing each letter of first_string with each of second_string
     for first_sub_string in range(first_length + 1):
         for second_sub_string in range(second_length + 1):
 
             if first_sub_string == 0:
                 # first_sub_string is empty, so insert all charecters of second_sub_string
                 distance[first_sub_string][second_sub_string] = second_sub_string
 
             elif second_sub_string == 0:
                 # second_sub_string is empty, so insert all charecters of first_sub_string
                 distance[first_sub_string][second_sub_string] = first_sub_string
 
             elif first_string[first_sub_string - 1] == second_string[second_sub_string - 1]:
                 # If last charecters of both substring are same, no operation required here
                 # It's value will be equal to the edit distance of the substring without this same charecters ie. Diagonal value
                 distance[first_sub_string][second_sub_string] = distance[
                     first_sub_string - 1
                 ][second_sub_string - 1]
 
             else:
                 # If la",Python
"/* 
 Heap Sort 
 Heap Sort is treated as the best sorting technique in the category of selection sorting .
 It uses a heap tree as an underlying data structure to soer an array of elements
 This is an inplace sorting algorithm as it does not require any extra storage space other 
 than the input storage list. This algorithm requires 3 basic steps 
 Create heap : Create the initial heap tree with n elements stored in the array A
 Remove max : Select the value in the root node and swap with the value in the i'th 
 location
 Rebuild heap : Rebuild the heap for elements A[1,2,3,..., i - 1]
 The first operation is done once , the second and third are done n times 
 */
 #include <stdio.h>
 #include <stdlib.h>
 
 /* removeMax function is to remove the maximum element, 
 which is at the root of the Max heap */
 
 void removeMax(int *b, int n)
 {
     int temp = b[n];
     b[n] = b[1];
     b[1] = temp;
 }
 
 /* swap function swaps the position of the given two numbers
 in the sequence */
 
 void swap(int *b, int a, int c)
 {
     int temp = b[a];
     b[a] = b[c];
     b[c] = temp;
 }
 
 /* 
 reBuildHeap function rebuilds the heap from which the root element was 
 removed.
 */
 
 void reBuildHeap(int *b, int i)
 {
     if (i == 1)
     {
         return;
     }
     int j = 1;
     int flag = 1;
     while (flag == 1)
     {
         int left = 2 * j, right = (2 * j) + 1;
         if (right <= i)
         {
             if (b[j] <= b[left] && b[left] >= b[right])
             {
                 swap(b, left, j);
                 j = left;
             }
             else
             {
                 if (b[j] <= b[right] && b[right] >= b[left])
                 {
                     swap(b, right, j);
                     j = right;
                 }
                 else
                 {
                     flag = 0;
                 }
             }
         }
         else
         {
             if (left <= i)
             {
                 if (b[j] <= b[left])
",C
"import java.util.*;
 
 public class MinimumSumPartition {
 
     // Function to find the minimum sum
     public static int findMinSum(int[] arr, int i, int sumCalculated, int total)
     {
         // check for last element, meaning we have sum of one subset as sumCalculated and the other as
         // total - 2*sumCalculated, so we return their absolute difference
         if (i == 0) {
             return Math.abs((total-sumCalculated) - sumCalculated);
         }
 
         // returning minimum of when we first take arr[i] in first set and when we take it in 2nd set
         // recursive approach
         return Math.min(findMinSum(arr, i - 1, sumCalculated + arr[i-1], total),
                 findMinSum(arr, i-1, sumCalculated, total));
     }
 
     public static void main(String[] args) {
 
         Scanner scanner = new Scanner(System.in);
         System.out.println(""Enter size for the array:"");
         int size = scanner.nextInt();
         int[] arr = new int[size];
         System.out.println(""Enter array elements:"");
         for (int i = 0; i < size; i++) {
             arr[i] = scanner.nextInt();
         }
         scanner.close();
 
         // find total sum of all array elements
         int arraySum = 0;
         for (int i = 0; i < size; i++) {
             arraySum += arr[i];
         }
 
         int result = findMinSum(arr, size, 0, arraySum);
 
         System.out.println(""The minimum difference between sum of 2 sets is:"" + result);
     }
 }
 /*
 * Sample input/output
 * Enter size for the array:
 * 6
 * Enter array elements:
 * 3 1 4 2 2 1
 * The minimum difference between sum of 2 sets is:1
 *
 * Time complexity: O(2^n)
 * Space complexity: O(n)
 */
",Java
"/*Next greatest element to the right of each element in the array
   ALGORITHM
  *Using a stack to find out the next greatest element to the right
  *Start the scanning of the array from the right 
  *Declare an array and a stack
  *If the stack is empty, then no element to the right is greater than the present element
  *If the stack is not empty but the element present at the top of the stack is not greater than the current element then-
  * pop the stack till  the stack is not empty or the top element of stack is greater than the current element
  *If the stack is not empty and the element at the top of the stack is greater than the current element then push the topmost element to the stack
 */
 #include <bits/stdc++.h>
 using namespace std;
 void nextLargest(int a[], int n)
 {
     vector<int> v;
     stack<int> s;
     for (int i = n - 1; i >= 0; i--)
     {
         if (s.empty() == true)
             v.push_back(-1);
         else if (s.empty() != true && s.top() > a[i])
             v.push_back(s.top());
         else if (s.empty() != true && s.top() <= a[i])
         {
             while (s.top() <= a[i] && s.empty() != true)
             {
                 s.pop();
             }
 
             if (s.empty() == true)
                 v.push_back(-1);
             if (s.top() > a[i] && s.empty() != true)
                 v.push_back(s.top());
         }
 
         s.push(a[i]);
     }
     //reversing the array containing the next greatest element to the right
     reverse(v.begin(), v.end());
     for (int i = 0; i < n; i++)
         cout << v[i] << "" "";
 }
 int main()
 {
     int n;
     cin >> n;
     int a[n];
     for (int i = 0; i < n; i++)
         cin >> a[i];
     nextLargest(a, n);
 }
 /*
 INPUT:
 n=4
 a[n]=1 3 2 4
 OUTPUT:
 3 4 4 -1
 Code Complexity: O(n^2)
 */
",C-Plus-Plus
"/*
     Description: 
     Given two sorted arrays, the task is to merge them in a sorted manner.
     There are two sorted arrays and after merging there will be only one array in sorted manner.
 */
 import java.util.*;
 public class MergeSortedArrays {
    public static void main(String[] args) {
       int A[] = {-2,3,5,8,9};
       int B[] = {1,2,3,4,5};
       System.out.println(Arrays.toString(solve(A,B)));   
    }
    /*
        function to merge the given sorted arrays. 
    */
     public static int[] solve(final int[] A, final int[] B) {
        /* 
           Declaring a new Array of the expected result size i,e sum of length of Array A and Array B 
        */ 
        int ARR[] = new int[A.length+B.length]; 
        /*
           Declaring two pointers p1 and p2
           p1 points to first element of Array A
           p2 points to first element of Array B
        */ 
        int pointer1=0,pointer2=0;
         int k=0;
         while(pointer1<A.length && pointer2<B.length) {
             if(A[pointer1]<B[pointer2]) {
                 ARR[k++] = A[pointer1++];
             }
             else {
                  ARR[k++] = B[pointer2++];
             }
         }
         while(pointer1<A.length) {
             ARR[k++]=A[pointer1++];
         }
         while(pointer2<B.length) {
             ARR[k++]=B[pointer2++];
         }
         return ARR;
     }
 }
 /*
   Example: 
   Input: 
       A[] = {-2,3,5,8,9}
       B[] = {1,2,3,4,5}
   Output:
      [-2,1,2,3,3,4,5,5,8,9]
      
    Explanation: 
       After Merging A and B produces the output as described above.
 */
 /*
   Time and Space Complexity
   M = length of Array A
   N = length of Array B
   Time Complexity O(M+N)
   Space Complexity O(M+N)
 */
",Java
"import java.util.*;
 
 /*
 A program to check whether a string is palindrome or not.
 A plaindrome string is a string which is same to its reverse.
 eg. 1234321, radar etc.
 Time Complexity = O(n/2) //represents the number of operations to be performed by an algorithm to complete its task
 Space Complexity = O(n) //represents the total space needed by the algorithm
 */
 
 public class Palindrome {
 
     private static Scanner sc = new Scanner(System.in);
     public static void main(String[] args) {
 
         //the string entered by the user is stored in string_1
         System.out.println(""Kindly enter the string: "");
         String string_1 = sc.nextLine();
 
         //to check if the string is palindrome or not
         Boolean check = ispalindrome(string_1);
 
         if(check==true)
             System.out.println(string_1+"" is a palindrome."");
         else
             System.out.println(string_1+"" is not a palindrome."");
     }
 
     //method to check if the string is a palindrome or not
     //method returns true if the string is a palindrome else it returns false
     private static boolean ispalindrome(String string_1) 
     {
         //storing the last index of the string in n
         int n =string_1.length() - 1;
         //comparing the characters of the string
         //first to the end and so on
         for (int i = 0; i < (n) / 2; i++) 
         {
            if (string_1.charAt(i) != string_1.charAt(n-i)) 
                return false;
         }
         return true; 
     }
 }
 
 /*
 Output:
 
 Kindly enter the string: 
 1234321
 1234321 is a palindrome.
 
 Kindly enter the string: 
 radar
 radar is a palindrome.
 
 Kindly enter the string: 
 lol
 lol is a palindrome.
 
 Kindly enter the string: 
 good
 good is not a palindrome.
 
 */
 
",Java
"//Java Program to Remove Duplicates from a Unsorted Linked List 
 //Without using any Extra Space i.e while finding Duplicates we can't
 //use any Data Structure to store values.
 //Then we can use two pointers approach :current and runner ,current iterates through the linked list
 //and runner check all subsequent nodes for every current and try to find duplicates in the list.
 
 import java.util.*;
 //class structure for Linked List
 public class RemDupInLLWithoutExtraSpace {
   static Node head;
   class Node {
     public int data;
     public Node next;
     Node(int data) {
       this.data = data;
     }
   }
   
   //insert new node at the beginning
   public void insert_At_beginning(int data) {
     Node ptr = new Node(data);
     if (head != null) {
       ptr.next = head;
       head = ptr;
     } else {
       ptr.next = null;
       head = ptr;
     }
   }
 
   //check whether a Linked List is empty or not
   public boolean isEmpty() {
     if (head == null)
       return true;
     return false;
   }
 
   public void display() {
     Node ctr = head;
     if (!isEmpty()) {
       while (ctr != null) {
         System.out.print(ctr.data + "" "");
         ctr = ctr.next;
       }
       System.out.println();
     } else {
       System.out.println(""List is empty"");
     }
   }
 
   /*
   Two pointers current and runner is used
   current will iterate through the linked list and runner will
   check all the subsequent nodes for duplicates
   */
   public void delete_Duplicates() {
     Node current = head;
     while (current != null) {
       //Remove all future nodes that have the same value
       Node runner = current;
       while (runner.next != null) {
         if (runner.next.data == current.data) {
           runner.next = runner.next.next;
         } else {
           runner = runner.next;
         }
       }
       current = current.next;
     }
   }
 
   public static void main(String[] args) {
     Scanner sc = new Scanner(System.in);
     Rem",Java
"#include <bits/stdc++.h>
 using namespace std;
 
 /*
  Factorial is calculated using recursive formula : n! = n * (n-1)!
  We will initially save Factorial of 0 and 1 as 1. Then  we will
  recursively call Factorial on the lower numbers and save its data in array
  */
 int fac[100];
 int Factorial(int n)
 {
     if(n == 0 || n == 1)
         return 1;
 
     fac[0] = 1;
     fac[1] = 1;
 
     for(int i=2 ; i<=n ; i++)
     {
         fac[i] = i * fac[i-1];
     }
     return(fac[n]);
 }
 
 int main()
 {
     int n;
     cout<<""Enter number : "";
     cin>>n;
     cout<<""Factorial of ""<<n<<"" is : ""<<Factorial(n);
 
     return 0;
 }
 
 /*
     Sample Input-Output:
     Enter number : 5
     Factorial of 5 is : 120
 
     Time Complexity: O(n)
     Space Complexity: O(n)
 */
 
 
",C-Plus-Plus
"#include<iostream>
 #include<utility>
 #include<queue>
 #include<vector>
 
 using namespace std; 
 # define INF 0x3f3f3f3f 
 typedef pair<int, int> iPair; 
  
  /* Used priority queue STL and vector pair representation of graph
     for quicker implementation of Dijkstra's shortest path algorithm */
   
 void addEdge(vector <pair<int, int> > adj[], int u, 
                                      int v, int wt) 
 { 
     adj[u].push_back(make_pair(v, wt)); 
     adj[v].push_back(make_pair(u, wt)); 
 } 
    
   
 void shortestPath(vector<pair<int,int> > adj[], int V, int src) 
 { 
   
     priority_queue< iPair, vector <iPair> , greater<iPair> > pq; 
   
     vector<int> dist(V, INF); 
   
     pq.push(make_pair(0, src)); 
     dist[src] = 0; 
   
     while (!pq.empty()) 
     { 
         int u = pq.top().second; 
         pq.pop(); 
   
         for (auto x : adj[u]) 
         { 
             int v = x.first; 
             int weight = x.second; 
             if (dist[v] > dist[u] + weight) 
             { 
                 dist[v] = dist[u] + weight; 
                 pq.push(make_pair(dist[v], v)); 
             } 
         } 
     } 
   
     printf(""Vertex Distance from Source\n""); 
     for (int i = 0; i < V; ++i) 
         printf(""%d \t\t %d\n"", i, dist[i]); 
 } 
   
 int main() 
 { 
     //sample graph
     int V = 9; 
     vector<iPair > adj[V]; 
    
     //Adding edges of the graph
     addEdge(adj, 0, 1, 4); 
     addEdge(adj, 0, 7, 8); 
     addEdge(adj, 1, 2, 8); 
     addEdge(adj, 1, 7, 11); 
     addEdge(adj, 2, 3, 7); 
     addEdge(adj, 2, 8, 2); 
     addEdge(adj, 2, 5, 4); 
     addEdge(adj, 3, 4, 9); 
     addEdge(adj, 3, 5, 14); 
     addEdge(adj, 4, 5, 10); 
     addEdge(adj, 5, 6, 2); 
     addEdge(adj, 6, 7, 1); 
     addEdge(adj, 6, 8, 6); 
     addEdge(adj, 7, 8, 7); 
   
     shortestPath(adj, V, 0); 
   
     return 0; 
 } 
",C-Plus-Plus
"//This problem is of placing n queens on n*n chessboard which is solved using backtracking so no two queens can attack each other
 // like we place n queens in n*n chessboard in such a way so that no two queens should be placed in same row, same column and same diagonal
 #include <iostream>
 using namespace std;
 
 // To check whether the curren posotion is safe for placing the queen or not
 bool isSafe(int board[][10],int i,int j,int n){
     // To check whether the queen is placed in current column or not
     for(int row=0;row<i;row++){
         if(board[row][j] == 1){
             return false;
         }
     }
 
     // To check whether the queen is placed in current left diagonal or not
     int x = i;
     int y = j;
     while(x>=0 && y>=0){
         if(board[x][y] == 1){
             return false;
         }
         x--;
         y--;
     }
 
     // To check whether the queen is placed in current column or not
      x = i;
      y = j;
     while(x>=0 && y<n){
         if(board[x][y] == 1){
             return false;
         }
         x--;
         y++;
     }
 
     // if we can place our queen in the current cell then return true
     return true;
 }
 
 // A recursive function to solve n queen problem
 bool solveNqueen(int board[][10], int i, int n){
     //base case
     if(i == n){
         // we have successfully placed all the n queens from row(0 to n)
         // therefore print the board
         for(int i=0;i<n;i++){
             for(int j=0;j<n;j++){
                 if(board[i][j] == 1){
                     cout<<""1 "";
                 }
                 else{
                     cout<<""0 "";
                 }
             }
             cout<<endl;
         }
         // We are return false here to print all the ways to plave n queens
        cout<<endl<<endl;
        return false;
     }
 
     // recusive case
     for(int j=0;j<n;j++){
         // we will check whether a given cell is save for placing queen or not
         if(isSafe(b",C-Plus-Plus
"/*
  1.Hashing is most frequently used in case you have operation like search, insert, delete or subset of these because
    hashing provides these operations in O(1) time on an average
  2.The data is stored in a hash table
  3.Collision happens when our hash function give the same hash value for two or more input values in that case we can use
    linear probing to avoid collisions.
  
  	Steps to be followed:
  	1.we will create an empty hash table and initialize all of its value as -1 which represent empty cells.
  	2.Then we will iterate over the input array and compute the hash value of all the keys to be inserted,
  	 put it in appropriate cells if that cell is already filled we will linearly search for next free cell
  	 and then put the key.
  	3.We have taken hash function as arr[i]%hashSize
 */
 
 import java.util.*;
 public class linearProbing {
 	
 static int[] linearProbing(int hashSize, int arr[], int arraySize){
     int hash_table[] = new int[hashSize];
     
     for(int i = 0; i < hashSize; i++) {
          hash_table[i] = -1;
     }
     
     for(int i=0;i<arraySize;i++){
         if(hash_table[arr[i]%hashSize]==-1){
             hash_table[arr[i]%hashSize]=arr[i];
         }
         else{
             int counter=0;
             int k=(1+arr[i])%hashSize;
             while(counter<hashSize&&hash_table[k]!=-1){
                  k=(k+1)%hashSize;
                  counter++;
             }
             if(counter<hashSize){
             hash_table[k]=arr[i];
             }
         }
     }
     return hash_table;
 }
 
 public static void main(String[] args) {
 	
 	Scanner sc = new Scanner(System.in);
 	System.out.println(""Enter hash size :"");	
 	int hashSize = sc.nextInt();
 	
 	System.out.println(""Enter array size :"");	
 	int arraySize = sc.nextInt();
 	
 	int array[]=new int[arraySize];
 	
 	System.out.println(""Enter elements of array :"");
 	for(int i=0;i<arraySize;i++) {
 	    array[i]=sc.nextInt();
 	}	
 	int hashTable[]= linearProbing(ha",Java
"/*
     At the Perfect programming Company, programmers program in pairs in order to ensure that the highest quality code is produced. 
     The productivity of each pair of programmers is the speed of the slower programmer. 
     For an even number of programmers, give an efficient algorithm for pairing them up so that 
     sum of productivity of all pairs is maximized. 
     Analyze the running time of your algorithm.
 */
 
 import java.util.*;
 
 public class Pair_programmers_productivity_problem {
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the no of programmers(even):- "");
         int n = sc.nextInt();
 
         int[] speed = new int[n];
         System.out.println(""Enter the speed of programmers:- "");
         for(int i = 0; i<n; i++){
             speed[i] = sc.nextInt();
         }
         System.out.println(String.format(""Maximum sum of speed of programmers is %d"", maximum_sum_of_speed_of_programmers(speed, n)));               
     }
     /*
     We use the Greedy Approach here in this problem. We sort the speed[] array, 
     traverse it with a gap of 2(since we have to pair the programmers) and just add the speed
     */
     public static int maximum_sum_of_speed_of_programmers(int arr[], int n){
         Arrays.sort(arr);
         int max_sum = 0;
         for(int j = 0; j<n; j+=2){
             max_sum += arr[j];
         }
         return max_sum;
     }
 }
 /*
     Time Complexity:- O(n)
     Space Complexity:- O(1)
 */
 
 /*
 Sample testcase:
 Enter the no of programmers(even):- 6
 
 Enter the speed of programmers:- 10 2 4 15 20 22
 
 Maximum sum of speed of programmers is 32
 */
",Java
"/*
 Catalan numbers is a number sequence, which is found useful in a number of
 combinatorial problems, often involving recursively-defined objects.
 */
 
 var n = prompt(""Enter the number:"");
 
 var c = [];
 
 function catalan(n) {
     if (n == 0) return 1;
     if (!c[n]) {
         var s = 0;
         for (var i = 0; i < n; i++)
             s += catalan(i) * catalan(n - i - 1);
         c[n] = s;
     }
     return c[n];
 }
 document.write(""Nth Catalan Number are:"")
 document.write(""<br>"");
 for (var i = 0; i <= n; i++) {
     document.write(catalan(i));
     document.write(""<br>"");
 }
 
 /*
 Input:
 Enter the number:
 15
 Output:
 Nth Catalan Number are:
 1
 1
 2
 5
 14
 42
 132
 429
 1430
 4862
 16796
 58786
 208012
 742900
 2674440
 9694845
 
 Time Complexity: O(2^n)
 Space Complexity: O(1)
 */",JavaScript
"/*
 WE have to find the Intersection Point of Y shaped LinkedList                                   
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Node
 {
 public:
     int data;
     Node *next1, *next2;
 };
 //pointers to the Node
 Node *head1 = NULL, *head2 = NULL;
 Node *temp1, *temp2, *ptr;
 
 // function declaration
 void Insert_1();
 void Insert_2();
 void Display_All();
 void Intersect();
 int Find_Intersection();
 int ele;
 
 //  Main() function begins
 int main()
 {
     int ch;
     do
     {
         cout << ""\n \n\n \t\t PROGRAM TO FIND INTERSECTION POINT"" << endl;
         cout << ""\t********************************************************************"" << endl;
         cout << ""\t 1) INSERT IN LIST 1 \t \t 2) INSERT IN LIST 2"" << endl;
         cout << ""\t 3) DISPLAY ALL LIST \t \t 4) INTERSECT LISTS AT SPECIFIC POSITION"" << endl;
         cout << ""\t 5) EXIT \t \t\t 6) FIND THE INTERSECTION POINT "" << endl;
         cout << ""ENTER YOUR CHOISE :"";
         cin >> ch;
         switch (ch)
         {
         case 1:
             //inserting values in List 1
             Insert_1();
             break;
 
         case 2:
             //inserting values in List 2
             Insert_2();
             break;
 
         case 3:
             //returns the list
             Display_All();
             break;
 
         case 4:
             //this function is used to intersect both list as per user's choise
             Intersect();
             break;
 
         case 6:
             // returns the point of intersection
             cout << ""Point Of Intersection : "" << Find_Intersection();
             break;
 
         case 5:
             exit(0);
             break;
 
         default:
             cout << ""Invalid Input"" << endl;
         };
     } while (1);
     return 0;
 }
 
 void Insert_1()
 {
     ptr = new Node();
     cout << ""ENTER THE ELEMENT : "";
     cin >> ele;
     ptr->data = ele;
     ptr->next1 = NULL;
     if (head1 == ",C-Plus-Plus
"/*
 In postorder traversal , the root node is visited in the end,that is , first visit
 the left sub-tree , then the right sub-tree , and lastly the root .
 Postorder traversal is Defined as
 * Traverse the left sub-tree of the root R in postorder
 * Traverse the right sub-tree of the root R in postorder
 * Visit the root node R
 */
 
 class Node {
     constructor(data) {
         this.data = data;
         this.left = null;
         this.right = null;
     }
 }
 
 class BinarySearchTree {
     constructor() {
         this.root = null;
     }
     //insert function inserts a new node into the binary search tree
     insert(value) {
         var New = new Node(value);
         if (this.root === null) {
             this.root = New;
             return this;
         }
         let curr = this.root;
         let prev = null;
         while (curr) {
             if (value < curr.data) {
                 prev = curr;
                 curr = curr.left;
             }
             else if (value > curr.data) {
                 prev = curr;
                 curr = curr.right;
             }
         }
         if (prev.data > value) {
             prev.left = New;
             return this;
         }
         else {
             prev.right = New;
             return this;
         }
 
     }
 
     recursive_postorder(node) {
         if (node !== null) {
             this.recursive_postorder(node.left);
             this.recursive_postorder(node.right);
             console.log(node.data);
         }
     }
 }
 
 /*
 install readline-sync module to get user input 
 To install use the command : npm install readline-sync
 */
 const readline = require(""readline-sync"");
 console.log(""Enter the number of nodes to insert"");
 let n = Number(readline.question());
 
 let b = new BinarySearchTree();
 console.log(""Enter the values of nodes to insert\n"")
 for (let i = 0; i < n; i++) {
     console.log(""Enter the value for node "" + (i + 1));
     b.insert(Number(readline.question())",JavaScript
"/* Find a Median of two Sorted arrays of different size. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function to find Median of two Sorted array of different size */
 int solve()
 {
     /* Input n1 = size of array 1
        Input n2 = size of array 2 */
     int n1,n2;
     cin >> n1 >> n2;
 
     int arr1[n1],arr2[n2];
 
     /* Input values in array 1 */
     for (int i = 0; i < n1; ++i)
     {
         cin >> arr1[i];
     }
 
     /* Input values in array 2 */
     for (int i = 0; i < n2; ++i)
     {
         cin >> arr2[i];
     }
 
     /* Create a vector */
     vector<int> v;
 
     /* Push array 1 element in vector */
     for (int i = 0; i < n1; ++i)
     {
         v.push_back(arr1[i]);
     }
 
     /* Push array 2 element in vector */
     for (int i = 0; i < n2; ++i)
     {
         v.push_back(arr2[i]);
     }
 
     /* Sort the given vector */
     sort(v.begin(), v.end());
     
     /* Find medina using this formula */
     int mid = v[v.size()/2];
     
     /* Return Calculated median */
     return mid;
 }
 
 int main()
 {
     int Median = solve();
 
     cout << ""Median is : "" << Median <<endl;
     return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
         1 4
         900
         5 8 10 20
         
     Output 1 :
 
         Median is : 10
 
     Input 2 :
 
         5 6 
         1 2 3 4 5
         3 4 5 6 7 8
     
     Output 2 :
     
         Median is : 4
     
     Time complexity: O(nlogn)
     Space Complexity: O(n)
 */
",C-Plus-Plus
"import java.util.*;
 public class ArmstrongNumber
 {
 	static int length_number(int num){
 		return String.valueOf(num).length();
 	}
     	static boolean isArmstrong(int x){
         	int res = x;
 		int val = 0;
 		int len = length_number(x);
 		while(res>0){
 			int temp = res % 10;
 			val += Math.pow(temp, len);
 			res = res / 10;
 		}
 		if(x == val)
 		    return true;
 		else    
 		    return false;
     	}
 	public static void main(String[] args) {
 		Scanner sc = new Scanner(System.in);
 		System.out.print(""Enter the number: "");
 		int num = sc.nextInt();
 		if(isArmstrong(num))
 		    System.out.println(num+"" is an Armstrong Number."");
 		else 
 		    System.out.println(num+"" is not an Armstrong Number."");
 	}
 }
 
 /*
 Sample input and output
 Example 1:
 Enter a number : 1002
 Number is not an armstrong number.
 
 Example 2:
 Enter a number : 153
 Number is an armstrong number.
 
 Example 3:
 Enter a number : 8208
 8208 is an armstrong number.
 
 Complexities
 time: O(log(n))
 space: O(1)
 */
",Java
"/* This code checks if a number is a magic number.
 Magic number - We find the recursive sum of digits
 of number till a single digit. If the single digit 
 is 1, then it is a magic number, else it is not.*/
 
 package main
 
 import (
 	""fmt"";
 )
 
 // This function finds sum of digits of a number
 func sum_of_digits(n int) int {
 	var sum int = 0
 	for n != 0 {
 		sum += n % 10
 		n = n / 10
 	}
 	// Returning the sum
 	return sum
 }
 
 // This function checks if number is a magic number
 func check_magic_number(number int) int {
 	var first int
 
 	// Find the sum of digits of number
 	first = sum_of_digits(number)
 
 	/* Till we get a single digit, recursively
 	call the sum function*/
 	for first >= 10 {
 		first = sum_of_digits(first)
 	}
 
 	// If the sum becomes 1, return 1 else -1
 	if(first == 1) {
 		return 1
 	} else {
 		return -1
 	}
 }
 
 func main() {
 
 	// Take number as input from the user
 	var number int
 	fmt.Print(""Enter a number to check if it is a magic number: "")
 	fmt.Scan(&number)
 
 	// Call the magic number checker function
 	var result int = check_magic_number(number)
 
 	/* If returned value is 1, then the number is
 	a magic number, else it is not*/
 	if(result == 1) {
 		fmt.Print(""\nThe number "", number, "" is a magic number.\n"")
 	} else {
 		fmt.Print(""\nThe number "", number, "" is not a magic number.\n"")
 	}
 }
 
 /* Sample I/O:
 
 Enter a number to check if it is a magic number: 1729
 
 The number 1729 is a magic number.
 
 */
 
",Go
"""""""
 Basically a strong number is number in which sum of factorial of each digit
 of the number is equal to that number
 EX : Consider 145=1! + 4! + 5! = 1 + 24 + 120 = 145
 Here input a number
 We initialize sum to 0 and assign the input number to a temporary variable
 In side while loop --> (we find sum of factorial of each digit of the number)
 In side factorial function --> (we calculate the factorial of each digit and return it)
 In the end if number and the sum obtained is equal then it is a Strong number
 otherwise not
 """"""
 
 
 def factorial(n) :
     p = 1
     for i in range(1 , n + 1) :
         p = p * i
     return p
 
 
 number = int(input(""Enter a number greater than zero : ""))
 temp = number
 sums = 0
 if number > 0 :
     while temp > 0 :
         remainder = temp % 10
         sums = sums + factorial(remainder)
         temp = temp // 10
     if sums == number :
         print('Number' , number , 'is a Strong Number')
     else :
         print('Number' , number , 'is not a Strong Number')
 else :
     print('0 is not a Strong Number')
 
 # Time Complexity : O(log n)
 # Space Complexity : O(1)
 
 # TestCase 1:
 # Enter a number greater than zero : 65
 # Number 65 is not a Strong Number
 # TestCase 2:
 # Enter a number greater than zero : 145
 # Number 145 is a Strong Number
",Python
"{
  ""cells"": [
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {
     ""id"": ""zNvhCnuxI7A4""
    },
    ""outputs"": [],
    ""source"": [
     ""from qiskit import __qiskit_version__, QuantumCircuit, execute, Aer\n"",
     ""from qiskit.visualization import plot_histogram, plot_bloch_vector, plot_bloch_multivector\n""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""p2528vcNQoaw""
    },
    ""source"": [
     ""# Bell States\n"",
     ""Bell state - A specific quantum state of two qubits which is maximally entangled. They represent the simplest examples of entangled states.Bell states are used in Quantum Teleportation,Quantum cryptography and super dense coding.\n"",
     ""There are four known Bell states:\n"",
     ""\n"",
     ""\n"",
     ""$$|\\phi^+\\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle+|11\\rangle\\big)$$\n"",
     ""$$|\\phi^-\\rangle = \\frac{1}{\\sqrt{2}}\\big(|00\\rangle-|11\\rangle\\big)$$\n"",
     ""$$|\\psi^+\\rangle = \\frac{1}{\\sqrt{2}}\\big(|01\\rangle+|10\\rangle\\big)$$\n"",
     ""$$|\\psi^-\\rangle = \\frac{1}{\\sqrt{2}}\\big(|01\\rangle-|10\\rangle\\big)$$\n""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {
     ""id"": ""b-VIlaFOTDso""
    },
    ""source"": [
     ""# Creating the phi-plus state\n"",
     ""To create the phi+ state we first take two qubits(both initalized to $|0\\rangle$). Then add the following gates\n"",
     ""- A Hadamard gate H on the first qubit, which puts it into the superposition state $(|0\\rangle+|1\\rangle)/\\sqrt{2}$. \n"",
     ""- A controlled-Not operation (CX) between the two qubits. ""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 3,
    ""metadata"": {
     ""colab"": {
      ""base_uri"": ""https://localhost:8080/"",
      ""height"": 94
     },
     ""id"": ""o-ndWokIQu4z"",
     ""outputId"": ""1f73c5d0-0a2c-4282-ae6f-f134fd345053""
    },
    ""outputs"": [
     {
      ""data"": {
       ""image/png"": ""iVBORw0KGgoAAAANSUhEUgAAAKoAAAB7CAYAAADkFBsIAAAAOXRFWHRTb2Z0d2FyZQBNY",Python
"/* This program written in Go checks if a number is a perfect
 number. A perfect number is a number which is equal to the sum
 of its divisors (excluding the number itself).*/
 
 package main
 
 import (
 	""fmt""
 	""os""
 )
 
 // This function checks if a number is a perfect number
 func is_perfect(number int) int {
 
 	// This variable stores the sum of divisors of number
 	sum_of_divisors := 0
 	// Iterate from 1 till the number
 	for i := 1; i < number; i++ {
 		if(number % i == 0) {
 			// Add divisors
 			sum_of_divisors += i
 		}
 	}
 	// If the sum of divisors is equal to the number
 	if(sum_of_divisors == number) {
 		// Return 1
 		return 1
 	}
 	// Else return -1
 	return -1
 }
 
 func main() {
 
 	// Take number as input from the user
 	fmt.Print(""Enter a number to check if it's a perfect number: "")
 	var number int
 	fmt.Scan(&number)
 
 	// If the number is non-positive, exit
 	if(number <= 0) {
 		fmt.Print(""\nPlease enter a positive number.\n"")
 		os.Exit(0)
 	}
 
 	// Call the function
 	var result int = is_perfect(number);
 
 	// If the result is 1, the number is a perfect number
 	if(result != -1) {
 		fmt.Print(""\nThe number "", number, "" is a perfect number.\n"")
 	} else {
 		// Else it is not
 		fmt.Print(""\nThe number "", number, "" is not a perfect number.\n"")
 	}
 }
 
 /*
 Sample I/O:
 
 1)
 Enter a number to check if it's a perfect number: 28
 
 The number 28 is a perfect number.
 
 2)
 Enter a number to check if it's a perfect number: 12
 
 The number 12 is not a perfect number.
 
 3)
 Enter a number to check if it's a perfect number: -2
 
 Please enter a positive number.
 
 */
",Go
"// C Program to check whether a number is Armstrong or not
 
 #include<stdio.h>
 #include<math.h>
 
 void ArmstrongNumber(int n){
 	int num=n, rem, sum=0;
 	
 	// Counting number of digits
 	int digits = (int) log10(num) + 1;
 
     while(num > 0) 
     {  
         rem = num % 10; 
         sum = sum + pow(rem,digits); 
         num = num / 10; 
     } 
     
     if(n==sum)
     	printf(""%d is an Armstrong number."",n);
     else
     	printf(""%d is not an Armstrong number."",n);
 }
 
 int main(){
 	int num;
 	
 	printf(""Enter the number: "");
 	scanf(""%d"",&num);
 	
 	ArmstrongNumber(num);
 	
 	return 0;
 }
 
 /*
 	Sample input/output:
 	
 	Example 1:
 	Enter the number: 153
 	153 is an Armstrong number.
 
 	Example 2:
 	Enter the number: 1094
 	1094 is not an Armstrong number.
 	
 	Time Complexity= O(log(n)) 
 	Space Complexity= O(1)
 */
",C
"/*
   Given a 2D vector of intervals where intervals[i]={start_time,end_time} ,
   merge all the overlapping intervals and
   return the array of non-overlapping intervals that cover all the intervals in the input.
 */
 
 
 #include<bits/stdc++.h>
 #include<vector>
 using namespace std;
 
 vector<vector<int>> merge_interval(vector<vector<int>> interval);
 
 int main()
 {
     //number of intervals
     int n;
     cin>>n;
 
     // input 2D vector
     vector<vector<int>> intervals;
 
     //taking data from user
     int x,y;
     for(int i=0;i<n;i++)
     {
         cin>>x>>y;
         intervals.push_back({x,y});
     }
 
     vector<vector<int>> result;
 
     //calling function merge_interval
    result = merge_interval(intervals);
 
    //displaying output
    for(int i=0;i<result.size();i++)
    {
        cout<<result[i][0]<<"",""<<result[i][1];
        cout<<endl;
    }
 
     return 0;
 }
 
 vector<vector<int>> merge_interval(vector<vector<int>> interval)
 {
     if(interval.size()==0)
         return interval;
 
     //sorting the vector in ascending order
     sort(interval.begin(),interval.end());
 
     //for result to store
     vector<vector<int>> merged;
 
     vector<int> temp = interval[0];
 
     for(int i=0;i<interval.size();i++)
     {
         //interval[i](start_time) is less than temp(end_time)
         //then it is merged
         if(interval[i][0] <= temp[1])
         {
             if(interval[i][1] >= temp[1])
             temp[1] = interval[i][1];
         }
         //interval[i](start_time) is greater than temp(end_time)
         else
         {
             merged.push_back(temp);
             temp = interval[i];
         }
 
     }
      //last interval
     merged.push_back(temp);
 
     return merged;
 }
 
 
 /*
    Time Complexity: O(NlogN) + O(N) ...N is the number of intervals
                     (sorting)  (traversing)
    Space Complexity:O(N)
 */
 
 /*   Examples:
 
    1)Input:
      3   ...N
      2 4
      3 8
      10 12
 
",C-Plus-Plus
"#include <iostream>
 using namespace std;
 
 int Hash(int x, int s) {
 	return x % s;
 }
 int prime(int p, int x) {
 	return p - (x % p);
 }
 //Function to insert element in the hash table
 void DoubleHashing(int D[], int s, int x, int p) {
 	int index = Hash(x, s);
 	int i = 0;
 	while (D[index] != 0 && D[index] != -1) {
 		i++;
 		index = (Hash(x, s) + ( i * prime(p, x) ) ) % s;
 
 	}
 	D[index] = x;
 
 }
 //Function to search for an element.
 void DHSearch(int D[], int s, int x, int p) {
 	int index = Hash(x, s);
 	int i = 0;
 	while (D[index] != 0) {
 		if (D[index] == x) {
 			cout << ""Element found at index "" << index << endl;
 			return;
 		}
 		i++;
 		index = (Hash(x, s) + ( i * prime(p, x) ) ) % s;
 
 	}
 	cout << ""Element not found "" << endl;
 }
 //Function to delete an element from the Hash Table.
 void DHDelete(int D[], int s, int x, int p) {
 	int index = Hash(x, s);
 	int i = 0;
 	while (D[index] != 0) {
 		if (D[index] == x) {
 			cout << ""Element deleted "" << endl;
 			D[index] = -1;
 			return;
 		}
 		i++;
 		index = (Hash(x, s) + ( i * prime(p, x) ) ) % s;
 
 	}
 	cout << ""Element not found "" << endl;
 }
 
 //Main Function
 //Space Complexity: O(n) - Array for the hash table.
 //Time Complexity: O(m) ; Where m is the size of hashtable the algorithm will scan to allocate the elements their correct position.
 int main() {
 	int n, x;
 	cout << ""Hello world!"" << endl;
 	//Enter number of elements you want to insert.
 	cout << ""Enter number of elements "" << endl;
 	cin >> n;
 	int s = 2 * n;
 	int p = s;
 	while (p > 0) {
 		if ( ( ((p - 1) % 6 == 0) && ((p + 1) % 6 != 0) )  || ( ((p + 1) % 6 == 0) && ((p - 1) % 6 != 0) ))
 			break;
 		p--;
 	}
 	int L[s] = {0}, Q[s] = {0}, D[s] = {0};
 	//Enter the elements that you want to insert.
 	cout << ""Enter elements "" << endl;
 	for (int i = 0; i < n; i++) {
 		cin >> x;
 		DoubleHashing(D, s, x, p);
 	}
 	cout << ""Hash Table "" << endl;
 	for (int i = 0; i < s; i++) {
 		cout << D[i] << endl;
 	}
 	cout << ",C-Plus-Plus
"/* Below code is an implementation of binary search in Java using
 recursive method. An array is taken as input from the user, followed
 by the element the user wants to search in the array. The search function
 is called. If the element is present in the array, then print the index
 of the element in the array.
 NOTE : For binary search to work, the input array must be SORTED*/
 
 import java.util.*;
 
 public class BinarySearchRecursive {
 
 	// This method recursively searches for element in array
 	static int search(int array[], int left, int right, int element) {
 		
 		// If left pointer exceeds the right pointer
 		if(left > right) {
 			return -1;
 		}
 		
 		else {
 			// Find the middle index
 			int middle = left + (right - left) / 2;
 			// If element is found return index
 			if(array[middle] == element) 
 				return middle;
 			/* If middle element is greater than the given element
 			to search, then, recursively search in the left half of
 			the array.*/
 			else if(array[middle] > element) {
 				return search(array, left, middle - 1, element);
 			}
 			/* If middle element is less than the given element to
 			search, then, recursively search in the right half of
 			the array.*/
 			else if(array[middle] < element) {
 				return search(array, middle + 1, right, element);
 			}
 		}
 		// If not found, return -1
 		return -1;
 	}
 	public static void main(String[] args) {
 		
 		Scanner scan = new Scanner(System.in);
 
 		// Take length of array as input from the user
 		System.out.print(""Enter the length of array: "");
 		int length = scan.nextInt();
 
 		// Take elements of array as input from the user
 		int[] array = new int[length];
 		System.out.print(""Enter "" + length + "" elements followed by spaces: "");
 		for(int i = 0; i < length; i++) {
 			array[i] = scan.nextInt();
 		}
 
 		// Take element to search as input from the user
 		System.out.print(""Enter the element you want to search: "");
 		int element = scan.nextInt();
 
 		// Call sear",Java
"/*
 Description :   
 Three Sum Problem - In this problem, user will provide an array and we
                     have find wether there is any ""three"" numbers are 
                     present in the array who's sum is equal to the target 
 		            provided. If it is present then it will show true else 
                     it will show false.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int main()
 {
 	// n= size of an array
 	int n;
 	cout << ""Enter the size of an array : "" << endl;
 	cin >> n;
 	//target = the number who's sum we have find.
 	int target;
 	cout << ""Enter the target you want to set : "" cin >> target;
 
 	//n size of array
 	vector<int> a(n);
 	//taking input in the array
 	cout << ""Enter "" << n << "" number of elements : "" << emdl;
 	for (auto &i : a)
 	{
 		cin >> i;
 	}
 	bool found = false;
 	//sorting the array
 	sort(a.begin(), a.end());
 
 	for (int i = 0; i < n; i++)
 	{
 		int low = i + 1, high = n - 1;
 		while (low < high)
 		{
 			int current = a[i] + a[low] + a[high];
 			if (current == target)
 			{
 				found = true;
 			}
 			if (current < target)
 			{
 				low++;
 			}
 			else
 			{
 				high--;
 			}
 		}
 	}
 	if (found)
 	{
 		cout << ""True : Target value is present !"";
 	}
 	else
 	{
 		cout << ""False : Target value is not present !"";
 	}
 }
 
 /*
 Time Complexity  : O(n*n)
 Space Complexity : O(n)
 
 Test Cases :
 Test Case  1: 
     Input :
 	Enter the size of an array : 
 	6
 	Enter the target you want to set : 
 	24
 	Enter 6 number of elements : 
 	102 3 6 9 34 24
 
 	Output : True  : Target value is present !
 
 Test Case 2:
     Input :
 	Enter the size of an array : 
 	6
 	Enter the target you want to set : 
 	24
 	Enter 6 number of elements : 
 	2 3 6 9 3 25
 
 	Output : False : Target value is not present !
 */
",C-Plus-Plus
"/* Problem Description
 Given a set of N jobs where each job i has a deadline and profit associated to it. 
 Each job takes 1 unit of time to complete and only one job can be scheduled at a time.
 We earn the profit if and only if the job is completed by its deadline.
 The task is to find the maximum profit and the number of jobs done.
 */
 
 import java.io.*;
 import java.lang.*;
 import java.util.*;
 
 public class Job_Scheduling_Greedy {
     // this Job class will store the id, profit, deadline property 
 	static class Job {
 	    int id, profit, deadline;
 	    Job(int id, int deadline, int profit){
             this.id = id;
             this.profit = profit;
             this.deadline = deadline;
         }
 	};
 	
 	// solve() will do the task of getting the profit
 	static int[] solve (Job[] arr , int n )
 	{
 		// Sort the array in descending order according to profit
 		Arrays.sort(arr , (a,b) -> b.profit - a.profit );
 		int res[]  = new int[2] ;
 		int totalProfit = 0;
 		int count = 0 ;        
 		Boolean[] slots = new Boolean[n];
 		Arrays.fill(slots, false);
 	       /* iterate through the jobs with minDeadLine to remaining jobs and
 		 check if there is any slote available and also claculate the profit
 	       */
 		for (int i = 0; i < n; i++) {
 		    int minDeadLine = Math.min( arr[i].deadline - 1 , n- 1) ;
 		    for (int j = minDeadLine ; j >= 0; j--) 
 		    {
 			if (slots[j] == false) {
 			    count ++ ;
 			    slots[j] = true;
 			    totalProfit += arr[i].profit ;
 			    break;
 			}
 		    }
 		}
 		// store the count and profit in res array and return the result
 		res[0] = count ;
 		res[1] = totalProfit ;
 		return res ;
 	}
 	
  	public static void main(String[] args) throws IOException{
 	    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
 	    System.out.println(""Enter number of testcase"");
 	    int test = Integer.parseInt(br.readLine().trim());
 	    while(test-->0){
             // input the no. of j",Java
"package main
 
 import (
 	""fmt""
 	""os""
 )
 
 // Node defines the structure of a particular node in binary tree
 type Node struct {
 	data  int
 	left  *Node
 	right *Node
 }
 
 // NewNode creates a node and returns it's pointer
 func NewNode(data int) *Node {
 	return &Node{
 		data: data,
 	}
 }
 
 // CreateTree creates a new tree from level order array
 func (root *Node) CreateTree(arr []int, pos, size int) *Node {
 	var r *Node // nill by default
 	if pos < size {
 
 		r = NewNode(arr[pos])
 
 		// fill left subtree
 		r.left = r.CreateTree(arr, pos*2+1, size)
 
 		// fill right subtree
 		r.right = r.CreateTree(arr, pos*2+2, size)
 	}
 	return r
 }
 
 // InorderTraversal prints the Inorder traversal of tree
 func (root *Node) InorderTraversal() {
 	// Inorder Traversal : Left -> Root -> Right
 	if root != nil {
 		root.left.InorderTraversal()
 		fmt.Printf(""%v "", root.data)
 		root.right.InorderTraversal()
 
 	}
 }
 
 // Driver Code
 func main() {
 	// taking size of tree
 	var size int
 	fmt.Println(""Enter size of the tree: "")
 	_, err := fmt.Scanf(""%d\n"", &size)
 	// exit on invalid size
 	if err != nil {
 		println(""Invalid size"")
 		os.Exit(-1)
 	}
 
 	// allocating memory for array
 	arr := make([]int, size)
 	fmt.Println(""Enter values in level order fashion: "")
 
 	// Taking inpur
 	for i := 0; i < size; i++ {
 		_, err = fmt.Scanf(""%d"", &arr[i])
 
 		if err != nil {
 			println(""Invalid argument"")
 			os.Exit(-1)
 		}
 	}
 
 	// declaring root
 	var root *Node
 
 	// creating the tree
 	root = root.CreateTree(arr, 0, size)
 
 	// Calling InorderTraversal
 	root.InorderTraversal()
 }
 
 /*
 Sample input:
 Enter size of the tree:
 6
 Enter values in level order fashion:
 5 6 7 3 10 9
 
 Example Input Tree
 
 			  5
 		    /   \
 		  6      7
 		 / \    /
 		3  10  9
 
 Output
 3 6 10 5 9 7
 */
",Go
"// Minimum Sum Partition using recursion
 #include <iostream>
 #include <string>
 using namespace std;
 
 /* Partition the Set into two subsets Set1, Set2 such that the
   difference between the sum of elements in Set1 and the sum
   of elements in Set2 is minimized */
 int minPartition(int Set[], int n, int Set1, int Set2)
 {
     /* Case 0. If list becomes empty, return the absolute
        difference between two sets */
     if (n < 0)
         return abs(Set1 - Set2);
 
     /* Case 1. Include current item in the subset Se1 and recur
        for remaining items (n - 1) */
     int inc = minPartition(Set, n - 1, Set1 + Set[n], Set2);
 
     /* Case 2. Exclude current item from subset Se1 and recur for
        remaining items (n - 1) */
     int exc = minPartition(Set, n - 1, Set1, Set2 + Set[n]);
 
     //Returning included and excluded values
     return min(inc, exc);
 }
 
 //Main Code
 int main()
 {
 
     //int Set[] = { 10, 20, 15, 5, 25};
 
     int size;
     std::cout << ""Enter the number of elements you want in Set: "";
     std::cin >> size;
     int Set[size]; //Creating Set of size 'size'
     std::cout << ""Enter elements: "" << std::endl;
 
     for (int i = 0; i < size; i++) //Enter the elements in the Set
     {
         std::cin >> Set[i];
     }
     // Number of elements
     int n = sizeof(Set) / sizeof(Set[0]);
 
     cout << ""\nThe entered elements in the Set are: \n"" << std::endl;
     for (int i = 0; i < size; ++i) {
         cout << Set[i] << "" "";
     }
     //Printing the minimum difference
     cout << ""\nThe minimum difference is "" << minPartition(Set, n - 1, 0, 0);
 
     return 0;
 }
 
 /*
 SAMPLE INPUT:
 5
 1
 2
 3
 4
 5
 SAMPLE OUTPUT:
 Enter the number of elements you want in Set: Enter elements: 
 
 The entered elements in the Set are: 
 
 1 2 3 4 5 
 The minimum difference is 1
 
 Time Complexity = O(n*sum) 
 Depends on the value of 'n' and 'sum'
 */
",C-Plus-Plus
"//Given an array, find the inversion count for the array.
 //Inversion count of an array:- It indicates how far the array is from being a sorted array. For a sorted array, it is zero.
 //Sorted Array:- An array in arranged in a particular order (for this question its acsending order)
 
 /* 
   Why we use Merge Sort approach?
   If we will use simple approach, i.e., traverse through the array, and for every index, 
   find the number of smaller elements on its right side of the array, using a nested loop 
   and sum up the counts for all index in the array and print the sum, 
   it will take O(n^2) Time Complexity.
   Instead, we will use Merge Sort approach(Algorithm given below) to reduce Time Complexity to O(nlogn).
 */  
 
 /*
   Algorithm:- 
    1. The idea is similar to merge sort, divide the array into two equal
       or almost equal halves in each step until the base case is reached.
    2. Create a function merge that counts the number of inversions when two halves of the array are merged, 
       create two indices i and j, i is the index for the first half, and j is an index of the second half. 
       If a[i] is greater than a[j], then there are (mid  i) inversions because left and right subarrays
       are sorted, so all the remaining elements in left-subarray (a[i+1], a[i+2]  a[mid]) will be greater than a[j].
    3. Create a recursive function to divide the array into halves and find the answer by summing the
       number of inversions in the first half, the number of inversion in the second half and
       the number of inversions by merging the two.
    4. The base case of recursion is when there is only one element in the given half.
    5. Print the answer.
 */
 
 
 /*----CODE----*/
 #include <bits/stdc++.h>
 
 using namespace std;
 
 //This Function merges the two parts of sorted arrays into a single array after merge sort is being performed.
 int merge(int arr[], int temp[], int left, int mid, int right)
 {	
 	int i, j, k;
 	
   	//For k",C-Plus-Plus
"#class of stack 
 class stack:   
     def __init__(self):
         self.items=[]
     def push(self,item):
         self.items.append(item)
     def pop(self):
         return self.items.pop()
     def is_empty(self):
         return self.items==[]
 
 
 #function to reverse a function
 def reverse(string):
 
    """""" 
     >>Input:ziuQ
     >>Output:Quiz
     
   """"""
     x=len(string)
     l=0
     while l<x:
         s.push(string[l])
         l+=1
     rev=''
     while not s.is_empty():
         rev+=s.pop()
     return rev
 s=stack()
 
 #  Driver Code Starts
 if __name__=='__main__':
     t=int(input())
     for i in range(t):
         str1=input()
         print(reverse(str1))
",Python
"
 '''
 Locally weighted linear regression is a non-parametric algorithm, that is, 
 the model does not learn a fixed set of parameters as is done in ordinary linear regression. 
 Rather parameters 'theta' are computed individually for each query point x. 
 While computing 'theta', a higher preference is given to the points in the 
 training set lying in the vicinity of x than the points lying far away from x.
 
 Get the dataset from 'https://www.kaggle.com/aswin1871/tips-csv'
 '''
 
 import numpy as np
 import pandas as pd
 import matplotlib.pyplot as plt
 
 def kernel(point,xmat,k):
     '''
         This function calculates the weights kernel which is used to find the local weights.
     '''
     m,n = np.shape(xmat)
 
     # Stores the weight matrix consisting of 1s along the diagonals and 0s elsewhere.
     weights = np.mat(np.eye(m))
 
     for j in range(m):
         # Calculates the distance between each point under consideration and all other points of the dataset
         diff = point-xmat[j]
 
         # Perfoms the kernel weight equation
         weights[j,j] = np.exp((diff*diff.T)/(-2.0*k**2))
     return weights
 
 
 def local_weight(point,xmat,k,ymat):
     '''
         This function calculates the local weight of each point in the dataset with respect to the point under consideration.
     '''
 
     # Retrieves the weight kernel of each point wrt the given point.
     wei = kernel(point,xmat,k)
 
     # Calculates the weight matrix for the particular point
     w = (xmat.T*(wei*xmat)).I*(xmat.T*(wei*ymat.T))
     return w
 
 def local_weight_regression(xmat,ymat,k):
     '''
         Performs Local Weight Regression on each point of the dataset.
     '''
     m,n = np.shape(xmat)
 
     #  Defines the matrix which returns the predricted point for each input feature.
     ypred = np.zeros(m)
     for i in range(m):
 
         # the given point multiplied by the weight matrix values gives the predicted value.
         ypred[i] = xmat[i]*local_weig",Python
"""""""
 Given an array of positive and negative numbers, arrange them in an alternate 
 fashion such that every positive number is followed by negative and vice-versa 
 maintaining the order of appearance. 
 Number of positive and negative numbers need not be equal. 
 If there are more positive numbers they appear at the end of the array.
 If there are more negative numbers, they too appear in the end of the array.
 
 Examples : 
 
 Input:  {1, 2, 3, -4, -1, 4}
 Output: {-4, 1, -1, 2, 3, 4}
 
 Input:  {-5, -2, 5, 2, 4, 7, 1, 8, 0, -8}
 output: {-5, 5, -2, 2, -8, 4, 7, 1, 8, 0} 
 """"""
 
 def rearrange_list_with_order(arr):
     posi=[]
     negi=[]
     
     for i in range(len(arr)):
         if arr[i]>=0:
             posi.append(arr[i])
         else:
             negi.append(arr[i])
     
     l=len(arr)
 
     arr2=[]      
     
     for i in range(l):
     #print(negi[i],posi[i],len(negi),len(posi))
         if i<len(negi):
             arr2.append(negi[i])
         if i<len(posi):
             arr2.append(posi[i])
     return arr2 
 
 if __name__ == ""__main__"":
     arr = list(map(int,input(""Enter the list : "").split()))
     print('After rearrange with order',rearrange_list_with_order(arr))
 
 """"""
 Time Complexity: O(n^2)
 Space Complexity : O(1)
 
 INPUT: 
 Enter the list 1: 1 2 3 -4 -1 4
 
 
 OUTPUT:
 After rearrange with order [-4, 1, -1, 2, 3, 4]
 """"""
",Python
"/**
  * Maximum of All Subarrays of Size k
  * Cpp program to find the maximum integer in each subarray of 
  * fixed size k, given an array of integers, using the 'Sliding 
  * Window Technique'. 
  */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void MaximumEachSubarray(int len, int arr[], int k)
 {
     //Deque stores indices of useful elements for each window.
     //These elments are sorted in decreasing order, so that for each
     //window, maximum element is at the front.
     deque<int> maxElement;
     vector<int> ans;
     //Edge case
     //If len is smaller than k, push maximum element into the answer
     if (k > len) {
         ans.push_back(*max_element(arr, arr + len));
     }
     //Two pointer one pointing to start and other to the end of current window
     int start = 0, end = 0;
     //The same process is repeated over all windows of length k.
     while (end < len) {
         //For any element, all elements smaller than it and to its left in
         //the window are useless as they cannot be the maximum for that
         //window. Hence, we remove them from rear of deque.
         while (maxElement.size() > 0 && maxElement.back() < arr[end])
             maxElement.pop_back();
         //Adding newest element to rear of deque
         maxElement.push_back(arr[end]);
         //If window size is not reached,increment end pointer
         if (end - start + 1 < k)
             end++;
         else if (end - start + 1 == k) { //Adding front element to ans
             //If front element equals 1st element
             //of current window, we remove it from deque
             ans.push_back(maxElement.front());
             if (maxElement.front() == arr[start])
                 maxElement.pop_front();
             //slide the window
             start++;
             end++;
         }
     }
     cout << ""Array of maximum integers in all k-sized subarrays: "";
     for (int i = 0; i < ans.size(); i++)
         cout << ans[i] << "" "";
 }
 
 in",C-Plus-Plus
"/*
 C++ program to reverse a number.
 The reverse of a number is a number that is obtained when a number is traversed from right to left.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 // Function to do reverse
 
 int reverse(int num) {
   // Initializing rev as 0
 
   int rev = 0;
   do {
     // Adding the last digit
 
     rev = rev * 10 + num % 10;
     // Removing the last digit
 
     num = num / 10;
   } while (num > 0);
 
   return rev;
 }
 
 int main() {
   int num;
   // Taking Input 
 
   cout << ""Enter the number: "";
   cin >> num;
   // Printing Output
 
   cout << ""The reverse of the given number is: "" << reverse(num);
   return 0;
 }
 
 /*
 Time Complexity - O(n), where 'n' is the number of digits in the number.
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 SAMPLE I
 
 INPUT
 Enter the number: 1234
 
 OUTPUT
 The reverse of the given number is: 4321
 
 */
   
",C-Plus-Plus
"import java.io.*; 
 import java.util.*;
 
 public class demo{                                              
     public static  Integer change(Integer amount, Integer[] coins) {        //Bottomup dp
          if (amount == 0) return 1;                                         //base case if no coin is selected,then there can be one way only ie. not selecting any coin
         
         int[][] dp = new int[coins.length + 1][amount + 1];                 //dp[i][j] represents the amount of coin combinations within first i coins to get j amount
         for (int i = 0; i <= coins.length; i++) dp[i][0] = 1;
         
         for (int i = 1; i <= coins.length; i++) {
             for (int j = 1; j <= amount; j++) {
                 if (coins[i - 1] > j) {
                     dp[i][j] = dp[i - 1][j];                               //dp[i - 1][j] Not selecting the i th coin , let the other coins form j
                 } else {
                     dp[i][j] = dp[i][j - coins[i - 1]] + dp[i - 1][j];     //dp[i][j - coins[i - 1]] select i th coin one or multiple times to form j, we take using i th coin into consideration every time
                 }
             }
         }
         return dp[coins.length][amount];
     }
  
     public static void main(String args[]){
         Scanner sc = new Scanner(System.in);
 
         Integer n = sc.nextInt();
 
         ArrayList<Integer> li = new ArrayList<Integer>(); 
         while(true){
             System.out.println(""Please enter coin value: "");  //enter coin values
             li.add(sc.nextInt());
             System.out.println(""Do you want to add more yes/no?"");
             String answer = sc.next(); 
 
             if (answer.equals(""no"")){
                 break;
             }
         }
         Integer arr[] = new Integer[li.size()]; //converting arraylist to array
         arr = li.toArray(arr);
 
         System.out.println(change(n,arr));
     }
 }
 
 
 /*
 Sample Test Case
 Input:
 N = 4
 S = {1,2,3}
 
 Explan",Java
"/* 
 Finding largest prime factor of a given number by using DART.
 
 Given a positive integer, find largest prime factor.
 */
 
 import 'dart:io';
 
 int largest_Prime_Factor(int n) {
   int larg_prime = -1;
   // return larg_prime;
 
   // if there is a number divisible by 2 then remove all 2s which can are
   // dividing that number so that we can focus on more greater prime number
   while (n % 2 == 0) {
     larg_prime = 2;
     n = n ~/ 2;
   }
 
   for (int i = 3; i * i <= n; i += 2) {
     while (n % i == 0) {
       larg_prime = i;
       n = n ~/ i;
     }
   }
 
   // when n itself is a prime number then we considering it here
   if (n > 2) larg_prime = n;
 
   return larg_prime;
 }
 
 void main() {
   // taking input from user
   var n;
   print('Enter the element: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   int prime;
   print(""\nLargest prime number of $n is: "");
   prime = largest_Prime_Factor(n);
   print(prime);
 }
 
 /*
 TIME COMPLEXITY: O(n).
 SPACE COMPLEXITY: O(1).
 
 SAMPLE INPUT/OUTPUT:
 Enter the element: 
 99
 
 Largest prime number of 99 is:
 11
 */
",Dart
"/* Move all Negative numbers to beginning and Positive to the end */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 /* Function for Moving all Negative numbers to beginning and Positive to end */
 void solve()
 {
     /* Input n = size of array */
     int n;
     cin >> n;
 
     int a[n];
     
     /* Input elements in an array */
     for (int i = 0; i < n; ++i)
     {
         cin >> a[i];
     }
 
     /* Create the empty result array
        to store the result */
     int result[n]; 
     
     /* Take a pointer of index of result */  
     int k = 0; 
 
     /* Traverse the array and store 
        Negative element in result array */
     for (int i = 0 ; i < n ; i++) 
     {
         if (a[i] < 0) 
         {
             result[k++] = a[i];
         }
     }
   
     /* Check if result array contain all positive
        and negative elements then return */
     if (k == n || k == 0) 
         return; 
   
     /* Store positive elements in the result array */  
     for (int i = 0; i < n ; i++)
     { 
         if (a[i] >= 0 )
         { 
             result[k++] = a[i]; 
         }
     }
 
     /* Print elements form result array*/
     for (int i = 0; i < n; ++i)
     {
         cout << result[i] << "" "";
     }
 }
 
 int main()
 {
     solve();
     return 0;
 }
 
 /*
 Test cases :
     
     Input 1 :
         
         9
         -12 11 -13 -5 6 -7 5 -3 -6
 
     Output 1 :
 
         -12 -13 -5 -7 -3 -6 11 6 5  
 
     Input 2 :
 
         8
         1 -1  11 5 -3 -2 7 6
     
     Output 2 :
     
         -1 -3 -2 1 11 5 7 6  
     
     Time complexity: O(n)
     Space Complexity: O(n)
 */
",C-Plus-Plus
"""""""Julia program to implement Binary Search algorithm.
 Binary Search is a Divide and Conquer strategy based algorithm, where the entire array is divided into two halfs and the
 required element is searched for in one of these sections as per the conditions. It is done on sorted arrays.
 """"""
 
 function binary_search(arr, n, ele)
     low = 1
     high = n
     while high >= low
         mid = low + (high - low)  2
         # If the mid element is the required element, return that index
         if(arr[mid] == ele)
             return mid
         # ele is greater than mid element then ele would be present in first half of the array
         elseif (arr[mid] > ele)
             high = mid - 1
         #Else if  ele is smaller than mid element then ele would be present in last half of the array
         else
             low = mid + 1
         end
     end
     # If the element is not found return 0
     return 0
 end
 
 
 print(""How many numbers are present in the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""Array is Empty!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())] 
 print(""Which number do you want to search in the array? "")
 ele = readline()
 ele = parse(Int, ele)
 # Sort the array in ascending order
 arr = sort(arr)
 res = binary_search(arr, n, ele)
 if (res == 0)
     print(""The number $ele is not present in the array"")
 else
     print(""The number $ele is present in the array."")
 end
 
 
 """"""
 Time Complexity - O(log(n)), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 How many numbers are present in the array? 5 
 Enter the numbers: 1 2 3 4 5
 Which number do you want to search in the array? 6
 The number 6 is not present in the array
 
 SAMPLE II
 
 How many numbers are present in the array? 3
 Enter the numbers: 3 1 2
 Which number do you want to search in the array? 2
 The number 2 is present in the ar",Julia
"/* This is a simple program in go language to find if a give number
    is a automorphic number or not. An automorphic number is an
    integer whose square ends with the given integer, as (25)2 = 625,
    and (76)2 = 5776.
 */
 
 package main
 
 import (
 
   ""fmt""
 
 )
 
 // This is a global variable
 var n int
 
 // This function tells us if the number is automorphic number or not 
 func automorphicnumber() {
 
    var number int
    var b int
    b = n
    number = n*n
    i := 1
 
    //to construct the last digits
    for b != 0  {
 
      i = i*10
      b = b/10
    }
 
    //checking if the last digits form the orginal number
    if((number%i) == n) {
 
       fmt.Print(""The given number is Automorphic number!"")
 
    }else{
 
      fmt.Print(""The given number is not Automorphic number!"")
    }
 
 }
 
 // driver function
 func main() {
 
    fmt.Print(""Enter the number you want to check :"")
    fmt.Scan(&n)
 
    // calling automorphic function 
    automorphicnumber()
 }
 
 /*
    Sample I/O :
 
    a) Is Automorphic Number :
 
    Enter the number you want to check :76
    The given number is Automorphic number!
 
    b) Is not Automorphic Number :
 
    Enter the number you want to check :7
    The given number is not Automorphic number! 
 */
 
",Go
"//Power Set Using Bitwise
 
 #include <bits/stdc++.h>
 using namespace std;
 
 void printPowerSet(string str)
 {
 	int n = str.length();
 
 	int powSize = pow(2, n);
 
 	for(int counter = 0; counter < powSize; counter++)
 	{
 		for(int j = 0; j < n; j++)
 		{
 			if((counter & (1 << j)) != 0)
                 cout<<str[j];
 		}
 		
 		cout<<endl;
 	}
 }
 
 int main() {
 	
 	string s ;
 	cin>>s;
 
     printPowerSet(s);     
 }
 
 /*
 Time Complexity: O(n2^n)
 Space Complexity: O(1)
 */
 /*Sample Input:
 Example 1:- abc
 Example 2:- pqrst
 
 Sample Output:
 Example 1:-
 a
 b
 ab
 c
 ac
 bc
 abc 
 Example 2:-
 p
 q
 pq
 r
 pr
 qr
 pqr
 s
 ps
 qs
 pqs
 rs
 prs
 qrs
 pqrs
 t
 pt
 qt
 pqt
 rt
 prt
 qrt
 pqrt
 st
 pst
 qst
 pqst
 rst
 prst
 qrst
 pqrst
 */
 
",C-Plus-Plus
"#include<stdio.h>
 #include<stdbool.h> 
 
 #define INF 9999999
 
 // number of vertices in graph
 #define V 5
 
 // create a 2d array of size 5x5
 //for adjacency matrix to represent graph
 int G[V][V] = {
   {0, 9, 75, 0, 0},
   {9, 0, 95, 19, 42},
   {75, 95, 0, 51, 66},
   {0, 19, 51, 0, 31},
   {0, 42, 66, 31, 0}};
 
 int main() {
   int no_edge;  // number of edge
 
   // create a array to track selected vertex
   // selected will become true otherwise false
   int selected[V];
 
   // set selected false initially
   memset(selected, false, sizeof(selected));
   
   // set number of edge to 0
   no_edge = 0;
 
   // the number of egde in minimum spanning tree will be
   // always less than (V -1), where V is number of vertices in
   //graph
 
   // choose 0th vertex and make it true
   selected[0] = true;
 
   int x;  //  row number
   int y;  //  col number
 
   // print for edge and weight
   printf(""Edge : Weight\n"");
 
   while (no_edge < V - 1) {
     //For every vertex in the set S, find the all adjacent vertices
     // , calculate the distance from the vertex selected at step 1.
     // if the vertex is already in the set S, discard it otherwise
     //choose another vertex nearest to selected vertex  at step 1.
 
     int min = INF;
     x = 0;
     y = 0;
 
     for (int i = 0; i < V; i++) {
       if (selected[i]) {
         for (int j = 0; j < V; j++) {
           if (!selected[j] && G[i][j]) {  // not in selected and there is an edge
             if (min > G[i][j]) {
               min = G[i][j];
               x = i;
               y = j;
             }
           }
         }
       }
     }
     printf(""%d - %d : %d\n"", x, y, G[x][y]);
     selected[y] = true;
     no_edge++;
   }
 
   return 0;
 }
",C
"/*
 	==============================================================
 			Implementing QUEUE using STACK data structure
 	==============================================================
 	stack can be implemented using two queues
 
 	 1 -> By making push() operation costly :
 		This method insert new entered element in the pushQueue,
 		so that pop() operation just dequeue from pushQueue. To put the element at top of pushQueue, popQueue is used.
 
 	  2 -> By making pop() operation costly :
 		In this method, in push() operation, the new element is entered at the top of pushQueue.
 		In pop() operation, all the elements of pushQueue are dequeued and enqueued to popQueue and top of popQueue is returned.
 		finally all the elements of popQueue dequeued and enqueued to pushQueue again
 
 	  This program uses second way
 
 */
 
 package main
 
 import (
 	""fmt""
 )
 
 // CAPACITY of every Stack and Queue in this program
 const CAPACITY int = 10
 
 // QUEUE user-definded data type to hold the variables for our queue data structure
 type QUEUE struct {
 	front int
 	back  int
 	array [CAPACITY]int
 }
 
 func (queue *QUEUE) initQueue() {
 	queue.front = -1
 	queue.back = -1
 }
 
 // isEmpty(): checks if the both front and back are less than 0 it means Queue is empty
 func (queue *QUEUE) isEmpty() bool {
 	if queue.front < 0 && queue.back < 0 {
 		return true
 	}
 	return false
 }
 
 // iFull(): checks if the back of Queue is greater or equals to last index of array,
 // if so it will return true otherwise false
 func (queue *QUEUE) isFull() bool {
 	if queue.back >= CAPACITY-1 {
 		return true
 	}
 	return false
 }
 
 // enQueue(): it first checks if there is space available for new element,
 // if available it will just insert the value to end of the Queue
 func (queue *QUEUE) enQueue(value int) {
 	if queue.isFull() {
 		fmt.Println(""Queue is full"")
 	} else {
 		if queue.front < 0 {
 			queue.front++
 		}
 		queue.back++
 		queue.array[queue.back] = value
 	}
 }
 
 // pop()",Go
"{
   ""nbformat"": 4,
   ""nbformat_minor"": 0,
   ""metadata"": {
     ""colab"": {
       ""name"": ""K_nearest_neighbors.ipynb"",
       ""provenance"": []
     },
     ""kernelspec"": {
       ""name"": ""python3"",
       ""display_name"": ""Python 3""
     },
     ""accelerator"": ""GPU""
   },
   ""cells"": [
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""sO_IMbljLMNj"",
         ""colab_type"": ""text""
       },
       ""source"": [
         ""# Building K Nearest Neighbor classifier from scratch.""
       ]
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""M6UfZmwc5tFr"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""import numpy as np\n"",
         ""from collections import Counter""
       ],
       ""execution_count"": 3,
       ""outputs"": []
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""tGPHY7rl_u5i"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""# implementing formula for euclidean distance\n"",
         ""def euclidean_distance(x1,x2):\n"",
         ""  return np.sqrt(np.sum((x1-x2)**2))""
       ],
       ""execution_count"": 2,
       ""outputs"": []
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""wpM1M503-p2_"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""#creating the KNN classifier class\n"",
         ""class KNN:\n"",
         ""  #setting k = 3 as default value\n"",
         ""  def __init__(self,k=3):\n"",
         ""    self.k = k\n"",
         ""  \n"",
         ""  def fit(self,X,y):\n"",
         ""    self.X_train = X\n"",
         ""    self.y_train = y\n"",
         ""  \n"",
         ""  def predict(self,X):\n"",
         ""    y_pred = [self._predict(x) for x in X]\n"",
         ""    return np.array(y_pred)\n"",
         ""\n"",
         ""  def _predict(self,x):\n"",
         ""    #distance\n"",
         ""    distances = [euclidean_distance(x,x_train) for x_",Python
"/*
 Given an array of numbers find the next smallest element to the right of each element.
 ALGORITHM:
 *We use the concept of Last In First Out of stacks
 */ 
 
 import java.util.Stack;
 import java.util.Scanner;
 
 public class NextSmallestToRight
 {
     public static void nextSmallestToRight(int a[],int n)
     {
         //Initializing in-built stack
         Stack<Integer> st=new Stack<>();
         int v[]=new int[n];
         for(int i=n-1;i>=0;i--)
         {
             if(st.empty())
             v[i]=-1;
             else if(st.empty()!=true && st.top()<a[i])
             v[i]=st.top();
             else if(st.empty()!=true && st.top()>=a[i])
             {
                 while(st.empty()!=true && st.top()>=a[i])
                 st.pop();
 
                 if(st.empty())
                 v[i]=-1;
                 else if(st.top()<a[i])
                 v[i]=st.top();
             }
             st.push(a[i]);
         }
         for(int i=0;i<n;i++)
         System.out.print(v[i]+"" "");
     }
     public static void main(String args[])
     {
         Scanner s=new Scanner(System.in);
         int n;
         System.out.println(""Enter the size of the array: "");
         n=s.nextInt();
         int a[]=new int[n];
         System.out.println(""Enter the elements: "");
         for(int i=0;i<n;i++)
         a[i]=s.nextInt();
         nextSmallestToRight(a,n);
         s.close();        
     }
 }
 
 /*
 Time Complexity: O(n)
 
 Space Complexity: O(n)
 
 Input:
 
 Enter the size of the array: 
 4
 Enter the elements:
 3 4 1 7
 
 Output:
 
 1 1 -1 -1
 */
",Java
"/* 
 Problem: Solving Quadratic equations in C.
 Aim: A program that prints roots and also tells us the types of the roots of a quadratic equation ax+bx+c=0
 */
 #include<stdio.h>
 #include<math.h>
 
 void quadratic_equation_roots(){
 	// value a, b, and c;
 	double a, b, c;
 	double discriminant;
 	printf(""Enter the co-efficients (x^2), x, and 1 of the quadratic equation (a*x*x+b*x+c)=0: "");
 	scanf(""%lf%lf%lf"",&a,&b,&c);
 	// calculate the discriminant (b^2 - 4ac)
 	discriminant=(b*b-4*a*c);
 	// If a is 0, then equation is not quadratic, but linear
 	if(a==0){
 		printf(""\nThe equation is a linear equation, not a qudratic equation"");
 	}
 	// discriminant is greater than 0 --> real and distinct roots
 	else if(discriminant>0){
 		printf(""\nThe roots are unequal and both have real value. And the roots are,"");
 		printf(""\nroot1 = %.2lf"",(-b+sqrt(discriminant))/(2*a));
 		printf(""\nroot2 = %.2lf"",(-b-sqrt(discriminant))/(2*a));
 	}
 	// discriminant is equal to 0 --> real and equal roots
 	else if(discriminant==0){
 		printf(""\nThe roots are equal and both have real values. And the roots are, "");
 		printf(""\nroot1 = root2 = %.2lf"",-b/(2*a));
 	}
 	// discriminant is less than zero, imaginary roots
 	else{
 		printf(""\nThe roots are complex numbers and have imaginary roots. And the roots are, "");
 		printf(""\nroot1 = %.2lf + %.2lfi"",-b/(2*a),sqrt(-discriminant)/(2*a));
 		printf(""\nroot2 = %.2lf - %.2lfi"",-b/(2*a),sqrt(-discriminant)/(2*a));
 	}	
 }
 void main(){
 	quadratic_equation_roots();
 }
 /* 
 Sample Test Cases:
 ....Test case 1:
 Enter the co-efficients (x^2), x, and 1 of the quadratic equation (a*x*x+b*x+c)=0: 3 -6 2
 
 The roots are unequal and both have real value. And the roots are,
 root1 = 1.58
 root2 = 0.42
 
 ....Test case 2:
 Enter the co-efficients (x^2), x, and 1 of the quadratic equation (a*x*x+b*x+c)=0: 6 -12 6
 
 The roots are equal and both have real values. And the roots are,
 root1 = root2 = 1.00
 
 ....Test case 3:
 Enter the co-efficien",C
"import java.util.Scanner;
 
 /*
 *Shell Sort is a very efficient sorting algorithm based on insertion sort technique.
 *
 *Shell Sort is more effective than insertion sort as
 *sometimes in Insertion Sorting, we shift a large block to insert an item at the right place
 *as per the sorting order,
 *which can be avoided by using the Shell Sort algorithm.
 *
 *In Shell Sort, the sorting is done at certain intervals/gaps and everytime, this gap is reduced.
 *This way, Shell Sort becomes nearly twice as fast as Insertion Sort.
 */
 
 public class ShellSort {
 	int shellsort(int arr[], int n) {
 		//here n is the size of the array
 		//initially gap = n/2
 		for (int gap = n / 2; gap > 0; gap = gap / 2) {
 			for (int i = gap; i < n; i++) {
 				//decreasing the gap
 				int k = arr[i];
 				int j = i;
 
 				while (j >= gap && arr[j - gap] > k) {
 					arr[j] = arr[j - gap];
 					j = j - gap;
 				}
 				arr[j] = k;
 			}
 		}
 		return 0;
 	}
 
 	private static Scanner sc = new Scanner(System.in);
 
 	public static void main(String args[]) {
 		//we store the number of elements in n
 		System.out.println(""Kindly enter the number of elements: "");
 		int n = sc.nextInt();
 
 		//declaring an array of n elements
 		int array[] = new int[n];
 
 		//taking the input from the user
 		for (int i = 0; i < n; i++) {
 			System.out.print(""\n"" + i + ""'th element : "");
 			array[i] = sc.nextInt();
 		}
 
 		System.out.println(""\nArray before sorting"");
 		for (int j = 0; j < n; j++)
 			System.out.print(array[j] + "" "");
 
 
 		//creating an object of shellsort class so that the methods inside shellsort class can be used
 		ShellSort object = new ShellSort();
 		object.shellsort(array, n);
 
 		System.out.println(""\nArray after sorting"");
 		for (int k = 0; k < n; k++)
 			System.out.print(array[k] + "" "");
 
 	}
 }
 
 /*
 Output:
 
 Kindly enter the number of elements: 5
 
 0'th element : 1
 1'th element : 2
 2'th element : 5
 3'th element : 3
 4'th element : 0
 Array before sortin",Java
"'''
 Given an array of n positive integers, find the first equilibrium point in the array.
 Equilibrium Point in an array is a position at which sum of elements before it is equal 
 to the sum of elements after it.
 
 '''
 
 def findEquilibriumPoint(arr, n):
     
     '''
     Returns equilibrium point if exists,
     -1 otherwise.
     
     '''
     #initialize sum of elements to the left to zero
     lsum = 0
     #initialize sum of elements to the right to sum of all the elements in the array
     rsum = sum(arr)
     #loop through elements in the array
     for i in range(n):
         #subtract element at ith position from rsum
         rsum -= arr[i]
         #check if left sum equals right sum, if true return the position,
         #otherwise add element at ith position to lsum
         if lsum == rsum:
             return i+1
         else:
             lsum += arr[i]
     return -1
 
 
 if __name__ == ""__main__"":
     arr = [int(x) for x in input(""Enter elements of the array: "").split()]
     n = len(arr)
     equi_point = findEquilibriumPoint(arr,n) 
     if equi_point == -1:
         print(""Equilibrium point does not exist."")
     else:
         print(f""Position {equi_point} is the equilibrium point. "")
         
         
 """"""
 
 Time complexity: O(n)
 Space complexity: O(n)
 
 Test case 1
 Input:
 Enter elements of the array: 1 2 3 4 5
 Output:
 Equilibrium point does not exist.
 
 Test case 2
 Input:
 Enter elements of the array: 3 2 4 1 4
 Output:
 Position 3 is the equilibrium point.
 
 """"""",Python
"/*
 DIFFERENCE OF TWO STRINGS
 Problem Statement
     Given 2 strings a and b. String b has one more char added and shuffled. Find the char added in the string b.
 Implementation 
     a. Using Hashmap (Slow approach and extra space)
     b. Using Bits Manipulation (Efficient Approach and no extra space)
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 // Efficient Approach (Space - O(1) and time - O(N))
 char bits_diff(string a, string b)
 {
     char xorr = 0;
     int i = 0;
     for(i=0;i<a.size();i++){
         xorr ^= (a[i] ^ b[i]);
     }
     return xorr ^ b[i];
 }
 
 // Space - O(N) and Time - O(M+N) where m and n are the size of the 2 strings
 char map_diff(string a, string b) {
     unordered_map<char,int> mp1, mp2;
     for(auto x:a) 
         mp1[x]++;
     for(auto y:b)
         mp2[y]++;
         
     for(auto x:b)
     {
         if(mp1.find(x)==mp2.end()) // finds the char of mp1 in mp2 
             return x;
         else if(mp1[x]!=mp2[x])  // a = 's' and b = 'ss' for the same char but diff count ans = 's'
             return x;
     }
     return b[(b.size())-1];
 }
 
 int main()
 {
     string a,b; 
     cin>>a>>b;
     cout<< bits_diff(a,b) << endl;
     cout<< map_diff(a,b) << endl;
     return 0;
 }
 
 /*
 Input 
     a = ""abc""
     b = ""abcd""
 Output: d
 
 Input 
     a = """"
     b = ""c""
 Output: c
 
 Input 
     a = ""zz""
     b = ""zzz""
 Output: z
 */",C-Plus-Plus
"# Julia program to Right Rotate a number by a specific bits.
 
 # Right Rotate 'cnt' number of bits of the given number 'n'
 function right_rotate_bits(n, cnt)
     cnt = cnt % 31
     while(cnt > 0)
         # Store the current LSB in a temporary variable
         lsb = n & 1
         # Right rotate the given number by one bit and drop its LSB
         n = (n >> 1) & (~(1 << 31))
         # Set the dropped LSB as the new MSB
         n = n | (lsb << 31)
         # Decrement cnt
         cnt = cnt - 1
     end
     return n
 end
 
 
 print(""Enter the number? "")
 num = readline()
 num = parse(Int, num)
 print(""How many bits do you want to rotate? "")
 cnt = readline()
 cnt = parse(Int, cnt)
 left = right_rotate_bits(num, cnt)
 print(""The Right-rotated number is: $left"")
 
 
 """"""
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 Enter the number? 39
 How many bits do you want to rotate? 17
 The Right-rotated number is: 1277952 
 """"""
",Julia
"/*
 C# Program for Recursive Implementation of Binary Search
 Binary Search - 
 Search a sorted array by repeatedly dividing the search interval in half. 
 Begin with an interval covering the whole array. If the value of the search
 key is less than the item in the middle of the interval, narrow the interval
 to the lower half. Otherwise narrow it to the upper half. Repeatedly check 
 until the value is found or the interval is empty.
 */
 using System;
 
 class Program
 {
     static int RecursiveBinarySearch(int[] arr, int l,int r, int x)
     {
         if (r >= l)
         {
             int mid = l + (r - l) / 2;
 
             //if the element is present at the middle itself
             if (arr[mid] == x)
                 return mid;
 
             //if the element is smaller thar the mid, then it can only be present in left subarray
             if (arr[mid] > x)
                 return RecursiveBinarySearch(arr, l, mid - 1, x);
 
             //else the Element can only be present in right subarray
             return RecursiveBinarySearch(arr, mid + 1, r, x);
         }
 
         //we reach here when element not present in array 
         return -1;
     }
 
     static void Main()
     {
         Console.WriteLine(""Enter size of array that you like to create"");
         int n = int.Parse(Console.ReadLine());
 
         int[] arr = new int[n];
         Console.WriteLine(""Enter values in array"");
 
         for (int i = 0; i < n; i++)
         {
             arr[i] = int.Parse(Console.ReadLine());
         }
 
         Console.WriteLine(""Enter value that you like to find in array"");
         int x = int.Parse(Console.ReadLine());
 
         int index = RecursiveBinarySearch(arr, 0, n - 1, x);
 
         if (index >= 0)
             Console.WriteLine(""Found at index: "" + index);
         else
             Console.WriteLine(x + "" isn't present in the array"");
     }
 }
 /*
 Sample Input
 Enter size of array that you like to create
 7
 Enter values in array
 ",C-Sharp
"# finding least positive number
 # Given an array of integers, find the first missing positive integer in
 # linear time and constant space.In other words,
 # find the lowest positive integer that does not exist in the array.
 # The array can contain duplicates
 # and negative numbers as well.
 # code contributed by devanshi katyal
 # space complexity:O(1)
 # time complexity:O(n)
 
 
 def MainFunction(arr, size):
     for i in range(size):
         if (abs(arr[i]) - 1 < size and arr[abs(arr[i]) - 1] > 0):
             arr[abs(arr[i]) - 1] = -arr[abs(arr[i]) - 1]
     for i in range(size):
         if (arr[i] > 0):
             return i + 1
     return size + 1
 
 
 def findpositive(arr, size):
     j = 0
     for i in range(size):
         if (arr[i] <= 0):
             arr[i], arr[j] = arr[j], arr[i]
             j += 1
     return MainFunction(arr[j:], size - j)
 arr = list(map(int, input().split("" "")))
 # sample input= [-1, 2, 4,3 , 0]
 print(""the smallest missing positive number is"", findpositive(arr, len(arr)))
 # output: the smallest missing positive number is 1
",Python
"/*String Method:*/
 import java.util.Scanner;
 
 public class CountDigits {
 
 	public static int countdigit(int n) {
 	     if(n==0){
 	         return 1;
 	     }
          return (Integer.toString(n).length());
 	}
 	
 	public static void main(String[] args) {
 
 		Scanner sc=new Scanner(System.in);
 		
 		System.out.print(""Enter a number : "");
 		int n=sc.nextInt();
 		
 		System.out.println(""Number of digits in a number are : "");
 		System.out.println(countdigit(n));
 				
 	}
 }	
 /*	
  	Sample Input : 
 	Enter a number : 24567
  	
 	Sample Output : 5
 	 
 	 
 */
",Java
"//program to find longest common subsequence using dynamic programming in java
 import java.util.*;
 public class lcsdp
 {
 
   public static void main(String args[]) 
      {
    	Scanner s=new Scanner(System.in);
 	System.out.println(""Enter first string: "");//input the string1
 	String a=s.next(); //sample input- asdfgk
 	System.out.println(""Enter second string: "");//input the string2
 	String b=s.next();//sample input- adflom
 	lcs(a,b);//call lcs function
 	 //sample output-3
 	s.close();
      }
 		
    public static void lcs(String s1, String s2)
      {
 			
 	int[][] storage = new int[s1.length() + 1][s2.length() + 1];
 	System.out.println(""The length of lcs is "" +lcsDP(s1, s2, storage));
      }
 
    public static int lcsDP(String s, String t, int[][] storage)
      {
 	int m = s.length();
 	int n = t.length();
 	int storage1[][] = new int[s.length() + 1][t.length() + 1];
 	for(int i=0;i<=m;i++)
 	{ //initialize 1st row as 0
 	  storage1[i][0]=0;
 	 }
 	for(int i=0;i<=n;i++)
 	{//initialize 1st column as zero
            storage1[0][i]=0;
 	 }
 	 for(int i=1;i<=m;i++){
             for(int j=1;j<=n;j++){
 		 if(s.charAt(m-i)==t.charAt(n-j)){//down to top approach
 		      storage1[i][j]=1+storage1[i-1][j-1];
 	            }
 		  else{
 		      storage1[i][j]=Math.max(storage1[i][j-1],storage1[i-1][j]);
 	               //maximum out of the two
 		       }
 		}
 	   }
 	   return storage1[m][n];
      }
 
 }
 /*
 Input:
 Enter first string:
 asdfghjk
 Enter second string:
 adfgiou
 Output:
 The length of lcs is 4
 Time Complexity  : O(m*n)
 Space Complexity : O(m*n)
 */
",Java
"/*
     We are given an array a[], check whether the value exists or not,
     if exits print the index(1 based indexing) else print -1.
 
     Bilinear approach:
     Let A be the linear array of n elements. The algorithm searches for element 'key'. 
     Let 'index' represent the location of the element 'key' in the array. 
     The algorithm returns the values index=-1 if the element 'key' is not present in the array 
     and value index if the element 'key' is present in the array.
 
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 #define MAX 100005
 
 //bilenear search algorithm
 int bilinear(vector<int>&a,int n,int key)
 {
     int front=0,back=n-1;
     //terminating condition
     while(front<=back)
     {
         if(a[front]==key) 
             return front+1;
         if(a[back]==key)
             return back+1;
         front++;
         back--;
     }
     return -1;
 }
 
 int main()
 {
     //declare and read the values of n;
     int n; 
     cin>>n;
     //declare and read the values of a[] of size n
     vector<int>a(MAX);
     for(int i=0;i<n;i++)
         cin>>a[i];
     //declare and read the value of key
     int key; 
     cin>>key;
     //Billinear approach
     cout<<bilinear(a,n,key);
     
     return 0;
 }
 
 /*
 Time complexity  : O(N)
 Space complexity :O(1)
 */
 
 /*
 Sample Input 1: 
 5
 5 4 3 2 1
 1
 
 Sample Output 1:
 5
 
 Sample Input 2: 
 5
 5 4 3 2 1
 7
 
 Sample Output 2:
 -1
 */
 
",C-Plus-Plus
"/*
     If the factorial of individual digits of a number when summed up yields the number itself then the number is called Krishnamurthy 
     Number. 
     Example : 
     Consider the number 145
     Summing of factorials of the individual digits we get = 1! + 4! + 5! = 1 + 24 + 120 =145.
     Hence 145 is not a Krishnamurthy number.
 */
 
 //CPP Program to find whether a number is a Krishnamurthy number
 
 #include<iostream>
 
 //Function to calculate the factorial of the individual digits
 
 int Factorial ( int n )
 {
     if ( n == 1 || n == 0 )
     {
         return 1;
     }
     return n * Factorial( n - 1 );
 }
 
 int Krishnamurthy_No ( int num )
 {
     int digit, sum = 0 ,copy = num;
 
     //Running a loop till we have extracted all the digits from the copy of the given number
     
     while ( copy > 0 ) 
     {
         digit = copy % 10;
         sum = sum + Factorial ( digit );
         copy = copy / 10;
     }
     return sum;
 }
 
 int main () 
 {
     int number, digit, sum = 0;
     std::cout << ""Enter a natural number "" << std::endl;
     std::cin >> number;
     int answer = Krishnamurthy_No ( number ); 
 
     //Comparing if calculated sum adds up to the number
 
     if ( answer == number)
     {
         std:: cout << number <<"" is a krishnamurthy number. "";
     }
     else
     {
         std:: cout << number <<"" is not a krishnamurthy number. "";
     }
 }
 
 /*
     Test Case 1 :-
         INPUT : 37 
         OUTPUT : 37 is not a krishnamurthy number.
     Test Case 2 :-
         INPUT : 145
         OUTPUT: 145 is a krishnamurthy number.
         
 */
",C-Plus-Plus
"/**
  * copyright 2020 @author omkarlanghe
  * 
  * @file
  * Given an unsorted array arr[] of size N, rotate it by D elements (clockwise).
  * Input:
  * 
  * The first line of the input contains T denoting the number of testcases. First line of each test case contains two space separated elements, N denoting the size of the array and an integer D denoting the number size of the rotation.
  * Subsequent line will be the N space separated array elements.
  * 
  * Output:
  * For each testcase, in a new line, output the rotated array.
  * 
  * Example:
  * Input:
  * 
  * 2                        where 2 is the total number of test cases.
  * 5 2                      where 5 is the size of array and 2 is the rotation factor for test case 1.
  * 1 2 3 4 5                space seperated integers represting elements of an array for test case 1.
  * 10 3                     where 10 is the size of array and 3 is the rotation factor for test case 2.
  * 1 2 5 3 4 6 7 8 9 10     space seperated integers represting elements of an array for test case 2.
  * 
  * Output:
  * 4 5 1 2 3
  * 8 9 10 1 2 3 4 5 6 7
  * 
  * Timecomplexity: O(n) where n is the size of an array.
 */
 #include <iostream>
 #include <vector>
 
 void right_rotate_array(std::vector<int> *, int, int);
 void rotate_by_one_element(std::vector<int> *, int);
 
 /**
  * Function which performs array rotation by one element based on its given rotation factor.
 */
 void right_rotate_array(std::vector<int> *arr, int size, int rotation_factor) {
     for (int i = 0 ; i < rotation_factor ; i++) {
         rotate_by_one_element(arr, size);
     }
 }
 
 /**
  * Function which shifts array elements by one position to its right.
 */
 void rotate_by_one_element(std::vector<int> *arr, int size) {
     int temp = (*arr)[size - 1];
     for (int i = (size - 2) ; i >= 0 ; i--) {
         (*arr)[i+1] = (*arr)[i];
     }
     (*arr)[0] = temp;
 }
 
 /** Main function */
 int main() {
     int t, size, rotate_factor, input;
   ",C-Plus-Plus
"def nextPermutation(array):
         """"""
         Function for next Permutation
         It rearranges numbers into the lexicographically next greater permutation of numbers.
         If such an arrangement is not possible, it will rearrange it as the lowest possible order (i.e., sorted in ascending order).
         """"""
         length = len(array)
         if length <= 2:
             return array.reverse()
         pointer = length - 2
         
         while pointer >= 0 and array[pointer] >= array[pointer + 1]:
             pointer -= 1
         
         if pointer == -1:
             return array.reverse()
         
         for number in range(length - 1, pointer, -1):
             if array[pointer] < array[number]:
                 array[pointer], array[number] = array[number], array[pointer]
                 break
         
         array[pointer + 1:] = reversed(array[pointer + 1:])
         return array
 
 
 if __name__ == ""__main__"":
     #User input for both the strings
     print('Enter values of the array')
     array = list(map(int, input().rstrip().split()))
     print(nextPermutation(array))
         
 """"""
 Input: numbers = [1,1,5]
 Output: [1,5,1]
 Input: numbers = [3,2,1]
 Output: [1,2,3]
 """"""
",Python
"/*
 Segregate Even and Odd numbers of an Array by using DART.
 
 Given an array of integers, segregate the numbers into two groups of even and
 odd.
 */
 
 import 'dart:io';
 
 void segregate_even_odd(var array, int len) {
   int j = -1;
 
   for (int i = 0; i < len; i++) {
     if (array[i] % 2 == 0) {
       j++;
 
       int temp = array[i];
       array[i] = array[j];
       array[j] = temp;
     }
   }
 }
 
 void main() {
   var data = [];
 
   // taking input from user and storing it in data array
   var n, ele;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     data.add(ele);
   }
 
   print(""\nInputted array is $data"");
   segregate_even_odd(data, n);
   print(""Array after segregating is $data"");
 }
 
 /*
 TIME COMPLEXITY: O(n)
 SPACE COMPLEXITY: O(1)
 
 Enter the number of Elements:
 7
 Enter Element 1: 
 12
 Enter Element 2: 
 3
 Enter Element 3: 
 54
 Enter Element 4: 
 1
 Enter Element 5: 
 11
 Enter Element 6: 
 22
 Enter Element 7: 
 3
 
 Inputted array is [12, 3, 54, 1, 11, 22, 3]
 Array after segregating is [12, 22, 54, 1, 11, 3, 3]
 */
",Dart
"import 'dart:io';
 
 // Function to check if number is Strong
 bool checkStrong(int num) {
   int sum = 0;
   int num_copy = num;
 
   while (num_copy > 0) {
     int digit = num_copy % 10;
     sum += fact(digit);
     num_copy ~/= 10;
   }
   if (sum == num) {
     return true;
   }
   return false;
 }
 
 // Function to calculate factorial of a number
 int fact(int number){
   int result = 1;
   int count = 1;
   while(count <= number){
     result *= count;
     count++;
   }
   return result;
 }
 
 // Main Function with driver code
 void main() {
   print(""Enter a number :"");
   int num = int.parse(stdin.readLineSync()!);
 
   // Call function to check if number is Strong
   if (checkStrong(num)) {
     print(""$num is a Strong Number"");
   } else {
     print(""$num is not a Strong Number"");
   }
 }
 
 /**
 Sample input/output:
 Enter a number :
 145
 145 is a Strong Number
 
 Enter a number :
 234
 234 is not a Strong Number
 */
",Dart
"//C Program to check a number is Happy Number or not.
 #include <stdio.h>
 
 int happy_number(int);
 int main()
 {
 	int n, ans;
 	printf(""Enter a number: "");
 	scanf(""%d"", &n);
 	ans = happy_number(n);
 	if (ans == 1)
 		printf(""%d is a happy number"", n);
 	else
 		printf(""%d is not a happy number"", n);
 	return 0;
 }
 
 // Function to check if the number is a happy number or not
 int happy_number(int n)
 {
 	int temp = n;
 	int sum = 0, digit;
 	while (sum != 1 && sum != 4)
 	{
 		sum = 0;
 		while (temp != 0)
 		{
 			digit = temp % 10;
 			sum += digit * digit;
 			temp = temp / 10;
 		}
 
 		temp = sum;
 
 	}
 
 	return sum;
 }
 
 /*
 Sample Output:
 Enter a number: 32
 32 is a happy number.
 
 Complexities
 Time Complexity:O(logn)
 Space Complexity:O(1)
 */
 
",C
"//C++ program to implement Heap Sort
 
 #include <iostream>
 using namespace std;
 
 //To place the element at idx to its right position
 void Heapify(int arr[],int idx,int size){
 
     int l=2*idx+1;
     int r=2*idx+2;
     int maxx=idx;
     
     if(l<size && arr[l]>arr[maxx])maxx=l;
     if(r<size && arr[r]>arr[maxx])maxx=r;
     swap(arr[maxx],arr[idx]);
     if(maxx!=idx)
     {
         Heapify(arr,maxx,size);
     }
 }
 
 int main()
 {
     cout<<""Enter the size of the array:"";
     int n;
     cin>>n;
     cout<<""Enter elements to be sorted:"";
     int arr[n];
     for(int i=0;i<n;i++)cin>>arr[i];
 
     //For building Heap   
     for(int i=(n-2)/2;i>=0;i--)          
     {
        Heapify(arr,i,n); 
     }
 
     //For extracting the maximum and placing it at the last of unsorted part
     for(int i=n-1;i>=1;i--)
     {
         swap(arr[0],arr[i]);
         Heapify(arr,0,i);
     }
     
     //Printing the array
     for(int i=0;i<n;i++)
     {
         cout<<arr[i]<<"" "";
     }
     return 0;
 }
 
 /*
 Time Complexity - O(nlogn), where 'n' is the size of the array
 Space Complexity - O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 INPUT
 Enter the size of array: 5
 Enter the elements of array: 5 4 3 2 1
 
 OUTPUT
 1 2 3 4 5
 
 */",C-Plus-Plus
"/*
 
 Brain.js is a GPU accelerated library of neural networks written in JavaScript for browsers and Node.js. It is simple, fast and easy to use.
 It provides multiple neural network implementations as different neural nets can be trained to do different things well.
 
 Below is the simple example of neural network with BrainJS.
 
 */
 
 const brain = require(""brain.js""); // the brain JS library
 const prompt = require(""prompt-sync"")({ sigint: true }); // A sync prompt for node.
 const network = new brain.NeuralNetwork(); // Create a neural network
 
 // Train network with sample input & output
 network.train([
   { input: [0, 0, 0], output: [0] },
   { input: [0, 0, 1], output: [0] },
   { input: [0, 1, 1], output: [0] },
   { input: [1, 0, 1], output: [1] },
   { input: [1, 1, 1], output: [1] },
 ]);
 
 let result;
 
 // Take user input
 console.log(""Command-line input any 1/0"");
 let data1 = +prompt("" data1: "");
 checkInput(data1);
 let data2 = +prompt("" data2: "");
 checkInput(data2);
 let data3 = +prompt("" data3: "");
 checkInput(data3);
 
 // Run the neural network over the given input data
 const output = network.run([data1, data2, data3]);
 if (output > 0.85) {
   result = 1;
 } else {
   result = 0;
 }
 
 console.log(`Prob: ${output}`);
 console.log(`Approx Result: ${result}`);
 
 // check for validating user input
 function checkInput(input) {
   if (input !== 0 && input !== 1) {
     console.log("" That's wrong"");
     process.exit(1);
   }
 }
 
 /*
 
 > node neuralNetwork
 
 Command-line input any 1/0
  data1: 0
  data2: 1
  data3: 0
 Prob: 0.050605230033397675
 Approx Result: 0
 
 Command-line input any 1/0
  data1: 1
  data2: 1
  data3: 0
 Prob: 0.913151741027832
 Approx Result: 1
 
 */
 
",JavaScript
"/*
 
 Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
 
 There are two ways of solving this problem -
 1. Brute Force Approach
 2. Optimal Solution
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 // Optimal soltuion
 let twoSumOptimal = function (nums, target) {
   let pairs = [];
   const indicies = {}; // Object to cache elements
 
   for (let i = 0; i < nums.length; i++) {
     const num = nums[i];
 
     // If element is present then add it to the pairs
     if (indicies[target - num]) {
       pairs.push([indicies[target - num], num]);
     }
 
     // Store the element
     indicies[num] = num;
   }
 
   if (pairs.length === 0) console.log(""No match"");
   else console.log(""Optimal Solution - "", pairs);
 
   return pairs;
 };
 
 // Brute force approach
 let twoSumBruteForce = (nums, target) => {
   let pairs = []; // to store all the pairs
 
   // Loop through the elements
   for (let i = 0; i < nums.length; i++) {
     const num = target - nums[i];
 
     for (let j = 0; j < nums.length; j++) {
       if (num === nums[j] && i !== j) {
         pairs.push([nums[i], nums[j]]); // push the match
       }
     }
   }
 
   if (pairs.length === 0) console.log(""No match"");
   else console.log(""Brute Force Solution - "", pairs);
 
   return pairs;
 };
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 
 // Check whether the entered value is number or not
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
 
   // Check whether the entered value is number or not
   if (array.includes(NaN)) return console.log(""Only numbers are allowed"");
 }
 
 // Get the sum target value
 let sumTarget =",JavaScript
"/*
 
 Jump search is a searching algorithm which works similarly to binary search i.e. it works on sorted array.
 Idea - Check fewer elements by jumping a certain number of steps.
 Ex., suppose length of array is 9, then jump search will be jumped by 9 i.e 3 steps.
 Time Complexity : O(n)
 
 */
 
 // Prompt node package for taking user input
 const prompt = require(""prompt-sync"")({ sigint: true });
 
 function jumpSearch(number) {
   // Number of steps to jump
   let jump = Math.floor(Math.sqrt(array.length));
   let start, end;
 
   start = 0;
   end = jump;
 
   // Loop to get the range in which 'number' resides
   while (array[end] <= number && end < array.length) {
     // Upgrade step range
     start = end;
     end = end + jump;
 
     // if end is greater than array of length
     if (end > array.length - 1) {
       end = array.length;
     }
   }
 
   // Start looking through the range
   for (let i = start; i <= end - 1; i++) {
     if (array[i] === number) {
       return console.log(""Found"", array[i]);
     }
   }
 
   return console.log(""Not found"");
 }
 
 /* Workflow of user input */
 
 // Take array length as input
 let arrayLength = +prompt(""Enter array length - "");
 // Check whether the entered value is number or not
 
 if (isNaN(arrayLength)) return console.log(""Only numbers are allowed"");
 
 // Globally declared array 
 let array = [];
 
 // Take array items
 for (let i = 1; i <= arrayLength; i++) {
   array.push(+prompt(`Enter ${i} element - `));
   
   // Check whether the entered value is number or not 
   if (array.includes(NaN)) return console.log(""Only numbers are allowed"");
 }
 
 console.log(""Your array - "", array);
 
 // Sort the given array ( Jump Search works for sorted array only )
 array.sort((a, b) => {
   return a - b;
 });
 
 // Ask the key/number to search in provided array
 let key = +prompt(""Enter number to search - "");
 if (isNaN(key)) return console.log(""It should be a number"");
 
 // Call the algorithm
 jumpSearch(key);",JavaScript
"/*
   A positive integer greater than 1 which has no other
   factors except 1 and the number itself is called a prime number.
   2, 3, 5, 7 etc. are prime numbers as they do not have any other factors.
 */
 import java.util.Scanner;
 public class Prime
 {
   public Prime(int first_range, int second_range)
   {
     for (int i = first_range; i <= second_range; i++)
     {
       int put = 1;
       for (int j = 2; j < i / 2; j++)
       {
         if (i % j == 0)
         {
           put = 0;
           break;
         }
       }
       if (put == 1)
       {
         System.out.println(i);
       }
     }
   }
 public static void main(String[] args)
 {
   Scanner scan = new Scanner(System. in );
   System.out.println(""Please enter range.."");
   int first_range = scan.nextInt();
   int second_range = scan.nextInt();
   Prime out = new Prime(first_range, second_range);
 }
 }
 
 /*
   Time complexity is O(n)
   Space complexity is O(n)
 
   Input :
   Please enter range..
   20
   50
 
   Output:
   23
   29
   31
   37
   41
   43
   47
   */
",Java
"// Here I use recursion to find all permutation of a string.
 // This method is useful for  non repeated character containing string and small length's strings because its time complaxity is in terms of n! .  
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void recursion (string s , int left_index , int right_index){
     if( left_index == right_index ) {
        cout<<s<<""  "";
     }
     // here my approach is to fix a character and find all permutation of next all character 
     // and fixing of characters is done by swaping
     for(int i = left_index ; i <= right_index ; i++) {
         swap(s[left_index] , s[i]) ;
         recursion(s , left_index + 1 , right_index) ; 
         swap(s[left_index] , s[i]) ;  
     }
 }
 
 int main() {
     string S ;
     cin>>S;
     recursion(S , 0 , S.size() - 1 ) ;
 }
 
 /*  Sample input : ab 
     sample output : ab , ba
 
     Test cases
     Input_1:xyz
     Output_1 : xyz  xzy  yxz  yzx  zyx  zxy
 
     Input_2 : abcde
     Output_2 :abcde  abced  abdce  abdec  abedc  abecd  acbde  acbed  acdbe  acdeb  acedb  
               acebd  adcbe  adceb  adbce  adbec  adebc  adecb  aecdb  aecbd  aedcb  aedbc  
               aebdc  aebcd  bacde  baced  badce  badec  baedc  baecd  bcade  bcaed  bcdae  
               bcdea  bceda  bcead  bdcae  bdcea  bdace  bdaec  bdeac  bdeca  becda  becad  
               bedca  bedac  beadc  beacd  cbade  cbaed  cbdae  cbdea  cbeda  cbead  cabde  
               cabed  cadbe  cadeb  caedb  caebd  cdabe  cdaeb  cdbae  cdbea  cdeba  cdeab  
               ceadb  ceabd  cedab  cedba  cebda  cebad  dbcae  dbcea  dbace  dbaec  dbeac  
               dbeca  dcbae  dcbea  dcabe  dcaeb  dceab  dceba  dacbe  daceb  dabce  dabec  
               daebc  daecb  decab  decba  deacb  deabc  debac  debca  ebcda  ebcad  ebdca  
               ebdac  ebadc  ebacd  ecbda  ecbad  ecdba  ecdab  ecadb  ecabd  edcba  edcab  
               edbca  edbac  edabc  edacb  eacdb  eacbd  eadcb  eadbc  eabdc  eabcd ",C-Plus-Plus
"/*Find the pair of adjacent elements that have the largest product   
  in a given array and return that product.
  
  Example: Let a={3, 6, -2, -5, 7, 3} be an array, then adjacent
  elements at position 4 & 5 i.e. 7 & 3 in the given array
  have the maximum product among adjacent elements = 21.
  Hence, the method will return 21.
  */
 
 import java.util.*;
 
 public class AdjacentElementProduct {
     //method to find largest adjacent elements product
     public static int largest_product(int[] arr) {
         /*let the initial max_prod be product of first two elements &
          then go on comparing it with the next adjacent element's products.
          If it is more then current max_prod value, update max_prod value. 
          */
         int max_product = arr[0] * arr[1];
         for (int i = 0; i < arr.length - 1; i++) {
             if (arr[i] * arr[i + 1] > max_product) {
                 max_product = arr[i] * arr[i + 1];
             }
         }
         return max_product;
     }
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
 
         System.out.print(""Enter size of the array : "");
         int n = sc.nextInt();
 
         int[] a = new int[n];
         System.out.print(""Enter array elements : "");
         for (int i = 0; i < n; i++) {
             a[i] = sc.nextInt();
         }
 
         System.out.print(""Largest adjacent elements product is : "" 
                          +largest_product(a));
     }
 }
 
 /*SAMPLE TEST CASE:
 Enter size of the array : 10
 Enter array elements : 2 -9 30 4 -8 10 11 7 -61 100
 Largest adjacent elements product is : 120
 
 Time Complexity : O(n)
 Space Complexity : O(n)
 */
",Java
"
 // Java program to implement Queue using two stacks with costly enQueue()  
 import java.util.*; 
   
 class QueuetoStack  
 {  
 static class Queue  
 {  
     static Stack<Integer> stk1 = new Stack<Integer>();  
     static Stack<Integer> stk2 = new Stack<Integer>();  
   
     static void enQueue(int x)  
     {  
         // Move all elements from stk1 to stk2  
         while (!stk1.isEmpty()) 
         {  
             stk2.push(stk1.pop());  
             //stk1.pop();  
         }  
   
         // Push item into stk1  
         stk1.push(x);  
   
         // Push everything back to stk1  
         while (!stk2.isEmpty())  
         {  
             stk1.push(stk2.pop());  
             //stk2.pop();  
         }  
     }  
   
     // Dequeue an item from the queue  
     static int deQueue()  
     {  
         // if first stack is empty  
         if (stk1.isEmpty())  
         {  
             System.out.println(""Q is Empty"");  
             System.exit(0);  
         }  
   
         // Return top of stk1  
         int s = stk1.peek();  
         stk1.pop();  
         return s;  
     }  
 };  
   
 // Main method 
 public static void main(String[] args)  
 {  
     Scanner sc = new Scanner(System.in);
     System.out.println(""Enter limit"");
     int n = sc.nextInt();
     Queue qu = new Queue();
     for(int i = 1; i <= n; i++)
        qu.enQueue(i);  
     for(int i = 1; i <= n; i++)
        System.out.println(qu.deQueue());  
     
 }  
 }
 
 
 /* Time Complexity:
   1) Push operation: O(N).
   2) Pop operation: O(1).
 
 Space Complexity: O(N).
 
 Input:
 10
 
 Output:
 1
 2
 3
 4
 5
 6
 7
 8
 9
 10
 */
",Java
"# Julia program to implement Selection sort
 
 function selection_sort(arr, n)
     for i in 1:n
         # Let the first element in this iteration be the minimum value
         min = i
         # Find the least element in the concerned part of the array
         for j in (i + 1):n
             if arr[min] > arr[j]
                 min = j
             end
         end
         # Swap the least element with the beginning of the concerned part of the array
         arr[i], arr[min] = arr[min], arr[i]
     end
 end
 
 
 
 print(""How many numbers do you want to sort? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""No numbers to sort!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 selection_sort(arr, n)
 print(""The numbers in sorted order is "")
 print(arr)
 
 
 
 """"""
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 How many numbers do you want to sort? 5
 Enter the numbers: 4 2 5 1 3
 The numbers in sorted order is [1, 2, 3, 4, 5]
 
 """"""
",Julia
"/**
 To find the Longest Common Subsequence of two
 strings using Bottom Up approach such that 
 we can change atmost K characters
 to increase the size of LCS.
 */
 
 import java.util.Scanner;
 
 public class KOrderedLCS {
     
 	private static void kOrderedLcsBottomUp(String a, String b, int k) {
 
 		int[][][] dp = new int[k + 1][a.length() + 1][b.length() + 1];
 
 		// for loop will start from last index of each string
 		// in case any of the three strings is empty then
 		// answer will be 0.
 		for (int i = 0; i <= k; i++) {
 			for (int j = a.length()-1; j >= 0; j--) {
 				for (int l = b.length()-1; l >= 0; l--) {
 
 					if (a.charAt(j) == b.charAt(l)) {
 						dp[i][j][l] = 1 + dp[i][j + 1][l + 1];
 						
 					} else {
 						int x = dp[i][j + 1][l];
 						int y = dp[i][j][l + 1];
 						int z = 0;
 						
 						// check if we can still convert a character
 						// to make it a part og LCS.
 						if (i > 0) {
 							z = 1 + dp[i - 1][j + 1][l + 1];
 						}
 
 						dp[i][j][l] = Math.max(x, Math.max(y, z));
 					}
 				}
 			}
 		}
 		System.out.println(""Length of Longest Common Subsequence - "" + dp[k][0][0]);
 	}
 
 	public static void main(String[] args) {
 
 		Scanner sc = new Scanner(System.in);
 
 		System.out.print(""Enter String A - "");
 		String a = sc.next();
 		System.out.print(""Enter String B - "");
 		String b = sc.next();
 		System.out.print(""Enter value of K - "");
 		int k = sc.nextInt();
 
 		kOrderedLcsBottomUp(a, b, k);
 	}
 }
 
 /**
 Time Complexity  : O(A*B*K)
 Space Complexity : O(A*B*K)
 
 Input:
 
 Enter String A - abcdefgh
 Enter String B - acjdfih
 Enter value of K - 2
 
 Output:
 
 Length of Longest Common Subsequence - 6
 
 */
",Java
"/*
 Sentinel Search implementation in Dart
 In this search, the last element of the array is replaced with the 
 element to be searched and then the linear search is performed on the array. 
 */
 
 import 'dart:io';
 
 bool Sentinel_Search(List arr, int n, int val) {
   // Storing the last element and replacing it with the value to be searched
   int last_ele = arr[n - 1];
   arr[n - 1] = val;
 
   int i = 0;
   // Iterating over the list until we find the value to be searched
   while (arr[i] != val) {
     i += 1;
   }
 
   // Replacing the last element of list
   arr[n - 1] = last_ele;
 
   if (i < (n - 1) || arr[n - 1] == val) {
     return true;
   }
   return false;
 }
 
 main() {
   var array = [];
 
   var n, ele, key;
   print('Enter the number of elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter value for element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     array.add(ele);
   }
 
   print('Enter the element to be searched: ');
   key = stdin.readLineSync();
   key = int.parse(key);
 
   bool status = Sentinel_Search(array, n, key);
   if (status) {
     print('Element is present in array');
   } else {
     print('Element is not present in array');
   }
 }
 
 /*
 
 TIME COMPLEXITY: O(n)
 
 SPACE COMPLEXITY: O(1)
 
 
 Enter the number of elements: 
 6
 Enter value for element 1: 
 12
 Enter value for element 2: 
 43
 Enter value for element 3: 
 33
 Enter value for element 4: 
 56
 Enter value for element 5: 
 12
 Enter value for element 6: 
 90
 Enter the element to be searched: 
 43
 Element is present in array
 
 */
",Dart
"#= Finding the Greatest Common Divisor of 2 numbers using the Euclidean
 Formula to lessen the time complexity.
 =#
 
 ## Function
 
 function GCD(a, b)
     if (a == 0)
         return b
     end
     if (b == 0)
         return a
     end
     if (a < b)
         a, b = b, a
     end
     ans = a % b
     while (ans != 0)
         a = b
         b = ans
         ans = a % b
     end
     return b
 end
 
 ## Input
 
 a = readline()
 a = parse(Int64, a)
 b = readline()
 b = parse(Int64, b)
 
 ## Calling the function
 
 GCD(a, b)
 
 #=
 Sample Test case:
 Input: 
     a = 1001  b = 2352
 Output:
     7
 Time complexity: O( log (min(a,b)) )
 =#
",Julia
"/*
 Given an array of N elements.
 Find MEX ( Minimum Excluded Element ) of input array.
 Mex of an array is the minimum positive integer that doesn't appear in this array.
 For example, MEX of the array containing 1, 3 and 4 is equal to 2.
 */
 
 import java.util.Scanner;
 import java.lang.*;
 
 public class MEXofanarray
 {
     // this get_MEX_of_array function will give us MEX of input array
     static int get_MEX_of_array(int ar[],int N)
     {
         /* we will use a visited_array[]
         check if visited_array[ar[i]] == 0 means
         ar[i] is visited or not if is not visited then we will increment it
         visited_array[ar[i]]++  */
         int visited_array[] = new int[N + 1];
     
         for(int i = 0; i < N; i++)
         {
              if(visited_array[ar[i]] == 0)
              {
                  visited_array[ar[i]]++;
              }
          }
 
          /* set MEX as 1
          then will start from 1 index and check if visited_array[i] == 0
          means that element is not present in array , hence that is the MEX
          */
          int MEX = 1;
          for(int i = 1; i < N; i++)
          {
              if(visited_array[i] == 0)
              {
                 MEX = i;
                 break;
              }
         }
         return MEX;
      }
 
 	public static void main(String args[]) 
 	{
 	   Scanner scan = new Scanner(System.in);
 	   System.out.print(""Enter the size of array \n"");
      	   int number = scan.nextInt();
 
 	   int[] ar = new int[number];
 	   System.out.println(""Enter array elements \n""); 
 	   for(int i = 0; i < number; i++)
 	   {
 	       ar[i] = scan.nextInt();
 	   }
 	   scan.close();
 	   int MEX_of_array = get_MEX_of_array(ar , N);
 	   System.out.println(""MEX of the Array is :\n""); 
            System.out.println(MEX_of_array);
 	}
 }
 /*
 Standard Input and Output
 
 Enter the size of the array :
 8
 Enter array elements :
 8 2 7 4 6 2 1 4
 
 MEX of the Array is :
 3
 
 Time Complexity",Java
"/*
 Two positive integers A and B are given. Find the number of pairs 
 of positive integers (X,Y) such that 1=X=A, 1=Y=B and X+Y is even.
 Input
 The first line of the input contains a single integer T denoting the
 number of test cases.The description of T test cases follows.
 The first and only line of each test case contains two space-separated 
 integers A and B.
 Output
 For each test case, print a single line containing one integer-the number
 of valid pairs.
 */
 #include<iostream>
 #include<algorithm>
 using namespace std;
 
 int main(){
     ios_base::sync_with_stdio(false);
     cin.tie(NULL);
     //t=test case
     int t; 
     cin>>t;
     while(t--)
          {
 	    long long c,d;
 	    long long ans=0;
 	    cin>>c>>d;
 	    long long a=min(c,d);
 	    long long b=max(c,d);
 	    if(a%2==0)
 	    {
 	        if(b%2==0)
 	        {
 	            ans=2*(a/2)*(b/2);
 	            cout<<ans<<endl;
 	            continue;
 	        }
 	        else
 	        {
 	            long long x=(a/2)*(b/2),y=(a/2)*((b/2)+1);
 	            cout<<x+y<<endl;
 	            continue;
 	            
 	        }
 	    }
 	    else
 	    {
 	       if(b%2==0)
 	        {
 	            long long x=(a/2)*(b/2),y=((a/2)+1)*(b/2);
 	            cout<<x+y<<endl;
 	            continue;
 	        }
 	        else
 	        {
 	            
 	            long long x=(a/2)*(b/2),y=((a/2)+1)*((b/2)+1);
 	            cout<<x+y<<endl;
 	            continue;
 	        } 
 	    }	    
 	}
 	
 	return 0;
 }
 /*
 Example Input
 4
 1 1
 2 3
 4 6
 8 9
 Example Output
 1
 3
 12
 36
 
 time complexity- O(t)
 //t is no. of test cases
 */
",C-Plus-Plus
"//SIMPLE COLUMNAR MULTIPLE ROUNDS TRANSPOSITION TECHNIQUE
 /* It is a type of transposition cipher technique which encrypts the plain text 
 message into a cipher text by rearranging the characters of the 
 plain text. The plain text is written row-wise and read column-wise.
 This procedure is chained and carried out k times. */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 string encrypt(string s,vector<int> &order) {
 	
 	float n = s.length();
 	int row = ceil(n/5),col = 5;
 	char arr[row][col];
 	for(int i = 0;i < row; ++i) {
 		for(int j = 0;j < col; ++j) {
 			if((i * col + j) >= s.length()) {
 				//1 is the bogus character  
 				arr[i][j] = '1' ;
 			}
 			else
 				arr[i][j] = s[i*col+j];
 		}
 	}
 	string encString = """";
 	for(int i = 0;i < col; ++i) {
 		for(int j = 0;j < row; ++j) {
 			encString += arr[j][order[i]];
 		}
 	}
 	return encString;
 }
 
 int main() {
 	
 	string s;
 	cout<<""Enter the plain text: ""; 
 	cin>>s;
 	int rounds;
 	cout<<""Enter the number of rounds: "";
 	cin>>rounds;
 	
 	vector<int>order(5);
 	//For example order of repositioning columns could be 1 0 2 3 4
 	cout<<""Enter the order of repositioning columns: "";  
 	for(int i = 0;i < 5;i++) {
 		cin>>order[i];
 	}
 
 	//Multiple Rounds
 	for(int i = 0;i < rounds; ++i) {
 		s = encrypt(s,order);
 	}
 	cout<<s;
 	
 }
 
 /*
 Example:
 Plain Text: TESSERACTCODING
 No. of rounds: 3
 Order of Columns: 2 3 0 1 4
 Cipher Text: ENTSAEICTRSDOCG
 
 Plain Text: NEOALGO
 Order of Columns: 3 0 1 4 2
 Cipher Text: LAOEN1O1G1
 
 Time Complexity: O(n*k)
 Space Complexity: O(1)
 */
",C-Plus-Plus
"import java.util.*;
 public class Factorial_large_numbers
 {
     public static int len = 0;
     public static int[] Factorial(int n, int[] arr, int[] str2){
         int temp = 0, carry = 0, i=0;
         for(i=0; i<len; i++){
             temp = str2[i]*n + carry;
             carry = temp/10;
             arr[i] = temp%10;
         }
         while(carry!=0){
             arr[i] = carry%10;
             carry = carry/10;
             len+=1;
             i+=1;
         }
         return arr;
     }
 	public static void main(String[] args) {
 	    Scanner sc = new Scanner(System.in);
 	    System.out.print(""Enter number : "");
 	    int num = sc.nextInt();
 	    String str = String.valueOf(num);
 	    len = str.length();
 	    int[] arr = new int[300];
 	    int[] str2 = new int[300];
 	    int i=0, temp=num;
 	    for(i=0; i<len; i++){
 	        str2[i] = temp%10;
 	        temp=temp/10;
 	    }
 	    for(int j=1; j<num; j++){
     	    str2 = Factorial(j, arr, str2);
 	    }
 	    System.out.print(""Factorial of ""+num+"" = "");
         for(i=len-1; i>=0; i--){
             System.out.print(str2[i]);
         }
 	}
 }
 
 /*
 Sample input and output
 Enter number : 10
 Factorial of 10 = 3628800
 
 Complexities
 time: O(n^2)
 space: O(n)
 */",Java
"const removeOuterParenthesis = (str) => {
 
   // breaking the string into an array of characters
   let strArr = str.split('');
   let stack=[];
 
   // looping the array to check the characters
   for(let i = 0; i < strArr.length; i++){
 
     // we store the index if the character is an opening parenthesis
     if(strArr[i] == '(') {
       stack.push(i);
     } else {
       // removing the elements of stack
       let ele = stack.pop();
 
       // this checks if we have reached the outermost
       // closing parenthesis
       if(!stack.length){
         // replace the outermost characters with 0
         strArr[i] = '0';
         strArr[ele] = '0';
       }
     }
   }
   // return the string after removing the 0's and joining the characters
   return strArr.filter(x=>x!='0').join('');
 }
 
 console.log(removeOuterParenthesis(""(()())(())""));
 console.log(removeOuterParenthesis(""(()())(())(()(()))""));
 
 /**
  * Output for the above inputs:
  * ()()()
  * ()()()()(())
  * 
  * Time complexity: O(n)
  * Space complexity: O(n)
  */
",JavaScript
"/*
  * A generalised Cullen Number is defined as a number in the form:
  * 
  *             (k x b^k) + 1   with   k + 2 > b
  *             where b is the base
  * 
  * This program gives the user the first n cullen numbers of base b.
  */
 
 import java.util.*;
 
 public class cullen_number
 {
     void main()
     {
         Scanner scanner = new Scanner(System.in);
         
         System.out.println(""Enter base b: "");
         int b = scanner.nextInt(); 
         scanner.nextLine();
         
         System.out.println(""Enter number of terms n: "");
         int n = scanner.nextInt(); 
         scanner.nextLine();
         
         int k = b-1,count = 0;
         
         System.out.println(""First ""+n+"" cullen numbers with base ""+b+"" are: "");
         while(count<n)
         {
             System.out.print(cullen(k,b)+"", "");
             k++;
             count++;
         }
     }
     
     int cullen(int k, int b)
     {
         //this function the (count)th cullen number
         return (int)(k * Math.pow(b,k))+1;
     }
 }
         
 /*
  * Test Case-
  * 
  * Enter base b: 
  * 3
  * Enter number of terms n: 
  * 5
  * First 5 cullen numbers with base 3 are: 
  * 19, 82, 325, 1216, 4375, 
  * 
  * Time Complexity: O(n)
  * where n is the number of terms extracted.
  * Space Complexity: O(n)
  */            ",Java
""""""" Length of Longest Common Substring problem in Python
 
 Given two strings, we have to find the length of the longest common substring in Python
 
 The problem can be solved using Dynamic Programming
 """"""
 
 
 def lengthoflongestcommonsubstring(S1, S2):
     # Build a 2D matrix in Bottom-Up manner. Every element
     # dp[i][j] contains the length of the longest common substring
     # of S1[0 .. i] and S2[0 .. j].
     n = len(S1)
     m = len(S2)
     ans = 0
     # Fill every element of the 2D matrix with 0 as value
     dp = [[0 for i in range(m+1)] for j in range(n+1)]
 
     for i in range(0, n + 1):
         for j in range(0, m + 1):
 
             # length of LCS when one of the string is empty is zero
             if 0 in (i, j):
                 dp[i][j] = 0
 
             # If the elements of both the strings match, then
             # the value of LCS increments by one.
             # Also Check if the value of lcs has reached the max till now.
             elif S1[i-1] == S2[j-1]:
                 dp[i][j] = dp[i - 1][j - 1] + 1
                 ans = max(ans, dp[i][j])
             else:
                 dp[i][j] = 0
     return ans
 
 
 if __name__ == '__main__':
     s1 = input(""Enter the first string: "")
     s2 = input(""Enter the second string: "")
     res = lengthoflongestcommonsubstring(s1, s2)
     print(""The length of the longest common substring is "" + str(res))
 
 
 # Time Complexity: O(n * m), where n, m are the size of the given strings
 # Space Complexity: O(n * m)
 
 # SAMPLE INPUT AND OUTPUT
 
 # Enter the first string: runner
 # Enter the second string: run
 # The length of the longest common substring is 3
",Python
"#include <bits/stdc++.h>
 using namespace std;
 
 int max_sum_subarray(int a[], int n){
 
     int max_ending=a[0];
 
     int ans=a[0];
 
     for(int i=1;i<n;i++)
     {
         max_ending=max(max_ending+a[i], a[i]);
         ans=max(ans,max_ending);
     }
 
     return ans;
 
 }
 
 int main() {
     int n;
     cin>>n;
 
     int a[n];
     for(int i=0;i<n;i++)
         cin>>a[i];
 
     cout<<max_sum_subarray(a,n);
     
 }
",C-Plus-Plus
"/**
  * @author omkarlanghe : https://github.com/omkarlanghe
  * A program to demostrate basic working of a data structure called Hashing.
  * This program supports seperate chaining method to avoid collision between hash indexes.
 */
 #include <iostream>
 #include <list>
 
 class HashTable {
  private:
     int BUCKET;
     std::list<int> *table = nullptr;
 
  public:
         HashTable(int v);
         void insert_item(int x);
         void delete_item(int key);
         int hash_function(int data) { return (data % BUCKET); }
         void display_hash_table();
 };
 
 /** constructor function which initialized hash table */
 HashTable::HashTable(int b) {
     this->BUCKET = b;
     table = new std::list<int>[BUCKET];
 }
 
 /** function to insert item in a hash table */
 void HashTable::insert_item(int key) {
     int index = hash_function(key);
     table[index].push_back(key);
 }
 
 /** function to delete item from a hash table */
 void HashTable::delete_item(int key) {
     int index = hash_function(key);
     std::list<int>::iterator it;
     for (it = table[index].begin() ; it != table[index].end() ; it++) {
         if (*it == key) {
             break;
         }
     }
 
     if (it != table[index].end()) {
         table[index].erase(it);
     }
 }
 
 /** function to display all the elements from hash table */
 void HashTable::display_hash_table() {
     for (int i = 0 ; i < BUCKET; i++) {
         std::cout << i;
         for (auto x : table[i]) {
             std::cout << "" :: "" << x;
         }
         std::cout << std::endl;
     }
 }
 
 /** main function */
 int main() {
     int size, x;
     std::cout << ""Enter the size : "" << std::endl;
     std::cin >> size;
 
     HashTable hash(size);
 
     std::cout << ""Enter the elements in hash table : "" << std::endl;
     for  (int i = 0 ; i < size ; i++) {
         std::cin >> x;
         hash.insert_item(x);
     }
 
     std::cout << ""Display before deletion : "" << std::endl;
     hash.display_hash_tabl",C-Plus-Plus
"// Given an array and an integer k, find the maximum for each and every contiguous subarray of size k.
 // https://www.spoj.com/problems/ARRAYSUB/
 
 #include<iostream>
 #include <deque>
 using namespace std;
 
 int main() {
 	//Taking Input From The User.
 	int n;
 	cout << ""Enter The value of N:\n"";
 	cin >> n; //Size of Array
 	int array[n];
 	cout << ""Enter the elements of array:\n"";
 	for (int i = 0; i < n; ++i) {
 		cin >> array[i];
 	}
 	int k;
 	cout << ""Enter the value of k:\n"";
 	cin >> k; //Size Of The Sliding Window
 
 	deque<int> d(k);//Created data Structure Deque Of Size k
 	cout << ""Maximum Numbers in sliding window of size "" << k << "" are:\n"";
 	for (int i = 0; i < n; i++) {
 		if (i >= k) {
 			cout << array[d.front()] << "" "";
 			//Checking whether a given number is in sliding window or not.
 			//If it is not then pop the front element.
 			while (!d.empty() && d.front() <= i - k) {
 				d.pop_front();
 			}
 		}
 		//If the given number is greater than number at last then we pop it.
 		while (!d.empty() && array[i] >= array[d.back()]) {
 			d.pop_back();
 		}
 		d.push_back(i);
 	}
 	cout << array[d.front()];
 }
 
 /*
 Time Complexity : O(N*Log2(N))
 Sample I/O:
 INPUT :
 Enter The value of N:
 9
 Enter the elements of array:
 1 2 3 1 4 5 2 3 6
 Enter the value of k:
 3
 
 OUTPUT:
 Maximum Numbers in sliding window of size 3 are:
 3 3 4 5 5 5 6
 */
",C-Plus-Plus
"/*Tries are tree based structures used for efficient 
 retrieval of key form huge set of strings.
 
 This is a basic implementation of Trie in which strings are inserted and 
 then there are some queries to find if strings are present in trie or not.
 
 Time Complexity for insert and find function: 
 O(l) where l is the length of word. 
 Space complexity: O(n*m) where n is number of keys 
 and m=max(l) i.e max length of input strings.*/
 
 #include<bits/stdc++.h>
 using namespace std;
 //Trie Node
 class Node{
 public:
 	char data;
 	//to store children of node
 	unordered_map<char,Node*> children;
 	bool terminal;
 	Node(char d){
 		data=d;
 		terminal=false;
 	}
 };
 
 class Trie{
 Node*root;
 public:
 	Trie(){
 		root=new Node('\0');
 	}
 	//to insert strings in Trie
 	void insert(string w){
 		Node*temp=root;
 		for(int i=0;w[i]!='\0';i++){
 			char ch=w[i];
 			if(temp->children.count(ch)){
 				temp=temp->children[ch];
 			}
 			else{
 				Node*n=new Node(ch);
 				temp->children[ch]=n;
 				temp=n;
 			}
 		}
 		temp->terminal=true;
 	}
 	//To find if string is present or not
 	bool find(string w){
 		Node*temp=root;
 		for(int i=0;w[i]!='\0';i++){
 			char ch=w[i];
 			if(temp->children.count(ch)==0){
 				return false;
 			}
 			else{
 				temp=temp->children[ch];
 			}
 		}
 		return temp->terminal;
 	}
 	//to delete a string from trie
 	void deletion(string w){
 		Node*temp=root;
 		for(int i=0;w[i]!='\0';i++){
 			char ch=w[i];
 			if(temp->children.count(ch)==0){
 				return;
 			}
 			else{
 				temp=temp->children[ch];
 			}
 		}
 		temp->terminal=false;
 	}
 };
 
 int main(){
     //initialize trie
 	Trie T;
 	cout<<""Enter number of strings:""<<endl;
 	int n;
 	cin>>n;
 	string*arr=new string[n];
 	cout<<""Enter the strings:""<<endl;
 	for(int i=0;i<n;i++){
 		cin>>arr[i];
 		T.insert(arr[i]);
 	}
 	cout<<""Enter number of queries to find if strings are present or not""<<endl;
 	int q;
 	cin>>q;
 	cout<<""Enter a string for each query:""<<endl;
 	while(q--)",C-Plus-Plus
"'''
 The longest bitonic subsequence is a sequence in which the sequence is first increasing then decreasing ,
 The below program finds the length of the longest bitonic subsequence.
 '''
 
 def longest_bitonic_subsequence(v,n):
     v_increase = []
     for i in range(n+1):
         v_increase.append(1)
     for i in range(n):
         for j in range(i):
             if(v[i] > v[j]):
                 if(v_increase[i] <= v_increase[j]):
                     v_increase[i] = v_increase[j] + 1
 
     v_decrease = []
     for i in range(n+1):
         v_decrease.append(1)
 
     for i in range(n-2,-1,-1):
         for j in range(n-1,i,-1):
             if(v[i] > v[j]):
                 if(v_decrease[i] <= v_decrease[j]):
                     v_decrease[i] = v_decrease[j] + 1
     max = 0
     for i in range(n):
         temp = v_decrease[i] + v_increase[i] -1
         if(temp > max):
             max = temp
     return max
 
 
 if __name__ == '__main__':
     n = int(input(""Enter the number of elements in the sequence : ""))
     print(""Enter the elements of the sequence"")
     v = list(map(int, input().split(' ')))
     print(""The length of longest bitonic subsequence is : "" + str(longest_bitonic_subsequence(v, n)))
 
 
 
 '''
 Sample I/O:
 
 Enter the number of elements in the sequence : 10
 Enter the elements of the sequence
 1 2 6 3 12 14 4 9 10 7
 The length of longest bitonic subsequence is : 7
 
 Time Complexity : O(n^2) 
 Space Complexity : O(n)
 '''",Python
"""""""
 Python Program to check whether a number is Palindrome or not
 An integer is a palindrome if the reverse of that number is equal to the original number.
 Example of Palindromes are 11,44,101,121.
 	
 """"""
 	
 def palindrome(n):
     temp = n
     sum = 0
     remainder = 0
     while n > 0:
         remainder = n % 10
         sum = sum * 10 + remainder
         n = n // 10
     if sum == temp:
         print (temp, 'is a palindrome')
     else:
         print (temp, 'is not a palindrome')
 if __name__ == '__main__':        
     n = eval(input('Enter No '))
     palindrome(n)
 	
 """"""
 Sample Case:
 Example 1:
 Enter a number: 121
 121 is a palindrome
 	
 Example 2:
 Enter a number: 123
 123 is not a palindrome
 	
 Time Complexity: O(n)
 Space Complexity: O(1)
 
 """"""
",Python
"/*
 given the starting and the end time of few meeting to be held. our goal is to find the minimum number of meeting rooms required to conducy all the meetings successfully.
 in brief we have to find the maximum number of meetings being help simultaneously.
 */
 #include<bits/stdc++.h>
 using namespace std;
 
 class meetings{
 public://access specifier since all the members of a class are by default private
 int meetingrooms(vector<vector<int>>& intervals)
 {
   //we'll be considering the start and the end times of all the meetings.
   vector<int> start_time,end_time;
  for(auto vec: intervals)
  {
    start_time.push_back(vec[0]);
    end_time.push_back(vec[1]);
  }
  sort(start_time.begin(),start_time.end());
  sort(end_time.begin(),end_time.end());
 
  int start=0, end=0;
  int parallel=0;
  int max_parallel=0;
 
  for(auto i=0;i<intervals.size();i++)
  {
    if(start_time[start]>=end_time[end])
    {
      parallel--;
      end++;
    }
    parallel++;
    start++;
 
    max_parallel=max(max_parallel,parallel);
  }
  return max_parallel;
  cout<<""\n"";
 }
 
 };
 
 /*
  Time Complexity : O(N)
  Space Complexity : O(N)
 */
 /*
 input1:
 [[0,30],[5,10],[15,20]]
 output1 : 2
 
 input2: [[7,10],[2,4]]
 output2: 1
 
 */",C-Plus-Plus
"'''
 Activity Selection Problem :
 Given ""row"" number of activities with start and end time,
 select activities in such manner that we can perform maximum
 number of activities among them. Note, activities are not sorted.
 Approach used is greedy, sorting the activities according to their
 end time and then comparing it with start time of next one.
 If start time is greater than or equal to the previous activity
 end time then it can be completed and hence added in the solution matrix.
 '''
 
 
 def final_activities():
     row = int(input(""Enter the number of rows: ""))
     # 2d list is used to enter the start and end time of jobs
     Activity = []
     print(""Enter elements of matrix row wise:"")
     for x in range(row):
         print(""Elements of row"", end = "" "")
         print(x)
         arr = []
         for _ in range(0, 2):
             arr.append(int(input()))
         Activity.append(arr)
     # sorting the 2d list according to the second key
     Activity.sort(key=lambda sec: sec[1])
 
     ptr = 0
     # matrix for activities selceted
     activity_selected = []
     # initial activity is always selected
     activity_selected.append(Activity[ptr])
 
     # If the starting time of next activity is greater than/equal
     # to the end time of previous, then it will be selected
     for itr in range(1, row):
         if Activity[ptr][1] <= Activity[itr][0]:
             activity_selected.append(Activity[itr])
             ptr = itr
     # printing the selected activities
     print(""Following activities are selected :"")
     print(activity_selected)
 
 
 if __name__ == ""__main__"":
     final_activities()
 
 
 '''
 Sample Input:
 Enter the number of rows: 
 4
 Enter elements of matrix row wise:
 Elements of row 0
 1
 2
 Elements of row 1
 2
 4
 Elements of row 2
 3
 5
 Elements of row 3
 4
 6
 
 Sample Output:
 Following activities are selected :
 [[1, 2], [2, 4], [4, 6]]
 
 Time Complexity: O(nlogn), n = row, for sorting the list
 Space Complexity: O(2*n",Python
"/*
 BEST FIT MEMORY ALLOCATION
 Available memory blocks are accepted as input from the user
 This strategy will continue searching for a block whose 
 size is closest to the requested block size. Pointer to 
 the block is returned after retaining residual space
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //structure to represent memoryblock with id and size
 typedef struct MemoryBlock
 {
     int id;
     int size;
 } MemoryBlock;
 
 //to print the id of allocated memory block
 void print_block(MemoryBlock block)
 {
     if (block.id != -1 && block.size != -1 && block.size != 0)
         printf(""Block #%d \n"", block.id);
     else
         printf(""Invalid Memory Block\n"");
 }
 
 //linked list to store memory blocks
 typedef struct MemoryManager
 {
     MemoryBlock b;
     struct MemoryManager *llink, *rlink;
 } MemoryManager;
 
 //best fit memory allocation
 MemoryBlock best_fit(MemoryManager *m, int memory)
 {
     MemoryBlock bl;
     //if the list is empty
     if (m == NULL)
     {
         bl.id = -1;
         bl.size = -1;
     }
     else
     {
         MemoryManager *ptr = m, *ptr1, *ptr2, *p;
         MemoryBlock best;
         best.id = -1;
         best.size = -1;
         int count = 0;
         //to find the most suitable memory block
         while (ptr->rlink != NULL)
         {
             if (count == 0)
             {
                 if (ptr->b.size >= memory)
                 {
                     best.id = ptr->b.id;
                     best.size = ptr->b.size;
                     count = 1;
                 }
             }
             else
             {
                 if (ptr->b.size >= memory && ptr->b.size < best.size)
                 {
                     best.id = ptr->b.id;
                     best.size = ptr->b.size;
                 }
             }
             ptr = ptr->rlink;
         }
         best.size = memory;
         bl = best;
         ptr = m;
         //to remove the memory allocated from the block",C-Plus-Plus
"#include<bits/stdc++.h>
 using namespace std;
 void floyd_warshall(int arr[][5]) {
 	int i, j, k;
 	//Add all vertex one by one
 	for (k = 0; k < 5; k++) {
 		//pick all as a source
 		for (i = 0; i < 5; i++) {
 			//pick all as a destination
 			for (j = 0; j < 5; j++) {
 				if ((arr[i][k] * arr[k][j] != 0) && (i != j)) {
 					//If vertex k is on the shortest path from
 					// i to j, then update the value of arr[i][j]
 					if ((arr[i][k] + arr[k][j] < arr[i][j]) || (arr[i][j] == 0)) {
 						arr[i][j] = arr[i][k] + arr[k][j];
 					}
 				}
 			}
 		}
 	}
 	//function to print solution
 	cout << ""\nOUTPUT"" << endl;
 	for (i = 0; i < 5; i++) {
 		cout << ""\nMinimum Cost for Node: "" << i << endl;
 		for (j = 0; j < 5; j++) {
 			cout << arr[i][j] << ""\t"";
 		}
 	}
 }
 //Main function began
 int main() {
 	int a[5][5];
 	//Enter values
 	cout << ""Enter values for matrix-\n\n"";
 	for (int i = 0; i < 5; i++) {
 		cout << ""Enter values for "" << (i + 1) << "" row :"" << endl;
 		for (int j = 0; j < 5; j++) {
 			cin >> a[i][j];
 		}
 	}
 	// call the floyd function
 	floyd_waeshall(a);
 }
 //main function ends
 
 /*
 Sample Input Output:
 Enter values for matrix-
 
 Enter values for 1 row :
 0
 3
 6
 0
 0
 Enter values for 2 row :
 3
 0
 2
 4
 0
 Enter values for 3 row :
 6
 2
 0
 1
 4
 Enter values for 4 row :
 0
 4
 1
 0
 2
 Enter values for 5 row :
 0
 0
 4
 2
 0
 
 OUTPUT:
 Minimum Cost for Node: 0
 0	3	5	6	8
 Minimum Cost for Node: 1
 3	0	2	3	5
 Minimum Cost for Node: 2
 5	2	0	1	3
 Minimum Cost for Node: 3
 6	3	1	0	2
 Minimum Cost for Node: 4
 8	5	3	2	0
 
 Time Complexity :O(N^3)
 */
",C-Plus-Plus
"import java.util.*;
 public class Main
 {
 	public static void main(String[] args) {
 		Scanner sc=new Scanner(System.in);
 		int indexI,indexJ,searchElement,countsToJump,lengthOfArray,position;
 		System.out.println(""Enter number of elements in array"");
 		lengthOfArray=sc.nextInt();
 		int array[]=new int[lengthOfArray];
 		System.out.println(""Enter array elements"");
 		for(indexI=0;indexI<lengthOfArray;indexI++)
 		array[indexI]=sc.nextInt();
 		System.out.println(""Enter element to be searched"");
 		searchElement=sc.nextInt();
 		countsToJump=(int)Math.sqrt(lengthOfArray);
 		position=-1;indexI=0;
 		while(indexI<lengthOfArray)
 		{
 		    if(array[indexI]==searchElement)
 		    position=indexI;
 		    if(array[indexI]>searchElement)
 		    break;
 		    indexI=indexI+countsToJump;
 		    
 		}
 		indexJ=0;
 		 
 		  
 		while(indexJ<countsToJump)
 		{
 		    
 		    indexI--;
 		    indexJ++;
 		    if(array[indexI]==searchElement)
 		    {position=indexI;
 		    break;
 		    }
 		}
 		if(position==-1)
 		System.out.println(""Element not found"");
 		else
 		System.out.println(""Element found at ""+position);
 	}
 }
 /* Enter number of elements in array                                                                                                            
 10                                                                                                                                           
 Enter array elements                                                                                                                         
 1                                                                                                                                            
 2                                                                                                                                            
 3                                                                                                                                            
 4  ",Java
"""""""Julia program to print the n'th term in the Golomb sequence 
 Golomb sequence is a non-decreasing integer sequence where n'th 
 term is  equal to the number of times n appears in the sequence""""""
 
 function golomb_sequence(n)
     dp = zeros(Int, n + 1)
     dp[1] = 1
 
     for i in 2:n
         dp[i] = 1 + dp[i - dp[dp[i - 1]]]
     end
     return dp[n]
 end
 
 print(""Enter the value of n?, where you need the n'th number in the golomb sequence. "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""The given value of n is invalid."")
     exit()
 end
 res = golomb_sequence(n)
 println(""The $n'th term in the golomb sequence is $res."")
 
 """"""
 Time Complexity: O(n), where 'n' is the given number
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the value of n?, where you need the n'th number in the golomb sequence. 5
 The 5'th term in the golomb sequence is 3.
 
 SAMPLE 2
 Enter the value of n?, where you need the n'th number in the golomb sequence. 867
 The 867'th term in the golomb sequence is 79.
 
 """"""
",Julia
"/* Problem Statement: 
 Given a string of '(' , ')' and lowercase english characters.
 The task is to remove the minimum number of parentheses so that the resulting parentheses string is valid.
 A parentheses string is valid if and only if:
 1.It is the empty string, contains only lowercase characters, or
 2.It can be written as AB (A concatenated with B), where A and B are valid strings, or
 3.It can be written as (A), where A is a valid string. */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //checks if character a and b together make () or not
 bool matching(char a, char b){ 
     if(a == '(' && b == ')'){
         return true;
     }
     return false;
 }
 
 string removeMin(string s){
     int n = s.size();
     //to store character and its index together
     stack<pair<char, int> > st;  
     for(int i = 0; i < n; i++){
         if(s[i] == '('){
             st.push({s[i], i});
         }
         else if(s[i] == ')'){
             if(st.empty() || !matching(st.top().first, s[i])){
                 st.push({s[i], i});
             }
             else{
                 st.pop();
             }
         }
     }
     while(!st.empty()){
         int idx = st.top().second;
         //remove all the elements from the string that were making the string invalid
         s.erase(s.begin() + idx); 
         st.pop();
     }
     return s;
 }
 
 int main() {
     string s;
     cin >> s;
     cout << removeMin(s);
     return 0;
 }
 
 /* Examples: 
 1.  Input: ""he((l)l)o)""
     Output: ""he((l)l)o""
 2.  Input: "")))(((""
     Output: """" */
",C-Plus-Plus
"/*
  This code converts infix expression to prefix expression in JavaScript.
 
  Infix expression:-  The expression of the form a op b. 
  When an operator is in-between every pair of operands.
 
  Prefix expression:-  An expression is called the prefix expression
   if the operator appears in the expression before the operands. 
   Simply of the form (operand1 operand2 operator). 
 
 */
 
 var stackarr=[];
 var topp=-1;
 
 //function for push in stack
 function push(e)
 {
    topp++;
    stackarr[topp]=e;
 }
 
 // function for popping out from stack
 function pop()
 {
     if(topp==-1)
     return 0;
     else
     {
         var popped_ele=stackarr[topp];
         topp--;
         return popped_ele;
     }
 }
 
 //function to check is operator or not
 function operator(op)
 {
     return ((op=='+' || op=='-' || op=='^' || op=='*' || op=='/' || op=='(' || op==')')? true:false);
  
 }
 
 // function for checking precedency
 function precedency(pre)
 {
     if(pre=='@' || pre=='(' || pre==')')
     {
         return 1;
     }
     else if(pre=='+' || pre=='-')
     {
         return 2;
     }
     else if (pre=='/' || pre=='*')
     {
         return 3;
     }
     else if(pre=='^')
     {
         return 4;
     }
     else
     return 0;
 }
 
 // function for infix to prefix conversion
 function InfixtoPrefix(infixval)
 {
     var prefix=[];
     var temp=0;
     push('@'); 
 
     for(var i=infixval.length-1;i>=0;i--)
     {
         var el=infixval[i];
         if(operator(el))
         {
             if (el =='(') {
                 while (stackarr[topp] != "")"") {
                   prefix[temp++] = pop();
                 }
                 pop();
             }
             else if(el==')')
             {
                 push(el);
             }
             
             // function for comparing precedency
 
             else if(precedency(el)>precedency(stackarr[topp]))
             {
                 push(el);
             }
             else
            ",JavaScript
"// C++ program to implement Circle  Sort
 #include <stdio.h>
 
 // Helper function to swap to values
 void swap(int *a, int *b)
 {
     int temp = *a;
     *a = *b;
     *b = temp;
 }
 /*
 Performs recursive circular swaps and returns value 1 if atleast one swap occurs
 */
 int rec_sort(int arr[], int beg, int end)
 {
     int isSwap = 0;
 
     // If concerned array is empty, Return
     if (beg == end)
         return 0;
 
     // Storing the values of beg, end to later use in the recursive call
     int begA, endA;
     for (begA = beg, endA = end; begA < endA; begA++, endA--)
     {
         //Compares the first and last elements
         if (arr[begA] > arr[endA])
         {
             swap(&arr[begA], &arr[endA]);
             isSwap = 1;
         }
     }
 
     // If the array has odd number of elements
     if (begA == endA)
         if (arr[begA] > arr[endA + 1])
         {
             swap(&arr[beg], &arr[endA + 1]);
             isSwap = 1;
         }
 
     int mid = (end - beg) / 2;
     int isSwapA = rec_sort(arr, beg, beg + mid);
     int isSwapB = rec_sort(arr, beg + mid + 1, end);
 
     return (isSwap || isSwapA || isSwapB);
 }
 
 void circle_sort(int arr[], int n)
 {
     while (rec_sort(arr, 0, n - 1))
     {
     }
 }
 
 int main()
 {
     int n;
     printf(""\nHow many numbers do you want to sort? "");
     scanf(""%d"", &n);
     int arr[n];
 
     if (n <= 0)
     {
         printf(""There are no numbers to sort!!!"");
         return 0;
     }
     // Input the numbers to sort
     printf(""Enter the numbers: "");
     for (int i = 0; i < n; i++)
         scanf(""%d"", &arr[i]);
 
     //Call the sort function
     circle_sort(arr, n);
 
     printf(""The numbers in sorted order is: "");
     // Print the sorted array
     for (int i = 0; i < n; i++)
         printf(""%d "", arr[i]);
     printf(""\n"");
     return 0;
 }
 
 /*
 
 Time Complexity: O(n*log(n))
 Space Complexity: O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 How many numbers do you want",C
"/*
 Caeser cipher is  a type of substitution cipher, i.e., each letter of 
 a given text is replaced by a letter some fixed number[key] of positions down the alphabet
 */
 
 import 'dart:io';
 
 /* Encrypts the message by replacing individual
 letters by a letter 'key' places down the alphabet */
 String encrypt(String plain, int key) {
   int length = plain.length;
   List<int> encrypt = [];
 
   //Iterate through whole string and replace letters
   for(int index = 0; index < length; index++){
     int char = plain[index].codeUnitAt(0);
 
     if(plain[index].codeUnitAt(0) <= 91){
       encrypt.add(((char-65) + key) % 26 + 65);
     }
     else if(plain[index].codeUnitAt(0) >= 97){
        encrypt.add(((char-97) + key) % 26 + 65);
     }
   }
   String encrypted_string = String.fromCharCodes(encrypt);
   return encrypted_string;
 }
 
 /* Decrypts the message by replacing individual
 letters by a letter 'key' places up the alphabet */
 String decrypt(String plain, int key) {
   int length = plain.length;
   List<int> decrypt = [];
 
   //Iterate through whole string and replace letters
   for(int index = 0; index < length; index++){
     int char = plain[index].codeUnitAt(0);
   
     if(plain[index].codeUnitAt(0) <= 91){
       decrypt.add(((char-65) - key) % 26 + 65);
     }
     else if(plain[index].codeUnitAt(0) >= 97){
        decrypt.add(((char-97) - key) % 26 + 65);
     }
   }
   String decrypted_string = String.fromCharCodes(decrypt);
   return decrypted_string;
 }
 
 
 void main() {
     print(""Enter 1 to ENCRYPT and 2 to DECRYPT : "");
     int choice = int.parse(stdin.readLineSync()!);
     
     if(choice == 1){
       print(""Enter message to ENCRYPT : "");
       String toEncrypt = stdin.readLineSync()!;
 
       print(""Enter key value:"");
       int key = int.parse(stdin.readLineSync()!);
 
       // call encrypt function
       String encrypted = encrypt(toEncrypt, key);
       print(""\nEncrypted message is $encrypted"");
     }
     else if(choice == ",Dart
"/*Euclidean Algorithm for GCD
 GCD of two numbers is the largest number that divides both of them
 */
 #include <stdio.h>
 
 int Euclid_GCD(int, int);
 int main()
 {
 	int num1, num2, gcd;
 	printf(""Enter the two numbers:"");
 	scanf(""%d %d"", &num1, &num2);
 	gcd = Euclid_GCD(num1, num2);
 	printf(""GCD=%d"", gcd);
 	return 0;
 }
 
 // Recursive function to show Euclidean Algorithm
 int Euclid_GCD(int num1, int num2)
 {
 	if (num2 == 0)
 		return num1;
 	else
 		return (Euclid_GCD(num2, num1 % num2));
 }
 
 /*
 Sample Output
 Enter the two numbers:77 121
 GCD=11
 
 Complexities
 Time Complexity:O(logN)
 Space Complexity:O(1)
 */
 
",C
"// Stack in Go
 
 package main
 
 import ""fmt""
 
 type stack []int
 
 var limit = 5
 
 func (stk *stack) pushStack(ele int) {
 	if !((*stk).isFull()) {
 		*stk = append(*stk, ele)
 		fmt.Printf(""Added element: %v\n"", ele)
 	} else {
 		fmt.Println(""Stack is full!"")
 	}
 }
 
 func (stk *stack) popStack() {
 	if !((*stk).isEmpty()) {
 		top_ele, top := (*stk).peekStack()
 		fmt.Printf(""Popped Element: %v\n"", top_ele)
 		(*stk) = (*stk)[:top]
 	} else {
 		fmt.Println(""Stack is empty!"")
 	}
 }
 
 func (stk *stack) isEmpty() bool {
 	return len(*stk) == 0
 }
 
 func (stk *stack) isFull() bool {
 	return len(*stk) == limit
 }
 
 func (stk *stack) peekStack() (int, int) {
 	top := len(*stk) - 1
 	top_ele := (*stk)[top]
 	return top_ele, top
 }
 
 func main() {
 	fmt.Println(""Welcome to Stack program in Go!"")
 	var stack1 stack
 	stack1.pushStack(4)
 	stack1.pushStack(5)
 	stack1.pushStack(1)
 	stack1.pushStack(3)
 	stack1.pushStack(7)
 	stack1.pushStack(9)
 	stack1.popStack()
 	stack1.popStack()
 	stack1.popStack()
 	topOfStack, topIndex := stack1.peekStack()
 	fmt.Printf(""Top element of stack: %v\tIndex of top element: %v\n"", topOfStack, topIndex)
 }
",Go
"/*
 Introduction 
 Given two Binary Trees , Check whether they are structurally identical or not.
 
 Argument/Return Type
 Input of total no.of nodes is taken
 Input of key values of nodes of tree are taken in level order form 
 Incase of a null node , -1 is taken as input
 */
 
 #include <bits/stdc++.h> 
 using namespace std;
 
 //Define Node as structure
 struct Node 
 {
     int key;
     Node* left;
     Node* right;
 };
  
 // Function to create a node with 'value' as the data stored in it. 
 // Both the children of this new Node are initially null.
 struct Node* newNode(int value)
 {
     Node* n = new Node;
     n->key = value;
     n->left = NULL;
     n->right = NULL;
     return n;
 }
 
 // Function to build tree with given input
 struct Node* createTree(vector<int>v)
 {
     int n=v.size();
     if(n==0) 
       return NULL;
     vector<struct Node* >a(n);
     //Create a vector of individual nodes with given node values
     for(int i=0;i<n;i++)  
     {
         //If the data is -1 , create a null node
         if(v[i]==-1)  
           a[i] = NULL;
         else 
           a[i] = newNode(v[i]);
     }
     //Interlink all created nodes to create a tree
     //Use two pointers using int to store indexes
     //One to keep track of parent node and one for children nodes
     for(int i=0,j=1;j<n;i++) 
     {
         //If the parent node is NULL , advance children pointer twice
         if(!a[i])
         {
           j=j+2;
           continue;
         } 
         //Connect the two children nodes to parent node
         //First left and then right nodes
         a[i]->left = a[j++];
         if(j<n) 
           a[i]->right = a[j++];
     }
     return a[0];
 }
 
 //Function to check whether given two binary trees are structurally identical or not
 bool IsStructurallyIdentical(struct Node* root1, struct Node* root2)
 {
     //If both are null nodes , return true
     if(!root1 && !root2)
       return true;
     
     //else if one of them is a null nod",C-Plus-Plus
"""""""
 Chinese Remainder Theorem: In number theory, the Chinese remainder theorem
         states that if one knows the remainders of the Euclidean division
         of an integer n by several integers, then one can determine uniquely
         the remainder of the division of n by the product of these integers,
         under the condition that the divisors are pairwise coprime.
 
 Method : Chinese Remainder Theorem / Inverse Modulo Implementation
 
 """"""
 
 def multiply_fun(li):
     result = 1
     for i in li:
         result *= i
 
     return result
 
 
 def Chinese_Remainder(n, a):
     sum = 0
     pr = multiply_fun(n)
 
     for n_i, a_i in zip(n, a):
         p = pr / n_i
 
         sum += a_i * muinv(p, n_i) * p
 
     return int(sum % pr)
 
 
 def muinv(a, b):
     b0 = b
     x0, x1 = 0, 1
 
     if b == 1:
         return 1
 
     while a > 1:
         q = a // b
         a, b = b, a % b
         x0, x1 = x1 - q * x0, x0
 
     if x1 < 0:
         x1 += b0
 
     return x1
 
 # ----------------------------- DRIVER CODE ---------------------------
 
 
 if __name__ == ""__main__"":
 
     k = int(input(""Enter size of array : ""))
     n = list(map(int, input(""Enter value of coprime divisors :"") . split()))
     a = list(map(int, input(""Enter value of remainders :"").split()))
 
     ans = Chinese_Remainder(n, a)
 
     print(""x = "", ans)
 
 '''
 Time Complexity : O(N^2)
 Space Complexity: O(N)
 '''
 
 """"""
 Sample Input / Output
 
 Enter size of array : 3
 Enter value of coprime divisors : 2 3 5
 Enter value of remainders : 1 2 4
 x =  29.0
 
 
 Enter size of array : 5
 Enter value of coprime divisors : 5 4 3 7 11
 Enter value of remainders : 1 2 3 4 5
 x =  1446.0
 """"""
 
",Python
"/*
 DOUBLY LINKED LIST TO CHECK IF A STRING IS PALINDROME
 A string is accepted as input from the user.
 The characters in the string are inserted as nodes
 into the doubly linked list.
 Two pointers lptr and rptr are used to point to the
 beginning and end of the string respectively.
 The list is traversed from left to right using lptr
 and right to left using rptr.
 If the characters match until they reach the same node
 the string is palindrome
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 //structure for doubly linked list
 typedef struct node
 {
     char data;
     struct node *rlink;
     struct node *llink;
 } node;
 
 //to insert into doubly linked list
 void insert(node *head, char a)
 {
     node *n = malloc(sizeof(node));
     n->data = a;
     n->rlink = NULL;
     node *ptr = head;
     while (ptr->rlink)
         ptr = ptr->rlink;
     ptr->rlink = n;
     n->llink = ptr;
 }
 
 //to check if the string is palindrome
 int palindrome(node *head)
 {
     if (head->rlink == NULL)
         return 1;
     node *rptr = head;
     while (rptr->rlink)
         rptr = rptr->rlink;
     node *lptr = head->rlink;
     while (lptr != rptr)
     {
         if (lptr->data != rptr->data)
             return 0;
         lptr = lptr->rlink;
         rptr = rptr->llink;
     }
     return 1;
 }
 
 //driver code
 void main()
 {
     node *head = malloc(sizeof(node));
     char str[30];
     printf(""Enter a string : "");
     scanf(""%s"", str);
     for (int i = 0; str[i] != '\0'; i++)
         insert(head, str[i]);
     if (palindrome(head) == 1)
         printf(""%s is a palindrome\n"", str);
     else
         printf(""%s is not a palindrome\n"", str);
 }
 
 /*
 SAMPLE I/O:
 Enter a string : refer
 refer is a palindrome
 
 Time Complexity: O(n)
 Space Complexity: O(n)
 */
",C
"/*
 Given a non-empty string containing
 an out-of-order English representa-
 tion of digits 0-9,output the digits
 in ascending order.
 Note:
 Input contains only lowercase English
 letters.
 Input is guaranteed to be valid and 
 can be transformed to its original 
 digits.That means invalid inputs such
 as ""abc"" or ""zeroe"" are not permitted.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 string EnglishToDigit(string English)
 {
     long long int L, i, Z, Max;
     string Temp, Digit;
     vector<pair<string, int> > M;
     L = English.length();
     int count[26] = { 0 };
     for (i = 0; i < L; i++) {
         count[English[i] - 'a']++;
     }
     M.push_back({ ""six"", 6 });
     M.push_back({ ""zero"", 0 });
     M.push_back({ ""seven"", 7 });
     M.push_back({ ""eight"", 8 });
     M.push_back({ ""five"", 5 });
     M.push_back({ ""four"", 4 });
     M.push_back({ ""three"", 3 });
     M.push_back({ ""two"", 2 });
     M.push_back({ ""one"", 1 });
     M.push_back({ ""nine"", 9 });
     for (auto it = M.begin(); it != M.end(); it++) {
         Max = INT_MAX;
         Temp = it->first;
         Z = Temp.length();
         for (i = 0; i < Z; i++) {
             if (count[Temp[i] - 'a'] < Max) {
                 Max = count[Temp[i] - 'a'];
             }
         }
         for (i = 0; i < Max; i++) {
             Digit += ('0' + it->second);
         }
         for (i = 0; i < Z; i++) {
             count[Temp[i] - 'a'] -= Max;
         }
     }
     sort(Digit.begin(), Digit.end());
     return Digit;
 }
 
 int main()
 {
     string English, Digit;
     cout << ""Enter the String"" << endl;
     cin >> English;
     Digit = EnglishToDigit(English);
     cout << ""Coverted String"" << endl;
     cout << Digit << endl;
     return 0;
 }
 
 /*
 Time Complexity:O(N)
 Space Complexity:O(1)
 Where N is the length
 of the string.
 
 Sample I/O
 Input:
 Enter the String
 owoztneoer
 Output:
 Coverted String
 012
 */
",C-Plus-Plus
"/*
 Flood Fill Algorithm determines the area connected to the given node in a multidimensional array.
 
 Problem Statement: To fill connected, similarly-coloured areas with a different color.
 
 Idea (DFS): Start from the current source node and replace its color with the replacement color
 and recursively explore all valid neighbours and replace their color as well.
 
 Idea(BFS): To apply BFS and process all 8 adjacent pixels of the current one and enqueue each
 valid pixel which has the same color as that of the previous one.
 
 Input for the algorithm: matrix, a start node, target color, replacement color.
 
 Time Complexity: O(M.N)
 */
 
 #include <bits/stdc++.h>
 #define M 10
 #define N 10
 using namespace std;
 
 //for processing 8 directions
 int row[] = {-1, -1, -1, 0, 0, 1, 1, 1};
 int col[] = {-1, 0, 1, -1, 1, -1, 0, 1};
 
 //to check the valid neighbours
 bool safe(char matrix[M][N], int start_x, int start_y, char target)
 {
     return (start_x >= 0 && start_y >= 0 && start_x < M && start_y < N && matrix[start_x][start_y] == target);
 }
 
 void floodFillDFS(char matrix[M][N], int start_x, int start_y, char target, char replacement)
 {
     queue<pair<int, int>> q;
     q.push({start_x, start_y});
 
     while (!q.empty())
     {
         pair<int, int> node = q.front();
         q.pop();
         int x = node.first;
         int y = node.second;
         matrix[x][y] = replacement;
         //Processing all 8 dircetions
         for (int k = 0; k < 8; k++)
         {
             if (safe(matrix, x + row[k], y + col[k], target))
             {
                 q.push({x + row[k], y + col[k]});
             }
         }
     }
 }
 
 void floodFillBFS(char matrix[M][N], int start_x, int start_y, char target, char replacement)
 {
     //replacing color of current cell
     matrix[start_x][start_y] = replacement;
     //processing all 8 neighbours recursively
     for (int k = 0; k < 8; k++)
     {
         if (safe(matrix, start_x + row[k], start_y + col[k]",C-Plus-Plus
"// Stock Span Problem
 // Given a list of prices of a stock for N number of days, find stock span for each day.
 // link to problem:  https://practice.geeksforgeeks.org/problems/stock-span-problem/
 
 #include<stdio.h>
 #define MAXSIZE 50
 
 int stack[MAXSIZE];
 int top = -1;
 
 int isempty() {
 	if (top == -1)
 		return 1;
 	else
 		return 0;
 }
 
 int isfull() {
 	if (top == MAXSIZE)
 		return 1;
 	else
 		return 0;
 }
 
 int peek() {
 	return stack[top];
 }
 
 int pop() {
 	int data;
 	if (!isempty()) {
 		data = stack[top];
 		top = top - 1;
 		return data;
 	} else {
 		printf(""Stack is empty.\n"");
 	}
 }
 
 void push(int data) {
 	if (!isfull()) {
 		top = top + 1;
 		stack[top] = data;
 	} else {
 		printf(""Stack is full.\n"");
 	}
 }
 
 void calcSpan(int arr[], int days) {
 	int i, span[days];
 
 	if (days == 0)
 		return;
 	// initialization
 	span[0] = 1;
 	push(0);
 	for (i = 1; i < days; i++) {
 		// checking if previous stock prize is less
 		while (!isempty() && arr[i] > arr[peek()])
 			pop();
 		// updating the span value
 		if (isempty()) {
 			span[i] = i + 1;
 		} else {
 			span[i] = i - peek();
 		}
 		push(i);
 	}
 	// printing the span
 	for (i = 0; i < days; i++)
 		printf(""%d  "", span[i]);
 
 	printf(""\n"");
 }
 
 int main() {
 	int n;
 	printf(""Enter the no. of days: \n"");
 	scanf(""%d"", &n);
 	printf(""Enter the stock prizes: \n"");
 	int arr[n];
 	for (int i = 0; i < n; i++)
 		scanf(""%d"", &arr[i]);
 
 	calcSpan(arr, n);
 	return 0;
 }
 
 /*
  Input:
  Enter the no. of days:
  5
  Enter the stock prizes:
  30 20 40 50 60
  Output:
  1  1  3  4  5
 
  Time complexity: O(n)
  Space complexity: O(n)
  */
",C
"""""""
 Inversion: Inversion Count for an array indicates  how far (or close)
         the array is from being sorted. If the array is already sorted then
         inversion count is 0. If the array is sorted in the reverse order that
         inversion count is the maximum.
         Formally speaking, two elements a[i] and a[j] form an inversion
         if a[i] > a[j] and i < j.
 
 Purpose: Given an array A of length N containing distinct integers from 1
         to N. If we make 2 sets containing N numbers, one arranged serially
         another in the give array order. If we connect the i_th number from
         the 1st set to the i_th number in the second set, Find the number of
         intersection.
         Example: A = [1, 2, 5, 4, 3]
 
           	  SET 1         SET 2
 		   (1)-----------(1)
 		   (2)-----------(2)
 		   (3)		 (5)
 		     \           /
 		      \	        /
 		  (4)--X-------X----(4)
                 	\     /
                  	 \   /
                   	  \ /
                    	   X
                   	  / \
                          /   \
 		     	/     \
               	      (5)     (3)
 
         Number of intersection = 3
 
 Method: Divide and Conquer / Merge-Sort
 Intuition: This is a typical problem for Divide and Conquer algorithm also
             referred to as the inversion problem.
         1. The idea is similar to merge sort, divide the array into two equal
             or almost equal halves in each step until the base case is reached.
         2. Create a function merge that counts the number of inversions when
             two halves of the array are merged, create two indices i and j, i
             is the index for the first half and j is an index of the second half.
             if a[i] is greater than a[j], then there are (mid  i) inversions
             because the left and right subarrays are sorted, so all the remaining
             elements in left-subarray (a[i+1], a[i+2]  a[mid]) will be greater than a[j",Python
"# Unique_Number_III
 # Given an array that contains all elements occurring 3 times, but one
 # occurs only once. Find that unique element.
 
 
 def unique_element(array, size):
     for i in range(size):
         j = 0
         while(j < size):
             if (i != j and array[i] == array[j]):
                 break
             j += 1
         if (j == size):
             return array[i]
 
     return -1
 
 
 print(""Enter Elements:"")
 array = input().split()
 size = len(array)
 print(""Unique element:"")
 print(unique_element(array, size))
 
 '''
 Sample I/O:
     Input:
     Enter Elements:
     1 1 1 4 2 2 2 3 3 3
 
     Output:
     Unique element:
     4
 
 Time Complexity: O(size*size)
 Space Complexity:O(1)
 '''
",Python
"// C++ PROGRAM TO COMPUTE THE SUM OF DIGITS OF A NUMBER
 
 #include <iostream>
 using namespace std;
 
 // Function to calculate the sum of digits
 int sum_of_digits(int N)
 {
     int sum = 0;
     while(N != 0)
     {
         // Adding the last digit of the number to the sum
         int rem = N % 10;
         sum += rem;
         // Removing the last digit
         N = N / 10;
     }
     return sum;
 }
 
 int main()
 {
     int N;
     cout << ""Enter any integer:"";
     cin >> N;
     
     cout << ""Sum of the digits of a number:"" << sum_of_digits(N) << endl;
     return 0;
 }
 
 /*
 Example 1:
 Input : N = 453
 Output: 12
 Explanation: Sum of digits of number = (4+5+3) = 12
 
 Example 2:
 Input : N = 101
 Output: 2
 Explanation: Sum of digits of number = (1+0+1) = 2
 */
",C-Plus-Plus
"/* Vernam Cipher
 
 Vernam Cipher is a symmetric key cryptographic algorithm and is one of the transposition technique that converts plain text into ciphertext.
 In this algorithm the size of the key and plain text must be same. */
 
 
 #include<bits/stdc++.h>
 using namespace std;
 
 string encrypt(string plain,string key){
   string enc="""";
   int n=key.length();
   for(int i=0;i<n;i++){
     int y = plain[i]+key[i]-130;
     if(y>=26) {
       y = y-26;
     }
     enc+=char(y+65);
   }
   return enc;
 }
 
 string decrypt(string enc,string key){
   string dec="""";
   int n=enc.length();
   for(int i=0;i<n;i++){
     if(enc[i]>=key[i]){
       dec+=char(enc[i]-key[i]+65);
     }
     else{
       dec+=char(enc[i]-key[i]+91);  
     }
   }
   return dec;
 }
 
 int main(){
   string plain,encrypted,decrypted,key;
   cout<<""USE UPPERCASE LETTERS""<<endl;
   cout<<""Enter the Key: "";
   cin>>key;
   transform(key.begin(), key.end(), key.begin(), ::toupper);
 
   cout<<""\nEnter the plain text of same size as that of key: "";
   cin>>plain;
   transform(plain.begin(), plain.end(), plain.begin(), ::toupper);
 	
   int n=key.length();
   if(plain.length()<key.length()){
     cout<<""Invalid"";
     return 0;
   }
 	
   encrypted = encrypt(plain,key);
   cout<<""\nCipher text: ""<<encrypted<<endl;
 	
   decrypted = decrypt(encrypted,key);
   cout<<""Decrypted text: ""<<decrypted<<endl;	
 }
 
 
 /* Output
 USE UPPERCASE LETTERS
 Enter the Key: TESSERACTCODING
 
 Enter the plain text of same size as that of key: OPENSOURCESTART
 
 Cipher text: HTWFWFUTVGGWIEZ
 Decrypted text: OPENSOURCESTART */
",C-Plus-Plus
"/*
 selection sort is an in-place comparison sorting algorithm. It has an O(n) time complexity, 
 which makes it inefficient on large lists, and generally performs worse than the similar insertion 
 sort. 
 
 Time complexity:O(n^2)
 
 The selection sort algorithm sorts an array by repeatedly finding the minimum element
 (considering ascending order) from unsorted part and putting it at the beginning.
 The algorithm maintains two subarrays in a given array.
 
 1) The subarray which is already sorted.
 2) Remaining subarray which is unsorted.
 
 In every iteration of selection sort, the minimum element (considering ascending order) from the 
 unsorted subarray is picked and moved to the sorted subarray.
 
 arr[] = 64 25 12 22 11   min(11,25,12,22,64)=11
 
 // Find the minimum element in arr[0...4]
 // and place it at beginning
 11 25 12 22 64                                min(12,25,22,64) = 12
 
 // Find the minimum element in arr[1...4]
 // and place it at beginning of arr[1...4]
 11 12 25 22 64                                min(25,22,64) = 22
 
 // Find the minimum element in arr[2...4]
 // and place it at beginning of arr[2...4]
 11 12 22 25 64                                min(25,64) = 25
 
 // Find the minimum element in arr[3...4]
 // and place it at beginning of arr[3...4]
 11 12 22 25 64                                 min(64) = 64
 
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 
 void swap(int *xp, int *yp)
 {
     int temp = *xp;
     *xp = *yp;
     *yp = temp;
 }
 //create a array dynamically
 int *create(int n)
 {
     int *a = (int *)malloc(n * sizeof(int));
 
     for (int i = 0; i < n; i++)
     {
         /* take input using element */
         scanf(""%d"", (a + i));
     }
 
     return a;
 }
 
 //display the arrray
 void display(int *a, int n)
 {
     for (int i = 0; i < n; i++)
     {
         /* display it */
         printf(""%d"", *(a + i));
         printf("" "");
     }
 }
 
 //selection sort function
 int *selection_sort(int *a, int n)
 {
 ",C
" 
 'use strict';
 
 process.stdin.resume();
 process.stdin.setEncoding('utf-8');
 
 let inpStr = '';
 let curr = 0;
 
 process.stdin.on('data', inputStdin => {
     inpStr += inputStdin;
 });
 
 process.stdin.on('end', _ => {
     inpStr = inpStr.trim().split('\n').map(string => {
         return string.trim();
     });
     
     master();    
 });
 
 function lineread() {
     return inpStr[curr++];
 }
 
 function master() {
     console.log(""INPUT TEST CASES"");
     let t = parseInt(lineread());
     for(let i=0;i<t;i++)
     {   
         console.log(""INPUT NUMBER OF ELEMENTS"");
         let line = lineread().split(' ');
         let ele = parseInt(line[0]);
         line = lineread().split(' ').map(x=>parseInt(x));
         console.log(""INPUT ARRAY ELEMENTS"");
         let a = new Array(ele);
         for(let k=0;k<ele;k++){
             a[k]=line[k];
         }
         let Ob = new Kadanes();
         let sol = Ob.kadanesalgo(a,ele);
         console.log(""MAX SUM OF SUBARRAY IS : "");
         if(sol===0)
             sol=0;
         console.log(sol);
     }
     
 }
 
 
 
 class Kadanes {
     
     kadanesalgo(a,ele){
         let mh = 0, mf = a[0];
         for(let p=0;p<ele;p++) 
         {
             mh+=a[p];
             mf=Math.max(mh,mf);
             if(mh<0)
                 mh=0;
         }
         return mf;
     } 
 }
 
 // solved example
 // Input:
 // INPUT TEST CASES = 1
 //INPUT NUMBER OF ELEMENTS = 4
 // INPUT ARRAY ELEMENTS = -1 -2 -3 -4
 // Output:
 //  MAX SUM OF SUBARRAY IS : -1
 // Explanation:
 // Max subarray sum is -1 
 // of element (-1)
 
 // Time Complexity: O(N)
 // Auxiliary Space: O(1)
",JavaScript
"#= You are a thief who has a bag with some capacity, you broke into a hous
 and you found some valuables, you want to take the maximum value back 
 with you. You are confused what to pick, no worries, coders are here 
 to help you in your burglary. =#
 
 ## Function
 
 function knapsack(weights, values, items, capacity)
     if (items == 0 || capacity == 0)
         return 0
     end
     if (weights[items] > capacity)
         return knapsack(weights, values, items - 1, capacity)
     end
     return max(
         knapsack(weights, values, items - 1, capacity - weights[items]) + values[items],
         knapsack(weights, values, items - 1, capacity),
     )
 end
 
 ## Input
 
 println(""Enter the number of items"")
 n = readline()
 n = parse(Int64, n)
 println(""Enter the capacity of the knapsack"")
 w = readline()
 w = parse(Int64, w)
 values = Int64[]
 println(""Enter the values of each item"")
 for i = 1:n
     temp = readline()
     temp = parse(Int64, temp)
     push!(values, temp)
 end
 weights = Int64[]
 println(""Enter the weights of each item"")
 for i = 1:n
     temp = readline()
     temp = parse(Int64, temp)
     push!(weights, temp)
 end
 
 ## Calling the function
 
 print(""The maximum value you could take is "")
 print(knapsack(weights, values, n, w))
 
 #=
 Sample Test Case:
 Input:
     Enter the number of items
     3
     Enter the capacity of the knapsack
     50
     Enter the values of each item
     60 100 120
     Enter the weights of each item
     10 20 30
 Ouput:
     The maximum value you could take is 220
 =#
",Julia
"// A number is said to be Magic Number, when the recursive sum of the digits is 1.
 #include <stdio.h>
 
 int calsum(int);
 int magic_num(int);
 int main()
 {
 	int num;
 	printf(""Enter the number to be checked:"");
 	scanf(""%d"", &num);
 	if (magic_num(num) == 1)
 		printf(""%d is a magic number"", num);
 	else
 		printf(""%d is not a magic number"", num);
 	return 0;
 }
 
 // Function to check if the number is a magic number or not
 int magic_num(int num)
 {
 	int sum;
 	while (num > 9)
 	{
 		sum = calsum(num);
 		num = sum;
 	}
 
 	return num;
 }
 
 // Function to calculate the sum of digits
 int calsum(int num)
 {
 	int sum = 0, rem;
 	while (num > 0)
 	{
 		rem = num % 10;
 		sum = sum + rem;
 		num = num / 10;
 	}
 
 	return sum;
 }
 
 /*
 Sample Output
 Enter the number to be checked:1729
 1729 is a magic number
 
 Complexities
 Time Complexity:O(n)
 Space Complexity:O(n)
 */
 
",C
"/* This program calculates the GCD(Greatest Common Divisor)
 of two numbers given as input.*/
 
 package main
 
 import (
 	""fmt""
 )
 
 // This function finds the minimum of two numbers and returns it
 func min(n1, n2 int) int {
 	if(n1 < n2) {
 		return n1
 	} else {
 		return n2
 	}
 }
 
 // This function calculates the GCD.
 func is_gcd(n1, n2 int) int {
 
 	// Find the minimum of two numbers
 	var min int = min(n1, n2)
 	var result int
 
 	// Iterate till the minimum
 	for i := 1; i <= min; i++ {
 		// It it divides both n1 and n2
 		if(n1 % i == 0 && n2 % i == 0) {
 			// Set it as gcd
 			result = i
 		}
 	}
 	// After completion return the GCD
 	return result
 }
 
 func main() {
 
 	// Take two numbers as input from the user
 	fmt.Print(""Enter two numbers followed by spaces: "")
 	var n1, n2 int
 	fmt.Scan(&n1, &n2)
 
 	// Call the GCD function
 	var result int = is_gcd(n1, n2)
 
 	// Print the result
 	fmt.Print(""\nGCD of "", n1, "" and "", n2, "" is "", result, ""\n"")
 }
 
 /* Sample I/O:
 
 Enter two numbers followed by spaces: 100 12
 
 GCD of 100 and 12 is 4
 
 */
",Go
"  /*This is a java code of checking whether the Strings are anagram to each other and not...
   An anagram of a string is another string that contains the same characters,
   Only the order of characters can be different.
   In other words, Two strings are said to be anagram if we can form one string
   by arranging the characters of another string.
   For example, Race and Care. Here, we can form Race by arranging the characters of Care.
   For example, abcd and dabc are an anagram of each other.
   */
   import java.util.Scanner;
   import java.lang.String;
   public class Annagram 
   {
 	
         static boolean isAnagram(String first_string, String second_string) 
 	{ 
               first_string = first_string.toLowerCase();
               second_string = second_string.toLowerCase();
               boolean check = true;
               int first_length[] = new int[256];
 	  
 	      /* system provided the ASCII table
               which had 256 characters and each ASCII code
 	      (numerical code) was assigned to one character.
               */
               
 	      int second_length[] = new int[256];
               
 	      for (char each_char : first_string.toCharArray()) 
 	       {
                    int index = (int) each_char;
                    first_length[index]++;
                }
               
 	      for (char each_char : second_string.toCharArray()) 
 	       {
                    int index = (int) each_char;
                    second_length[index]++;
                }
               
 	      /*
               For comparing each character from one
               String to another.
               */
               
 	      for (int i = 0; i < 256; i++) 
 	      {
                   if (first_length[i] != second_length[i]) 
 		  {
                       check = false;
                       break;
                   }
               }
               return check;
         }
         public static void main(String[] args) 
      ",Java
"//Given an array of integers which represents the preorder traversal of a Binary Search Tree 
 //Construct the BST and return its root.
 
 #include <iostream>
 #include <stack>
 using namespace std;
 
 //Structure for node contains data, pointer to the left child and pointer to the right child
 struct Node{
     int data;
     Node *left;
     Node *right;
 };
 
 //Function to create a new node with desired value and return its address
 Node* CreateNode (int val){
     Node* new_node = new Node;
     new_node->data = val;
     new_node->left = new_node->right = NULL;
     return new_node;
 }
 
 //Function to generate BST from preorder traversal 
 //Iterative solution using stack which runs in O(n) time
 Node* BstFromPreorder (int pre[], int size){
     stack <Node*> stk;
     //First element of preorder traversal is always the root
     Node *root = CreateNode (pre[0]);     
     Node *p = root;
     //count maintains number of nodes in tree                      
     int count = 1;                        
     //Iterate through the rest of pre[] array
     while (count < size){
         if (pre[count] < p->data)  
         //If the element is less than the element pointed by p 
         {
             Node *temp = CreateNode ( pre[count++] );
             p->left = temp;
             stk.push (p);
             p = temp;
         }
         else 
         {
             //If the element is greater than the element pointed by p and is smaller than the element at top of stack 
             if ((pre[count] > p->data) && ((stk.size()==0) || (pre[count] < stk.top()->data))){
                 Node *temp = CreateNode ( pre[count++] );
                 p->right = temp;
                 p = temp;
             }
             //If the element is greater than element pointed by p and at the top of stack
             else{
                 p = stk.top();
                 stk.pop();
             }
         }
     }
     return root;  
 }
 
 //Function to print inorder traversal o",C-Plus-Plus
"/*
 Catalan numbers is a ""number sequence"", Its useful in a number of
 combinatorial problems, often involving recursively-defined objects.
 */
 
 import 'dart:io';
 
 // To find nth catalan number using recursive function
 int catalan(int n){
   if (n <= 1)
     return 1;
   int res = 0;
   for (int i = 0; i < n; i++)
     res = res + catalan(i) * catalan(n - i - 1);
 
   return res;
 }
 
 int main(){
   print(""Enter the Number:"");
   int n  = int.parse(stdin.readLineSync()!);
   for (int i = 0; i < n; i++)
   {
     stdout.write(catalan(i));
     stdout.write("" "");
   }
   return 0;
 }
 
 /*
 Input:
 Enter the Number:
 13
 Output:
 1 1 2 5 14 42 132 429 1430 4862 16796 58786 208012 
 
 Time Complexity: O(2^n)
 Space Complexity: O(1)
 */",Dart
"// C program to Check if a number is a Mystery Number or Not.
 /*
 A mystery number is that number which can be expressed as a sum of two 
 numbers and those two numbers must be the reverse of each other
 */
 #include <stdio.h>
 #include <stdbool.h>
 
 // Helper function to reverse a number.
 int reverse(int n)
 {
     int rev = 0;
     for (; n > 0; n /= 10)
     {
         rev = rev * 10;
         rev = rev + (n % 10);
     }
     return rev;
 }
 
 bool check_mystery_num(int n)
 {
     /* Let us iterate from 1 upto n/2, to check if there is any pair, such that thier
        sum equals the given number and check if the pair are reverse of each other  */
     for (int i = 1; i <= n / 2; i++)
     {
         if (reverse(i) == n - i)
         {
             return true;
         }
     }
     return false;
 }
 
 int main()
 {
     int n;
     printf(""Enter the number: "");
     scanf(""%d"", &n);
     bool res = check_mystery_num(n);
     if (res)
     {
         printf(""The given number %d is a Mystery Number."", n);
     }
     else
     {
         printf(""The given number %d is not a Mystery Number."", n);
     }
     return 0;
 }
 
 /*
 Time Complexity: O(n*log(n)), where 'n' is the given number
 Space Complexity: O(1)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 Enter the number: 43234
 The given number 43234 is a Mystery Number.
 
 SAMPLE 2
 Enter the number: 1234
 The given number 1234 is not a Mystery Number.
 
 */
",C
"""""""Julia program to implement Insertion sort
 In Insertion Sort we maintain a sorted part and an unsorted part,
 and continously shift elements from unsorted part to the sorted part
 thus getting the whole array sorted in the process.
 """"""
 
 function insertion_sort(arr, n)
     # Begin the iteration from the second element considering, the first element as a part of the sorted part 
     for i in 2:n
         temp = arr[i]
         j = i - 1
         # Find the first element from the beginning of the array that is smaller than the temp element
         # And shift all the elements till then towards right. 
         while j > 0 && temp < arr[j]
             arr[j + 1] = arr[j]
             j = j - 1
         end
         arr[j + 1] = temp
     end
 end
 
 
 
 print(""How many numbers do you want to sort? "")
 n = readline()
 n = parse(Int64, n)
 if (n <= 0)
     println(""No numbers to sort!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 insertion_sort(arr, n)
 print(""The numbers in sorted order is "")
 print(arr)
 
 
 
 """"""
 Time Complexity - O(n^2), where 'n' is the size of the array
 Space Complexity - O(n)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 How many numbers do you want to sort? 6
 Enter the numbers: 76 243 89 25 8337 72
 The numbers in sorted order is [25, 72, 76, 89, 243, 8337]
 
 """"""
",Julia
"'''
 - Phone Keypad Sequence:
     Given a keypad as shown in the diagram, and an n digit number,
     list all words which are possible by pressing these numbers.
 - Example:
     Input number: 23
 
     Output: ad ae af
             bd be bf
             cd ce cf
 - Approach :
     1. As observed each digit can represent 3 to 4 different
     alphabets (except 0 and 1)
     2. Map each number with its keypad string equivalent.
     3. Use recrsive function to try all alphabets mapped to the
     current digit in alphabetic order, and again call the recursive
     function for the next digit and will pass on the current output string.
 '''
 
 keypad = [
     # 0 and 1 digit don't have any characters associated
     [],
     [],
     ['a', 'b', 'c'],
     ['d', 'e', 'f'],
     ['g', 'h', 'i'],
     ['j', 'k', 'l'],
     ['m', 'n', 'o'],
     ['p', 'q', 'r', 's'],
     ['t', 'u', 'v'],
     ['w', 'x', 'y', 'z']
 ]
 # input number in the form of a list (number cannot start from 0 or 1)
 input_num = [2, 3]
 
 
 def printAllCombinations(index, result=""""):
     # if we have processed every digit of the key, print the result
     if index == -1:
         print(result, end=' ')
         return
 
     # stores the current digit
     digit = input_num[index]
 
     # get the size of the list corresponding to the current digit
     length = len(keypad[digit])
 
     # one by one, replace the digit with each character in the corresponding
     # list and recur for the next digit
     for i in range(length):
         printAllCombinations(index -
                              1, keypad[digit][i] + result)
 
 
 printAllCombinations(len(input_num) - 1)
 
 
 # - Output
 #    ad ae af bd be bf cd ce cf
 
 # - Complexity Analysis :
 #     Time Complexity : O(4^n)
 #         here as each digit of the number has 3 or 4 alphabets
 #         we have taken the upper bound
 #         so that all cases can be incorporated in it.
 
 #     Space Complexity :
 #         O(1)
 #         No extr",Python
"'''
 Ugly numbers are numbers whose only prime factors are 2, 3 or 5.
 The sequence 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 
 shows the first 11 ugly numbers.
 '''
 
 
 def Divide(a, b):
     while a % b == 0:
         a = a / b
     return a
 
 
 def isUgly(num):
     num = Divide(num, 2)
     num = Divide(num, 3)
     num = Divide(num, 5)
     return 1 if num == 1 else 0
 
 
 def getUglyNo(num):
     i = 1
     count = 1
     while num > count:
         i += 1
         if isUgly(i):
             count += 1
     return i
 
 num = int(input(""Enter Number: ""))
 ugly = getUglyNo(num)
 print(""Ugly number is "", ugly)
 
 '''
 Time Complexity:O(n)
 Space Complexity: O(1)
 
 Example 1:
 Input:
 Enter Number: 10
 Output:
 Ugly number is 12
 
 Example 2:
 Input:
 Enter Number: 4
 Output:
 Ugly number is 4
 '''
",Python
"/* C Program to find whether a Binary Tree is a Binary Search Tree.
     This problem is solved using In-order traversal.We start with root node,
     and during the traversal , we compare the previous element with the current
    element and during that if we found current is greater than previous ,we
    conclude  that it is not a Binary Search Tree*/
 
 #include <malloc.h>
 #include <stdio.h>
 
 // structure of the Node
 struct Node {
   int data;
   struct Node *left;
   struct Node *right;
 };
 
 // structure of the queue
 struct Queue {
   struct Node *data;
   struct Queue *next;
 };
 
 // check whether Queue is empty or not
 int isEmpty(struct Queue *q) {
   if (q == NULL) {
     return 1;
   }
   return 0;
 }
 
 // enqueue the element at the rear end
 int enQueue(struct Queue **f, struct Queue **r, struct Node *data) {
   struct Queue *q;
   /*create new node*/
   q = (struct Queue *)malloc(sizeof(struct Queue));
   q->data = data;
   q->next = NULL;
 
   // If queue is empty
   if (*f == NULL) {
     *f = q;
   } else {
     (*r)->next = q;
   }
 
   *r = q;
   return 0;
 }
 
 // dequeue the element from the front end
 struct Node *deQueue(struct Queue **f) {
   struct Node *temp;
 
   if (isEmpty(*f)) {
     printf(""\n Queue is empty"");
 
   } else {
     temp = (*f)->data;
     (*f) = (*f)->next;
   }
 
   return temp;
 }
 
 // insertion in Binary Tree
 int insertBinaryTree(struct Node **root, int data) {
   struct Node *temp, *cur;
   struct Queue *f = NULL, *r = NULL;
 
   // new node creation based on data
   temp = (struct Node *)malloc(sizeof(struct Node));
   if (temp == NULL) {
     return -1;
   } else {
     temp->data = data;
     temp->left = NULL;
     temp->right = NULL;
   }
 
   if (*root == NULL) {
     *root = temp;
     return;
   }
   // queue used to insert data to the binary tree
   enQueue(&f, &r, *root);
   while (!isEmpty(f)) {
 
     cur = deQueue(&f);
 
     // move left
     if (cur->left == NULL) {
       cur->left = temp;
   ",C
"""""""
 Problem Statement :
 Given a list of elements, return all possible subsets (the power set).
 
 Description:
 Power Set P(S) of a set S is the set of all subsets of S.
 Power Set P(S) for a set S of <n> elements is 2^n elements.
 
 Approach :
 Iterate i from 0 to 2^n (as P(S) will have 2^n elements) and:
      Find the binary equivalent of i.
      Add the jth element from the array to the current subset when the jth
       bit of binary(i) is 1.
      Add the subset to powerset list at end of each iteration.
 """"""
 
 
 def binary(num, size):
     """"""
     num: int
     size: int
 
     Takes in a number and returns it's binary equivalent.
     Adds trailing zeroes at the beginning to make the
     length of binary equivalent equal to size.
     """"""
     binary_out = ''
     while num > 0:
         binary_out += str(num % 2)
         num //= 2
     binary_out += (size - len(binary_out)) * '0'
     return binary_out[::-1]
 
 
 def subsets(nums):
     """"""
     nums: List[int] of unique elements
     Returns a list of all possible subsets
     """"""
     n = len(nums)
     powerset = []
     for i in range(2 ** n):
         binary_eq = binary(i, n)
         subset = []
         for j in range(n):
             if binary_eq[j] == '1':
                 subset.append(nums[j])
         powerset.append(subset)
     return powerset
 
 
 if __name__ == ""__main__"":
     list_of_values = input(""Enter values seperated by space: "").split()
     print(""Power Set:"", subsets(list_of_values))
 
 # Sample Input-Output:
 
 # Sample Input 1:
 # Enter values seperated by space: 1 2 3
 # Sample Output 1:
 # Power Set: [[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]]
 
 # Sample Input 2:
 # Enter values seperated by space: 1 2 -1 0
 # Sample Output 2:
 # Power Set: [[], [0], [-1], [-1, 0], [2], [2, 0], [2, -1], [2, -1, 0],
 # [1], [1, 0], [1, -1], [1, -1, 0], [1, 2], [1, 2, 0],
 # [1, 2, -1], [1, 2, -1, 0]]
 
 # Time Complexity: O(N * 2*N)
 # Space Complexity: O(2*N)
",Python
"import java.util.Scanner;
 
 public class DFS{
 
 	//dfs function for connected graph
 	public static void dfsHelper(int[][] edges,
 	 int noVertices, int startVertex, boolean[] visited){
 
 	 	System.out.print(startVertex +  "" "");
 	 	visited[startVertex] = true;
 
 	 	for(int i = 0; i < noVertices; i++){
 	 		if(i == startVertex)
 	 			continue;
 
 	 		/*If there is an edge b/w starting vertex
 	 		and curr vertex, call print on curr vertex */
 	 		if(edges[startVertex][i] == 1){
 
 	 			/*If we have already visited curr vertex,
 	 			we will not call print on it */
 	 			if(visited[i])
 	 				continue;
 
 	 			dfsHelper(edges, noVertices, i, visited);
 	 		}
 	 	}
 
 	}
 
 	//this works for disconnected graph also
 	public static void dfs(int[][] edges, int noVertices){
 		boolean[] visited = new boolean[noVertices];
 
 		for(int i = 0; i < noVertices; i++){
 			if(!visited[i])
 				dfsHelper(edges, noVertices, i, visited);
 		}
 
 	}
 
 	public static void main(String[] args) {
 		Scanner scanner = new Scanner(System.in);
 
 		System.out.println(""Enter the number of vertices in Graph : "");
 		int n = scanner.nextInt();  // no. of vertices
 
 		System.out.println(""Enter the number of edges in the Graph : "");
 		int e = scanner.nextInt();  // no. of edges
 
 		// Adjacency Matrix
 		int[][] edges = new int[n+1][n+1];
 
 		//Take input of all edges
 		System.out.println(""Enter the edges :"");
 		for(int i = 0; i < e; i++){
 			int firstVertex = scanner.nextInt();
 			int secondVertex = scanner.nextInt();
 			edges[firstVertex][secondVertex] = 1;
 			edges[secondVertex][firstVertex] = 1;;
 		}
 
 		System.out.println(""DFS Traversal : "");
 		dfs(edges, n);
 	}
 }
 
 /*
 Sample Case : 
 Enter the number of vertices in Graph : 
 10
 Enter the number of edges in the Graph : 
 8
 Enter the edges :
 1 2
 1 3
 2 4
 4 6
 3 5
 5 0
 7 8
 8 9
 DFS Traversal : 
 0 5 3 1 2 4 6 7 8 9
 */
 	 
",Java
"import java.util.*;
 
 class target_sum_triplets {
     
     public static void main(String args[]) {
         Scanner sc = new Scanner(System.in); // input
         int n = sc.nextInt(); //  array size
 
         int arr[] = new int[n];
 
         for (int i = 0; i < n; i++){
             arr[i] = sc.nextInt();// array elements
         }
 
         int target = sc.nextInt(); // target sum
 
         Arrays.sort(arr);
 
         for (int j = 0; j < n - 1; j++) {
             int start = j + 1;
             int end = n - 1;
 
             while (start < end) {
 
                 if (arr[j] + arr[start] + arr[end] == target) {
                     System.out.println(arr[j] + "", "" + arr[start] + "" and "" + arr[end]); // output 
                     start++;
                     end--;
                 } else if (arr[j] + arr[start] + arr[end] < target)
                     start++;
 
                 else
                     end--;
             }
         }
     }
 }
 
 /* Sample Input Output ->
 Input
 9
 5 7 9 1 2 4 6 8 3
 10
 
 Output
 1, 2 and 7
 1, 3 and 6
 1, 4 and 5
 2, 3 and 5 
 
 Complexity Analysis
 
 Time Complexity - O(n^2)
 Space Complexity - O(1) */
",Java
"/*Farmer John has built a new long barn, with N (2 <= N <= 100,000) stalls.
 The stalls are located along a straight line at positions x1,...,xN (0 <= xi <= 1,000,000,000).
 His C (2 <= C <= N) cows don't like this barn layout and become aggressive towards each other once put into a stall. 
 To prevent the cows from hurting each other, FJ wants to assign the cows to the stalls, 
 such that the minimum distance between any two of them is as large as possible. 
 What is the largest minimum distance?*/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 bool canplacecows(int stalls[], int n, int c, int min_sep)
 {
 	int last_cow = stalls[0];
 	int cnt = 1;
 	for (int i = 1; i < n; i++)
 	{
 		if (stalls[i] - last_cow >= min_sep)
 		{
 			last_cow = stalls[i];
 			cnt++;
 			if (cnt == c)
 			{
 				return true;
 			}
 		}
 	}
 
 	return false;
 }
 
 int main()
 {
 	int stalls[100], n, cows;
 	cout<<""Enter the the total no of stalls and cows: "";
 	cin >> n >> cows;
 
 	for (int i = 0; i < n; ++i)
 	{
 		cin >> stalls[i];
 	}
 
 	int start = 0;
 	int end = stalls[n - 1] - stalls[0];
 	int ans = 0;
 	while (start <= end)
 	{
 		int mid = (start + end) / 2;
 		bool canplacecow = canplacecows(stalls, n, cows, mid);
 		
 		if (canplacecow)
 		{
 			ans = mid;
 			start = mid + 1;
 		}
 		else
 		{
 			end = mid - 1;
 		}
 	}
 
 	cout << ""the largest minimum distance: "" << ans << ""\n"";
 	return 0;
 }
 /* Example :
 1)Input :
 5 3
 1 2 4 8 9
 Output : 3
 
 Time Complexity : O(nlog n)
 Space Complexity : O(n)
 
 */
",C-Plus-Plus
"package main
 
 import (
 	""fmt""
 	""math""
 	""strconv""
 	""strings""
 )
 
 // multiply takes in two numbers as string
 // and multiply them in recursive way
 func multiply(first, second string) string {
 	// if the number are small we don't need to use
 	// karatsuba multiplication
 	if len(first) < 2 || len(second) < 2 {
 		intA, _ := strconv.Atoi(first)
 		intB, _ := strconv.Atoi(second)
 		return strconv.Itoa(intA * intB)
 	}
 
 	if len(first)%2 == 1 {
 		first = ""0"" + first
 	}
 	if len(second)%2 == 1 {
 		second = ""0"" + second
 	}
 
 	// makeing the length of both number same
 	// added to fix uneven length factors
 	first, second = addZeroFront(first, second)
 
 	// split strings from middle
 	mid := getMiddle(first, second)
 	firstRight, firstLeft := splitNum(first, mid)
 	secondRight, secondLeft := splitNum(second, mid)
 
 	// making recursive calls
 	// for multiplication
 	leftMultiplication := multiply(firstLeft, secondLeft)
 	rightMultiplication := multiply(add(firstLeft, firstRight), add(secondLeft, secondRight))
 	temp := multiply(firstRight, secondRight)
 
 	t0 := sub(sub(rightMultiplication, temp), leftMultiplication)
 	t1 := add(addZeroEnd(leftMultiplication, mid*2), addZeroEnd(t0, mid))
 	t2 := add(t1, temp)
 	return trim(t2)
 }
 
 func getMiddle(first, second string) int {
 	mid := math.Max(float64(len(first)), float64(len(second)))
 	return int(mid / 2)
 }
 
 func splitNum(s string, mid int) (string, string) {
 	right := s[mid:]
 	left := s[:mid]
 	return right, left
 }
 
 func addZeroFront(first, second string) (string, string) {
 	if len(first) < len(second) {
 		first = strings.Repeat(""0"", len(second)-len(first)) + first
 	} else {
 		second = strings.Repeat(""0"", len(first)-len(second)) + second
 	}
 	return first, second
 }
 
 func addZeroEnd(s string, mid int) string {
 	return s + strings.Repeat(""0"", mid)
 }
 
 func trim(s string) string {
 	for s[:1] == ""0"" && len(s) > 1 {
 		s = s[1:]
 	}
 	return s
 }
 
 func add(first, second string) strin",Go
"// Given a value N, if we want to make change for N cents,
 // and we have infinite supply of each of S = { S1, S2, .. , Sm}
 // valued coins, how many ways can we make the change?
 // The order of coins doesnt matter.
 
 package main
 
 import ""fmt""
 
 // function to count coins
 func countCoins(coins []int, numberOfCoin, value int) int {
 	// creating 2d slice
 	dp := make([][]int, value+1)
 	for itr := 0; itr <= value; itr++ {
 		dp[itr] = make([]int, numberOfCoin)
 	}
 
 	// value if n = 0
 	for i := 0; i < numberOfCoin; i++ {
 		dp[0][i] = 1
 	}
 
 	// bottom up manner
 	for i := 1; i < value+1; i++ {
 		for j := 0; j < numberOfCoin; j++ {
 
 			var x int
 			if i-coins[j] >= 0 {
 				x = dp[i-coins[j]][j]
 			} else {
 				x = 0
 			}
 
 			var y int
 			if j >= 1 {
 				y = dp[i][j-1]
 			} else {
 				y = 0
 			}
 
 			dp[i][j] = x + y
 		}
 	}
 	return dp[value][numberOfCoin-1]
 }
 
 func main() {
 	fmt.Print(""Enter the number of coins : "")
 	var numberOfCoin int
 	fmt.Scan(&numberOfCoin)
 
 	fmt.Print(""Enter the value of coins : "")
 	coins := make([]int, numberOfCoin)
 	for itr := 0; itr < numberOfCoin; itr++ {
 		fmt.Scan(&coins[itr])
 	}
 
 	fmt.Print(""Enter the amount : "")
 	var value int
 	fmt.Scan(&value)
 
 	count := countCoins(coins, numberOfCoin, value)
 
 	fmt.Println(""Number of coins : "", count)
 }
 
 // Time complexity : O(numberOfCoin * value)
 // Space complexity : O(numberOfCoin * value)
 
 // TEST CASE 1:
 // Enter the number of coins : 3
 // Enter the value of coins : 1 2 3
 // Enter the amount : 4
 // Number of coins :  4
 
 // TEST CASE 2:
 // Enter the number of coins : 4
 // Enter the value of coins : 2 5 3 6
 // Enter the amount : 10
 // Number of coins :  5
",Go
"/*
 Depth first search is a graph traversal technique.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 void dfs(int source, vector <int> adj[],bool visited[]){
     //visit the source
     cout<<source<<"" "";
     //mark visited as true
     visited[source] = true;
     //Traverse all its adjacents
     for(auto s:adj[source]){
         //Check if the adjacent is not visited
         if(!visited[s]){
             //Do the same for this vertex i.e. call dfs for this adjacent as source
             //This lets you reach the depth of the graph, So you traverse down a hirearchy instead of going to all adjacents as we do in bfs
             dfs(s,adj,visited);
         }
     }
 }
 int main(){
     int n,m; cin>>n>>m;
     vector <int> adj[n];
     int a,b;
     for(int i=0;i<m;i++){
         cin>>a>>b;
         adj[a].push_back(b);
         adj[b].push_back(a);
     }
     bool visited[n];
     memset(visited,false,sizeof(visited));
     //Calling dfs for all non visited graphs to cover non connected compnents in graph
     for(int i=0;i<n;i++){
         if(!visited[i]){
             dfs(i,adj,visited);
         }
     }cout<<endl;
     return 0;
 }
 /*
 Input:
 4 5
 0 1
 2 3
 1 3
 0 3
 1 2
 Output:
 0 1 3 2
 
 Time Complexity: O(n+m) //Sum of vertices and edges
 Space Complexity: O(n)  //For the visited array
 */
",C-Plus-Plus
"#include <stdio.h>
 
 #define MAX 30
 
 typedef struct edge {
   int u, v, w;
 } edge;
 
 typedef struct edge_list {
   edge data[MAX];
   int n;
 } edge_list;
 
 edge_list elist;
 
 int Graph[MAX][MAX], n;
 edge_list spanlist;
 
 void kruskalAlgo();
 int find(int belongs[], int vertexno);
 void applyUnion(int belongs[], int c1, int c2);
 void sort();
 void print();
 
 // Applying Krushkal Algo
 void kruskalAlgo() {
   int belongs[MAX], i, j, cno1, cno2;
   elist.n = 0;
 
   for (i = 1; i < n; i++)
     for (j = 0; j < i; j++) {
       if (Graph[i][j] != 0) {
         elist.data[elist.n].u = i;
         elist.data[elist.n].v = j;
         elist.data[elist.n].w = Graph[i][j];
         elist.n++;
       }
     }
 
   sort();
 
   for (i = 0; i < n; i++)
     belongs[i] = i;
 
   spanlist.n = 0;
 
   for (i = 0; i < elist.n; i++) {
     cno1 = find(belongs, elist.data[i].u);
     cno2 = find(belongs, elist.data[i].v);
 
     if (cno1 != cno2) {
       spanlist.data[spanlist.n] = elist.data[i];
       spanlist.n = spanlist.n + 1;
       applyUnion(belongs, cno1, cno2);
     }
   }
 }
 
 int find(int belongs[], int vertexno) {
   return (belongs[vertexno]);
 }
 
 void applyUnion(int belongs[], int c1, int c2) {
   int i;
 
   for (i = 0; i < n; i++)
     if (belongs[i] == c2)
       belongs[i] = c1;
 }
 
 // Sorting algo
 void sort() {
   int i, j;
   edge temp;
 
   for (i = 1; i < elist.n; i++)
     for (j = 0; j < elist.n - 1; j++)
       if (elist.data[j].w > elist.data[j + 1].w) {
         temp = elist.data[j];
         elist.data[j] = elist.data[j + 1];
         elist.data[j + 1] = temp;
       }
 }
 
 // Printing the result
 void print() {
   int i, cost = 0;
 
   for (i = 0; i < spanlist.n; i++) {
     printf(""\n%d - %d : %d"", spanlist.data[i].u, spanlist.data[i].v, spanlist.data[i].w);
     cost = cost + spanlist.data[i].w;
   }
 
   printf(""\nSpanning tree cost: %d"", cost);
 }
 
 int main() {
   int i, j, total_cost;
 
   n = 6;
 
   Graph[0][0] = 0;
   Graph[0",C
"# Python Program to multiply two numbers using Russian Peasant method
 
 # Function to multiply two numbers using Russian Peasant method
 
 
 def russianPeasant(number1, number2):
 
     result = 0
 
     # While second number doesn't
     # become 1
     while (number2 > 0):
 
         # If second number becomes odd, add the first number to result
         if (number2 & 1):
             result = result + number1
 
         # Double the first number and halve the second number
         number1 = number1 << 1       # bitwise left shift operator
         number2 = number2 >> 1       # bitwise right shift operator
 
     return print(""Result is"", result)
 
 # Driver code
 number1 = int(input(""Enter 1st Number:""))
 number2 = int(input(""Enter 2nd Number:""))
 russianPeasant(number1, number2)
 
 '''
 Sample I/O:
     Input:
     Enter 1st Number:5
     Enter 2nd Number:5
 
     Output:
     Result is 25
 
 Time complexity: (1)
 Space complexity: (1)
 '''
",Python
"// Author : @belikesayantan
 
 package main
 
 import (
 	""bufio""
 	""errors""
 	""fmt""
 	""log""
 	""os""
 	""strconv""
 	""strings""
 	""time""
 )
 
 func main() {
 	var strArray []string
 	var intArray []int
 
 	fmt.Println(""Enter an array with spaces"")
 	reader := bufio.NewReader(os.Stdin)
 	arr, err := reader.ReadString('\n')
 	if err != nil {
 		inputErr := errors.New(""something is wrong with your array input"")
 		log.Fatal(inputErr)
 	}
 	arr = strings.TrimSpace(arr)
 	strArray = strings.Split(arr, "" "")
 
 	for _, val := range strArray {
 		ele, err := strconv.Atoi(val)
 		if err != nil {
 			panic(err)
 		}
 		intArray = append(intArray, ele)
 	}
 
 	start := time.Now() // timer starts and records running time of InsertionSort Algorithm
 	fmt.Println(""Sorted Array is: "", InsertionSort(intArray))
 	end := time.Now() // timer stops and recording running time of InsertionSort Algorithm is completed
 
 	fmt.Println(""\nRunning Time of InsertionSort Algorithm is: "", end.Sub(start))
 }
 
 // InsertionSort Algorithm Time Complexity : O(n^2)
 func InsertionSort(arr []int) []int {
 	if len(arr) == 0 {
 		return nil
 	}
 
 	if len(arr) == 1 {
 		return arr
 	}
 
 	for i := 0; i < len(arr); i++ {
 		j := i
 		key := arr[j]
 
 		for i > 0 && key < arr[i-1] {
 			arr[i] = arr[i-1]
 			i--
 		}
 		arr[i] = key
 
 	}
 
 	return arr
 }
 
 /*
 	I/O Sample:
 
 	Sample 1:
 	 go run insertionSort.go
 	Enter an array with spaces
 	5 3 2 4 5 84 6 1 54
 	Sorted Array is:  [1 2 3 4 5 5 6 54 84]
 
 	Running Time of InsertionSort Algorithm is:  29.736s
 
 
 	Sample 2:
 	 go run insertionSort.go
 	Enter an array with spaces
 	5 8 6 9 1 3 2 7 4
 	Sorted Array is:  [1 2 3 4 5 6 7 8 9]
 
 	Running Time of InsertionSort Algorithm is:  32.004s
 
 
 
 	Time Complexity:
 		1. (n) in best case
 		2. O(n^2) in average case
 		3. O(n^2) in worst case
 
 	Space Complexity: O(1) in worst case
 
 */
",Go
"/*
 A program written in C language to detect the middle element of a linkedlist. 
 The approach used is the Two-pointer Approach. 
 In this approach, we use 2 pointers, assign both to the head. We move the first pointer by one mode and the other pointer by two nodes, such that when the second pointer reaches the end, the first pointer reaches the middle. Hence, we are able to detect the middle element of the linkedlist.
 */
 #include<stdio.h>  
 #include<stdlib.h>  
   
 /*Defining a Node*/
 struct Node  
 {  
     int val;  
     struct Node* next;  
 };  
 /*Fuction to dtetct the middle element*/
 void detectMiddle(struct Node *head)  
 {  
     struct Node *first_ptr = head;  
     struct Node *second_ptr = head;  
   
     if (head!=NULL)  
     {  
         while (second_ptr != NULL && second_ptr->next != NULL)  
         {  
             second_ptr = second_ptr->next->next;  
             first_ptr = first_ptr->next;  
         }  
         printf(""The middle element is %d\n"", first_ptr->val);  
     }  
 }  
 /*A Function to push the element at the end of the linkedlist*/  
 void push(struct Node** head_ref, int new_data)  
 {  
     
     struct Node* new_node =  
         (struct Node*) malloc(sizeof(struct Node));  
   
     
     new_node->val = new_data;  
   
    
     new_node->next = (*head_ref);  
   
     
     (*head_ref) = new_node;  
 }  
 /* Driver function*/
 int main()  
 {  
     struct Node* head = NULL;  
     int i;
     printf(""Enter the number of elements in the linkedlist ""); 
     scanf(""%d"",&i); 
     for (int p=i; p>0; p--)  
     {  
         int c;
         printf(""\nEnter the element "");
         scanf(""%d"",&c);
         push(&head, c);  
     }  
      detectMiddle(head); 
     return 0;  
 }  
 
 /*
 Output: 
 Enter the number of elements 5
 Enter the element 2
 Enter the element 3
 Enter the element 1
 Enter the element 6
 Enter the element 7
 The middle element is 1
 */",C
"/* Java Program to implement a stack using two queues
 by making the push operation costly*/
 
 import java.util.*;
 
 public class StackUsingQueue {
     static class Stack {
         // the 2 queues
         Queue<Integer> qu1 = new LinkedList<>();
         Queue<Integer> qu2 = new LinkedList<>();
 
         // storing current size
         int currentSize;
 
         Stack() {
             currentSize = 0;
         }
 
         void push(int num) {
             currentSize++;
 
             // first, push num into an empty qu2
             qu2.add(num);
 
             // now we push the other elements from qu1 to qu2
             while (!qu1.isEmpty()) {
                 qu2.add(qu1.peek());
                 qu1.remove();
             }
         }
 
         void pop() {
             if (qu2.isEmpty()) {
                 return;
             }
 
             // remove element and reduce size if qu2 not empty
             qu2.remove();
             currentSize--;
         }
 
         int top() {
             if (qu2.isEmpty()) {
                 return -1;
             }
 
             // return the top element
             return qu2.peek();
         }
 
         int size() {
             return currentSize;
         }
     }
 
     public static void main(String[] args) {
         Stack stack = new Stack();
 
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter size:"");
         int size = sc.nextInt();
         System.out.println(""Enter the numbers:"");
         for (int i = 0; i < size; i++) {
             stack.push(sc.nextInt());
         }
         sc.close();
 
         System.out.println(""Current Size:"" + stack.size());
         for (int i = size; i > 0; i--) {
             System.out.println(stack.top());
             stack.pop();
         }
         System.out.println(""Current Size:"" + stack.size());
     }
 }
 
 /**
  * Sample input/output:
  * 
  * Enter size:
  * 5
  * Enter the numbers:
  * 5
  * 4
  * 3
  * 2
  * 1
  * C",Java
"/*
 Implementing Bilinear search by using DART.
 
 Given an array of integers, check wether the element to search exists or not in
 the array, and if it exists find its position.
 */
 import 'dart:io';
 
 int bilinearSearch(var array, int key) {
   int front = 0;
   int back = array.length - 1;
 
   while (front <= back) {
     if (array[front] == key) return front + 1;
     if (array[back] == key) return back + 1;
     front += 1;
     back -= 1;
   }
   return -1;
 }
 
 void main() {
   var data = [];
 
   // taking input from user and storing it in data array
   var n, ele, key;
   print('Enter the number of Elements: ');
   n = stdin.readLineSync();
   n = int.parse(n);
 
   for (int i = 1; i <= n; i++) {
     print('Enter Element $i: ');
     ele = stdin.readLineSync();
     ele = int.parse(ele);
     data.add(ele);
   }
 
   print(""\nInputted array is $data"");
 
   print(""\nEntered the element you want to search: "");
   key = stdin.readLineSync();
   key = int.parse(key);
 
   int found = bilinearSearch(data, key);
   if (found != -1)
     print(""Element found at position: $found"");
   else
     print(""Element not found!!!"");
 }
 
 /*
 TIME COMPLEXITY: O(n)
 SPACE COMPLEXITY: O(1)
 
 Sample I/O:
 Example 1:
 
 Enter the number of Elements: 
 5
 Enter Element 1: 
 2
 Enter Element 2: 
 23
 Enter Element 3: 
 4
 Enter Element 4: 
 5
 Enter Element 5: 
 6
 
 Inputted array is [2, 23, 4, 5, 6]
 
 Entered the element you want to search:
 7
 Element not found!!!
 
 Example 2:
 
 Enter the number of Elements: 
 5
 Enter Element 1: 
 89
 Enter Element 2: 
 34
 Enter Element 3: 
 16
 Enter Element 4: 
 60
 Enter Element 5: 
 33
 
 Inputted array is [89, 34, 16, 60, 33]
 
 Entered the element you want to search:
 16
 Element found at position: 3
 */
",Dart
"/*
 
 Convex Hull (Jarvis's Algorithm)
 
 Convex Hull is the outermost polygon that can be formed from a set of
 points such that it encloses all other points in the set and none of its corners
 are bent inwards.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // POINT data structure
 typedef struct POINT
 {
 	int x;
 	int y;
 } POINT;
 
 // Gives orientation of p->q->r
 int orientation(POINT p, POINT q, POINT r)
 {
 	int slope = (p.y - r.y) * (p.x - q.x) - (p.y - q.y) * (p.x - r.x);
 	// clockwise
 	if (slope > 0)
 		return 1;
 	// anti-clockwise
 	if (slope < 0)
 		return -1;
 	// collinear
 	else
 		return 0;
 }
 
 // Prints point
 void printPoint(POINT a)
 {
 	cout << a.x << "" "" << a.y;
 }
 
 // Returns whether two points are same
 bool isSame(POINT a, POINT b)
 {
 	return (a.x == b.x && a.y == b.y) ? 1 : 0;
 }
 
 // Prints the points in convex hull
 void convexHull(POINT arr[], int n)
 {
 	if (n < 3)
 		return;
 
 	// Stores the points in convex hull
 	vector<POINT> result;
 
 	// Find the leftmost point
 	int leftMost = 0; // Index of leftMost point
 	for (int i = 0; i < n; i++)
 	{
 		if (arr[leftMost].x > arr[i].x)
 		{
 			leftMost = i;
 		}
 	}
 
 	// leftMost point will be part of convex hull
 	result.push_back(arr[leftMost]);
 
 	int curr = leftMost;
 	while (1)
 	{
 		// Index of next target which can potentially be in hull
 		int nextTarget = (curr + 1) % n;
 
 		// Checking whether nextTarget can be in hull
 		// nextTarget will be part of hull if there doesnot exist a point which is
 		// more anti-clockwise than curr -> nextTarget
 		for (int i = 0; i < n; i++)
 		{
 			int o = orientation(arr[curr], arr[i], arr[nextTarget]);
 			if (o == -1)
 			{
 				// curr -> i is more anticlockwise than curr -> nextTarget
 				nextTarget = i;
 			}
 		}
 
 		// If nextTarget comes back to start, it implies that there
 		// are no more points to be added in hull
 		if (nextTarget == leftMost)
 			break;
 
 		// Push nextTarget to hull
 		result.push_ba",C-Plus-Plus
"/*Vigenere Cipher Algorithm is a famous cryptographic algorithm.
 Vigenre cipher is a method of encrypting alphabetic text by using a series of interwoven Caesar ciphers*/
 
 #include <bits/stdc++.h>
 using namespace std;
 
 string encryption(string message, int x, string key) {
 	string cipher;
 	for (int i = 0; i < message.size(); ++i) {
 		int t=(message[i] + key[i%x])%26;
 		cipher+=('A'+t);
 	}
 	return cipher;
 }
 
 string decryption(string cipher, int x, string key) {
 	string message;
 	for (int i = 0; i < cipher.size(); ++i) {
 		int t=(cipher[i] - key[i%x] +26)%26;
 		message+=('A'+t);
 	}
 	return message;
 }
 
 int main() {
 
 	//use only uppercase character
 	int choice;
 	cout << ""Choose 1 if you want to ENCRYPT or 2 if you want to DECRYPT: "";
 	cin >> choice;
 
 	if(choice == 1) {
 		string message;
 		cout << ""Enter a plaintext message: "";
 		cin >> message;
 
 		string key;
 		cout << ""Enter a keyword: "";
 		cin >> key;
 
 		cout << ""\nEncrypted message: "" << encryption(message, key.size(), key);
 		cout << endl;
 	}
 
 	else if(choice == 2) {
 		string ciphertext;
 		cout << ""Enter a ciphertext: "";
 		cin >> ciphertext;
 
 		string key;
 		cout << ""Enter a keyword: "";
 		cin >> key;
 
 		cout << ""\nDecrypted message: "" << decryption(ciphertext, key.size(), key);
 		cout << endl;
 	}
 
 	else {
 		cout << ""\nInvalid choice."" << endl;
 	}
 	return 0;
 }
 
 /* 
 Sample I/O:
 
 1)
 Choose 1 if you want to ENCRYPT or 2 if you want to DECRYPT: 1
 Enter a plaintext message: NEOALGO
 Enter a keyword: MARS
 
 Encrypted message:  ZEFSXGF
 
 2)
 Choose 1 if you want to ENCRYPT or 2 if you want to DECRYPT: 2
 Enter a ciphertext: ZEFSXGF
 Enter a keyword: MARS
 
 Decrypted message: NEOALGO
 */
",C-Plus-Plus
"const findPalindrome = (str) => {
   sequence = processString(str);
 
   // array for holding the palindromic sequence around every center
   let positions = [];
   let start = 0;
   let end = 0;
 
   // i is our current center
   for (let i = 0; i < sequence.length;) {
 
       // we check on both sides of i till where we can find same letters on 2
       // positions
       while (start > 0 && end < sequence.length - 1 && sequence[start - 1] === sequence[end + 1]) {
           start--;
           end++;
       }
 
       // getting the length of palindrome around current center
       positions.splice(i, 0, end - start + 1);
 
       // this is case 2. Current palindrome is proper suffix of input. Meaning input
       // is the longest palindrome
       if (end === (sequence.length - 1)) {
           break;
       }
 
       // Mark newCenter to be either end or end + 1 depending on if we dealing with
       // even or old number input.
       let newCenter = end + (i % 2 == 0 ? 1 : 0);
 
       for (let j = i + 1; j <= end; j++) {
 
           // Its possible left mirror might go beyond current center palindrome. So take
           // minimum of either left side palindrome or distance of j to end.
           // T[j] = Math.min(T[i - (j - i)], 2 * (end - j) + 1);
           num = positions[Math.abs(i - (j - i))];
           positions.splice(j, 0, (Math.min(num, (2 * (end - j) + i))));
 
           // This check is to make sure we do not pick j as new center. As soon as we find
           // a center lets break out of this inner loop.
           if (j + parseInt(positions[i - (j - i)] / 2) === end) {
               newCenter = j;
               break;
           }
       }
 
       // make i as newCenter. Set right and left to atleast the value we already know
       // should be matching based of left side palindrome.
       i = newCenter;
       if (i < positions.length) {
           end = i + parseInt(positions[i] / 2);
           start = i - parseInt(positions[",JavaScript
"/*
     Sleep sort is a sorting algorithm used to sort non-negative integers. Sleep sort works by creating a separate thread for each item in the input which is to be sorted and then each thread sleeps for an amount of time which is proportional to the value of corresponding array element. Therefore, the thread which is having the least amount of sleep time wakes up first and the element gets printed and then the second least element and so on. The largest element wakes up after a long time and then the element gets printed at the last and thus the output obtained is a sorted array.
         
 */
 
 import java.util.Scanner;
 import java.util.concurrent.*;
 
 public class SleepSort {
 
     public static void main(String[] args) {
         Scanner sc = new Scanner(System.in);
 
         System.out.println(""Enter the number of elements in an array: "");
         int number = sc.nextInt();
 
         System.out.println(""\nEnter the elements in an array: "");
         int array[] = new int[number];
 
         for (int i = 0; i < number; i++) {
             array[i] = sc.nextInt();
 
         }
         sleepSort(array);
     }
 
     public static void sleepSort(int[] array) {
         
         // CountDownLatch in java is used to make sure that a task waits for other threads before it starts.
         // Here the task is going to wait for threads which is equal to array length before it starts.
         final CountDownLatch countDone = new CountDownLatch(array.length);
         System.out.println(""\nThe sorted array is: "");
         
         for (final int num : array) {
             // Creates a new thread.
             new Thread(new Runnable() {
                 public void run() {
                     // Decrements the count of the countDone
                     countDone.countDown();
                     try {
                         //Causes the current thread to wait until the countDone has counted down to zero
                         countDone.await();
     ",Java
"/*
 RabinKarp algorithm or KarpRabin algorithm is a string-searching algorithm that uses hashing to find an exact match of a pattern string in a text. 
 It uses a rolling hash to quickly filter out positions of the text that cannot match the pattern, and then checks for a match at the remaining positions.
 */
 import java.util.*;
 class  Main
 {
     public static void main( String[] args )
  {
    String actualText , patternToBeSearched;
    Scanner sc=new Scanner(System.in);
    System.out.println( ""Enter actual text"" ) ;
    actualText = sc.nextLine();
    System.out.println( ""Enter pattern to be searched"" );
    patternToBeSearched = sc.nextLine();
    int indexI , indexJ , locationIndex = -1 , count = 0;
    long sumOfCharactersOfTempString = 0 ,sumOfCharactersOfPatternToBeSearched = 0;
    for( indexI = 0; indexI < patternToBeSearched.length() ; indexI++ )
    {
        sumOfCharactersOfPatternToBeSearched = sumOfCharactersOfPatternToBeSearched + (long) (patternToBeSearched.charAt(indexI) * Math.pow(127,patternToBeSearched.length()-1-indexI) );
    }
    for( indexI = 0; indexI <= actualText.length() - patternToBeSearched.length(); indexI++ )
    {
        sumOfCharactersOfTempString = 0; indexJ = indexI;
        for( count = 0; count < patternToBeSearched.length(); count++ )
         {   
             sumOfCharactersOfTempString = sumOfCharactersOfTempString + (long)( actualText.charAt(indexJ) * Math.pow(127,patternToBeSearched.length()-1-count) );
             indexJ++;
         }
         if( sumOfCharactersOfTempString == sumOfCharactersOfPatternToBeSearched)
         locationIndex = indexI;
          
     }
     if(locationIndex != -1)
     System.out.println( ""Pattern found at index "" + locationIndex );
     else
     System.out.println( ""Pattern not found"" );
     }
 }
",Java
"""""""
 Connected Components:- In an undirected graph, a connected
         component is a subgraph such that there exists at least
         one path connecting any of the two nodes of that graph.
 Purpose: Given an undirected graph with N nodes and M edges where
         each node is numbered between 1 and N find the total number
         of connected components in the graph.
 Method: Breadth-First Search
 Intuition: For every node of the graph that is not yet visited,
         1. we will call BFS() function to traverse the graph and
             marking the nodes visited.
         2. increase the count of connected components by 1
 Time Complexity:  O(N+M)
 Space Complexity: O(N)
 Argument: Dictionary ( Graph )
 Return:   Integer    ( Number of connected components )
 """"""
 from collections import defaultdict, deque
 
 
 # Breadth-First Search
 def BFS(graph, node, visited):
 
     # Initilizing the queue with the source node and mark the node visited
     q = deque([node])
     visited[node] = 1
 
     while q:
         # Pop the leftmost node of the queue
         v = q.popleft()
 
         for each in graph[v]:
 
             # If the node is not visited yet, then mark it visited and push
             # into the queue
             if not visited[each]:
                 visited[each] = 1
                 q.append(each)
 
     return 1
 
 
 def Connected_Components(n, graph):
 
     # Variable visited to keep a track of already visited nodes
     visited = [0] * (n + 1)
 
     # To count the number of Connected Components
     count = 0
 
     # Iterate through each node and check if it is visited or not
     for i in range(1, n + 1):
 
         # if not visited, call BFS() function and increase the count by 1
         if not visited[i]:
             BFS(graph, i, visited)
             count += 1
 
     # Return the answer
     return count
 
 
 # ------------------------------- DRIVER CODE -----------------------------
 
 if __name__ == ""__main__"":
 
     n, m = map",Python
"""""""
 Given n non-negative integers representing an elevation map where the 
 width of each bar is 1, compute how much water it can trap after raining.
 """"""
 
 # function to find the water trapped
 def trap(arr, n):
     if n < 3:
         return 0
 
     # initialize the values
     water, i, j = 0, 1, n-2
     left = arr[0]
     right = arr[n-1]
 
     while i <= j:
 
         # fill left
         if left <= right:
             left = max(left, arr[i])
             water += left - arr[i]
             i += 1
 
         # fill right
         else:
             right = max(right, arr[j])
             water += right - arr[j]
             j -= 1
 
     # return result
     return water
     
 # Driver's code
 if __name__ == ""__main__"":
     # creating an empty lists
     arr = []
     n = int(input('Enter length of array: '))
     arr = list(map(int,input(""\nEnter elements of array: "").strip().split()))[:n]
 
     print('Water trapped is is: ' +
         str(trap(arr, n)))
 
 """"""
 Time Complexity: O(n)
 Space Complexity: O(n)
 
 Example 1:
 
 Input:
 Enter number of elements: 
 12
 Enter the elements: 
 0 1 0 2 1 0 1 3 2 1 2 1
 
 Output:
 Water it can trap is: 6
 
 """"""
",Python
"/*
 The worst fit strategy is a reverse of the best-fit strategy. It allocates the largest block available in the storage list.
 The idea behind worst-fit is to reduce the rate of production of small blocks. The below program is an implementation of
 the worst fit algorithm using array data structure.
 */
 
 class Block{
     constructor(){
         this.size = 0
         this.ID = 0
         this.fragment = 0
     }
 }
 
 class Process{
     constructor(){
         this.Num = 0
         this.size = 0
         this.block = null
     }
 }
 
 class Worstfit{
     initialiseBlocks(arr,sizes,n){
         for(let i=0;i<n;i++){
             arr[i].size = sizes[i]
             arr[i].fragment = sizes[i]
             arr[i].ID = i + 1
         }
     }
 
     printResult(arr2, numOfProcess){
         console.log(
         ""Process No            Process Size          Block ID          Block Size         Block Fragment""
         );
         for(let i=0;i<numOfProcess;i++){
             console.log(
                 arr2[i].Num
                 + ""                     ""
                 + arr2[i].size
                 + ""                     ""
                 + arr2[i].block.ID
                 + ""                     ""
                 + arr2[i].block.size
                 + ""                     ""
                 + arr2[i].block.fragment
             )
         }
 
     }
     worstfit(arr, sizes, n, arr2, numOfProcess){
         let maxBlock = new Block()
         for(let i = 0; i <numOfProcess;i++){
             let max = 0
             for(let j=0;j<n;j++){
                 if(arr2[i].size <= arr[j].fragment && arr[j].fragment > max){
                     max = arr[j].fragment
                     maxBlock = arr[j]
                 }
             }
             maxBlock.fragment = maxBlock.fragment - arr2[i].size
             arr2[i].block = new Block()
             arr2[i].block.size = maxBlock.size
             arr2[i].block.ID = maxBlock.ID
             arr2[i].block",JavaScript
"/* This code is an implementation of caesar cipher. Here the 
 plaintext is shifted by a fixed amount. The shift is chosen by
 the user. Each alphabet of plaintext is then converted to decimal,
 shifted, and then again converted back to ascii to form the 
 ciphertext. Here the input plaintext must be all in lowercase*/
 
 package main
 
 import (
 	""fmt""
 	""bufio""
 	""os""
 )
 
 // This is the encryption function
 func caesar(plaintext string, shift int) string {
 
 	/* Updating the plaintext by replacing all
 	the spaces with underscores.*/
 	var message string
 	for j:= 0; j < len(plaintext); j++ {
 		if(string(plaintext[j]) == "" "") {
 			message += string(""_"")
 		} else {
 			message += string(plaintext[j])
 		}
 	}
 
 	// Cipher text string
 	var cipher string
 	// Iterating through each alphabet of plaintext
 	for i:=0; i < len(message); i++ {
 		/* Shift the alphabets of plaintext. If it is
 		an underscore, add a space in ciphertext*/
 		if(string(message[i]) != ""_"") {
 			var temp int = (int(plaintext[i]) + shift - 97) % 26
 			temp = temp + 97
 			cipher += string(temp)
 		} else {
 			cipher += "" ""
 		}
 	}
 	// Return the ciphertext
 	return cipher
 }
 
 func main() {
 
 	// Taking plaintext as input from the user
 	fmt.Print(""Enter a plaintext: "")
 	scanner := bufio.NewScanner(os.Stdin)
 	scanner.Scan()
 	plaintext := scanner.Text()
 
 	// Taking the shift amount as input from user
 	var shift int
 	fmt.Print(""Enter the shift  : "")
 	fmt.Scan(&shift)
 
 	// Calling the encryption function, print the ciphertext
 	var ciphertext string = caesar(plaintext, shift)
 	fmt.Print(""\nEncrypted plaintext is: "", ciphertext, ""\n"")
 }
 
 /* Sample I/O:
 
 Enter a plaintext: this is a ciphertext
 Enter the shift  : 7
 
 Encrypted plaintext is: aopz pz h jpwolyalea
 
 */
 
",Go
"// A C++ program to print topological sorting of a DAG (Directed Acyclic Graph) 
 // using DFS approach
 
 #include<iostream> 
 #include <list> 
 #include <stack> 
 #include <conio.h>
 using namespace std; 
 
 class Graph 
 { 
 	int V;	// V = number of vertices 
 	list<int> *adj; 
 	void topologicalSortUtil(int v, bool visited[], stack<int> &Stack); 
 	
 	public: 
 	Graph(int V); 
 	void addEdge(int v, int w); 
 	void topologicalSort(); 
 }; 
 
 Graph::Graph(int V) 
 { 
 	this->V = V; 
 	adj = new list<int>[V]; 
 } 
 
 void Graph::addEdge(int v, int w) 
 {  
 	adj[v].push_back(w); // directed connection between 2 nodes in the graph
 } 
 
 void Graph::topologicalSortUtil(int v, bool visited[], stack<int> &Stack) 
 { 
 	visited[v] = true; 
 
 	list<int>::iterator i; 
 	for (i = adj[v].begin(); i != adj[v].end(); ++i) 
 		if (!visited[*i]) 
 			topologicalSortUtil(*i, visited, Stack); 
 
 	Stack.push(v); 
 } 
 
 // The function is used to do Topological Sort. It uses recursive topologicalSortUtil() 
 void Graph::topologicalSort() 
 { 
 	stack<int> Stack;  
 	bool *visited = new bool[V]; 
 	for (int i = 0; i < V; i++) 
 		visited[i] = false; 
 
 	for (int i = 0; i < V; i++) 
 		if (visited[i] == false) 
 			topologicalSortUtil(i, visited, Stack); 
 
 	// Print contents of stack 
 	while (Stack.empty() == false) 
 	{ 
 		cout << Stack.top() << "" ""; 
 		Stack.pop(); 
 	} 
 } 
 
 int main() 
 { 
 	/*
 	int nodes, x, y;
 	cout << ""Enter the number of nodes in the graph: "";
 	cin >> nodes;
 	Graph g(nodes); 
 
 	cout << ""Enter the edges of the graph: \n"";
 	for(int i = 0; i < nodes; i++){
 		cin >> x >> y;
 		g.addEdge(x, y);
 	}
 	*/
 	Graph g(6); 
 	g.addEdge(5, 2); 
 	g.addEdge(5, 0); 
 	g.addEdge(4, 0); 
 	g.addEdge(4, 1); 
 	g.addEdge(2, 3); 
 	g.addEdge(3, 1);
 
 	cout << ""\nFollowing is a Topological Sort of the given graph \n""; 
 	g.topologicalSort(); 
 
 	return 0; 
 } ",C-Plus-Plus
"/* This is a program in go language to check if the number given is kaprekar
    number or not. A kaprekar number is a number where sum of the half parts
    of the squared digits of the orginal number is same as the input number.
    Example : 9 -> 81 -> 8+1 -> 9
    So, 9 is a kaprekar number.
 */
 
 package main
 
 import (
 
   ""fmt""
   ""math""
 
 )
 
 //global variables we use
 var n int
 var digits int
 var square int
 var sum int
 
 // This function calculates the count of the digit we send to it
 func digitcnt(){
 
   digits = 0
   for square != 0 {
 
      digits += 1
      square = square/10
   }
 
   square = n*n
 }
 
 // This function tells us if a number is a kaprekar number or not
 func kaprekar(n int) int {
 
    // Base case
    if(n == 1) {
      fmt.Printf(""The given number is a kaprekar number!"")
      return 1;
 
    }
 
    // calling the digits count
    digitcnt()
 
    //here we calculate if the number is kaprekar or not
    for i:=1;i<digits;i++  {
 
       //To avoid the numbers like 10,100..as they are not kaprekar numbers
       res := int(math.Pow(10.0,float64(i)))
 
       if (res == n){
           continue
       }
 
       // calculating the sum of the 2 half
       sum = (square/res) + (square%res)
       if (sum == n) {
          fmt.Printf(""The given number is kaprekar number!"")
          return 1;
 
       }
 
    }
 
    // if the above sum != n then n is not kaprekar number
    fmt.Printf(""The given number is not a kaprekar number!"")
    return 0;
 
 }
 
 //driver function
 func main() {
 
   //Scanning the input here
   fmt.Print(""Enter the number :"")
   fmt.Scanln(&n)
 
   square = n*n
 
   //callingg kaprekar function
   kaprekar(n)
 
 }
 
 /* Sample I/O :
     
    a) Is a kaprekar number :   
 
    Enter the number :297
    The given number is kaprekar number!
 
    b) Is not a kaprekar number :
 
    Enter the number :3
    The given number is not a kaprekar number!    
 */
 
",Go
"/*
 Travelling Salesman Problem states-
 A salesman has to visit every city exactly once.
 He has to come back to the city from where he starts his journey.
 We need to find-
 What is the shortest possible route that the salesman must follow to complete his tour?
  */
 import java.util.*;
 import java.lang.*;
 
 //Travelling Salesman Problem using Dynamic programming
 public class Traveling_SalesmanDP {
 
     public static void main(String[] args)
     {
 
         Scanner in = new Scanner(System.in);
 
         int c[][]=new int[10][10], tour[]=new int[10];
 
         int i, j,cost;
 
         System.out.println("""");
 
         // taking no. of cities input from user
         System.out.print(""Enter No. of Cities: "");
 
         int n = in.nextInt();
 
         if(n==1)
 
         {
             System.out.println("""");
             System.out.println(""Path is not possible!"");
             System.exit(0);
         }
 
         System.out.println("""");
         System.out.println(""Enter the Cost Matrix:"");
 
         for(i=1;i<=n;i++)
 
             for(j=1;j<=n;j++)
 
                 c[i][j] = in.nextInt();
 
         for(i=1;i<=n;i++)
 
             tour[i]=i;
 
         cost = tspdp(c, tour, 1, n);
 
         System.out.println("""");
 
         //printing out the path(min cost)
         System.out.print(""The Optimal Tour is: "");
 
         for(i=1;i<=n;i++)
 
             System.out.print(tour[i]+""->"");
 
         System.out.println(""1"");
 
         System.out.println("""");
 
         //cost of the optimal path
         System.out.println(""Minimum Cost: ""+cost);
     }
 
     static int tspdp(int c[][], int tour[], int start, int n)
     {
 
         int mintour[]=new int[10], temp[]=new int[10], mincost=999,ccost, i, j, k;
 
         if(start == n-1)
         {
             return (c[tour[n-1]][tour[n]] + c[tour[n]][1]);
         }
 
         for(i=start+1; i<=n; i++)
         {
 
             for(j=1; j<=n; j++)
 
                 temp[j] = tour[j];
 
           ",Java
"//Java program to find middle of LinkedList
 
 /*Possible Approaches: 
 i) Traverse List: Traverse list to find it's length, then scan list to locate n/2 node from the beginning.
 ii) Two - Pointer Approach: It is the efficient approach (only one scan). Use 2 pointers. Move one at twice the speed of second. 
 When first pointer reaches the end of list, second pointer will point the middle node of the LinkedList.					   		
 */
 import java.util.*;
 public class MiddleOfLinkedList {
 	Node head;
     	static class Node {
 		int data;
 		Node next;
 			Node(int data) {
             			this.data = data;
 			}
     		}
  
     public void addToTheLast(Node node) {
  
         if (head == null) {
             head = node;
         }
 	else {
             Node temp = head;
             while (temp.next != null)
                 temp = temp.next;
 		temp.next = node;
         }
     }
  
     public void printList() {
         Node temp = head;
         while (temp != null) {
             System.out.format(""%d "", temp.data);
             temp = temp.next;
         }
         System.out.println();
     }
  
     // This function will find middle element in linkedlist
     public Node findMiddleNode(Node head){
     	Node pointer1, pointer2;       
     	pointer1 = pointer2 = head;	 
     	int i = 0;
     	while(pointer1.next != null){
     		if(i == 0){
     			pointer1 = pointer1.next;
     			i=1;
     		}
     		else if(i == 1){
     			pointer1 = pointer1.next  
     			pointer2 = pointer2.next;
     			i=0;
     		}
     	}	
     	return pointer2; 
     }
     	
     //Main Method
     public static void main(String[] args) {
         MiddleOfLinkedList list = new MiddleOfLinkedList();
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the size of Linked List:"");
         int n = sc.nextInt();
         System.out.println(""Enter the data of Linked List:"");
         int num = sc.nextInt();
         Node head = new Node(num);
         list.add",Java
"/* This is a simple program in go language to calculate the sum of
    the individual digits of a given number taken as input and
    prints the output sum */
 
 package main
 
 import(
 
  ""fmt""
 
 )
 
 // global variables: number,reminder and sum
 var n int
 var r int
 var sum int
 
 //function to print the output sum
 func printfunction(){
 
   fmt.Printf(""The sum of digits of the number given is :%d"",sum)
 
 }
 
 //function to calculate the sum of digits
 func Sum(n int) {
 
   for n != 0{
 
      r = n%10
      sum += r
      n = n/10
 
   }
 
 }
 
 //driver function
 func main() {
 
   fmt.Print(""Enter the number :"")
   fmt.Scanln(&n)
 
   //calling the sum function to calculate the sum of digits 
   Sum(n)
 
   //calling print function to print the output sum
   printfunction()
 
 }
 /*
    Sample I/O :
 
    Enter the number :1234
    The sum of digits of the number given is :10
 */
 
",Go
"// Kosaraju-Sharir's algorithm is a linear time algorithm
 // to find the strongly connected components of a directed graph.
 
 using System;
 using System.Collections.Generic;
 using System.IO;
 using System.Linq;
 using System.Text;
 
 namespace SCC_
 {
     // Strongly Connected Component
     class SCC
     {
         private int nodeNum;
         private Dictionary<int, int> stack;
         private Dictionary<int, List<int>> graph;
         private List<List<int>> scc = new List<List<int>>();
         private List<int> sccCount = new List<int>();
 
         public SCC()
         {
             this.nodeNum = 0;
             this.graph = new Dictionary<int, List<int>>();
             this.stack = new Dictionary<int, int>();
             // Lists for Strongly Connected Components
             this.scc = new List<List<int>>();
             // Length of Strongly Connected Components
             this.sccCount = new List<int>();
         }
         public SCC(Dictionary<int, List<int>> graph, int nodeNum)
         {
             this.nodeNum = nodeNum;
             this.graph = graph;
             this.stack = new Dictionary<int, int>();
             // Lists for Strongly Connected Components
             this.scc = new List<List<int>>();
             // Length of Strongly Connected Components
             this.sccCount = new List<int>();
         }
         // To Load your dataset
         public void LoadData(string path, int nodeNum)
         {
             this.nodeNum = nodeNum;
             using (var fileStream = new FileStream(path, FileMode.Open, FileAccess.Read))
             {
                 using var sr = new StreamReader(fileStream, Encoding.UTF8);
 
                 string[] content = sr.ReadToEnd().Split('\n');
                 foreach (var element in content)
                 {
                     int key = Convert.ToInt32(element.Split(' ')[0]);
                     if (!this.graph.ContainsKey(key))
                     {
                     ",C-Sharp
"""""""Julia program to implement Subset Sum problem.
 Given a set, we have to find if there exist a subset with the given sum.
 The given problem can be solved using Dynamic Programming.
 """"""
 
 function subset_sum(set, n, S)
 
     # Initialize the entire 2D matrix with 0 as value, signifying false.
     dp = zeros(Int, n + 1, S + 1)
 
     # When the sum is zero, the answer is always true, by forming an empty subset.
     for i in 1:n + 1
         dp[i,1] = 1
     end
 
     # When the given set is empty and the required sum is not zero, then such a subset cannot e formed.
     for i in 1:S + 1
         dp[1,i] = 0
     end
 
     """"""Tabulating the dp array in Bottom-Up manner. In such a way that each cell of the dp[i, j]
        array contains whether a subset of sum j can be formed with elements in the given set till i""""""
     for i in 2:n + 1
         for j in 2:S + 1
             if j < (set[i - 1] + 1)
                 dp[i,j] = dp[(i - 1),j]
             else
                 if (dp[(i - 1),j] == 1)
                     dp[i, j] = 1
                 elseif (dp[(i - 1),(j - set[i - 1])] == 1)
                     dp[i, j] = 1
                 else
                     dp[i, j] = 0
                 end
             end
         end
     end
     return dp[n + 1,S + 1]
 end
 
 
 print(""What is the size of the set? "")
 n = readline()
 n = parse(Int, n)
 arr = Int[]
 if (n > 0)
     print(""Enter the numbers: "")
     arr = [parse(Int, num) for num in split(readline())]
 else
     print(""The set is Empty!!!"")
     exit()
 end
 print(""Enter the sum? "")
 S = readline()
 S = parse(Int, S)
 res = subset_sum(arr, n, S)
 if (res == 1)
     print(""A subset with the given sum is present in the array."")
 else
     print(""A subset with the given sum is not present in the array."")
 end
 
 
 """"""
 Time Complexity - O(n * S), where 'n' is the size of the array and 'S is the Sum
 Space Complexity - O(n * S)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE I
 
 What is the size of the set? 3
 En",Julia
"import java.util.*;
 import java.lang.*;
 import java.io.*;
 
 class SpiralMatrix {
     public List<Integer> spiralOrder(int[][] matrix) {
         ArrayList<Integer> arrLL = new ArrayList<>();
         
         //EDGE CASE
         if (matrix.length == 0) return arrLL;
         
         int m = matrix.length;      // Number of rows
         int n = matrix[0].length;  // Number of columns
         
         // Number of rows = Number of Columns = 1
         if (m == 1 && n == 1) {
             arrLL.add(matrix[0][0]);
             return arrLL;
         }
         
         // Number of rows = 1
         if (m == 1) {
             for (int j = 0; j < n; j++){
                 arrLL.add(matrix[0][j]);
                 
             }
             return arrLL;
         }
         
         // Number of columns = 1
         if (n == 1){
             for (int i = 0; i < m; i++){
                 arrLL.add(matrix[i][0]);
                 
             }
             return arrLL;
         }
         
         
         int i = 0;
         int j = 0;
         int k1 = 0;
         int k2 = 0;
         int itr = 0;
         while (j < n || i < m || j > k1 || i > k2){
             boolean one = false;
             while (j < n ){
                 if (i != itr || i >= m) break;
                 arrLL.add(matrix[i][j]);
                 j++;
                 one = true;
             }
         
             i++; j--; n--;
             boolean b = false;
             while (i < m && one == true){
                 arrLL.add(matrix[i][j]);
                 b = true;
                 i++;
             }
             
             j--; i--; m--;
             
             boolean bk = false;
             while ( j>= k1  && b == true){
                 arrLL.add(matrix[i][j]);
                 j--;
                 bk = true;
             }
             
             j++; i--; k1++;
             
             while ( i > k2 && bk == true) {
                 arrLL.add(matrix[i][j",Java
"/*
 Description: 
         In a given string, the task is to create a string
         with the first letter of every word in the string.
         For example a given string is = ""hey you"" ,so output 
         will be = ""hy"" (first letter of each word).
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 class Solution
 {
 public:
     string firstAlphabet(string S)
     {
         //empty string to store answer
         string result = """";
         bool val = true;
         //size of the string
         int len = S.length();
         for (int i = 0; i < len; i++)
         {
             if (S[i] == ' ')
             {
                 val = true;
             }
             else if (S[i] != ' ' && val == true)
             {
                 result.push_back(S[i]);
                 val = false;
             }
         }
         return result;
     }
 };
 
 int main()
 {
     string input_string;
     cout << ""Enter the string : "" << endl;
     getline(cin, input_string);
     Solution ob;
     cout << ""Resultant string : "" << endl;
     cout << ob.firstAlphabet(input_string) << endl;
     return 0;
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /*
 Test Cases :
     Test Case 1 :
         Input :
         Enter the string : 
         united public school
         Output : 
         Resultant string : 
         ups
     Test Case 2 : 
         Input : 
         Enter the string : 
         computer science
         Output :
         Resultant string : 
         cs
 */
 
",C-Plus-Plus
"/*
 Hexadecimal number is a number which has base value as 16.
 To convert a decimal number to hexadecimal number, we have to keep on dividing the decimal number by 16 & store the remainder in
 each division. According to remainder the hexadecimal digits are stored. The mapping of remainder to hex digit is same for
 remainder 0-9(i.e 0 in decimal is 0 in hexadecimal as well). For remainder 10-15, the corresponding hexadecimal digits are A-F.
 (i.e 10(in decimal) = A(in hex) & so on). Once all the remainders are calculated write those remainders in reverse order, this
 gives the equivalent hexadecimal number.
 
 In this problem, decimal number is given as input & we have to output its equivalent hexadecimal number.
 I/O : 201
 O/P : C9
 Explanation : 201 in decimal format is equivalent to the C9 in hexadecimal.
 */
 
 #include<stdio.h>
 
 //Function that converts decimal number to hexadecimal number.
 int decToHex(int fdec , char fhex[])
 {
 	int j = 0, remainder = 0;
 	
 	//This loop calculates the remainder & map it to hex number until the number is greater than 0.
 	while(fdec > 0)
 	{
 		remainder = fdec % 16 ;
 		/*
 		If remainder is less than 10(i.e 0-9) then add remainder to 48. 48 is the ASCII value of 0. ASCII value of 1 is 49. So
 		we add the remainder to ASCII value of 0 to get ASCII value of remainder & store it in character array. Here, j is used
 		to keep track of array index.
 
 		If remainder is greater than 9(i.e 10-15) which means remainder is A-F in hexadecimal. So add remainder to 55. 55 is
 		ASCII value of A. ASCII value of B is 56. So we add remainder & ASCII value of A to get ASCII value of remainder in
 		terms of hex form & store it in array.
 		*/
 		if(remainder < 10)
 		{
 			fhex[j] = 48 + remainder ;
 		}
 		else
 		{
 			fhex[j] = 55 + remainder ;
 		}
 		j = j + 1 ;
 		fdec = fdec / 16 ;
 	}
 
 	//j contains the number of digits in hexadecimal number.
 	return j ;
 }
 
 int main(void)
 {
 	int dec = 0, i = 0, len = 0 ;
 	//Characte",C
"/*
 
 Remove Element from the Array
 
 For a given array of integers arr[], and a key value 
 remove the key values from the array if present, and 
 return the new size of the array thus obtained.
 It is given that removal of all the elements should be in-place,
 there should be no use of extra space.
 
 */
 
 import java.util.Scanner; 
 import java.util.Arrays; 
 
 class remove_elements_from_array
 {
     //function to remove the key value
     //from arrray if present
     public int removeKey(int arr[], int key)
     {
         //simply returning for an empty array
         if(arr.length == 0){
             return 0;
         }
 
         int newSize = 0;
         
         for(int pass = 0; pass < arr.length; pass++)
         {
             if(arr[pass] != key)
             {
                 arr[newSize] = arr[pass];
                 newSize++;
             }
         }
 
         return newSize;
     }
 
     //driver method
     public static void main(String []args)
     {
         Scanner sc = new Scanner(System.in); 
 
         System.out.println(""Enter the size of the array: ""); 
         int size = sc.nextInt(); 
 
         System.out.println(""Enter the key value: ""); 
         int key = sc.nextInt(); 
 
         int arr[] = new int[size]; 
 
         System.out.println(""Enter the elements of array: ""); 
         for(int i = 0; i < size; i++) 
         { 
             arr[i] = sc.nextInt(); 
         } 
 
         System.out.println(""New size of array thus formed after the removal of ""+key+"" is : "");
         System.out.print(removeKey(arr, key));
         System.out.println();
     }
 }
 
 /*
 
 EXAMPLES:-
 
 Example 1:
 Input--
 Enter the size of the array: 5
 Enter the key value: 6
 Enter the elements of array: 2 1 8 33 6  
 New size of array thus formed after the removal of 6 is : 4
 
 Example 2:
 Input--
 Enter the size of the array: 3
 Enter the key value: 1
 Enter the elements of array: 6 80 44
 New size of array thus formed after the removal of 1",Java
"'''
 Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
 If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).
 The replacement must be in place and use only constant extra memory.
 Ex1: 
 Input :[1, 2, 3]
 output:[1, 3, 2]
 
 Ex2:
 Input :[3, 2, 1]
 output:[1, 2, 3]
 
 Ex3:
 Input :[1, 1, 5]
 output:[1, 5, 1]
 
 
 '''
 def permute(arr):
     #if the arr is smaller than 2 return the arr same 
     if len(arr)<2:
         return arr
     
     inverse=len(arr)-2
     #if the array element start larger value then inverse the array 
     while inverse>=0 and arr[inverse]>=arr[inverse+1]:
         inverse-=1
     
     if inverse<0:
         return 
     
     #checking the value  larger value swap the poistion with smaller element  
     for i in reversed(range(inverse, len(arr))):
         if arr[i]>arr[inverse]:
             arr[i], arr[inverse]=arr[inverse],arr[i]
             break
     arr[inverse+1:]= reversed(arr[inverse+1:])
     #result 
     return arr
 
 if __name__ == ""__main__"":
     arr= list(map(int, input(""Enter the list: "").split()))
     print(permute(arr))
 
 '''
 Time Complexcity: O(n)
 Space Complexcity: O(1)
 
 INPUT:
 Enter the list: 
 1 2 3 
 
 OUTPUT:
 [1,3,2]
 
 '''
",Python
"{
   ""nbformat"": 4,
   ""nbformat_minor"": 0,
   ""metadata"": {
     ""colab"": {
       ""name"": ""Untitled23.ipynb"",
       ""provenance"": [],
       ""collapsed_sections"": []
     },
     ""kernelspec"": {
       ""name"": ""python3"",
       ""display_name"": ""Python 3""
     },
     ""accelerator"": ""GPU""
   },
   ""cells"": [
     {
       ""cell_type"": ""markdown"",
       ""metadata"": {
         ""id"": ""q_lqqTn0DYBR"",
         ""colab_type"": ""text""
       },
       ""source"": [
         ""# Using PyTorch to solve a linear regression problem from scratch""
       ]
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""FXp9Wo4gsleM"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""import numpy as np\n"",
         ""import torch""
       ],
       ""execution_count"": 2,
       ""outputs"": []
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""iIM6-lIvtzbu"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""#Input values\n"",
         ""inputs = np.array([[73,67,43],\n"",
         ""                   [91,88,64],\n"",
         ""                   [87,134,58],\n"",
         ""                   [102,43,37],\n"",
         ""                   [69,96,70]], dtype='float32')""
       ],
       ""execution_count"": 3,
       ""outputs"": []
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""JfBeB_EXunO0"",
         ""colab_type"": ""code"",
         ""colab"": {}
       },
       ""source"": [
         ""#Actual target values\n"",
         ""targets = np.array([[56,70],\n"",
         ""                    [81,101],\n"",
         ""                    [119,133],\n"",
         ""                    [22,37],\n"",
         ""                    [103,119]], dtype='float32')""
       ],
       ""execution_count"": 4,
       ""outputs"": []
     },
     {
       ""cell_type"": ""code"",
       ""metadata"": {
         ""id"": ""63X-0P8NvA_X"",
         ""colab_type"": ""code"",
         ""colab"": {}",Python
"/* 
 Description : 
         Finding the longest substring without repeating characters having linear time Complexity O(n) 
 		and constant Space Complexity O(1) 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //length of longest substring
 int Lols(char str[], int len)
 {
 	//returning zero if the string is empty
 	if (str == NULL || len == 0)
 	{
 		return 0;
 	}
 	// varible for traversing in the string
 	int i = 0;
 	int j = 0;
 	// to store the maximum length of the substring w/o repeating Characters
 	int max_len = 0;
 	// boolean varible to check for the charecters
 	bool hash[256] = {0};
 
 	while (i < len)
 	{
 		if (hash[str[i]])
 		{
 			if (i - j + 1 > max_len)
 			{
 				//max_len=max(max_len,i-j+1);
 				max_len = i - j + 1;
 			}
 			while (str[j] != str[i])
 			{
 				hash[str[j]] = 0;
 				j++;
 			}
 			i++;
 			j++;
 		}
 		else
 		{
 			hash[str[i]] = 1;
 			i++;
 		}
 	}
 	if (max_len < len - j)
 	{
 		//max_len=max(max_len,len-j);
 		max_len = len - j;
 	}
 
 	return max_len - 1;
 }
 
 int main(void)
 {
 	char string[20];
 	printf(""Enter Input String:"");
 	scanf(""%[^\n]%*c"", string);
 	// length of the string
 	int len = strlen(string);
 	printf(""\nlength of longest substring without repeating characters: %d\n"", Lols(string, len));
 }
 
 /*
 Time complexity : O(n)
 Space complexity : O(n)
 */
 
 /* 
 Sample Input-output
 
 Input: Enter Input String:abcbacbb
 Output: length of longest substring without repeating charecters: 3
 
 Input: Enter Input String:Hackincodes
 Output: length of longest substring without repeating charecters: 7
 
 Input: Enter Input String:ddddd
 Output: length of longest substring without repeating charecters: 1
 
 Input: Enter Input String:
 Output: length of longest substring without repeating charecters: 0  
 */
 
",C-Plus-Plus
"""""""
 The program uses dictionary in python
 to count the number of occurence a letter
 makes in a word
 """"""
 
 
 def LetterCount(word):
     dict = {}
 
     for c in word:
         co = dict.get(c, 0)
         if co == 0:
             dict[c] = 1
         else:
             dict[c] = co + 1
 
     return(dict)
 
 if __name__ == '__main__':
     word = input(""enter a word "").lower()
     LetterCount = LetterCount(word)
     print(LetterCount)
 
 
 """"""
 Sample Input-output
 enter a word aayuhsi
 {'a': 2, 'y': 1, 'u': 1, 'h': 1, 's': 1, 'i': 1}
 """"""
 
 """"""
 Time complexity- O(n)
 
 """"""
",Python
"const factorial = (n) => {
     let res = [];
 
     // Initialize result
     res[0] = 1;
     let resSize = 1;
 
     // Apply simple factorial formula n! = 1 * 2 * 3 * 4...*n
     for (let x = 2; x <= n; x++) {
         resSize = multiply(x, res, resSize);
     }
 
     console.log(""Factorial of given number is "");
     var s = """";
     for (let i = resSize - 1; i >= 0; i--) {
         s = s + res[i];
     }
 
     console.log(s);
 }
 
 // for multiplications
 const multiply = (x, res, resSize) => {
     let carry = 0; // Initialize carry
 
     // One by one multiply n with individual digits of res[]
     for (let i = 0; i < resSize; i++) {
         let prod = res[i] * x + carry;
         res[i] = prod % 10; // Store last digit of 'prod' in res[]
         carry = Math.floor(prod / 10); // Put rest in carry
     }
 
     // Put carry in res and increase result size
     while (carry != 0) {
         res[resSize] = carry % 10;
         carry = Math.floor(carry / 10);
         resSize++;
     }
 
     return resSize;
 }
 
 factorial(25);
 factorial(50);
 
 /**
  * Sample output for above input:
  * Factorial of given number is
  * 15511210043330985984000000
  * Factorial of given number is
  * 30414093201713378043612608166064768844377641568960512000000000000
  *
  * Time complexity: O(log(N!))
  */
",JavaScript
"//Java Code to find the last digit of nth fibonacci number
 
 import java.io.* ;
 import java.util.* ;
 
 public class LastDigitFibonacci {
 
   public static void main(String[] args) {
 
     //dynamic input
     Scanner sc = new Scanner(System. in );
     System.out.println(""Input:\n"");
     System.out.println(""Enter the value of N\n"");
     //long used to hold large value of N
     long N = sc.nextLong();
     //On observing,we can find the repitition of last digit after 60
     //precomputed an array of size 60 and stored fibonacci respectively
     int f[] = new int[60];
     f[0] = 0;   //setting value of Oth index of f[] to 0
     f[1] = 1;   //setting value of 1th index of f[] to 1
     for (int i = 2; i < 60; i++) {
       //adding the previous and next previous elements mod 10 and storing it in present index
       //thus the last digit after adding is stored in f[i] 
       f[i] = (f[i - 2] + f[i - 1]) % 10;
     }
     System.out.println(""Output:\n"");
     System.out.println(""The last digit of "" + N + ""th fibonaci is "" + f[(int)(N % 60L)]);
 
   }
 }
 
 /*
   Input:
   Enter the value of N 
   67
   Output:
   The last digit of 67th fibonacci is 3
   
   Time Complexity: O(1)
   Space Complexity:O(1)
 */
",Java
"""""""
 Julia program to implement Maximum Sum Decreasing Subsequence
 In this problem, given an array we have to find the maximum sum an decreasing subsequence of that array can make.
 This problem is a slight modification to the Longest Decreasing subsequence problem.
 The problem can be solved using Dynamic Programming
 """"""
 
 
 function maximum_sum_decreasing_subsequence(arr, n)
     max_sum = 0
     dp = Int[]
 
     # Initialize the dp array with the array values, as the maximum sum 
     # at each point is atleast as the value at that point  
     for i in 1:n
         push!(dp, arr[i])
     end
 
     for i in 1:n
         for j in 1:(i-1)
             if(arr[i] < arr[j] && dp[i] < dp[j] + arr[i])
                 dp[i] = dp[j] + arr[i]
             end
         end
     end
 
     # Now Find the maximum element in the dp array 
     max_sum = findmax(dp)[1]
     return max_sum
 
 end
 
 
 print(""What is the length of the array? "")
 n = readline()
 n = parse(Int, n)
 if (n <= 0)
     println(""No numbers present in the array!!!"")
     exit()
 end
 arr = Int[]
 print(""Enter the numbers: "")
 arr = [parse(Int, num) for num in split(readline())]
 res = maximum_sum_decreasing_subsequence(arr, n)
 print(""The maximum sum of an  decreasing subsequence of the given array is $res"")
 
 
 """"""
 Time Complexity: O(num ^ 2), where 'num' is the size of the given array
 Space Complexity: O(num)
 
 SAMPLE INPUT AND OUTPUT
 
 SAMPLE 1
 
 What is the length of the array? 10
 Enter the numbers: 23 14 5 84 24 222 321 43 123 432
 The maximum sum of an  decreasing subsequence of the given array is 444
 
 SAMPLE 2
 
 What is the length of the array? 5
 Enter the numbers: 5 4 3 2 1
 The maximum sum of an  decreasing subsequence of the given array is 15
 """"""
",Julia
"{
  ""cells"": [
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""## Linear Regression With Multiple Variables in Python""
    ]
   },
   {
    ""cell_type"": ""markdown"",
    ""metadata"": {},
    ""source"": [
     ""This algorithms reads housing price data from a file named \""ex1data2.txt\"" and predicts the price based on two features size and number of bedrooms.""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 6,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""%matplotlib notebook\n"",
     ""import numpy as np\n"",
     ""import pandas as pd\n"",
     ""import matplotlib.pyplot as plt""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 1,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""def add_ones(X):\n"",
     ""    \""\""\""\n"",
     ""    adds a column of ones to the matrix\n"",
     ""    \""\""\""\n"",
     ""    m = len(X)\n"",
     ""    X = np.c_[np.ones(m), X]\n"",
     ""    return X""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 2,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""def cost(t, X, y):\n"",
     ""    \""\""\""\n"",
     ""    computes the squared error function \n"",
     ""    \""\""\""\n"",
     ""    m = len(X)\n"",
     ""\n"",
     ""    hypo = np.dot(X,t)\n"",
     ""    J = np.sum(np.power((hypo-y),2)) / (2*m)\n"",
     ""    return J""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 3,
    ""metadata"": {},
    ""outputs"": [],
    ""source"": [
     ""def scaling(arr):\n"",
     ""    \""\""\""\n"",
     ""    implements feature scaling\n"",
     ""    \""\""\""\n"",
     ""    arr = arr.astype('float64')\n"",
     ""    n = len(arr[0])\n"",
     ""    mu = np.mean(arr, axis=0).reshape(1,n)\n"",
     ""    sigma = np.std(arr, axis=0).reshape(1,n)\n"",
     ""    for x in range(n):\n"",
     ""        arr[:,x]-= mu[0,x]\n"",
     ""        arr[:,x]/= sigma[0,x]\n"",
     ""    return (mu,sigma,arr)""
    ]
   },
   {
    ""cell_type"": ""code"",
    ""execution_count"": 4,
    ""metadata"": {},
  ",Python
"/*
 Adjacency matrix is a representation of graph using a square matrix.
 This an efficient representation of graph and it has many applications.
 The below program is an implementation of adjacency matrix
 */
 #include <stdio.h>
 #include <stdlib.h>
 typedef struct AdjacencyMatrix
 {
     int arr[10][10];
 } AdjacencyMatrix;
 void insert_to_graph(AdjacencyMatrix *g, int parent, int value)
 {
     g->arr[parent][value] = 1;
 }
 
 void print_graph(AdjacencyMatrix *g)
 {
     for (int i = 0; i < 10; i++)
     {
         for (int j = 0; j < 10; j++)
         {
             printf(""%d "", g->arr[i][j]);
         }
         printf(""\n"");
     }
 }
 
 int main()
 {
     AdjacencyMatrix *g = (AdjacencyMatrix *)malloc(sizeof(AdjacencyMatrix));
     for (int i = 0; i < 10; i++)
         for (int j = 0; j < 10; j++)
             g->arr[i][j] = 0;
     while (1)
     {
         printf(""Enter the Edge to insert into the graph (v1,v2)\n"");
         int v1, v2;
         scanf(""%d %d"", &v1, &v2);
         insert_to_graph(g, v1, v2);
         printf(""Do you want to continue (Y/N)\n"");
         char choice;
         scanf("" %c"", &choice);
         if (choice == 'N' || choice == 'n')
         {
             break;
         }
     }
     print_graph(g);
     return 0;
 }
 
 /*
 Sample I/O:
 
 Enter the Edge to insert into the graph (v1,v2)
 0 1
 Do you want to continue (Y/N)
 y
 Enter the Edge to insert into the graph (v1,v2)
 2 4
 Do you want to continue (Y/N)
 y
 Enter the Edge to insert into the graph (v1,v2)
 1 2
 Do you want to continue (Y/N)
 n
 0 1 0 0 0 0 0 0 0 0
 0 0 1 0 0 0 0 0 0 0
 0 0 0 0 1 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0
 0 0 0 0 0 0 0 0 0 0
 
 Time Complexity : O(n^2)
 Space Complexity : O(n^2)
 */
",C
"/*
 Given two words and a string.
 By using two words , Count How many different subsequence's can be created through the string.
 Two subsequence's are considered to be different if they start or end
 at different positions in the string.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 //From this get_count_max_possible_subsequence() function we will count max different subsequence's can be created
 int get_count_max_possible_subsequence(string word1, string word2, string text)
 {
     int size_of_text = text.size();
     int size_of_word1 = word1.size();
     int size_of_word2 = word2.size();
     int count_max_possible_subsequence = 0;
     int count1 = 0;
     for(int i = 0; i < size_of_text; i++)
     {
         /* here we will check if string s1 is first word or not
         if yes we will increment the count1
          */
         string s1 = text.substr(i , size_of_word1);
         if(s1 == word1)
             count1++;
         string s2 = text.substr(i , size_of_word2);
         if(s2 == word2)
         {
             /* here we will check if string s2 is second word or not
             if yes we will increment the count_max_possible_subsequence
             with current count1 value
             */
             count_max_possible_subsequence += count1;
         }
     }
     return count_max_possible_subsequence;
 }
 
 int main()
 {
     string text, word1, word2;
 	
     cout << ""Enter the two words : \n"";
     cin >> word1 >> word2;
     cout << ""Enter the string : \n"";
     cin >> text;
 	
     int count_max_possible_subsequence = get_count_max_possible_subsequence(word1, word2, text);
 	
     cout << ""Maximum possible subsequence can be created is : "";
     cout << count_max_possible_subsequence << endl;
 }
 
 /*
 Standard Input and Output
 
 Enter the two words :
 KICK
 START
 Enter the string :
 KICKXKICKXSTARTXKICKXSTART
 Maximum possible subsequence can be created is : 5
 
 Time Complexity : O( N )
 Space Complexity : O( N )
 
 */
",C-Plus-Plus
"/*
 Problem Introduction
 You are going to travel to another city that is located  miles away from your home city. Your car can travel.
 At most  miles on a full tank and you start with a full tank. Along your way, there are gas stations at
 Distances petrolbunk1,petrolbunk2..... petrolbunk from your home city. What is the minimum number of refills needed?
 */
 
 
 #include<bits/stdc++.h>
 using namespace std;
 #define ll long long int
 
 
 //function to find whether Refueling is possible or not
 int car_fueling(ll current_refill,ll max_distance,ll last_refills, ll total_number_of_stops, ll pos[])
 {   ll number_of_refills=0;
     while(current_refill<=total_number_of_stops)                          
     {   last_refills=current_refill;
         //condition to check to reach the nearest stop
         while(current_refill<=total_number_of_stops && pos[current_refill+1]-pos[last_refills]<=max_distance)
         {
             current_refill++;
         }
         // if Cannot reach the destination nor the next gas station
         if(current_refill==last_refills)
         {  
             return -1;
         }
         /*
         incrementing number of refills 
         under the condition it is lesser than the total number of stops */
         if(current_refill<=total_number_of_stops)
         { 
             number_of_refills++;
         }
     }
     if(current_refill!=last_refills)
     {
     return number_of_refills;
     }
 }
 
 
 int main()
 {
     long long distance,max_distance,total_number_of_stops,i,number_of_refills=0,current_refill=0,last_refills; 
     cout<<""Enter the distance to be travelled:\n"";
     cin>>distance;
     cout<<""Enter The miles that the car can travel with full tank:\n"";
     cin>>max_distance;  
     cout<<""Enter the number of stops:\n"";
     cin>>total_number_of_stops;                         
     long long a[total_number_of_stops+1];              
     a[0]=0;
     cout<<""Enter the postions of the gas stations:\n"";      ",C-Plus-Plus
"/*
 Given a graph with N vertices (numbered from 0 to N-1) and M undirected edges,
 then count the distinct 3-cycles in the graph. A 3-cycle PQR is a cycle in which
 (P,Q), (Q,R) and (R,P) are connected by an edge.
 */
 
 /* 
 V is the number of vertices in the input graph and E is the number of edeges in
 the input graph.
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 int getCycles(bool** graph, int vertices){
     int cycleCount = 0;
     for(int i=0; i<vertices-2; ++i){
         for(int j=i+1; j<vertices-1; ++j){
             for(int k=j+1; k<vertices; ++k){
                 if (graph[i][j] && graph[j][k] && graph[k][i]){
                     ++cycleCount;
                 }
             }
         }
     }
     return cycleCount;
 }
 
 int main()
 {
     int vertices, edeges;
     
     cout<<""Enter the number of vertices and number of edeges in the graph""<<endl;
     
     cin >> vertices >> edeges;
     
     bool** graph = new bool*[vertices];
     
     for(int i=0; i<vertices; ++i){
         graph[i] = new bool[vertices]();
     }
     
     cout<<""Enter the path vertices""<<endl;
     
     for(int i=0, a, b; i<edeges; ++i){
         cin >> a >> b;
         graph[a][b] = true;
         graph[b][a] = true;
     }
     
     cout<<""The number of distinct 3-cycles in the graph is/are: "";
     
     cout << getCycles(graph, vertices);
     
     for(int i=0; i<vertices; ++i){
         delete[] graph[i];
     }
     
     delete[] graph;
 }
 
 /*
 Sample Input 1:
 Enter the number of vertices and number of edeges in the graph                                                                                  
 3 3                                                                                                                                                                                                                                                                                            
 Enter the path vertices                                       ",C-Plus-Plus
"/*
 Reversing individual words of a string using stacks
 Algorithm/Approach:
 We iterate through the string character-by-character.
 If the current character is not a space, or not a newline character or not a null character,
 we push it into the stack
 Otherwise, we pop the elements from the stack until it's empty. 
 (Because a space or newline or null character marks the end of a word.)
 */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 
 typedef struct stack {
     int capacity, top;
     char* arr;
 }stack;
 /* creating a structure to implement stack */
 
 int isEmpty(stack* s) {
     return s->top == -1;
 }
 /* to check if the stack is empty */
 
 int isFull(stack* s) {
     return s->top == s->capacity - 1;
 }
 /* to check if the stack is full */
 
 stack* createStack(int size) {
     struct stack* s = (struct stack*)malloc(sizeof(struct stack));
     s->capacity = size;
     s->arr = (char*)malloc(size * sizeof(char));
     s->top = -1;
     return s;
 }
 
 void push(stack* s, char data) {
     s->arr[++s->top] = data;
 }
 /* push a given element into the stack */
 
 char pop(stack* s) {
     return s->arr[s->top--];
 }
 /* to pop the top element from stack */
 
 void reverseWords(char sentence[100], int length) {
     stack* s = createStack(length);
     for (int i = 0; i < length; i++) {
         char letter = sentence[i];
         if ((!isspace(letter)) && (letter != '\n') && (letter != '\0')) {
             push(s, letter);
             /* anything other than an alphabet or number indicates that a word has ended */
         }
         else {
             while (!(isEmpty(s))) {
                 printf(""%c"", pop(s));
             }
             printf(""%c"", letter);
         }
     }
 }
 
 int main() {
     int size, i = 0;
     char sentence[100];
     printf(""Enter a sentence:\n"");
     fgets(sentence, 100, stdin);
     printf(""The sentence after reversing individual words is:\n"");
     reverseWords(sentence, strlen(",C
"/*
 Given a string of parenthesis check if parenthesis occurred in pair
 Example:
 Input: s=""({})""
 Output: yes
 Input: s=""[{(}])""
 Output: yes
 Input: s=""(((}""
 Output: no
 */
 
 #include <stdio.h>
 #include <string.h>
 #include <math.h>
 #include <stdlib.h>
 int check(char *a){
     int a1 = 0,a2 = 0 , b1= 0, b2=0,c1=0,c2=0;
     for(int i=0;i<strlen(a) ; i++){
         if(a[i]=='{')
             a1++;
         else if(a[i]=='}')
             a2++;
         else if(a[i]=='(')
             b1++;
         else if(a[i]==')')
             b2++;
         else if(a[i] =='[')
             c1++;
         else if(a[i]==']')
             c2++;
     }
     if(a1==a2 && c1==c2 && b1==b2)             //we are checking if opening and closing brackets are same then it is true 
         return 1;
     else 
         return 0;
 }
 int main() {
 char a[1001];
     int n,valid;
 
      scanf(""%s"",a); //accepting input
          valid = check(a);        //if function returns 1 then it is true
          if(valid==1)
              printf(""yes\n"");
     else                //else it is false
         printf(""no\n"");
     return 0;
 }
",C
"/**
  * In mathematics, the double factorial or semi-factorial
  * of a number n (denoted by n!!) is the product of all
  * the integers from 1 up to n that have the same parity
  * (odd or even) as n.
  */
 import java.util.*;
 
 public class DoubleFactorial {
 
     // Recursive approach
     private static int recursiveDoubleFactorial(int num) {
         // checking for 1 and 0
         if (num == 0 || num == 1) {
             return 1;
         }
 
         // using recursion
         return num * recursiveDoubleFactorial(num - 2);
     }
 
     // Iterative approach
     private static int iterDoubleFactorial(int num) {
         int result = 1;
         // using iterations
         for (int i = num; i >= 0; i = i - 2) {
 
             if (i == 0 || i == 1) {
                 return result;
             } else {
                 result *= i;
             }
         }
 
         return result;
     }
     
     public static void main(String[] args) {
         
         Scanner sc = new Scanner(System.in);
         System.out.println(""Enter the number:"");
         int num = sc.nextInt();
         System.out.println(""Which approach would you like to use?"");
         System.out.println(""1. Recursive"");
         System.out.println(""2. Iterative"");
         int ch = sc.nextInt();
         sc.close();
 
         int result;
         switch (ch) {
         case 1:
             result = recursiveDoubleFactorial(num);
             System.out.println(""Double factorial:"" + result);
             break;
 
         case 2:
             result = iterDoubleFactorial(num);
             System.out.println(""Double factorial:"" + result);
             break;
 
         default:
             System.out.println(""Invalid choice."");
         }
     }
 }
 /**
  * Sample input/output
  * Enter the number:
  * 5
  * Which approach would you like to use?
  * 1. Recursive
  * 2. Iterative
  * 1
  * Double factorial:15
  * 
  * Enter the number:
  * 6
  * Which approach would you like to use?",Java
"""""""
 Given a sorted array and a target value,
 return the index if the target is found.
 If not, return the index where it would be if it were inserted in order.
 You may assume no duplicates in the array.
 
 """"""
 # taking the input from the user
 
 x = list(map(int, input(""Enter the elements in the list: "").strip().split()))
 target = int(input(""Enter the Element whose index has to be found: ""))
 
 # finding whether the target value is in the list or not
 
 if target in x:
     a = x.index(target)
     print(
         ""The number is present at the index {}."".format(a)
     )  # if target is present then printing the index
 else:
     x.append(target)  # adding the target in the list
     x.sort()  # sorting the list
     a = x.index(target)
     print(
         ""Number not found. It can be inserted at index {}."".format(a)
     )  # printing the target index
 
 '''
 Time complexity : O(N)
 Space complexity : O(N)
 '''
 
 '''
 Test Case :
 
 Input: 
  Enter the elements in the list:[1,3,5,6]
  Enter the Element whose index has to be found: 5
 Output:
 The number is present at the index {}. 2
 '''",Python
"# Python Program to swap the two nibbles in a given byte.
 
 # function to swap nibbles
 
 
 def swapNibbles(number):
     return ((number & 0x0F) << 4 | (number & 0xF0) >> 4)
 
 number = int(input(""Enter Number: ""))
 print(""After swapping the nibbles:"")
 print(swapNibbles(number))
 
 '''
 Sample I/O:
     Input
     Enter Number: 100
 
     Output:
     After swapping the nibbles:                                                                                               
     70
 
 Time Complexity: O(1)
 Space Complexity: O(1)
 
 '''
",Python
"/*
  This problem will be solved using dp.
  We will be given one strings and we have to print the
  Minimum number of deletion in a string to make it a palindrome.
 */
 
 #include <bits/stdc++.h>
 
 using namespace std;
 int dp[1001][1001];
 
 int minDeletion(string X, string Y, int m, int n) {
   // if length of any string is 0 then we cannot find common string
   for (int i = 0; i < m + 1; i++) {
     for (int j = 0; j < n + 1; j++) {
       if (i == 0 || j == 0)
         dp[i][j] = 0;
     }
   }
 
   for (int i = 1; i < m + 1; i++) {
     for (int j = 1; j < n + 1; j++) {
       /* if letters of both string X and Y are equal 
       then we will decrease row i.e i and column i.e j both by 1 */
       if (X[i - 1] == Y[j - 1]) {
         dp[i][j] = dp[i - 1][j - 1] + 1;
       }
       /* if letters of both string X and Y are not equal then first we will 
       decrease row i.e i by 1 and then column i.e j by 1 and then find maximum value b/w two */
       else {
         dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
       }
     }
   }
 
   return m - dp[m][n];
 }
 
 int main() {
   cout<<""Enter string s1""<<endl;
   string s1;
   cin >> s1;
   string s2 = s1;
   reverse(s2.begin(), s2.end());
   int m = s1.length();
   int n = s2.length();
   cout <<""Minimum number of deletion in a string to make it a palindrome ""<< minDeletion(s1, s2, m, n);
   return 0;
 }
 /*
 Input - 
 Enter string X
 bbbab
 Output -  
 Minimum number of deletion in a string to make it a palindrome
 4
 
 Time Complexity - O(m*n)
 Space Complexity - O(m*n)
 */
",C-Plus-Plus
"/*
 Code to convert a postfix expression to prefix expression using stacks
 ALGORITHM
 * Scan the postfix expression from left to right
 * If the symbol is an operand, push it to the stack
 * If the symbol is an operator, pop two operands from the stack 
 * Create a string by concatenating the two operands and the operator before them. 
 * Push the resultant string back to Stack
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void postfixToPrefix(string s)
 {
     stack<string> str;
     for(int i=0;i<s.length();i++)
     {
         if(s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/' || s[i]=='^')
         {
             string operand1=str.top();
             str.pop();
             string operand2=str.top();
             str.pop();
             //Creating the string by concatenating the operator and the operands
             string prefix_part=s[i]+operand2+operand1;
             str.push(prefix_part);
         }
         else
         {
             str.push(string(1,s[i]));
         }
     }
     while(!str.empty())
     {
         cout<<str.top();
         str.pop();
     }
 }
 
 //Driver code
 int main()
 {
     string s;
     cout<<""Enter the postfix expression:\n"";
     cin>>s;
     cout<<""Prefix expression:\n"";
     postfixToPrefix(s);
 }
 
 /*
 Space Complexity : O(n)
 
 Time Comlexity : O(n)
 
 Example:
 Input:
 Enter the postfix expression:
 ABC/-A
 
 Output: 
 Prefix Expression:
 A-A/BC
 */
",C-Plus-Plus
"//Count No of Set Bits
 
 #include<bits/stdc++.h>
 using namespace std;
 int main()
 {
 	int n,k;
 	cout<<""Enter number \n"";
 	cin>>n;
 	int res=0;
      while(n>0)
      {
      	res = res + (n & 1);
      	n=n>>1;
 	 }
 	  cout<<res; 
 }
 
 /*
 Time Complexity: O(logn)
 Space Complexity: O(1)
 */
 
 /*
 Sample Input:
 Example 1:- 
 Enter number
 5
 Example 2:-
 Enter number
 987
 
 Sample Output:
 Example 1:- 2
 Example 2:- 8
 */",C-Plus-Plus
"'''
 
 Palindrome : A sequence which appears the same when read forwards and backwards
 Purpose : To find if the given string is a palindrome or not, using doubly linked list
 
 Method : Data Structures :- Doubly Linked List
         - Create a doubly linked list
         - Assign each character to one node of the doubly linked list
         - Check if the data in the before node and after node are equal
         - If they are equal, perform increment and decrement operations
         - If they are not equal, return false
 
 Time complexity : 0(n)
 Space complexity : 0(1)
 Arguments : Arbitrary arguments
 Return : Message if the input is a palindrome or not
 Sample Input/Output :
 
 - Test case 1:
 Enter the string : clouds
 Not a Palindrome
 
 - Test case 2:
 Enter the string : madam
 Is a Palindrome
 
 - Test case 3:
 Enter the string : books
 Not a Palindrome
 
 '''
 
 
 class Node:
 
     def __init__(self, data):
         self.data = data
         self.next = None
         self.prev = None
 
 
 class DoublyLinkedList:
 
     @staticmethod
     def printList(node):
 
         '''Reversing the string'''
         rev_key = """"
         while node:
             rev_key += node.data
             node = node.next
         return rev_key
 
     def __init__(self):
         self.head = None
 
     def push(self, new_data):
 
         ''' Adding new node in the front of the list '''
         new_node = Node(new_data)
 
         if self.head is None:
             self.head = new_node
             return
 
         last = self.head
 
         while last.next:
             last = last.next
 
         last.next = new_node
         new_node.prev = last
         return
 
 
 if __name__ == ""__main__"":
 
     llist = DoublyLinkedList()
     keys = input(""Enter the string : "")
 
     for i in reversed(range(len(keys))):
         llist.push(keys[i])
 
     rev_keys = llist.printList(llist.head)
 
     if keys == rev_keys:
         print(""Is Palindrome"")
     else:
         print(""",Python
"/*
 
 Given N, Linked List and K,
 Reverse the Node of Linked List in Groups of K and return
 example:
 N=5
 Linked list: 1 2 3 4 5
 K=2
 
 Answer 2 1 4 3 5
 */
 #include <bits/stdc++.h>
 using namespace std;
 
 class Node
 {
 public:
     int data;
     Node *next;
 };
 void push(Node **head, int data)
 {
     Node *new_node = new Node();
     new_node->data = data;
     (new_node)->next = (*head);
     (*head) = new_node;
 }
 void printLL(Node *temp)
 {
     while (temp != NULL)
     {
         cout << temp->data << ""->"";
         temp = temp->next;
     }
 }
 Node *reverseK(Node *head, int k)
 {
     int flag = 0;
     Node *temp = head;
     while (temp)
     {
         temp = temp->next;
         flag++;
         if (flag == k)
             break;
     }
     if (flag < k)
         return head;
     int count = 0;
     Node *curr = head;
     Node *prev = NULL, *next = NULL;
     while (curr && count < k)
     {
         next = curr->next;
         curr->next = prev;
         prev = curr;
         curr = next;
         count++;
     }
     if (next != NULL)
     {
         head->next = reverseK(next, k);
     }
     return prev;
 }
 int main()
 {
     Node *head = NULL;
     int n;
     cout << ""Enter Numbers of Element N:"";
     cin >> n;
     cout << ""Enter elements:"";
     for (int i = 0; i < n; i++)
     {
         int a;
         cin >> a;
         push(&head, a);
     }
     int k;
     cout << ""Enter K:"";
     cin >> k;
     cout << ""\nOriginal Linked List:\n"";
     printLL(head);
     head = reverseK(head, k);
     cout << ""\nNew Linked List:\n"";
     printLL(head);
 }
 /*
 
 Sample Input/Output:
 Input:
 Enter Numbers of Element N:5
 Enter elements:1 2 3 4 5
 Enter K:2
 
 Output:
 Original Linked List:
 5->4->3->2->1->
 New Linked List:
 4->5->2->3->1->
 
 Time-Complexity: O(n)
 Space-Complexity: O(1)
 
 */
",C-Plus-Plus
"/*-----------------------VERTICAL ORDER TRAVERSAL---------------------------
 
 In this we have to get the vertical order of the tree
 -> The approach is to Level order traverse the Binary tree
 -> keep a track of the horizontal distance and vertical distance of the nodes from the root which 
 is at origin or say at (0,0)
 -> All the nodes at same horizontal distance come in the same column of the vertical traversal
 
 *CHECK*- In this there is also a possibility when we have more than two nodes at the same horizontal and
 vertical distance then we have sorted the values in increasing order
  INPUT -> THE VALUES OF THE TREE
             (1)
            /   \
         (2)     (3)
        /  \    /   \
     (4)   (5) (6)   (7)
  
  OUTPUT -> 2-D VECTOR WHICH DISPLAYS THE VERTICAL ORDER
           [[4]
           [2]
           [1,5,6]
           [3]
           [7]]
 
 */
 
 #include <bits/stdc++.h>
 using namespace std;
 
 // ---------------THE BiNARY TREE NODE CLASS----------------------------
 template <typename T>
 class BinaryTreeNode
 {
 public:
     T data;
     BinaryTreeNode<T> *left;
     BinaryTreeNode<T> *right;
 
     BinaryTreeNode(T data)
     {
         this->data = data;
         this->left = NULL;
         this->right = NULL;
     }
 
     ~BinaryTreeNode()
     {
         delete left;
         delete right;
     }
 };
 
 // --------------------FUNCTION TO TAKE INPUT THE TREE--------------------------------
 
 BinaryTreeNode<int> *TakeinputLevelWise()
 {
     int data;
     cout << ""enter the root data :"" << endl;
     cin >> data;
 
     if (data == -1)
     {
         return NULL;
     }
 
     BinaryTreeNode<int> *root = new BinaryTreeNode<int>(data);
     queue<BinaryTreeNode<int> *> nodes;
     nodes.push(root);
     while (nodes.size() != 0)
     {
         BinaryTreeNode<int> *front = nodes.front();
         nodes.pop();
         int leftchild;
         int rightchild;
         cout << ""Enter the left child of "" << front->data << "":"" << endl;
 ",C-Plus-Plus
"/*
 Ninja decided to find the distance between the neighbouring cities and then store them for future use. 
 He took data from the map and developed an input format. He is given an integer N denoting the number 
 of cities and then he has an array of size N - 1 that stores a pair of numbers at each index. Let the 
 pair be I1 and I2, which will denote a bidirectional edge between the two cities I1 and I2.
 A subtree is a subset of cities, where each city can be reached from every other city of the subset. 
 The path between each pair passes only though the cities present in the subset. Two subtrees are taken 
 differently if there are one or more cities in one subtree not present in the other.
 Now, you need to create an array of N - 1 elements where the ith element is the number of subtrees 
 in which the maximum distance between any two cities is equal to i.
 */
 
 #include <bits/stdc++.h>
 #include <vector>
 #include <climits>
 using namespace std;
 
 vector<int> countSubtreesMaxDistance(int n, vector<vector<int>>& edges) 
 {
     
     // Create the adjaceny matrix in form of graph
     vector<vector<int>> graph(n, vector<int>(n, INT_MAX / 2 - 1));
     for (auto e : edges) 
     {
         int u = e[0] - 1, v = e[1] - 1;
         graph[u][v] = graph[v][u] = 1;
     }
         
     // floyd-warshall algorithm for calculating shortest distance
     for (int k = 0; k < n; k++) 
     {
         for (int i = 0; i < n; i++) 
         {
             for (int j = 0; j < n; j++) 
             {
                 graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j]);
             }
         }
     }
     
     // initialise vector to store result 
     vector<int> res(n - 1, 0);
         
     /* Check for each combination of nodes and see if it's a subtree or not.
      If it's a subtree then see maximum distance that can be reached.*/
         
     // Each subtree
     // sub = subtree
     for (int sub = 0; su",C-Plus-Plus
"/*
 In Preorder traversal , the root is visited first , then the let sub-tree in preorder
 fashion, and then the right subtree in preorder fashion.The traversal is defined as 
 * Visit the root node R
 *Traverse the left sub-tree of R in preorder
 *Traverse the right sub-tree of R in preorder
 */
 
 class Node {
     constructor(data) {
         this.data = data;
         this.left = null;
         this.right = null;
     }
 }
 
 class BinarySearchTree {
     constructor() {
         this.root = null;
     }
     //insert function inserts a new node into the binary search tree
     insert(value) {
         var New = new Node(value);
         if (this.root === null) {
             this.root = New;
             return this;
         }
         let curr = this.root;
         let prev = null;
         while (curr) {
             if (value < curr.data) {
                 prev = curr;
                 curr = curr.left;
             }
             else if (value > curr.data) {
                 prev = curr;
                 curr = curr.right;
             }
         }
         if (prev.data > value) {
             prev.left = New;
             return this;
         }
         else {
             prev.right = New;
             return this;
         }
 
     }
 
     recursive_preorder(node) {
         if (node !== null) {
             console.log(node.data);
             this.recursive_preorder(node.left);
             this.recursive_preorder(node.right);
         }
     }
 }
 
 const readline = require('readline');
 const rl = readline.createInterface({ input: process.stdin , output: process.stdout });
 
 const getLine = (function () {
     const getLineGen = (async function* () {
         for await (const line of rl) {
             yield line;
         }
     })();
     return async () => ((await getLineGen.next()).value);
 })();
 
 const main =  async()=>{
     console.log(""Enter the number of nodes to insert"");
     let n = Number(await getLine());
     let b = new Binar",JavaScript
"/*
 The algorithm gives us a topological sort for the given directed graph. If the graph is cyclic it returns as no topological sort for the graph is possible.
 
 Steps:
 
 1: Firstly compute in-degree (number of incoming edges) for each of the vertex present in the DAG and initialize the count of visited nodes as 0.
 
 2: Pick all the vertices with in-degree as 0 and add them into a queue.
 
 3: Remove a vertex from the queue and then increment count of visited nodes by 1.
 Decrease in-degree by 1 for all its neighboring nodes.
 If in-degree of any neighboring node is reduced to zero, then add that node to the queue.
 
 4: Repeat 3 until the queue is empty.
 
 5: If count of visited nodes is not equal to the number of nodes in the graph then the topological sort is not possible for the given graph.
 */
 
 #include<bits/stdc++.h>
 using namespace std;
 
 void kahn_topological_sort(vector <int> adj[], int n){
     //Array for keeping a track for indegree of all nodes
     int in_degree[n]; 
     memset(in_degree,0,sizeof(in_degree));
     queue <int> q; 
     //Computing in degree of each node
     for(int i=0;i<n;i++){
         for(auto s: adj[i]){
             in_degree[s]++;
         }
     }
     //Pushing nodes with in degree zero into the queue
     for(int i=0;i<n;i++){
         if(!in_degree[i]){
             q.push(i);
         }
     }
     int count_of_visited_nodes{};
     //This vector will store the order
     vector <int> topological_order; 
     while(!q.empty()){
         //Storing the front i.e. the first node of the queue in curr
         int curr = q.front();
         //Pushing the node curr into the order
         topological_order.push_back(curr);
         //Poping that node from the queue
         q.pop();
         //Traversing to all adjacents of the curr node and decreasing there indegree by one
         for(auto s: adj[curr]){
             in_degree[s]--;
             //If any node's indegree becomes zero pushing it into the queue
          ",C-Plus-Plus
"""""""
 Hamiltonian Path: a Hamiltonian path (or traceable path) is a path
     in an undirected or directed graph that visits each vertex exactly
     once. A Hamiltonian cycle (or Hamiltonian circuit) is a Hamiltonian
     path that is a cycle.
 
 Problem Link: https://en.wikipedia.org/wiki/Hamiltonian_path
 Purpose: To determine the existance of a Hamiltonian Cycle in the provided
         undirected graph and return the path if such path exist.
         The nodes are numbered from 1 to N
 Method : Backtracking
 
 Time Complexity:  O(2^N)
 Space Complexity: O(N)
 Argument : Graph (Dictionary)
 Return   : Hamiltonian Cycle (List)
 
 """"""
 from collections import defaultdict
 
 
 def Move_next_node(n, graph, pos, ans):
     # Base Case: If all the node is visited:
     if pos == n:
 
         # Check wether the last node and the first node are
         # connected in order to form a Cycle
         if ans[0] in graph[ans[-1]]:
             return ans + [ans[0]]
 
         return False
 
     current = ans[-1]
 
     # Check for each of the adjoining vertices
     for i in graph[current]:
 
         # Check wether the node is already visited or not
         if i not in ans:
             ans += [i]
             temp = Move_next_node(n, graph, pos + 1, ans)
             if temp:
                 return temp
 
             ans.pop()
 
     return False
 
 
 def Hamiltonial_Cycle(n, graph):
     # To keep a track of already visited node and the answer
     # We will start exploring the graph from Vertex 1
     answer = [1]
 
     # Start Exploring adjoining node/vertex
     return Move_next_node(n, graph, 1, answer)
 
 
 # ------------------------DRIVER CODE ------------------------
 if __name__ == ""__main__"":
     n, m = map(int, input(""Enter the number of vertex and edges: "").split())
     print(""Enter the edges: "")
     graph = defaultdict(list)
     for i in range(m):
         a, b = map(int, input().split())
         graph[a] += [b]
         graph[b] += [a]
     ans = H",Python
"#time complexity : O(nlogn)
 #space complexity : O(n)
 
 # Returns sum of maximum sum subarray in arr[low.....high]
 def maxSumSubArray(arr, low, high) :
     # Base Case
     if (low == high) :
         return arr[low]
     # Find middle element
     mid = low + ((high - low) // 2)
     # Return maximum of left ,right and mid crossing
     return max(maxSumSubArray(arr, low, mid),
                maxSumSubArray(arr, mid+1, high),
                maxSumCrossing(arr, low, mid, high))
 
 # Find the maximum possible sum in arr[] such that arr[m] is part of it
 def maxSumCrossing(arr, low, mid, high) :
     # Include elements on left of mid.
     summ = 0; left_sum = -10000
     for i in range(mid, low-1, -1) :
         summ = summ + arr[i]
         if (summ > left_sum) :
             left_sum = summ
     # Include elements on right of mid
     summ = 0; right_sum = -1000
     for i in range(mid + 1, high + 1) :
         summ = summ + arr[i]
         if (summ > right_sum) :
             right_sum = summ
     return max(left_sum + right_sum, left_sum, right_sum)
 
 # Driver Code
 # creating an empty list
 listt = []
 # number of elements as input
 n = int(input(""Enter number of elements in arr : ""))
 # iterating till the range
 for i in range(0, n):
     element = int(input())
     listt.append(element) # adding the element
 print(""input array is : "",listt)
 n = len(listt)
 max_sum = maxSumSubArray(listt, 0, n-1)
 print(""Maximum contiguous sum is "", max_sum)
 
 #sample test case 
 #input array : [1, 3, 2, 4, 7]     [1,-1,2,3,-2]    [0,1,-1,0,0]     [2]     [-1,-1,-1,-1,-1]
 #output      :  17                  5                1                2       -1
",Python
"/* Shaker Sort In C
 The algorithm extends the bubble sort by operating in two directions
 */
 #include <stdio.h>
 
 void shakersort(int[], int);
 void swap(int *, int *);
 int main()
 {
 	int num, i, arr[10000];
 	printf(""Enter the number of elements:"");
 	scanf(""%d"", &num);
 	for (i = 0; i < num; i++)
 	{
 		scanf(""%d"", &arr[i]);
 	}
 
 	printf(""Enter the elements to be sorted:"");
 	for (i = 0; i < num; i++)
 	{
 		printf(""%d "", arr[i]);
 	}
 
 	shakersort(&arr[0], num);
 	printf(""\n"");
 	printf(""Sorted Array:"");
 	for (i = 0; i < num; i++)
 	{
 		printf(""%d "", arr[i]);
 	}
 
 	return 0;
 }
 // Sorts the given array bidirectionally
 void shakersort(int arr[], int num)
 {
 	int end, start, i;
 	end = num - 1;
 	start = 1;
 	// Bidirectional comparison
 	while (start <= num / 2)
 	{
 		for (i = start - 1; i < end; i++)
 		{
 			if (arr[i] > arr[i + 1])
 				swap(&arr[i], &arr[i + 1]);
 		}
 
 		end = end - 1;
 		for (i = end; i >= start; i--)
 		{
 			if (arr[i] < arr[i - 1])
 				swap(&arr[i], &arr[i - 1]);
 		}
 
 		start = start + 1;
 	}
 }
 // Swaps two elements
 void swap(int *x, int *y)
 {
 	int temp;
 	temp = *x;
 	*x = *y;
 	*y = temp;
 }
 
 /*
 Sample Output
 Enter the number of elements: 13
 Enter the elements to be sorted:86 74 -2 -9 67 25 33 86 17 -8 42 10 0
 Sorted Array:-9 -8 -2 0 10 17 25 33 42 67 74 86 86  
 
 Complexities
 Worst case performance:O(n^2)
 Best case performance:O(n)
 Average performance: O(n^2)
 Worst Case Space complexity: O(1) 
 */
 
",C
"/*
 Problem statement : Given n pairs of parentheses, we have to write a function to generate all combinations of well-formed parentheses.
 
 Constraints:
 
 1 <= n <= 8
 
 Approach : We will be given a number n which represents the pairs of parentheses, and we need to find out all of their valid combinations.So there are n opening brackets and n closing brackets ,and each valid combination will be of length 2*n.
 
 A valid parentheses combination is the one where every opening parenthesis ( has its corresponding closing ).We can solve this problem using recursion by generating all the combinations of parenthesis but this will be the naive approach as it generates all the permutations.So,
 The time complexity of this approach will be O(2^2n) which is quite large.
 
 So , we can improve this by generating only those combinations which we know for sure will be valid combination and so our time complexity will reduce considerably.We can use backtracking for this purpose.We need to keep some points in mind for the combination to be valid:
 
 1. Base case when number of opening and closing parentheses is equal to 0.
 2. A closing parenthesis cannot occur before the open parenthesis.
 
 For n = 2 , recursive tree is as follows
 open denotes open parentheses count , similarly close denotes close parentheses count
 
 
                                  output_string """" {open = 2, close = 2}
                                                /
                                  choose (     /
                                              /
                                             /
                                            /
                                  output_string ""("" {open = 1, close = 2}
                                             /    \
                                 choose (   /      \  choose )
                                           /        \
                                          /          \
                                         /            \
 ",C-Plus-Plus
"/* Code to check if a linked list is palindromic or not using stacks
 OBJECTIVE:
 1. Push the data of each node into the stack(LIFO)
 2. Pop each element of the stack and compare with the linked list element
 */
 #include <bits/stdc++.h>
 using namespace std;
 struct Node
 {
     int data;
     Node *next;
 };
 void push(Node **head, int new_data)
 {
     Node *temp = new Node();
     temp->data = new_data;
     temp->next = *head;
     *head = temp;
 }
 int checkPalin(Node *head)
 {
     stack<int> s;
     Node *temp = head;
     while (temp != NULL)
     {
         s.push(temp->data);
         temp = temp->next;
     }
     Node *ref = new Node();
     ref = head;
     while (ref != NULL)
     {
         int i = s.top();
         s.pop();
         if (i != ref->data)
         {
             return -1;
         }
         ref = ref->next;
     }
     return 1;
 }
 //Driver code
 int main()
 {
     int n;
     cout<<""Enter the length of the list"";
     cin>>n;
     int a[n];
     cin>>a[0];
     Node *head = new Node();
     head->data = a[0];
     head->next = NULL;
     for(int i=1;i<n;i++)
     {
         cin>>a[i];
         push(&head,a[i]);
     }
     cout << checkPalin(head) << ""\n"";
 }
 /*
 Time Complexity:O(n)
 INPUT: 
 Enter the length of the list3
 1
 2
 1
 OUTPUT:
 1
 */
",C-Plus-Plus
"/*
 In this algorithm we keep halving one number and doubling the 2nd one.
 While halving, if we get an odd number, we add the 2nd doubled number to the result.
 This goes on until the halving makes the first reach 0.
 It is also known as the Ancient Egyptian Multiplication, used by
 scribes to do multiplication without using the multiplication table.
 */
 #include <stdio.h>
 
 int Russian_Peasant_Algo(int, int);
 int main()
 {
 	int a, b, ans;
 	printf(""Enter the first number: "");
 	scanf(""%d"", &a);
 	printf(""\nEnter the second number: "");
 	scanf(""%d"", &b);
 	ans = Russian_Peasant_Algo(a, b);
 	printf(""\nThe product of the given number is %d\n"", ans);
 	return 0;
 }
 // Implementing the Russian-Peasant Algorithm
 int Russian_Peasant_Algo(int a, int b)
 {
 	int ans = 0;
 	while (b)
 	{
 		if (b % 2)
 		{
 			ans += a;
 		}
 		a *= 2;
 		b /= 2;
 	}
 	return ans;
 }
 
 /*
 Time Complexity: O(log2(max(no of digits in a, no of digits in b)))
 
 Sample Output
 Enter the first number: 4
 Enter the second number: 5
 The product of the given numbers is 20
 */
 
",C
